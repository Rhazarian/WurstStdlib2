globals
group w=null
force u=null
player array r
player s=null
integer t=0
hashtable i=null
integer S=0
hashtable c=null
integer o=0
integer O=0
timer array l
integer b=0
integer y=0
real p=.0
real e=.0
real q=.0
real a=.0
rect n=null
region d=null
string f=null
trigger R=null
integer T=0
integer Y=0
location G=null
group array g
group h=null
boolean array F
string array k
integer array j
integer x=0
string array v
string array m
string array Q
effect array W
effect array E
effect array Z
effect array U
effect array I
effect array P
effect array A
effect array D
effect array H
effect array J
effect array K
effect array L
integer array X
integer array C
integer V=0
integer array B
integer N=0
string array M
boolean ww=false
weathereffect uw=null
rect rw=null
weathereffect array sw
weathereffect array tw
weathereffect array iw
weathereffect array Sw
weathereffect array cw
weathereffect array ow
weathereffect array Ow
weathereffect array lw
weathereffect array bw
weathereffect array yw
weathereffect array pw
weathereffect array ew
integer array qw
integer array aw
string array nw
integer dw=0
integer fw=0
integer array Rw
integer array Tw
integer Yw=0
real array Gw
boolean gw=false
destructable array hw
destructable array Fw
destructable array kw
timerdialog jw=null
timer xw=null
real array vw
boolean array mw
string array Qw
integer array Ww
effect array Ew
effect array Zw
effect array Uw
effect array Iw
effect array Pw
effect array Aw
effect array Dw
effect array Hw
effect array Jw
effect array Kw
effect array Lw
effect array Xw
string Cw=null
boolean Vw=false
integer array Bw
location array Nw
unit Mw=null
real array wu
location uu=null
real array ru
real array su
real tu=.0
unit array iu
real array Su
string array cu
string ou=null
string array Ou
string lu=null
boolean array bu
boolean yu=false
real array pu
real eu=.0
real qu=.0
group au=null
real array nu
real array du
boolean fu=false
unit array Ru
unit array Tu
boolean Yu=false
real Gu=.0
real gu=.0
real hu=.0
real Fu=.0
integer ku=0
integer ju=0
real xu=.0
real vu=.0
real mu=.0
real Qu=.0
real Wu=.0
real Eu=.0
real Zu=.0
real Uu=.0
real Iu=.0
real Pu=.0
hashtable Au=null
integer Du=0
group Hu=null
location array Ju
group Ku=null
group Lu=null
force Xu=null
integer Cu=0
integer Vu=0
integer Bu=0
unit Nu=null
integer Mu=0
integer wr=0
integer ur=0
integer rr=0
integer sr=0
real tr=.0
real ir=.0
boolean Sr=false
group array cr
group array lr
integer br=0
real yr=.0
unit pr=null
real er=.0
real qr=.0
real ar=.0
hashtable nr=null
group dr=null
group fr=null
group Rr=null
sound Tr=null
group Yr=null
unit array Gr
location array gr
group hr=null
unit array Fr
integer array kr
location array jr
unit xr=null
real array vr
location mr=null
real array Qr
real array Wr
real Er=.0
unit array Zr
real array Ur
string array Ir
string Pr=null
string array Ar
string Dr=null
boolean array Hr
boolean Jr=false
real array Kr
real Lr=.0
real Xr=.0
group Cr=null
real array Vr
real array Br
integer array Nr
integer Mr=0
group ws=null
group us=null
group rs=null
unit array ss
integer ts=0
boolean array is
real array Ss
group cs=null
group os=null
unit Os=null
boolean array ls
integer array bs
group ys=null
group ps=null
group es=null
group qs=null
group as=null
group ns=null
real array ds
string array fs
real array Rs
string array Ts
group Ys=null
real array Gs
integer array gs
real array hs
real array Fs
real array ks
real array js
location array xs
boolean array vs
unit array ms
string Qs=null
real Ws=.0
boolean Es=false
real Zs=.0
string Us=null
real Is=.0
location Ps=null
unit As=null
integer Ds=0
integer array Hs
unit Js=null
unit array Ks
group Ls=null
group Xs=null
integer Cs=0
integer array Vs
group Bs=null
integer array Ns
string array Ms
integer wt=0
unit array ut
unit array rt
group st=null
group tt=null
group St=null
group ct=null
group ot=null
group Ot=null
group lt=null
group bt=null
group yt=null
group pt=null
boolean array et
boolean array qt
real array at
integer array nt
boolean array dt
integer array ft
boolean array Rt
group array Tt
group Yt=null
real array Gt
integer gt=0
unit ht=null
group Ft=null
group kt=null
group jt=null
gamecache xt=null
integer array vt
integer mt=0
integer array Qt
location array Wt
location array Et
boolean array Zt
leaderboard Ut=null
rect It=null
sound Pt=null
sound At=null
sound Dt=null
sound Ht=null
trigger Jt=null
trigger Kt=null
trigger Lt=null
trigger Xt=null
trigger Ct=null
trigger Vt=null
trigger Bt=null
trigger Nt=null
trigger Mt=null
trigger wi=null
trigger ui=null
trigger ri=null
trigger si=null
trigger ti=null
trigger ii=null
trigger Si=null
trigger ci=null
trigger oi=null
trigger Oi=null
trigger li=null
trigger bi=null
trigger yi=null
trigger pi=null
trigger ei=null
trigger qi=null
trigger ai=null
trigger ni=null
trigger di=null
trigger fi=null
trigger Ri=null
trigger Ti=null
trigger Yi=null
trigger Gi=null
trigger gi=null
trigger hi=null
trigger Fi=null
trigger ki=null
trigger ji=null
trigger xi=null
trigger vi=null
trigger mi=null
trigger Qi=null
trigger Wi=null
trigger Ei=null
trigger Zi=null
trigger Ui=null
trigger Ii=null
trigger Pi=null
trigger Ai=null
trigger Di=null
trigger Hi=null
trigger Ji=null
trigger Ki=null
trigger Li=null
trigger Xi=null
trigger Ci=null
trigger Vi=null
trigger Bi=null
trigger Ni=null
trigger Mi=null
trigger wS=null
trigger uS=null
trigger rS=null
trigger sS=null
trigger tS=null
trigger iS=null
trigger SS=null
trigger cS=null
trigger oS=null
trigger OS=null
trigger lS=null
trigger bS=null
trigger yS=null
trigger pS=null
trigger eS=null
trigger qS=null
trigger aS=null
trigger nS=null
trigger dS=null
trigger fS=null
trigger RS=null
trigger TS=null
trigger YS=null
trigger GS=null
trigger gS=null
trigger hS=null
trigger FS=null
trigger kS=null
trigger jS=null
trigger xS=null
trigger vS=null
trigger mS=null
trigger QS=null
trigger WS=null
trigger ES=null
trigger ZS=null
trigger US=null
trigger IS=null
trigger PS=null
trigger AS=null
trigger DS=null
trigger HS=null
trigger JS=null
trigger KS=null
trigger LS=null
trigger XS=null
trigger CS=null
trigger VS=null
trigger BS=null
trigger NS=null
trigger MS=null
trigger wc=null
trigger uc=null
trigger rc=null
trigger sc=null
trigger tc=null
trigger ic=null
trigger Sc=null
trigger cc=null
trigger oc=null
trigger Oc=null
trigger lc=null
trigger bc=null
trigger yc=null
trigger pc=null
trigger ec=null
trigger qc=null
trigger ac=null
trigger nc=null
trigger dc=null
trigger fc=null
trigger Rc=null
trigger Tc=null
trigger Yc=null
trigger Gc=null
trigger gc=null
trigger hc=null
trigger Fc=null
trigger kc=null
trigger jc=null
trigger xc=null
trigger vc=null
trigger mc=null
trigger Qc=null
trigger Wc=null
trigger Ec=null
trigger Zc=null
trigger Uc=null
trigger Ic=null
trigger Pc=null
trigger Ac=null
trigger Dc=null
trigger Hc=null
trigger Jc=null
trigger Kc=null
trigger Lc=null
trigger Xc=null
trigger Cc=null
trigger Vc=null
trigger Bc=null
trigger Nc=null
trigger Mc=null
trigger wo=null
trigger uo=null
trigger ro=null
trigger so=null
trigger io=null
trigger So=null
trigger co=null
trigger oo=null
trigger Oo=null
trigger lo=null
trigger bo=null
trigger yo=null
trigger po=null
trigger eo=null
trigger qo=null
trigger ao=null
trigger no=null
trigger do=null
trigger fo=null
trigger Ro=null
trigger To=null
trigger Yo=null
trigger Go=null
trigger go=null
trigger ho=null
trigger Fo=null
trigger ko=null
trigger jo=null
trigger xo=null
trigger vo=null
trigger mo=null
trigger Qo=null
trigger Wo=null
trigger Eo=null
trigger Zo=null
trigger Uo=null
trigger Io=null
trigger Po=null
trigger Ao=null
trigger Do=null
trigger Ho=null
trigger Jo=null
trigger Ko=null
trigger Lo=null
trigger Xo=null
trigger Co=null
trigger Vo=null
trigger Bo=null
trigger No=null
trigger Mo=null
trigger wO=null
trigger uO=null
trigger rO=null
trigger sO=null
trigger tO=null
trigger iO=null
trigger SO=null
trigger cO=null
trigger oO=null
trigger OO=null
trigger lO=null
trigger bO=null
trigger yO=null
trigger pO=null
trigger eO=null
trigger qO=null
trigger aO=null
trigger nO=null
trigger dO=null
unit fO=null
unit RO=null
unit TO=null
unit YO=null
integer GO=0
integer gO=0
integer hO=0
integer FO=0
integer kO=0
integer jO=0
integer xO=0
integer vO=0
integer mO=0
integer QO=0
integer WO=0
integer EO=0
integer ZO=0
integer UO=0
integer IO=0
integer PO=0
integer AO=0
integer DO=0
integer HO=0
integer JO=0
integer KO=0
integer LO=0
integer XO=0
integer CO=0
integer VO=0
integer BO=0
integer NO=0
integer MO=0
real wl=.0
integer ul=0
integer rl=0
integer sl=0
integer tl=0
integer il=0
integer Sl=0
integer cl=0
integer ol=0
integer Ol=0
integer ll=0
integer bl=0
integer yl=0
real pl=.0
integer el=0
group ql=null
integer al=0
integer nl=0
group dl=null
unit fl=null
player Rl=null
real Tl=.0
integer Yl=0
integer Gl=0
integer gl=0
integer array hl
integer array Fl
real array kl
real array jl
boolean array xl
integer vl=0
player array ml
integer array Ql
integer array Wl
integer array El
integer Zl=0
player Ul=null
integer Il=0
playercolor array Pl
integer array Al
integer array Dl
integer Hl=0
integer Jl=0
integer array Kl
integer array Ll
integer Xl=0
integer array Cl
integer array Vl
integer array Bl
unit array Nl
integer Ml=0
integer array wb
integer array ub
integer array rb
integer array sb
integer array tb
integer array ib
integer array Sb
integer cb=0
integer array ob
integer Ob=0
integer lb=0
integer array bb
integer yb=0
integer array pb
integer array eb
integer array qb
string array ab
boolean array nb
boolean array db
rect array fb
real array Rb
real array Tb
real array Yb
real array Gb
integer gb=0
integer array hb
integer Fb=0
integer kb=0
integer array jb
integer array xb
trigger array vb
trigger array mb
integer array Qb
real array Wb
real array Eb
unit array Zb
integer array Ub
integer Ib=0
integer array Pb
unit array Ab
unit array Db
unit array Hb
trigger array Jb
integer array Kb
trigger array Lb
trigger Xb=null
trigger Cb=null
trigger Vb=null
trigger Bb=null
trigger Nb=null
trigger Mb=null
trigger array wy
integer uy=0
unit ry=null
integer sy=0
integer ty=0
integer iy=0
integer Sy=0
integer cy=0
integer oy=0
integer Oy=0
real ly=.0
real by=.0
integer yy=0
integer py=0
integer ey=0
integer qy=0
string array ay
integer array ny
real dy=.0
integer fy=0
integer Ry=0
player Ty=null
integer Yy=0
integer array Gy
integer array gy
integer hy=0
integer array Fy
integer array ky
integer array jy
integer array xy
integer vy=0
integer my=0
integer Qy=0
integer Wy=0
integer Ey=0
integer Zy=0
integer Uy=0
integer Iy=0
integer Py=0
real Ay=.0
real Dy=.0
integer Hy=0
string Jy=null
playerevent Ky=null
trigger Ly=null
trigger Xy=null
trigger Cy=null
integer array Vy
integer By=0
integer Ny=0
integer My=0
integer array wp
integer array up
boolean rp=false
group sp=null
integer array tp
integer ip=0
integer Sp=0
integer cp=0
filterfunc op=null
integer array Op
integer lp=0
trigger bp=null
integer yp=0
integer pp=0
integer ep=0
integer qp=0
integer ap=0
integer np=0
integer dp=0
integer fp=0
integer Rp=0
integer Tp=0
integer Yp=0
integer Gp=0
integer gp=0
integer hp=0
string Fp=null
integer kp=0
integer array jp
integer array xp
integer array vp
string array mp
string array Qp
integer Wp=0
integer Ep=0
integer Zp=0
real Up=.0
integer Ip=0
timer Pp=null
integer Ap=0
integer array Dp
integer Hp=0
integer Jp=0
integer Kp=0
integer Lp=0
integer Xp=0
integer Cp=0
hashtable Vp=null
string Bp=null
boolean Np=false
force Mp=null
boolean array we
integer array ue
integer re=0
integer array se
string te=null
framehandle ie=null
real Se=.0
real ce=.0
timer oe=null
real Oe=.0
string le=null
integer be=0
integer ye=0
string array pe
integer ee=0
group qe=null
group ae=null
hashtable ne=null
hashtable de=null
hashtable fe=null
timer Re=null
integer Te=0
boolean Ye=false
integer Ge=0
integer ge=0
integer he=0
string Fe=null
string ke=null
integer je=0
integer xe=0
string ve=null
boolean me=false
rect Qe=null
rect We=null
region Ee=null
real Ze=.0
real Ue=.0
real Ie=.0
real Pe=.0
real Ae=.0
real De=.0
real He=.0
real Je=.0
real Ke=.0
real Le=.0
real Xe=.0
integer Ce=0
integer Ve=0
integer Be=0
integer Ne=0
integer Me=0
gamecache wq=null
string uq=null
string rq=null
string sq=null
string tq=null
string iq=null
integer Sq=0
integer cq=0
integer oq=0
integer Oq=0
gamecache lq=null
gamecache bq=null
gamecache yq=null
gamecache pq=null
integer eq=0
integer qq=0
string aq=null
string nq=null
integer dq=0
integer fq=0
integer Rq=0
trigger Tq=null
trigger Yq=null
string Gq=null
string gq=null
trigger hq=null
group Fq=null
unit array kq
integer jq=0
integer xq=0
string array vq
string mq=null
integer Qq=0
integer Wq=0
integer Eq=0
integer Zq=0
integer Uq=0
integer Iq=0
string Pq=null
string Aq=null
string Dq=null
string Hq=null
string Jq=null
integer Kq=0
integer Lq=0
integer Xq=0
integer Cq=0
integer array Vq
integer Bq=0
integer array Nq
integer Mq=0
integer array wa
player ua=null
filterfunc ra=null
player array sa
player ta=null
playercolor ia=null
playercolor Sa=null
playercolor ca=null
playercolor oa=null
playercolor array Oa
integer la=0
integer ba=0
string array ya
string array pa
integer ea=0
integer qa=0
string aa=null
string na=null
string da=null
string fa=null
integer Ra=0
boolean Ta=false
group Ya=null
unit Ga=null
integer ga=0
real ha=.0
real Fa=.0
real ka=.0
integer ja=0
trigger array xa
integer va=0
integer ma=0
integer Qa=0
integer Wa=0
integer Ea=0
integer Za=0
integer Ua=0
integer Ia=0
integer Pa=0
integer Aa=0
integer Da=0
integer Ha=0
integer Ja=0
integer array Ka
integer La=0
integer Xa=0
boolean Ca=false
hashtable Va=null
integer Ba=0
integer Na=0
integer Ma=0
integer wn=0
integer un=0
integer rn=0
integer sn=0
integer tn=0
integer Sn=0
integer cn=0
integer on=0
integer On=0
integer ln=0
integer bn=0
integer yn=0
integer pn=0
integer en=0
integer qn=0
integer an=0
integer nn=0
integer dn=0
integer fn=0
integer Rn=0
integer Tn=0
integer Yn=0
hashtable Gn=null
string gn=null
integer hn=0
string Fn=null
string kn=null
string jn=null
integer xn=0
integer vn=0
integer mn=0
integer array Qn
integer Wn=0
integer En=0
integer Zn=0
integer Un=0
integer In=0
integer Pn=0
camerasetup array An
integer Dn=0
integer Hn=0
integer Jn=0
integer Kn=0
integer Ln=0
integer Xn=0
integer Cn=0
integer Vn=0
integer Bn=0
integer Nn=0
integer Mn=0
integer wd=0
integer ud=0
integer rd=0
integer sd=0
integer td=0
integer id=0
integer Sd=0
integer cd=0
integer od=0
integer array Od
integer ld=0
hashtable bd=null
hashtable yd=null
hashtable pd=null
integer ed=0
conditionfunc qd=null
code ad=null
integer nd=0
integer dd=0
integer fd=0
integer Rd=0
integer Td=0
integer Yd=0
integer Gd=0
integer array gd
integer array hd
string array Fd
integer kd=0
integer jd=0
integer array xd
integer vd=0
integer array md
integer Qd=0
integer Wd=0
integer Ed=0
integer Zd=0
integer Ud=0
integer Id=0
trigger Pd=null
group Ad=null
integer Dd=0
integer array Hd
string array Jd
integer Kd=0
integer array Ld
string array Xd
unit array Cd
real array Vd
real array Bd
string Nd=null
integer Md=0
integer wf=0
integer uf=0
integer rf=0
integer sf=0
integer tf=0
integer Sf=0
integer cf=0
integer of=0
integer Of=0
integer lf=0
integer bf=0
integer yf=0
integer pf=0
integer ef=0
integer qf=0
real array af
real array nf
integer df=0
string ff=null
string Rf=null
string Tf=null
string Yf=null
string Gf=null
string gf=null
string hf=null
real Ff=.0
real kf=.0
filterfunc jf=null
integer xf=0
unit array vf
integer mf=0
integer Qf=0
integer Wf=0
integer Ef=0
string Zf=null
integer Uf=0
string If=null
integer array Pf
real array Af
boolean array Df
real array Hf
real array Jf
boolean array Kf
integer array Lf
integer Xf=0
integer Cf=0
integer Vf=0
string array Bf
integer Nf=0
string array Mf
integer wR=0
integer uR=0
integer rR=0
integer sR=0
integer tR=0
integer iR=0
integer SR=0
integer cR=0
integer oR=0
integer OR=0
integer lR=0
integer bR=0
integer yR=0
integer pR=0
integer array eR
integer array qR
integer aR=0
real array nR
real array dR
boolean array fR
integer RR=0
integer TR=0
integer YR=0
integer GR=0
string gR=null
integer hR=0
integer FR=0
integer kR=0
string jR=null
integer xR=0
integer vR=0
string array mR
integer array QR
integer WR=0
string ER=null
string ZR=null
unit UR=null
integer IR=0
integer array PR
integer AR=0
integer DR=0
integer HR=0
integer JR=0
integer KR=0
hashtable LR=null
hashtable XR=null
string CR=null
string VR=null
string BR=null
string NR=null
string MR=null
string wT=null
string uT=null
timer array rT
integer sT=0
integer tT=0
integer iT=0
integer ST=0
integer cT=0
integer oT=0
integer OT=0
integer lT=0
integer bT=0
integer yT=0
integer pT=0
integer eT=0
integer qT=0
integer aT=0
integer nT=0
trigger dT=null
group fT=null
integer RT=0
real TT=.0
integer YT=0
trigger GT=null
trigger gT=null
unit array hT
integer FT=0
string array kT
integer jT=0
integer xT=0
string vT=null
string mT=null
string QT=null
string WT=null
string ET=null
string ZT=null
string UT=null
integer array IT
integer array PT
integer array AT
integer array DT
integer HT=0
string array JT
integer array KT
real LT=.0
real XT=.0
real CT=.0
real VT=.0
hashtable BT=null
real NT=.0
real MT=.0
location wY=null
integer array uY
integer rY=0
integer sY=0
integer array tY
integer array iY
integer SY=0
integer cY=0
integer array oY
integer array OY
integer lY=0
integer bY=0
integer array yY
integer array pY
integer eY=0
integer qY=0
integer array aY
integer array nY
integer dY=0
integer fY=0
integer array RY
integer array TY
integer YY=0
integer GY=0
integer array gY
integer array hY
integer FY=0
integer kY=0
integer array jY
integer array xY
integer vY=0
integer mY=0
integer array QY
integer array WY
integer EY=0
integer ZY=0
integer array UY
integer array IY
integer PY=0
integer AY=0
integer array DY
integer array HY
integer JY=0
integer KY=0
integer array LY
integer array XY
integer CY=0
integer VY=0
integer array BY
integer array NY
integer MY=0
integer wG=0
integer array uG
integer array rG
integer sG=0
integer tG=0
integer array iG
integer array SG
integer cG=0
integer oG=0
integer array OG
integer array lG
integer array bG
integer yG=0
integer pG=0
integer array eG
integer array qG
integer aG=0
integer nG=0
integer array dG
integer array fG
integer RG=0
integer TG=0
integer array YG
integer array GG
integer gG=0
integer hG=0
integer array FG
integer array kG
integer jG=0
integer xG=0
integer array vG
integer array mG
integer QG=0
integer WG=0
integer array EG
integer array ZG
integer UG=0
integer IG=0
integer array PG
integer array AG
integer DG=0
integer HG=0
integer array JG
integer array KG
integer LG=0
integer XG=0
integer array CG
integer array VG
integer BG=0
integer NG=0
integer array MG
integer array wg
integer ug=0
integer rg=0
integer array sg
integer array tg
integer ig=0
integer Sg=0
integer array cg
integer array og
integer Og=0
integer lg=0
integer array bg
integer array yg
integer pg=0
integer eg=0
integer array qg
integer array ag
integer ng=0
integer dg=0
integer array fg
integer array Rg
integer Tg=0
integer Yg=0
integer array Gg
integer array gg
integer hg=0
integer Fg=0
integer array kg
integer array jg
integer xg=0
integer vg=0
integer array mg
integer array Qg
integer Wg=0
integer Eg=0
integer array Zg
integer array Ug
integer Ig=0
integer Pg=0
integer array Ag
integer Dg=0
integer array Hg
integer array Jg
integer Kg=0
integer array Lg
integer array Xg
integer Cg=0
integer Vg=0
integer array Bg
integer array Ng
integer Mg=0
integer wh=0
integer array uh
integer array rh
integer sh=0
integer th=0
integer array ih
integer array Sh
integer ch=0
integer oh=0
integer array Oh
integer array lh
integer bh=0
integer yh=0
integer array ph
integer eh=0
integer array qh
integer array ah
integer nh=0
integer dh=0
integer array fh
integer array Rh
integer Th=0
integer Yh=0
integer array Gh
integer gh=0
integer hh=0
integer array Fh
integer array kh
integer jh=0
integer xh=0
integer array vh
integer array mh
integer Qh=0
integer Wh=0
integer array Eh
integer array Zh
integer Uh=0
integer Ih=0
integer array Ph
integer array Ah
integer Dh=0
integer Hh=0
integer array Jh
integer array Kh
integer Lh=0
integer Xh=0
integer array Ch
integer array Vh
integer Bh=0
integer Nh=0
integer array Mh
integer array wF
integer uF=0
integer rF=0
integer array sF
integer array tF
integer iF=0
integer SF=0
integer array cF
integer oF=0
integer OF=0
integer array lF
integer bF=0
integer array yF
integer array pF
integer eF=0
integer qF=0
integer array aF
integer array nF
integer dF=0
integer fF=0
integer array RF
integer array TF
integer YF=0
integer GF=0
integer array gF
integer array hF
integer FF=0
integer kF=0
integer array jF
integer array xF
integer vF=0
integer mF=0
integer array QF
integer array WF
integer EF=0
integer ZF=0
integer array UF
integer IF=0
integer array PF
integer array AF
integer array DF
integer array HF
integer JF=0
integer KF=0
integer array LF
integer array XF
integer CF=0
integer VF=0
integer array BF
integer array NF
integer MF=0
integer wk=0
integer array uk
integer array rk
integer sk=0
integer tk=0
integer array ik
integer Sk=0
integer array ck
integer array ok
integer Ok=0
integer lk=0
integer array bk
integer array yk
integer pk=0
integer ek=0
integer array qk
integer array ak
integer nk=0
integer dk=0
integer array fk
integer array Rk
integer Tk=0
integer Yk=0
integer array Gk
integer gk=0
integer array hk
integer array Fk
integer kk=0
integer jk=0
integer array xk
integer array vk
integer array mk
integer Qk=0
integer Wk=0
integer array Ek
integer array Zk
integer Uk=0
integer Ik=0
integer array Pk
integer array Ak
integer Dk=0
integer Hk=0
integer array Jk
integer array Kk
integer Lk=0
integer Xk=0
integer array Ck
integer array Vk
integer Bk=0
integer Nk=0
integer array Mk
integer array wj
integer uj=0
integer rj=0
integer array sj
integer array tj
integer ij=0
integer Sj=0
integer array cj
integer array oj
integer Oj=0
integer lj=0
integer array bj
integer array yj
integer pj=0
integer ej=0
integer array qj
integer array aj
integer nj=0
integer dj=0
integer array fj
integer array Rj
integer Tj=0
integer Yj=0
integer array Gj
integer array gj
integer hj=0
integer Fj=0
integer array kj
integer array jj
integer xj=0
integer vj=0
integer array mj
integer array Qj
integer Wj=0
integer Ej=0
integer array Zj
integer array Uj
integer Ij=0
integer Pj=0
integer array Aj
integer array Dj
integer Hj=0
integer Jj=0
integer array Kj
integer array Lj
integer Xj=0
integer Cj=0
integer array Vj
integer array Bj
integer Nj=0
integer Mj=0
integer array wx
integer array ux
integer rx=0
integer sx=0
integer array tx
integer array ix
integer Sx=0
integer cx=0
integer array ox
integer array Ox
integer lx=0
integer bx=0
integer array yx
integer array px
integer ex=0
integer qx=0
integer array ax
integer array nx
integer dx=0
integer fx=0
integer array Rx
integer array Tx
integer Yx=0
integer Gx=0
integer array gx
integer array hx
integer Fx=0
integer kx=0
integer array jx
integer array xx
integer vx=0
integer mx=0
integer array Qx
integer array Wx
integer Ex=0
integer Zx=0
integer array Ux
integer array Ix
integer Px=0
integer Ax=0
integer array Dx
integer array Hx
integer Jx=0
integer Kx=0
integer array Lx
integer array Xx
integer Cx=0
integer Vx=0
integer array Bx
integer array Nx
integer Mx=0
integer wv=0
integer array uv
integer array rv
integer sv=0
integer tv=0
integer array iv
integer array Sv
integer cv=0
integer ov=0
integer array Ov
integer array lv
integer bv=0
integer yv=0
integer array pv
integer array ev
integer qv=0
integer av=0
integer array nv
integer array dv
integer fv=0
integer Rv=0
integer array Tv
integer Yv=0
integer Gv=0
integer array gv
integer array hv
integer Fv=0
integer kv=0
integer array jv
integer array xv
integer vv=0
integer mv=0
integer array Qv
integer array Wv
integer Ev=0
integer Zv=0
integer array Uv
integer array Iv
integer Pv=0
integer Av=0
integer array Dv
integer array Hv
integer Jv=0
integer Kv=0
integer array Lv
integer array Xv
integer Cv=0
integer Vv=0
integer array Bv
integer Nv=0
integer Mv=0
integer array wm
integer array um
integer rm=0
integer sm=0
integer array tm
integer im=0
integer array Sm
integer array cm
integer om=0
integer Om=0
integer array lm
integer array bm
integer array ym
integer pm=0
integer em=0
integer array qm
integer am=0
integer nm=0
integer array dm
integer array fm
integer Rm=0
integer Tm=0
integer array Ym
integer array Gm
integer gm=0
integer hm=0
integer array Fm
integer array km
integer jm=0
integer xm=0
integer array vm
integer mm=0
integer Qm=0
integer array Wm
integer array Em
integer Zm=0
integer Um=0
integer array Im
integer array Pm
integer Am=0
integer Dm=0
integer array Hm
integer Jm=0
integer Km=0
integer array Lm
integer array Xm
integer Cm=0
integer Vm=0
integer array Bm
integer array Nm
integer Mm=0
integer wQ=0
integer array uQ
integer array rQ
integer array sQ
integer array tQ
boolean array iQ
integer array SQ
integer array cQ
integer array oQ
integer array OQ
integer array lQ
integer array bQ
string array yQ
string array pQ
integer array eQ
integer array qQ
integer array aQ
integer array nQ
integer array dQ
integer array fQ
integer array RQ
integer array TQ
integer array YQ
integer array GQ
integer array gQ
integer array hQ
integer array FQ
string array kQ
string array jQ
integer array xQ
integer array vQ
string array mQ
integer array QQ
integer array WQ
integer array EQ
integer array ZQ
integer array UQ
integer array IQ
integer array PQ
integer array AQ
integer array DQ
integer array HQ
integer array JQ
integer array KQ
unit array LQ
integer array XQ
integer array CQ
integer array VQ
integer array BQ
integer array NQ
integer array MQ
integer array wW
integer array uW
integer array rW
integer array sW
integer array tW
integer array iW
integer array SW
integer array cW
integer array oW
integer array OW
integer array lW
integer array bW
integer array yW
integer array pW
integer array eW
integer array qW
string array aW
integer array nW
integer array dW
real array fW
integer array RW
integer array TW
integer array YW
integer array GW
integer array gW
integer array hW
integer array FW
integer array kW
unit array jW
frameeventtype array xW
integer array vW
integer array mW
timer array QW
timer array WW
integer array EW
boolean array ZW
integer array UW
boolean array IW
real array PW
boolean array AW
integer array DW
boolean array HW
integer array JW
boolean array KW
integer array LW
boolean array XW
real array CW
boolean array VW
integer array BW
boolean array NW
integer array MW
integer array wE
integer array uE
integer array rE
integer array sE
integer array tE
integer array iE
integer array SE
integer array cE
integer array oE
player array OE
integer array lE
real array bE
real array yE
integer array pE
integer array eE
player array qE
real array aE
real array nE
integer array dE
integer array fE
integer array RE
integer array TE
integer array YE
real array GE
real array gE
real array hE
real array FE
real array kE
integer array jE
real array xE
real array vE
integer array mE
integer array QE
integer array WE
real array EE
integer array ZE
real array UE
real array IE
player array PE
unit array AE
integer array DE
integer array HE
integer array JE
integer array KE
integer array LE
unit array XE
real array CE
integer array VE
integer array BE
integer array NE
integer array ME
integer array wZ
real array uZ
real array rZ
integer array sZ
integer array tZ
integer array iZ
real array SZ
real array cZ
player array oZ
integer array OZ
unit array lZ
integer array bZ
integer array yZ
integer array pZ
integer array eZ
real array qZ
real array aZ
gamecache array nZ
string array dZ
integer array fZ
integer array RZ
integer array TZ
integer array YZ
integer array GZ
integer array gZ
integer array hZ
integer array FZ
integer array kZ
integer array jZ
integer array xZ
string array vZ
integer array mZ
integer array QZ
integer array WZ
integer array EZ
integer array ZZ
integer array UZ
integer array IZ
integer array PZ
integer array AZ
integer array DZ
integer array HZ
integer array JZ
integer array KZ
integer array LZ
integer array XZ
integer array CZ
integer array VZ
integer array BZ
integer array NZ
integer array MZ
integer array wU
integer array uU
integer array rU
integer array sU
integer array tU
integer array iU
integer array SU
integer array cU
integer array oU
integer array OU
integer array lU
integer array bU
boolean array yU
integer array pU
integer array eU
boolean array qU
integer array aU
integer array nU
real array dU
real array fU
integer array RU
integer array TU
integer array YU
boolean array GU
integer array gU
integer array hU
integer array FU
integer array kU
integer array jU
real array xU
integer array vU
integer array mU
integer array QU
integer array WU
integer array EU
real array ZU
real array UU
integer array IU
integer array PU
integer array AU
integer array DU
real array HU
integer array JU
integer array KU
integer array LU
integer array XU
integer array CU
string array VU
real array BU
real array NU
integer array MU
integer array wI
integer array uI
string array rI
integer array sI
integer array tI
integer array iI
integer array SI
integer array cI
string array oI
integer array OI
integer array lI
integer array bI
integer array yI
integer array pI
integer array eI
integer array qI
integer array aI
integer array nI
integer array dI
integer array fI
integer array RI
integer array TI
real array YI
integer array GI
integer array gI
integer array hI
integer array FI
integer array kI
real array jI
real array xI
real array vI
real array mI
real array QI
real array WI
integer array EI
integer array ZI
integer array UI
integer array II
integer array PI
real array AI
integer array DI
real array HI
integer array JI
real array KI
integer array LI
integer array XI
integer array CI
integer array VI
real array BI
real array NI
real array MI
integer array wP
integer array uP
integer array rP
integer array sP
integer array tP
integer array iP
integer array SP
boolean array cP
integer array oP
integer array OP
integer array lP
integer array bP
integer array yP
integer array pP
integer array eP
hashtable array qP
hashtable array aP
string array nP
string array dP
integer array fP
boolean array RP
string array TP
integer array YP
integer array GP
integer array gP
integer array hP
integer array FP
integer array kP
integer array jP
integer array xP
integer array vP
string array mP
integer array QP
integer array WP
integer array EP
integer array ZP
integer array UP
integer array IP
integer array PP
integer array AP
player array DP
integer array HP
integer array JP
integer array KP
integer array LP
integer array XP
boolean array CP
integer array VP
integer array BP
integer array NP
integer array MP
integer array wA
integer array uA
integer array rA
integer array sA
integer array tA
integer array iA
integer array SA
integer array cA
integer array oA
integer array OA
integer array lA
integer array bA
integer array yA
integer array pA
integer array eA
integer array qA
integer array aA
integer array nA
integer array dA
integer array fA
integer array RA
integer array TA
integer array YA
integer array GA
integer array gA
integer array hA
integer array FA
integer array kA
integer array jA
string array xA
integer array vA
integer array mA
integer array QA
integer array WA
integer array EA
integer array ZA
integer array UA
player array IA
integer array PA
integer array AA
integer array DA
integer array HA
integer array JA
boolean array KA
integer array LA
integer array XA
integer array CA
integer array VA
integer array BA
integer array NA
integer array MA
integer array wD
integer array uD
integer array rD
integer array sD
integer array tD
integer array iD
integer array SD
integer array cD
integer array oD
integer array OD
integer array lD
integer array bD
integer array yD
integer array pD
integer array eD
integer array qD
integer array aD
integer array nD
integer array dD
integer array fD
integer array RD
integer array TD
integer array YD
integer array GD
integer array gD
integer array hD
integer array FD
integer array kD
integer array jD
player array xD
integer array vD
integer array mD
integer array QD
integer array WD
integer array ED
integer array ZD
integer array UD
integer array ID
integer array PD
player array AD
integer array DD
integer array HD
integer array JD
integer array KD
integer array LD
integer array XD
integer array CD
integer array VD
integer array BD
integer array ND
integer array MD
integer array wH
integer array uH
integer array rH
integer array sH
integer array tH
integer array iH
integer array SH
integer array cH
integer array oH
integer array OH
integer array lH
integer array bH
integer array yH
integer array pH
integer array eH
boolean array qH
boolean array aH
integer array nH
integer array dH
real array fH
real array RH
real array TH
real array YH
real array GH
real array gH
integer array hH
player array FH
string array kH
real array jH
real array xH
real array vH
real array mH
rect array QH
string array WH
integer array EH
real array ZH
real array UH
real array IH
real array PH
real array AH
real array DH
real array HH
real array JH
integer array KH
integer array LH
integer array XH
integer array CH
integer array VH
integer array BH
integer array NH
integer array MH
integer array wJ
string array uJ
integer array rJ
integer array sJ
integer array tJ
integer array iJ
integer array SJ
framehandle array cJ
framehandle array oJ
framehandle array OJ
integer array lJ
integer array bJ
integer array yJ
boolean array pJ
integer array eJ
integer array qJ
integer array aJ
integer array nJ
integer array dJ
integer array fJ
integer array RJ
integer array TJ
integer array YJ
integer array GJ
integer array gJ
boolean array hJ
string array FJ
integer array kJ
integer array jJ
integer array xJ
boolean array vJ
boolean array mJ
boolean array QJ
integer array WJ
integer array EJ
integer array ZJ
integer array UJ
camerasetup array IJ
integer array PJ
unit array AJ
unit array DJ
unit array HJ
unit array JJ
real array KJ
real array LJ
integer array XJ
destructable array CJ
item array VJ
item array BJ
integer array NJ
destructable array MJ
string array wK
integer array uK
integer array rK
integer array sK
integer array tK
integer array iK
integer array SK
group array cK
handle array oK
integer array OK
string array lK
item array bK
real array yK
string array pK
rect array eK
region array qK
integer array aK
integer array nK
integer array dK
sound array fK
string array RK
effect array TK
string array YK
string array GK
string array gK
string array hK
integer array FK
boolean array kK
trigger array jK
integer array xK
triggercondition array vK
triggeraction array mK
integer array QK
string array WK
integer array EK
unit array ZK
integer array UK
weathereffect array IK
widget array PK
string array AK
integer array DK
integer array HK
string array JK
integer array KK
unit array LK
integer array XK
integer array CK
integer array VK
unit array BK
integer array NK
integer array MK
integer array wL
integer array uL
group array rL
real array sL
integer array tL
integer array iL
integer array SL
integer array cL
integer array oL
integer array OL
integer array lL
integer array bL
integer array yL
group array pL
integer array eL
integer array qL
integer array aL
integer array nL
integer array dL
unit array fL
rect array RL
integer array TL
integer array YL
real array GL
real array gL
integer array hL
string array FL
string array kL
integer array jL
integer array xL
string array vL
integer array mL
string array QL
integer array WL
integer array EL
string array ZL
string array UL
string array IL
integer array PL
unit array AL
integer array DL
unit array HL
integer array JL
integer array KL
integer array LL
unit array XL
integer array CL
integer array VL
integer array BL
real array NL
real array ML
integer array wX
integer array uX
integer array rX
integer array sX
integer array tX
integer array iX
real array SX
real array cX
integer array oX
integer array OX
integer array lX
integer array bX
integer array yX
integer array pX
integer array eX
integer array qX
integer array aX
integer array nX
integer array dX
integer array fX
integer array RX
integer array TX
integer array YX
integer array GX
integer array gX
string array hX
string array FX
integer array kX
string array jX
string array xX
integer array vX
integer array mX
integer array QX
integer array WX
integer array EX
integer array ZX
integer array UX
integer array IX
string array PX
integer array AX
integer array DX
integer array HX
integer array JX
integer array KX
integer array LX
integer array XX
integer array CX
boolean array VX
boolean array BX
integer array NX
integer array MX
integer array wC
integer array uC
string array rC
integer array sC
integer array tC
integer array iC
string array SC
integer array cC
integer array oC
unit array OC
integer array lC
integer array bC
integer array yC
integer array pC
integer array eC
boolean array qC
integer array aC
integer array nC
real array dC
real array fC
real array RC
real array TC
integer array YC
integer array GC
integer array gC
integer array hC
integer array FC
boolean array kC
integer array jC
integer array xC
integer array vC
integer array mC
boolean array QC
integer array WC
integer array EC
integer array ZC
integer array UC
integer array IC
integer array PC
integer array AC
string array DC
string array HC
integer array JC
integer array KC
integer array LC
integer array XC
integer array CC
integer array VC
integer array BC
integer array NC
integer array MC
integer array wV
integer array uV
integer array rV
rect array sV
integer array tV
real array iV
real array SV
integer array cV
integer array oV
player array OV
real array lV
real array bV
integer array yV
integer array pV
integer array eV
integer array qV
integer array aV
real array nV
real array dV
real array fV
real array RV
integer array TV
integer array YV
integer array GV
integer array gV
integer array hV
integer array FV
integer array kV
integer array jV
integer array xV
integer array vV
integer array mV
integer array QV
integer array WV
real array EV
integer array ZV
integer array UV
integer array IV
integer array PV
integer array AV
real array DV
integer array HV
real array JV
real array KV
real array LV
real array XV
real array CV
integer array VV
integer array BV
integer array NV
integer array MV
real array wB
integer array uB
integer array rB
integer array sB
integer array tB
real array iB
integer array SB
integer array cB
integer array oB
integer array OB
integer array lB
integer array bB
integer array yB
integer array pB
integer array eB
integer array qB
integer array aB
integer array nB
real array dB
real array fB
integer array RB
integer array TB
integer array YB
unit array GB
integer array gB
integer array hB
integer array FB
integer array kB
integer array jB
integer array xB
boolean array vB
boolean array mB
integer array QB
integer array WB
integer array EB
integer array ZB
integer array UB
integer array IB
real array PB
integer array AB
integer array DB
integer array HB
real array JB
real array KB
real array LB
integer array XB
integer array CB
integer array VB
integer array BB
integer array NB
integer array MB
integer array wN
integer array uN
integer array rN
integer array sN
integer array tN
integer array iN
unit array SN
player array cN
integer array oN
real array ON
real array lN
integer array bN
integer array yN
player array pN
real array eN
real array qN
integer array aN
integer array nN
integer array dN
integer array fN
integer array RN
integer array TN
integer array YN
real array GN
integer array gN
integer array hN
integer array FN
integer array kN
integer array jN
real array xN
integer array vN
real array mN
real array QN
real array WN
real array EN
real array ZN
integer array UN
integer array IN
integer array PN
integer array AN
integer array DN
integer array HN
integer array JN
integer array KN
integer array LN
integer array XN
integer array CN
real array VN
integer array BN
integer array NN
integer array MN
integer array wM
real array uM
integer array rM
integer array sM
integer array tM
integer array iM
integer array SM
integer array cM
integer array oM
integer array OM
integer array lM
integer array bM
integer array yM
integer array pM
integer array eM
integer array qM
integer array aM
integer array nM
integer array dM
hashtable array fM
hashtable array RM
string array TM
integer array YM
string array GM
integer array gM
integer array hM
integer array FM
integer array kM
integer array jM
boolean array xM
integer array vM
integer array mM
string array QM
integer array WM
integer EM=0
string array ZM
real UM=.0
real IM=.0
real PM=.0
real AM=.0
integer DM=0
integer HM=0
integer JM=0
integer KM=0
integer LM=0
integer XM=0
integer CM=0
integer VM=0
integer BM=0
integer NM=0
integer MM=0
real w3=.0
real u3=.0
real r3=.0
real s3=.0
real t3=.0
real i3=.0
real S3=.0
real c3=.0
real o3=.0
real O3=.0
integer l3=0
integer b3=0
integer y3=0
integer p3=0
integer e3=0
integer q3=0
integer a3=0
integer n3=0
integer d3=0
integer f3=0
integer R3=0
integer T3=0
boolean Y3=false
integer G3=0
boolean g3=false
real h3=.0
boolean F3=false
integer k3=0
boolean j3=false
real x3=.0
boolean v3=false
integer m3=0
boolean Q3=false
integer W3=0
integer E3=0
integer Z3=0
integer U3=0
real I3=.0
real P3=.0
real A3=.0
real D3=.0
real H3=.0
real J3=.0
real K3=.0
real L3=.0
real X3=.0
real C3=.0
real V3=.0
real B3=.0
integer N3=0
integer M3=0
real w1=.0
real u1=.0
real r1=.0
integer s1=0
integer t1=0
real i1=.0
integer S1=0
integer c1=0
real o1=.0
real O1=.0
real l1=.0
real b1=.0
integer y1=0
real p1=.0
real e1=.0
real q1=.0
real a1=.0
real n1=.0
real d1=.0
real f1=.0
real R1=.0
real T1=.0
real Y1=.0
integer G1=0
integer g1=0
integer h1=0
real F1=.0
real k1=.0
integer j1=0
player x1=null
integer v1=0
integer m1=0
integer Q1=0
integer W1=0
integer E1=0
string Z1=null
string U1=null
string I1=null
string P1=null
string A1=null
integer D1=0
string H1=null
boolean J1=false
integer K1=0
real L1=.0
real X1=.0
integer C1=0
real V1=.0
real B1=.0
real N1=.0
real M1=.0
integer w4=0
integer u4=0
integer r4=0
integer s4=0
integer t4=0
integer i4=0
integer S4=0
integer c4=0
integer o4=0
integer O4=0
integer l4=0
integer b4=0
integer y4=0
integer p4=0
integer e4=0
integer q4=0
integer a4=0
integer n4=0
integer d4=0
integer f4=0
integer R4=0
integer T4=0
integer Y4=0
integer G4=0
integer g4=0
integer h4=0
integer F4=0
integer k4=0
integer j4=0
integer x4=0
integer v4=0
integer m4=0
real Q4=.0
integer W4=0
integer E4=0
integer Z4=0
integer U4=0
integer I4=0
real P4=.0
integer A4=0
real D4=.0
integer H4=0
integer J4=0
integer K4=0
integer L4=0
integer X4=0
real C4=.0
integer V4=0
real B4=.0
integer N4=0
integer M4=0
integer w2=0
integer u2=0
integer r2=0
real s2=.0
integer t2=0
integer i2=0
real S2=.0
real c2=.0
real o2=.0
real O2=.0
real l2=.0
real b2=.0
real y2=.0
integer p2=0
real e2=.0
real q2=.0
real a2=.0
real n2=.0
real d2=.0
integer f2=0
real R2=.0
real T2=.0
real Y2=.0
real G2=.0
real g2=.0
integer h2=0
integer F2=0
integer k2=0
integer j2=0
integer x2=0
integer v2=0
integer m2=0
integer Q2=0
integer W2=0
real E2=.0
integer Z2=0
integer U2=0
integer I2=0
integer P2=0
integer A2=0
integer D2=0
real H2=.0
integer J2=0
integer K2=0
integer L2=0
integer X2=0
real C2=.0
integer V2=0
integer B2=0
integer N2=0
integer M2=0
integer w5=0
integer u5=0
integer r5=0
integer s5=0
integer t5=0
real i5=.0
integer S5=0
integer c5=0
integer o5=0
integer O5=0
integer l5=0
integer b5=0
real y5=.0
integer p5=0
integer e5=0
integer q5=0
integer a5=0
real n5=.0
integer d5=0
integer f5=0
integer R5=0
integer T5=0
integer Y5=0
integer G5=0
integer g5=0
integer h5=0
integer F5=0
integer k5=0
real j5=.0
integer x5=0
integer v5=0
integer m5=0
integer Q5=0
integer W5=0
integer E5=0
real Z5=.0
integer U5=0
integer I5=0
integer P5=0
integer A5=0
real D5=.0
integer H5=0
integer J5=0
integer K5=0
integer L5=0
integer X5=0
integer C5=0
integer V5=0
integer B5=0
integer N5=0
integer M5=0
integer w6=0
integer u6=0
integer r6=0
integer s6=0
integer t6=0
integer i6=0
integer S6=0
integer c6=0
integer o6=0
integer O6=0
integer l6=0
real b6=.0
integer y6=0
integer p6=0
integer e6=0
integer q6=0
integer a6=0
real n6=.0
integer d6=0
real f6=.0
integer R6=0
integer T6=0
integer Y6=0
integer G6=0
integer g6=0
real h6=.0
integer F6=0
real k6=.0
integer j6=0
integer x6=0
integer v6=0
integer m6=0
integer Q6=0
real W6=.0
integer E6=0
integer Z6=0
real U6=.0
real I6=.0
real P6=.0
real A6=.0
real D6=.0
integer H6=0
real J6=.0
real K6=.0
real L6=.0
real X6=.0
real C6=.0
integer V6=0
real B6=.0
real N6=.0
real M6=.0
real w7=.0
real u7=.0
integer r7=0
integer s7=0
integer t7=0
integer i7=0
integer S7=0
integer c7=0
integer o7=0
integer O7=0
integer l7=0
integer b7=0
integer y7=0
integer p7=0
integer e7=0
integer q7=0
integer a7=0
integer n7=0
integer d7=0
integer f7=0
integer R7=0
integer T7=0
integer Y7=0
integer G7=0
integer g7=0
integer h7=0
integer F7=0
integer k7=0
integer j7=0
integer x7=0
integer v7=0
integer m7=0
integer Q7=0
integer W7=0
integer E7=0
integer Z7=0
integer U7=0
integer I7=0
integer P7=0
integer A7=0
integer D7=0
integer H7=0
integer J7=0
integer K7=0
integer L7=0
integer X7=0
integer C7=0
integer V7=0
integer B7=0
integer N7=0
real M7=.0
integer w8=0
integer u8=0
integer r8=0
integer s8=0
real t8=.0
integer i8=0
integer S8=0
integer c8=0
integer o8=0
real O8=.0
integer l8=0
integer b8=0
integer y8=0
integer p8=0
integer e8=0
integer q8=0
real a8=.0
integer n8=0
integer d8=0
integer f8=0
integer R8=0
real T8=.0
integer Y8=0
integer G8=0
integer g8=0
integer h8=0
integer F8=0
integer k8=0
integer j8=0
integer x8=0
real v8=.0
integer m8=0
integer Q8=0
integer W8=0
integer E8=0
real Z8=.0
integer U8=0
integer I8=0
integer P8=0
integer A8=0
integer D8=0
integer H8=0
integer J8=0
integer K8=0
real L8=.0
integer X8=0
integer C8=0
integer V8=0
integer B8=0
real N8=.0
integer M8=0
integer w9=0
integer u9=0
integer r9=0
integer s9=0
integer t9=0
integer i9=0
integer S9=0
integer c9=0
integer o9=0
integer O9=0
integer l9=0
integer b9=0
integer y9=0
integer p9=0
integer e9=0
integer q9=0
integer a9=0
real n9=.0
real d9=.0
real f9=.0
real R9=.0
real T9=.0
real Y9=.0
real G9=.0
integer g9=0
real h9=.0
real F9=.0
real k9=.0
real j9=.0
integer x9=0
integer v9=0
integer m9=0
integer Q9=0
integer W9=0
integer E9=0
integer Z9=0
integer U9=0
integer I9=0
integer P9=0
integer A9=0
real D9=.0
real H9=.0
real J9=.0
real K9=.0
real L9=.0
real X9=.0
real C9=.0
real V9=.0
boolean B9=false
string N9=null
boolean M9=false
string z=null
boolean zv=false
string ze=null
boolean zx=false
string to=null
boolean zo=false
string zr=null
integer zi=0
string za=null
integer in=0
string zn=null
boolean zV=false
string zE=null
integer zX=0
string zO=null
real zR=.0
real zI=.0
real zA=.0
real zN=.0
integer zb=0
real zB=.0
real zc=.0
integer zC=0
integer zd=0
integer zD=0
integer zf=0
unit array zF
unit array zg
unit array zG
unit array zh
unit array zH
unit array zj
integer array zJ
integer array zk
integer array zK
integer array zl
integer array zL
integer array zm
integer array zM
integer array zp
integer array zP
integer array zq
real array zQ
real array zs
integer array zS
integer array it
integer array zt
integer array zT
boolean array zu
boolean array zU
boolean array zw
boolean array zW
boolean array zy
boolean array zY
boolean array vz
boolean array ez
boolean array xz
boolean array oz
boolean array rz
boolean array iz
integer array az
integer array nz
integer array Vz
integer array Ez
integer array Xz
integer array Oz
code Rz=null
code Iz=null
code Az=null
code Nz=null
code bz=null
code Bz=null
code cz=null
code Cz=null
code dz=null
code Dz=null
code fz=null
code Fz=null
code gz=null
code Gz=null
code hz=null
code Hz=null
code jz=null
code Jz=null
code kz=null
code Kz=null
code lz=null
code Lz=null
code mz=null
code Mz=null
code pz=null
code Pz=null
code qz=null
code Qz=null
code sz=null
code Sz=null
code tz=null
code Tz=null
code uz=null
code Uz=null
code wz=null
code Wz=null
code yz=null
code Yz=null
code zz=null
code Zz=null
code zZ=null
code v0=null
code e0=null
code x0=null
code o0=null
code r0=null
code i0=null
code a0=null
code n0=null
code V0=null
code E0=null
code X0=null
code O0=null
code R0=null
code I0=null
code A0=null
code N0=null
code b0=null
code B0=null
code c0=null
code C0=null
code d0=null
code D0=null
code f0=null
code F0=null
code g0=null
code G0=null
code h0=null
code H0=null
code j0=null
code J0=null
code k0=null
code K0=null
code l0=null
code L0=null
code m0=null
code M0=null
code p0=null
code P0=null
code q0=null
code Q0=null
code s0=null
code S0=null
code t0=null
code T0=null
code u0=null
code U0=null
code w0=null
code W0=null
code y0=null
code Y0=null
code z0=null
code Z0=null
code z1=null
code z2=null
code z3=null
code z4=null
code z5=null
code z6=null
code z7=null
code z8=null
code vvv=null
code vev=null
code vxv=null
code vov=null
code vrv=null
code viv=null
code vav=null
code vnv=null
code vVv=null
code vEv=null
code vXv=null
code vOv=null
code vRv=null
code vIv=null
code vAv=null
code vNv=null
code vbv=null
code vBv=null
code vcv=null
code vCv=null
code vdv=null
code vDv=null
code vfv=null
code vFv=null
code vgv=null
code vGv=null
code vhv=null
code vHv=null
code vjv=null
code vJv=null
code vkv=null
code vKv=null
code vlv=null
code vLv=null
code vmv=null
code vMv=null
code vpv=null
code vPv=null
code vqv=null
code vQv=null
code vsv=null
code vSv=null
code vtv=null
code vTv=null
code vuv=null
code vUv=null
code vwv=null
code vWv=null
code vyv=null
code vYv=null
code vzv=null
code vZv=null
code v_v=null
code v0v=null
code v1v=null
code v2v=null
code v3v=null
code v4v=null
code v5v=null
code v6v=null
code v7v=null
code v8v=null
code v9v=null
code evv=null
code eev=null
code exv=null
code eov=null
code erv=null
code eiv=null
code eav=null
code env=null
code eVv=null
code eEv=null
code eXv=null
code eOv=null
code eRv=null
code eIv=null
code eAv=null
code eNv=null
code ebv=null
code eBv=null
code ecv=null
code eCv=null
code edv=null
code eDv=null
code efv=null
code eFv=null
code egv=null
code eGv=null
code ehv=null
code eHv=null
code ejv=null
code eJv=null
code ekv=null
code eKv=null
code elv=null
code eLv=null
code emv=null
code eMv=null
code epv=null
code ePv=null
code eqv=null
code eQv=null
code esv=null
code eSv=null
code etv=null
code eTv=null
code euv=null
code eUv=null
code ewv=null
code eWv=null
code eyv=null
code eYv=null
code ezv=null
code eZv=null
code e_v=null
code e0v=null
code e1v=null
code e2v=null
code e3v=null
code e4v=null
code e5v=null
code e6v=null
code e7v=null
code e8v=null
code e9v=null
code xvv=null
code xev=null
code xxv=null
code xov=null
code xrv=null
code xiv=null
code xav=null
code xnv=null
code xVv=null
code xEv=null
code xXv=null
code xOv=null
code xRv=null
code xIv=null
code xAv=null
code xNv=null
code xbv=null
code xBv=null
code xcv=null
code xCv=null
code xdv=null
code xDv=null
code xfv=null
code xFv=null
code xgv=null
code xGv=null
code xhv=null
code xHv=null
code xjv=null
code xJv=null
code xkv=null
code xKv=null
code xlv=null
code xLv=null
code xmv=null
code xMv=null
code xpv=null
code xPv=null
code xqv=null
code xQv=null
code xsv=null
code xSv=null
code xtv=null
code xTv=null
code xuv=null
code xUv=null
code xwv=null
code xWv=null
code xyv=null
code xYv=null
code xzv=null
code xZv=null
code x_v=null
code x0v=null
code x1v=null
code x2v=null
code x3v=null
code x4v=null
code x5v=null
code x6v=null
code x7v=null
code x8v=null
code x9v=null
code ovv=null
code oev=null
code oxv=null
code oov=null
code orv=null
code oiv=null
code oav=null
code onv=null
code oVv=null
code oEv=null
code oXv=null
code oOv=null
code oRv=null
code oIv=null
code oAv=null
code oNv=null
code obv=null
code oBv=null
code ocv=null
code oCv=null
code odv=null
code oDv=null
code ofv=null
code oFv=null
code ogv=null
code oGv=null
code ohv=null
code oHv=null
code ojv=null
code oJv=null
code okv=null
code oKv=null
code olv=null
code oLv=null
code omv=null
code oMv=null
code opv=null
code oPv=null
code oqv=null
code oQv=null
code osv=null
code oSv=null
code otv=null
code oTv=null
code ouv=null
code oUv=null
code owv=null
code oWv=null
code oyv=null
code oYv=null
code ozv=null
code oZv=null
code o_v=null
code o0v=null
code o1v=null
code o2v=null
code o3v=null
code o4v=null
code o5v=null
code o6v=null
code o7v=null
code o8v=null
code o9v=null
code rvv=null
code rev=null
code rxv=null
code rov=null
code rrv=null
code riv=null
code rav=null
code rnv=null
code rVv=null
code rEv=null
code rXv=null
code rOv=null
code rRv=null
code rIv=null
code rAv=null
code rNv=null
code rbv=null
code rBv=null
code rcv=null
code rCv=null
code rdv=null
code rDv=null
code rfv=null
code rFv=null
code rgv=null
code rGv=null
code rhv=null
code rHv=null
code rjv=null
code rJv=null
code rkv=null
code rKv=null
code rlv=null
code rLv=null
code rmv=null
code rMv=null
code rpv=null
code rPv=null
code rqv=null
code rQv=null
code rsv=null
code rSv=null
code rtv=null
code rTv=null
code ruv=null
code rUv=null
code rwv=null
code rWv=null
code ryv=null
code rYv=null
code rzv=null
code rZv=null
code r_v=null
code r0v=null
code r1v=null
code r2v=null
code r3v=null
code r4v=null
code r5v=null
code r6v=null
code r7v=null
code r8v=null
code r9v=null
code ivv=null
code iev=null
code ixv=null
code iov=null
code irv=null
code iiv=null
code iav=null
code inv=null
code iVv=null
code iEv=null
code iXv=null
code iOv=null
code iRv=null
code iIv=null
code iAv=null
code iNv=null
code ibv=null
code iBv=null
code icv=null
code iCv=null
code idv=null
code iDv=null
code ifv=null
code iFv=null
code igv=null
code iGv=null
code ihv=null
code iHv=null
code ijv=null
code iJv=null
code ikv=null
code iKv=null
code ilv=null
code iLv=null
code imv=null
code iMv=null
code ipv=null
code iPv=null
code iqv=null
code iQv=null
code isv=null
code iSv=null
code itv=null
code iTv=null
code iuv=null
code iUv=null
code iwv=null
code iWv=null
code iyv=null
code iYv=null
code izv=null
code iZv=null
code i_v=null
code i0v=null
code i1v=null
code i2v=null
code i3v=null
code i4v=null
code i5v=null
code i6v=null
code i7v=null
code i8v=null
code i9v=null
code avv=null
code aev=null
code axv=null
code aov=null
code arv=null
code aiv=null
code aav=null
code anv=null
code aVv=null
code aEv=null
code aXv=null
code aOv=null
code aRv=null
code aIv=null
code aAv=null
code aNv=null
code abv=null
code aBv=null
code acv=null
code aCv=null
code adv=null
code aDv=null
code afv=null
code aFv=null
code agv=null
code aGv=null
code ahv=null
code aHv=null
code ajv=null
code aJv=null
code akv=null
code aKv=null
code alv=null
code aLv=null
code amv=null
code aMv=null
code apv=null
code aPv=null
code aqv=null
code aQv=null
code asv=null
code aSv=null
code atv=null
code aTv=null
code auv=null
code aUv=null
code awv=null
code aWv=null
code ayv=null
code aYv=null
code azv=null
code aZv=null
code a_v=null
code a0v=null
code a1v=null
code a2v=null
code a3v=null
code a4v=null
code a5v=null
code a6v=null
code a7v=null
code a8v=null
code a9v=null
code nvv=null
code nev=null
code nxv=null
code nov=null
code nrv=null
code niv=null
code nav=null
code nnv=null
code nVv=null
code nEv=null
code nXv=null
code nOv=null
code nRv=null
code nIv=null
code nAv=null
code nNv=null
code nbv=null
code nBv=null
code ncv=null
code nCv=null
code ndv=null
code nDv=null
code nfv=null
code nFv=null
code ngv=null
code nGv=null
code nhv=null
code nHv=null
code njv=null
code nJv=null
code nkv=null
code nKv=null
code nlv=null
code nLv=null
code nmv=null
code nMv=null
code npv=null
code nPv=null
code nqv=null
code nQv=null
code nsv=null
code nSv=null
code ntv=null
code nTv=null
code nuv=null
code nUv=null
code nwv=null
code nWv=null
code nyv=null
code nYv=null
code nzv=null
code nZv=null
code n_v=null
code n0v=null
code n1v=null
code n2v=null
code n3v=null
code n4v=null
code n5v=null
code n6v=null
code n7v=null
code n8v=null
code n9v=null
code Vvv=null
code Vev=null
code Vxv=null
code Vov=null
code Vrv=null
code Viv=null
code Vav=null
code Vnv=null
code VVv=null
code VEv=null
code VXv=null
code VOv=null
code VRv=null
code VIv=null
code VAv=null
code VNv=null
code Vbv=null
code VBv=null
code Vcv=null
code VCv=null
code Vdv=null
code VDv=null
code Vfv=null
code VFv=null
code Vgv=null
code VGv=null
code Vhv=null
code VHv=null
code Vjv=null
code VJv=null
code Vkv=null
code VKv=null
code Vlv=null
code VLv=null
code Vmv=null
code VMv=null
code Vpv=null
code VPv=null
code Vqv=null
code VQv=null
code Vsv=null
code VSv=null
code Vtv=null
code VTv=null
code Vuv=null
code VUv=null
code Vwv=null
code VWv=null
code Vyv=null
code VYv=null
code Vzv=null
code VZv=null
code V_v=null
code V0v=null
code V1v=null
code V2v=null
code V3v=null
code V4v=null
code V5v=null
code V6v=null
code V7v=null
code V8v=null
code V9v=null
code Evv=null
code Eev=null
code Exv=null
code Eov=null
code Erv=null
code Eiv=null
code Eav=null
code Env=null
code EVv=null
code EEv=null
code EXv=null
code EOv=null
code ERv=null
code EIv=null
code EAv=null
code ENv=null
code Ebv=null
code EBv=null
code Ecv=null
code ECv=null
code Edv=null
code EDv=null
code Efv=null
code EFv=null
code Egv=null
code EGv=null
code Ehv=null
code EHv=null
code Ejv=null
code EJv=null
code Ekv=null
code EKv=null
code Elv=null
code ELv=null
code Emv=null
code EMv=null
code Epv=null
code EPv=null
code Eqv=null
code EQv=null
code Esv=null
code ESv=null
code Etv=null
code ETv=null
code Euv=null
code EUv=null
code Ewv=null
code EWv=null
code Eyv=null
code EYv=null
code Ezv=null
code EZv=null
code E_v=null
code E0v=null
code E1v=null
code E2v=null
code E3v=null
code E4v=null
code E5v=null
code E6v=null
code E7v=null
code E8v=null
code E9v=null
code Xvv=null
code Xev=null
code Xxv=null
code Xov=null
code Xrv=null
code Xiv=null
code Xav=null
code Xnv=null
code XVv=null
code XEv=null
code XXv=null
code XOv=null
code XRv=null
code XIv=null
code XAv=null
code XNv=null
code Xbv=null
code XBv=null
code Xcv=null
code XCv=null
code Xdv=null
code XDv=null
code Xfv=null
code XFv=null
code Xgv=null
code XGv=null
code Xhv=null
code XHv=null
code Xjv=null
code XJv=null
code Xkv=null
code XKv=null
code Xlv=null
code XLv=null
code Xmv=null
code XMv=null
code Xpv=null
code XPv=null
code Xqv=null
code XQv=null
code Xsv=null
code XSv=null
code Xtv=null
code XTv=null
code Xuv=null
code XUv=null
code Xwv=null
code XWv=null
code Xyv=null
code XYv=null
code Xzv=null
code XZv=null
code X_v=null
code X0v=null
code X1v=null
code X2v=null
code X3v=null
code X4v=null
code X5v=null
code X6v=null
code X7v=null
code X8v=null
code X9v=null
code Ovv=null
code Oev=null
code Oxv=null
code Oov=null
code Orv=null
code Oiv=null
code Oav=null
code Onv=null
code OVv=null
code OEv=null
code OXv=null
code OOv=null
code ORv=null
code OIv=null
code OAv=null
code ONv=null
code Obv=null
code OBv=null
code Ocv=null
code OCv=null
code Odv=null
code ODv=null
code Ofv=null
code OFv=null
code Ogv=null
code OGv=null
code Ohv=null
code OHv=null
code Ojv=null
code OJv=null
code Okv=null
code OKv=null
code Olv=null
code OLv=null
code Omv=null
code OMv=null
code Opv=null
code OPv=null
code Oqv=null
code OQv=null
code Osv=null
code OSv=null
code Otv=null
code OTv=null
code Ouv=null
code OUv=null
code Owv=null
code OWv=null
code Oyv=null
code OYv=null
code Ozv=null
code OZv=null
code O_v=null
code O0v=null
code O1v=null
code O2v=null
code O3v=null
code O4v=null
code O5v=null
code O6v=null
code O7v=null
code O8v=null
code O9v=null
code Rvv=null
code Rev=null
code Rxv=null
code Rov=null
code Rrv=null
code Riv=null
code Rav=null
code Rnv=null
code RVv=null
code REv=null
code RXv=null
code ROv=null
code RRv=null
code RIv=null
code RAv=null
code RNv=null
code Rbv=null
code RBv=null
code Rcv=null
code RCv=null
code Rdv=null
code RDv=null
code Rfv=null
code RFv=null
code Rgv=null
code RGv=null
code Rhv=null
string RHv=null
boolean Rjv=false
integer RJv=0
real Rkv=.0
timer RKv=null
playercolor Rlv=null
unit RLv=null
unit Rmv=null
unit RMv=null
unit Rpv=null
group RPv=null
group Rqv=null
destructable RQv=null
destructable Rsv=null
unit RSv=null
item Rtv=null
item RTv=null
item Ruv=null
destructable RUv=null
unit Rwv=null
unit RWv=null
group Ryv=null
unit RYv=null
unit Rzv=null
timer RZv=null
unit R_v=null
destructable R0v=null
group R1v=null
trigger R2v=null
rect R3v=null
lightning R4v=null
timer R5v=null
destructable R6v=null
unit R7v=null
unit R8v=null
item R9v=null
item Ivv=null
item Iev=null
item Ixv=null
unit Iov=null
unit Irv=null
group Iiv=null
group Iav=null
unit Inv=null
unit IVv=null
unit IEv=null
unit IXv=null
timer IOv=null
destructable IRv=null
unit IIv=null
unit IAv=null
unit INv=null
item Ibv=null
item IBv=null
item Icv=null
unit ICv=null
rect Idv=null
camerasetup IDv=null
unit Ifv=null
unit IFv=null
unit Igv=null
unit IGv=null
destructable Ihv=null
item IHv=null
item Ijv=null
group IJv=null
item Ikv=null
rect IKv=null
effect Ilv=null
trigger ILv=null
unit Imv=null
widget IMv=null
group Ipv=null
group IPv=null
unit Iqv=null
timer IQv=null
unit Isv=null
destructable ISv=null
group Itv=null
trigger ITv=null
rect Iuv=null
lightning IUv=null
unit Iwv=null
unit IWv=null
unit Iyv=null
unit IYv=null
unit Izv=null
endglobals
native UnitAlive takes unit id_1 returns boolean
function Avv takes trigger Aev,playerunitevent Axv returns nothing
local integer Aov=0
loop
exitwhen Aov==bj_MAX_PLAYER_SLOTS
call TriggerRegisterPlayerUnitEvent(Aev,Player(Aov),Axv,null)
set Aov=Aov+1
endloop
endfunction
function AIv takes trigger AAv,string ANv,boolean Abv returns nothing
local integer ABv=0
loop
exitwhen ABv==bj_MAX_PLAYERS-1
call TriggerRegisterPlayerChatEvent(AAv,Player(ABv),ANv,Abv)
set ABv=ABv+1
endloop
endfunction
function BZv takes nothing returns integer
local integer B_v
if ob[0]==0 then
set cb=cb+1
set B_v=cb
else
set B_v=ob[0]
set ob[0]=ob[ob[0]]
endif
return B_v
endfunction
function B0v takes nothing returns integer
local integer B1v=LoadInteger(i,S,0)
if B1v==0 then
set B1v=t+1
set t=B1v
else
call SaveInteger(i,S,0,LoadInteger(i,S,B1v))
call RemoveSavedInteger(i,S,B1v)
endif
return B1v
endfunction
function B2v takes nothing returns integer
local integer B3v=BZv()
set ub[B3v]=B0v()
set rb[B3v]=0
set sb[B3v]=0
set tb[B3v]=0
set ib[B3v]=0
set Sb[B3v]=0
return B3v
endfunction
function B4v takes nothing returns nothing
set p=GetCameraBoundMaxX()+GetCameraMargin(CAMERA_MARGIN_RIGHT)
set e=GetCameraBoundMinX()-GetCameraMargin(CAMERA_MARGIN_LEFT)
set q=GetCameraBoundMaxY()+GetCameraMargin(CAMERA_MARGIN_TOP)
set a=GetCameraBoundMinY()-GetCameraMargin(CAMERA_MARGIN_BOTTOM)
set n=GetWorldBounds()
set d=CreateRegion()
call RegionAddRect(d,n)
endfunction
function B5v takes nothing returns nothing
set y=B0v()
endfunction
function B6v takes nothing returns nothing
local trigger B7v=CreateTrigger()
local integer B8v=0
local integer B9v
set Ul=GetLocalPlayer()
call GetPlayerId(Ul)
if bj_MAX_PLAYERS>$C then
endif
set Zl=vl
loop
exitwhen B8v==bj_MAX_PLAYERS
set B9v=B8v
set ml[B9v]=Player(B8v)
set Ql[B9v]=B8v
set Pl[B8v]=GetPlayerColor(ml[B9v])
if GetPlayerController(ml[B9v])==MAP_CONTROL_USER and GetPlayerSlotState(ml[B9v])==PLAYER_SLOT_STATE_PLAYING then
set Al[Il]=B9v
set Dl[B8v]=Il
if Zl==vl then
set Zl=B8v
set Wl[B8v]=vl
set El[B8v]=vl
else
set El[B8v]=Ql[Al[Il-1]]
set Wl[Al[Il-1]]=B8v
set Wl[B8v]=vl
endif
call TriggerRegisterPlayerEvent(B7v,ml[B9v],EVENT_PLAYER_LEAVE)
call ForceAddPlayer(u,ml[B9v])
call GetHandleId(Pl[B8v])
set Il=Il+1
endif
call GetPlayerName(ml[B9v])
set B8v=B8v+1
endloop
call TriggerAddCondition(B7v,Filter(Rz))
set B7v=null
endfunction
function cvv takes nothing returns nothing
local integer cev=0
local integer cxv=1
loop
exitwhen cev>32
set cxv=cxv*2
set cev=cev+1
endloop
endfunction
function cov takes nothing returns nothing
local integer crv=0
loop
exitwhen crv==bj_MAX_PLAYER_SLOTS
set r[crv]=Player(crv)
set crv=crv+1
endloop
set s=GetLocalPlayer()
endfunction
function civ takes nothing returns nothing
local trigger cav=CreateTrigger()
call TriggerRegisterEnterRegion(cav,d,Filter(Cz))
set cav=null
endfunction
function cnv takes nothing returns nothing
set Mb=CreateTrigger()
call TriggerAddCondition(Mb,Condition(ONv))
set Jb[89]=CreateTrigger()
call TriggerAddCondition(Jb[89],Condition(Obv))
call TriggerAddAction(Jb[89],Obv)
set Nb=CreateTrigger()
call TriggerAddCondition(Nb,Condition(OBv))
set Lb[89]=null
set Lb[94]=null
set Vb=CreateTrigger()
call TriggerAddCondition(Vb,Condition(Ocv))
set Bb=CreateTrigger()
call TriggerAddCondition(Bb,Condition(OCv))
set Xb=CreateTrigger()
call TriggerAddCondition(Xb,Condition(Odv))
set Cb=CreateTrigger()
call TriggerAddCondition(Cb,Condition(ODv))
set mb[95]=CreateTrigger()
call TriggerAddCondition(mb[95],Condition(Ofv))
call TriggerAddAction(mb[95],Ofv)
set vb[95]=null
set Jb[94]=CreateTrigger()
call TriggerAddCondition(Jb[94],Condition(OFv))
call TriggerAddAction(Jb[94],OFv)
set wy[1]=CreateTrigger()
call TriggerAddAction(wy[1],Ogv)
call TriggerAddCondition(wy[1],Condition(Ogv))
set wy[2]=CreateTrigger()
call TriggerAddAction(wy[2],OGv)
call TriggerAddCondition(wy[2],Condition(OGv))
set wy[3]=CreateTrigger()
call TriggerAddAction(wy[3],Ohv)
call TriggerAddCondition(wy[3],Condition(Ohv))
set wy[4]=CreateTrigger()
call TriggerAddAction(wy[4],OHv)
call TriggerAddCondition(wy[4],Condition(OHv))
set wy[5]=CreateTrigger()
call TriggerAddAction(wy[5],Ojv)
call TriggerAddCondition(wy[5],Condition(Ojv))
set wy[6]=CreateTrigger()
call TriggerAddAction(wy[6],OJv)
call TriggerAddCondition(wy[6],Condition(OJv))
set wy[7]=CreateTrigger()
call TriggerAddAction(wy[7],Okv)
call TriggerAddCondition(wy[7],Condition(Okv))
set wy[8]=CreateTrigger()
call TriggerAddAction(wy[8],OKv)
call TriggerAddCondition(wy[8],Condition(OKv))
call ExecuteFunc("cvv")
call ExecuteFunc("B6v")
call ExecuteFunc("cov")
call ExecuteFunc("B5v")
call ExecuteFunc("B4v")
call ExecuteFunc("civ")
endfunction
function cVv takes nothing returns nothing
local trigger cEv=CreateTrigger()
call Avv(cEv,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(cEv,Filter(dz))
set cEv=null
set cEv=null
endfunction
function cXv takes nothing returns boolean
return(GetSpellAbilityId()=='A0GK')
endfunction
function cOv takes nothing returns boolean
return(GetSpellAbilityId()=='A0DQ')
endfunction
function cRv takes effect cIv,real cAv returns nothing
local timer cNv=CreateTimer()
call SaveEffectHandle(c,GetHandleId(cNv),O,cIv)
call TimerStart(cNv,cAv,false,Nz)
set cNv=null
set cNv=null
endfunction
function cbv takes nothing returns nothing
call cRv(AddSpecialEffect("Abilities\\Spells\\Other\\TalkToMe\\TalkToMe.mdl",GetSpellTargetX(),GetSpellTargetY()),GetUnitAbilityLevel(GetSpellAbilityUnit(),'A0G2'))
endfunction
function cBv takes nothing returns nothing
local unit ccv=GetSpellAbilityUnit()
local unit cCv=GetSpellTargetUnit()
call DestroyEffect(AddSpecialEffectTarget("Objects\\Spawnmodels\\Human\\HumanBlood\\HumanBloodKnight.mdl",cCv,"chest"))
call UnitDamageTarget(ccv,cCv,'}'*GetUnitAbilityLevel(ccv,'AOra')-25,true,true,ATTACK_TYPE_MELEE,DAMAGE_TYPE_NORMAL,WEAPON_TYPE_WHOKNOWS)
set cCv=null
set ccv=null
set ccv=null
set cCv=null
endfunction
function cdv takes nothing returns nothing
call GroupRemoveUnitSimple(GetEnumUnit(),us)
call GroupRemoveUnitSimple(GetEnumUnit(),ws)
call GroupRemoveUnitSimple(GetEnumUnit(),St)
call GroupRemoveUnitSimple(GetEnumUnit(),tt)
call GroupRemoveUnitSimple(GetEnumUnit(),os)
call GroupRemoveUnitSimple(GetEnumUnit(),ys)
call GroupRemoveUnitSimple(GetEnumUnit(),rs)
call GroupRemoveUnitSimple(GetEnumUnit(),Ot)
endfunction
function cDv takes nothing returns nothing
set G=GetUnitLoc(GetEnumUnit())
call EnumDestructablesInCircleBJ(700.,G,xPv)
call RemoveLocation(G)
endfunction
function cfv takes nothing returns boolean
return true
endfunction
function cFv takes nothing returns timer
if b>0 then
set b=b-1
call SaveInteger(i,y,GetHandleId(l[b]),0)
return l[b]
endif
return CreateTimer()
endfunction
function cgv takes nothing returns nothing
local unit cGv
local timer chv
if GetUnitAbilityLevel(GetEventDamageSource(),'A0MQ')==0 or GetEventDamage()==.0 or IsUnitInGroup(GetEventDamageSource(),dl)then
set cGv=null
set chv=null
return
endif
set cGv=GetEventDamageSource()
if GetRandomInt(0,'d')<$A then
call BlzEndUnitAbilityCooldown(cGv,'A0MQ')
endif
call GroupAddUnit(dl,cGv)
set chv=cFv()
call SaveUnitHandle(i,y,GetHandleId(chv),cGv)
call TimerStart(chv,1.,false,yz)
set chv=null
set cGv=null
set cGv=null
set chv=null
endfunction
function cHv takes nothing returns nothing
set ls[0]=false
set ls[GetConvertedPlayerId(GetTriggerPlayer())]=true
set F[GetConvertedPlayerId(GetTriggerPlayer())]=true
call DisplayTextToForce(GetPlayersAll(),k[GetConvertedPlayerId(GetTriggerPlayer())-1]+GetPlayerName(GetTriggerPlayer())+"|R|CFF808040 занял место администратора.|R")
endfunction
function cjv takes nothing returns boolean
local string cJv=GetEventPlayerChatString()
return true
if SubString(cJv,0,3)=="ic " and S2I(SubString(cJv,3,4))<=6 and S2I(SubString(cJv,3,4))>=1 and SubString(cJv,4,5)==" " and SubString(cJv,5,StringLength(cJv))=="0" or S2I(SubString(cJv,5,StringLength(cJv)))>=1 then
set cJv=null
return true
else
set cJv=null
return false
endif
endfunction
function ckv takes nothing returns boolean
return(GetUnitTypeId(GetEnumUnit())!='h000')and(GetUnitTypeId(GetEnumUnit())!='h0KW')and(IsUnitSelected(GetEnumUnit(),GetTriggerPlayer()))
endfunction
function cKv takes nothing returns nothing
if ckv()then
call UnitRemoveAbilityBJ('Amov',GetEnumUnit())
endif
endfunction
function clv takes unit cLv,integer cmv,integer cMv returns nothing
if cMv==0 then
call UnitRemoveAbility(cLv,cmv)
else
if GetUnitAbilityLevel(cLv,cmv)==0 then
call UnitAddAbility(cLv,cmv)
call UnitMakeAbilityPermanent(cLv,true,cmv)
endif
call SetUnitAbilityLevel(cLv,cmv,cMv)
endif
endfunction
function cpv takes nothing returns nothing
call clv(GetEnumUnit(),'Abun',0)
endfunction
function cPv takes nothing returns boolean
return(GetUnitTypeId(GetEnumUnit())!='h000')and(IsUnitSelected(GetEnumUnit(),GetTriggerPlayer()))
endfunction
function cqv takes nothing returns nothing
if cPv()then
call UnitRemoveAbilityBJ('A07W',GetEnumUnit())
endif
endfunction
function cQv takes trigger csv,code cSv returns triggeraction
return TriggerAddAction(csv,cSv)
endfunction
function ctv takes hashtable cTv,integer cuv,integer cUv,boolean cwv returns nothing
call SaveBoolean(cTv,cuv,cUv,cwv)
endfunction
function cWv takes hashtable cyv,integer cYv,integer czv returns boolean
return HaveSavedBoolean(cyv,cYv,czv)
endfunction
function cZv takes hashtable c_v,integer c0v,integer c1v returns boolean
return LoadBoolean(c_v,c0v,c1v)
endfunction
function c2v takes hashtable c3v,integer c4v,integer c5v returns boolean
return HaveSavedInteger(c3v,c4v,c5v)
endfunction
function c6v takes real c7v returns integer
return R2I(c7v)
endfunction
function c8v takes hashtable c9v,integer Cvv,integer Cev returns integer
return LoadInteger(c9v,Cvv,Cev)
endfunction
function Cxv takes hashtable Cov,integer Crv,integer Civ,integer Cav returns nothing
call SaveInteger(Cov,Crv,Civ,Cav)
endfunction
function Cnv takes string Sau returns nothing
endfunction
function CVv takes integer CEv returns string
local integer CXv=CEv
if CXv==0 then
return"|cffADADADtrace|r"
elseif CXv==1 then
return"|cff2685DCdebug|r"
elseif CXv==2 then
return"|cffFFCC00info|r"
elseif CXv==3 then
return"|cffF47E3Ewarning|r"
else
return"|cffFB2700error|r"
endif
endfunction
function COv takes player CRv,integer CIv,string CAv returns nothing
local string CNv
if ga<=CIv then
set CNv=CVv(CIv)+" - "+CAv
call DisplayTimedTextToPlayer(CRv,.0,.0,ha,CNv)
endif
endfunction
function Cbv takes string CBv returns nothing
call COv(ta,4,CBv)
endfunction
function Ccv takes string CCv returns integer
return StringHash(CCv)
endfunction
function Cdv takes string CDv,string Cfv returns nothing
local integer CFv
local string Cgv
local integer CGv
local integer Chv
local string CHv
local integer Cjv
local integer CJv
local string Ckv
local string CKv
set ZM[EM]=Cfv
set EM=EM+1
if me then
call Cnv("ERROR: "+CDv)
else
if not Np then
set CFv=Ccv(CDv)
if c2v(Vp,Cp,CFv)then
if c8v(Vp,Cp,CFv)+Xp<Oe then
set Ckv=CDv
set Cgv=""
set CGv=EM
set Chv=0
loop
set CGv=CGv-1
set Chv=Chv+1
exitwhen Chv>20
exitwhen CGv<0
set Cgv=Cgv+"
   "+ZM[CGv]
endloop
call Cbv(Ckv+Cgv)
call Cxv(Vp,Cp,CFv,c6v(Oe))
call ctv(Vp,Cp,CFv,false)
elseif cWv(Vp,Cp,CFv)then
if not cZv(Vp,Cp,CFv)then
call Cbv("|cffFF3A29Excessive repeating errors are being omitted")
call ctv(Vp,Cp,CFv,true)
endif
else
call Cbv("|cffFF3A29Excessive repeating errors are being omitted")
call ctv(Vp,Cp,CFv,true)
endif
else
call Cxv(Vp,Cp,CFv,c6v(Oe))
set CKv="Message: "+CDv
set CHv=""
set Cjv=EM
set CJv=0
loop
set Cjv=Cjv-1
set CJv=CJv+1
exitwhen CJv>20
exitwhen Cjv<0
set CHv=CHv+"
   "+ZM[Cjv]
endloop
call Cbv(CKv+CHv)
endif
endif
set Bp=CDv
call I2S(1/0)
endif
set EM=EM-1
endfunction
function Clv takes string CLv returns integer
local integer Cmv
set ZM[EM]=CLv
set EM=EM+1
if bh==0 then
if yh<$8000 then
set yh=yh+1
set Cmv=yh
set ph[Cmv]=4898
else
call Cdv("Out of memory: Could not create HashMap.","when calling error in HashMap, line 8")
set Cmv=0
endif
else
set bh=bh-1
set Cmv=lh[bh]
set ph[Cmv]=4898
endif
set EM=EM-1
return Cmv
endfunction
function CMv takes integer Cpv returns nothing
set lU[Cpv]=0
endfunction
function CPv takes integer G4i returns nothing
endfunction
function Cqv takes integer CQv returns nothing
call CPv(CQv)
endfunction
function Csv takes integer CSv returns nothing
call Cqv(CSv)
call CMv(CSv)
endfunction
function Ctv takes string CTv returns integer
local integer Cuv
set ZM[EM]=CTv
set EM=EM+1
set Cuv=Clv("when calling alloc_HashMap in HashMap, line 7")
call Csv(Cuv)
set EM=EM-1
return Cuv
endfunction
function CUv takes string Cwv returns boolean
local trigger CWv
set ZM[EM]=Cwv
set EM=EM+1
set CWv=CreateTrigger()
call cQv(CWv,OQv)
set bp=CWv
set yp=Ctv("when calling new_HashMap in ClosureFrames, line 24")
set EM=EM-1
set CWv=null
return true
endfunction
function Cyv takes nothing returns boolean
set EM=0
return CUv("ClosureFrames, line 1")
endfunction
function CYv takes hashtable Czv,integer CZv,integer C_v returns boolean
return HaveSavedReal(Czv,CZv,C_v)
endfunction
function C0v takes handle C1v returns integer
return GetHandleId(C1v)
endfunction
function C2v takes destructable C3v returns boolean
return CYv(Va,C0v(C3v),Ma)
endfunction
function C4v takes nothing returns boolean
return C2v(GetFilterDestructable())
endfunction
function C5v takes nothing returns boolean
set qe=CreateGroup()
return true
endfunction
function C6v takes nothing returns nothing
local timer C7v=GetExpiredTimer()
local unit C8v=LoadUnitHandle(c,GetHandleId(C7v),o)
call FlushChildHashtable(c,GetHandleId(C7v))
call DestroyTimer(C7v)
set C7v=null
call RemoveUnit(C8v)
set C8v=null
set C7v=null
set C8v=null
endfunction
function C9v takes nothing returns nothing
local unit dvv
local real dev
if GetUnitAbilityLevel(GetEventDamageSource(),UO)==0 or GetEventDamage()==.0 then
set dvv=null
return
endif
set dvv=LoadUnitHandle(i,PO,GetHandleId(GetEventDamageSource()))
set dev=GetEventDamage()
call BlzSetEventDamage(.0)
call SetWidgetLife(dvv,GetWidgetLife(dvv)+dev)
call DestroyEffect(AddSpecialEffectTarget("Abilities\\Spells\\Undead\\VampiricAura\\VampiricAuraTarget.mdl",dvv,"origin"))
set dvv=null
set dvv=null
endfunction
function dxv takes integer dov,integer drv returns integer
return c8v(de,dov,drv)
endfunction
function div takes integer dav,integer dnv,string dVv returns integer
local integer dEv
set ZM[EM]=dVv
set EM=EM+1
if Oh[dav]==0 then
if dav==0 then
call Cdv("Nullpointer exception when calling HashList.count","when calling error in HashList, line 15")
else
call Cdv("Called HashList.count on invalid object.","when calling error in HashList, line 15")
endif
endif
set dEv=dxv(dav,dnv)
set EM=EM-1
return dEv
endfunction
function dXv takes integer dOv,integer dRv,string dIv returns nothing
set ZM[EM]=dIv
set EM=EM+1
call Cxv(de,dOv,dRv,div(dOv,dRv,"when calling count in HashList, line 19")+1)
set EM=EM-1
endfunction
function dAv takes integer dNv,integer dbv,string dBv returns nothing
set ZM[EM]=dBv
set EM=EM+1
if Oh[dNv]==0 then
if dNv==0 then
call Cdv("Nullpointer exception when calling HashList.incrOccurences","when calling error in HashList, line 18")
else
call Cdv("Called HashList.incrOccurences on invalid object.","when calling error in HashList, line 18")
endif
endif
call dXv(dNv,dbv,"when calling incrOccurences in HashList, line 18")
set EM=EM-1
endfunction
function dcv takes integer dCv,integer ddv,string dDv returns nothing
set ZM[EM]=dDv
set EM=EM+1
call Cxv(ne,dCv,OU[dCv],ddv)
call dAv(dCv,ddv,"when calling incrOccurences in HashList, line 28")
set OU[dCv]=OU[dCv]+1
set EM=EM-1
endfunction
function dfv takes integer dFv returns integer
return OU[dFv]
endfunction
function dgv takes integer dGv,string dhv returns integer
local integer dHv
set ZM[EM]=dhv
set EM=EM+1
if Oh[dGv]==0 then
if dGv==0 then
call Cdv("Nullpointer exception when calling HashList.size","when calling error in HashList, line 67")
else
call Cdv("Called HashList.size on invalid object.","when calling error in HashList, line 67")
endif
endif
set dHv=dfv(dGv)
set EM=EM-1
return dHv
endfunction
function djv takes integer dJv,integer dkv,string dKv returns nothing
set ZM[EM]=dKv
set EM=EM+1
if div(dJv,dkv,"when calling count in HashSet, line 11")<=0 then
call Cxv(fe,dJv,dkv,dgv(dJv,"when calling size in HashSet, line 12"))
call dcv(dJv,dkv,"when calling add in HashSet, line 13")
endif
set EM=EM-1
endfunction
function dlv takes integer dLv,integer dmv,string dMv returns nothing
set ZM[EM]=dMv
set EM=EM+1
if Oh[dLv]==0 then
if dLv==0 then
call Cdv("Nullpointer exception when calling HashList.add","when calling error in HashList, line 25")
else
call Cdv("Called HashList.add on invalid object.","when calling error in HashList, line 25")
endif
endif
if Oh[dLv]<=$966 then
call dcv(dLv,dmv,"when calling add in HashList, line 25")
else
call djv(dLv,dmv,"when calling add in HashList, line 25")
endif
set EM=EM-1
endfunction
function dpv takes integer dPv,integer dqv returns integer
set HM=BlzBitOr(dPv,Gy[dqv])
return HM
endfunction
function dQv takes integer dsv,integer dSv returns integer
set E3=dpv(dsv,dSv)
return E3
endfunction
function dtv takes destructable dTv returns real
return GetDestructableOccluderHeight(dTv)
endfunction
function duv takes string dUv,integer dwv returns string
return SubString(dUv,dwv,dwv+1)
endfunction
function dWv takes integer dyv returns string
local string dYv=""
local integer dzv=dyv
local integer dZv=0
local integer d_v
loop
exitwhen dZv>3
set d_v=ModuloInteger(dzv,256)
set dzv=dzv/256
set dYv=duv(aq,d_v)+dYv
set dZv=dZv+1
endloop
return dYv
endfunction
function d0v takes integer d1v returns string
return dWv(d1v)
endfunction
function d2v takes integer d3v,string d4v returns string
local string d5v=BlzGetAbilityExtendedTooltip('Amls',0)
local string d6v
call BlzSetAbilityExtendedTooltip('Amls',"<"+d0v(d3v)+","+d4v+">",0)
set d6v=BlzGetAbilityExtendedTooltip('Amls',0)
call BlzSetAbilityExtendedTooltip('Amls',d5v,0)
return d6v
endfunction
function d7v takes string d8v returns real
return S2R(d8v)
endfunction
function d9v takes integer Dvv,string Dev returns real
return d7v(d2v(Dvv,Dev+",."))
endfunction
function Dxv takes integer Dov returns real
return d9v(Dov,"HP")
endfunction
function Drv takes destructable Div returns integer
return c8v(Va,C0v(Div),rn)
endfunction
function Dav takes integer Dnv,integer DVv returns integer
set JM=BlzBitAnd(Dnv,gy[DVv])
return JM
endfunction
function DEv takes integer DXv,integer DOv returns integer
set Z3=Dav(DXv,DOv)
return Z3
endfunction
function DRv takes real DIv,real DAv,real DNv,real Dbv returns real
set n9=DIv-DNv
set d9=DAv-Dbv
return n9
endfunction
function DBv takes destructable Dcv returns real
return GetDestructableY(Dcv)
endfunction
function DCv takes destructable Ddv returns real
return GetDestructableX(Ddv)
endfunction
function DDv takes destructable Dfv returns real
set o3=DCv(Dfv)
set O3=DBv(Dfv)
return o3
endfunction
function DFv takes hashtable Dgv,integer DGv,integer Dhv returns real
return LoadReal(Dgv,DGv,Dhv)
endfunction
function DHv takes destructable Djv returns real
return DFv(Va,C0v(Djv),wn)
endfunction
function DJv takes destructable Dkv returns real
return DFv(Va,C0v(Dkv),un)
endfunction
function DKv takes destructable Dlv returns boolean
return IsDestructableInvulnerable(Dlv)
endfunction
function DLv takes destructable Dmv returns real
return GetDestructableLife(Dmv)
endfunction
function DMv takes integer Dpv returns real
return d9v(Dpv,"occH")
endfunction
function DPv takes destructable Dqv returns real
return DFv(Va,C0v(Dqv),Ma)
endfunction
function DQv takes integer Dsv returns real
return Dsv*1.
endfunction
function DSv takes real Dtv returns integer
local integer DTv
if Dtv>.0 then
set DTv=c6v(Dtv+.5)
else
set DTv=c6v(Dtv-.5)
endif
return DTv
endfunction
function Duv takes integer DUv,integer Dwv,integer DWv returns nothing
call Cxv(XR,DUv,Dwv,DWv)
endfunction
function Dyv takes integer DYv,integer Dzv,integer DZv,string D_v returns nothing
set ZM[EM]=D_v
set EM=EM+1
if ph[DYv]==0 then
if DYv==0 then
call Cdv("Nullpointer exception when calling Table.saveInt","when calling error in Table, line 42")
else
call Cdv("Called Table.saveInt on invalid object.","when calling error in Table, line 42")
endif
endif
call Duv(DYv,Dzv,DZv)
set EM=EM-1
endfunction
function D0v takes integer D1v,integer D2v returns boolean
return c2v(XR,D1v,D2v)
endfunction
function D3v takes integer D4v,integer D5v,string D6v returns boolean
local boolean D7v
set ZM[EM]=D6v
set EM=EM+1
if ph[D4v]==0 then
if D4v==0 then
call Cdv("Nullpointer exception when calling Table.hasInt","when calling error in Table, line 9")
else
call Cdv("Called Table.hasInt on invalid object.","when calling error in Table, line 9")
endif
endif
set D7v=D0v(D4v,D5v)
set EM=EM-1
return D7v
endfunction
function D8v takes integer D9v,integer fvv,string fev returns boolean
local boolean fxv
set ZM[EM]=fev
set EM=EM+1
set fxv=D3v(D9v,fvv,"when calling hasInt in HashMap, line 14")
set EM=EM-1
return fxv
endfunction
function fov takes integer frv,integer fiv,string fav returns boolean
local boolean fnv
set ZM[EM]=fav
set EM=EM+1
if ph[frv]==0 then
if frv==0 then
call Cdv("Nullpointer exception when calling HashMap.has","when calling error in HashMap, line 13")
else
call Cdv("Called HashMap.has on invalid object.","when calling error in HashMap, line 13")
endif
endif
set fnv=D8v(frv,fiv,"when calling has in HashMap, line 13")
set EM=EM-1
return fnv
endfunction
function fVv takes integer fEv,integer fXv,integer fOv,string fRv returns nothing
set ZM[EM]=fRv
set EM=EM+1
if not fov(fEv,fXv,"when calling has in HashMap, line 18")then
set lU[fEv]=lU[fEv]+1
endif
call Dyv(fEv,fXv,fOv,"when calling saveInt in HashMap, line 20")
set EM=EM-1
endfunction
function fIv takes integer fAv,integer fNv,string fbv returns boolean
local boolean fBv
set ZM[EM]=fbv
set EM=EM+1
set fBv=div(fAv,fNv,"when calling count in HashList, line 88")>0
set EM=EM-1
return fBv
endfunction
function fcv takes integer fCv,integer fdv,string fDv returns boolean
local boolean ffv
set ZM[EM]=fDv
set EM=EM+1
if Oh[fCv]==0 then
if fCv==0 then
call Cdv("Nullpointer exception when calling HashList.has","when calling error in HashList, line 87")
else
call Cdv("Called HashList.has on invalid object.","when calling error in HashList, line 87")
endif
endif
set ffv=fIv(fCv,fdv,"when calling has in HashList, line 87")
set EM=EM-1
return ffv
endfunction
function fFv takes integer fgv,integer fGv,string fhv returns boolean
local boolean fHv
set ZM[EM]=fhv
set EM=EM+1
set fHv=fcv(bU[fgv],fGv,"when calling has in HashMap, line 88")
set EM=EM-1
return fHv
endfunction
function fjv takes integer fJv,integer fkv,string fKv returns boolean
local boolean flv
set ZM[EM]=fKv
set EM=EM+1
if ph[fJv]==0 then
if fJv==0 then
call Cdv("Nullpointer exception when calling IterableMap.hasKey","when calling error in HashMap, line 87")
else
call Cdv("Called IterableMap.hasKey on invalid object.","when calling error in HashMap, line 87")
endif
endif
set flv=fFv(fJv,fkv,"when calling hasKey in HashMap, line 87")
set EM=EM-1
return flv
endfunction
function fLv takes integer fmv,integer fMv,integer fpv,string fPv returns nothing
set ZM[EM]=fPv
set EM=EM+1
call fVv(fmv,fMv,fpv,"when calling put in HashMap, line 60")
if not fjv(fmv,fMv,"when calling hasKey in HashMap, line 61")then
call dlv(bU[fmv],fMv,"when calling add in HashMap, line 62")
endif
set EM=EM-1
endfunction
function fqv takes integer fQv,integer fsv,integer fSv,string ftv returns nothing
set ZM[EM]=ftv
set EM=EM+1
if ph[fQv]==0 then
if fQv==0 then
call Cdv("Nullpointer exception when calling HashMap.put","when calling error in HashMap, line 17")
else
call Cdv("Called HashMap.put on invalid object.","when calling error in HashMap, line 17")
endif
endif
if ph[fQv]<=4898 then
call fVv(fQv,fsv,fSv,"when calling put in HashMap, line 17")
else
call fLv(fQv,fsv,fSv,"when calling put in HashMap, line 17")
endif
set EM=EM-1
endfunction
function fTv takes integer fuv,integer fUv returns integer
return c8v(XR,fuv,fUv)
endfunction
function fwv takes integer fWv,integer fyv,string fYv returns integer
local integer fzv
set ZM[EM]=fYv
set EM=EM+1
if ph[fWv]==0 then
if fWv==0 then
call Cdv("Nullpointer exception when calling Table.loadInt","when calling error in Table, line 39")
else
call Cdv("Called Table.loadInt on invalid object.","when calling error in Table, line 39")
endif
endif
set fzv=fTv(fWv,fyv)
set EM=EM-1
return fzv
endfunction
function fZv takes integer f_v,integer f0v,string f1v returns integer
local integer f2v
set ZM[EM]=f1v
set EM=EM+1
set f2v=fwv(f_v,f0v,"when calling loadInt in HashMap, line 24")
set EM=EM-1
return f2v
endfunction
function f3v takes integer f4v,integer f5v,string f6v returns integer
local integer f7v
set ZM[EM]=f6v
set EM=EM+1
if ph[f4v]==0 then
if f4v==0 then
call Cdv("Nullpointer exception when calling HashMap.get","when calling error in HashMap, line 23")
else
call Cdv("Called HashMap.get on invalid object.","when calling error in HashMap, line 23")
endif
endif
set f7v=fZv(f4v,f5v,"when calling get in HashMap, line 23")
set EM=EM-1
return f7v
endfunction
function f8v takes integer f9v,integer Fvv,string Fev returns integer
local integer Fxv
local integer Fov
local integer Frv
local integer Fiv
set ZM[EM]=Fev
set EM=EM+1
if fov(nH[f9v],Fvv,"when calling has in RawcodeTable, line 52")then
set Frv=f3v(nH[f9v],Fvv,"when calling get in RawcodeTable, line 53")
set Fxv=Frv
set EM=EM-1
set A9=Fxv
return A9
endif
call fqv(nH[f9v],Fvv,dgv(dH[f9v],"when calling size in RawcodeTable, line 54"),"when calling put in RawcodeTable, line 54")
call dlv(dH[f9v],Fvv,"when calling add in RawcodeTable, line 55")
set Fiv=dgv(dH[f9v],"when calling size in RawcodeTable, line 56")-1
set Fov=Fiv
set EM=EM-1
set A9=Fov
return A9
endfunction
function Fav takes integer Fnv,integer FVv,string FEv returns integer
local integer FXv
local integer FOv
set ZM[EM]=FEv
set EM=EM+1
if Gg[Fnv]==0 then
if Fnv==0 then
call Cdv("Nullpointer exception when calling RawcodeTable.addRawcode","when calling error in RawcodeTable, line 51")
else
call Cdv("Called RawcodeTable.addRawcode on invalid object.","when calling error in RawcodeTable, line 51")
endif
endif
set FOv=f8v(Fnv,FVv,"when calling addRawcode in RawcodeTable, line 51")
set FXv=FOv
set EM=EM-1
set g9=FXv
return g9
endfunction
function FRv takes real FIv,real FAv returns real
set f1=FIv
set R1=FAv
return f1
endfunction
function FNv takes destructable Fbv returns real
return GetDestructableMaxLife(Fbv)
endfunction
function FBv takes destructable Fcv returns integer
return GetDestructableTypeId(Fcv)
endfunction
function FCv takes integer Fdv,destructable FDv,real Ffv,real FFv,string Fgv returns nothing
local integer FGv
local integer Fhv
local integer FHv
local integer Fjv
local integer FJv
local integer Fkv
local integer FKv
local integer Flv
local integer FLv
local real Fmv
local real FMv
local integer Fpv
local integer FPv
local integer Fqv
local integer FQv
local integer Fsv
local integer FSv
local integer Ftv
local integer FTv
local integer Fuv
local integer FUv
local integer Fwv
set ZM[EM]=Fgv
set EM=EM+1
set Fkv=0
set RE[Fdv]=Fkv
set FKv=0
set TE[Fdv]=FKv
set Flv=Fav(fE[Fdv],FBv(FDv),"when calling addRawcode in DestructableData, line 77")
set YE[Fdv]=Flv
if DKv(FDv)then
set FLv=dQv(RE[Fdv],0)
set RE[Fdv]=FLv
endif
set Fmv=FRv(DRv(DDv(FDv),O3,Ffv,FFv),d9)
set FMv=R1
set GE[Fdv]=Fmv
set gE[Fdv]=FMv
set hE[Fdv]=DPv(FDv)
if hE[Fdv]!=.0 then
set Fpv=dQv(RE[Fdv],1)
set RE[Fdv]=Fpv
set FGv=c6v(hE[Fdv])
if DQv(FGv)!=hE[Fdv]or FGv>$FF then
set FPv=dQv(RE[Fdv],2)
set RE[Fdv]=FPv
set Fhv=c6v(hE[Fdv]*10.)+$7FFF
if(Fhv-$7FFF)*1./$A==hE[Fdv]and Fhv>=0 and Fhv<=$FFFF then
set Fqv=DEv(RE[Fdv],1)
set RE[Fdv]=Fqv
endif
endif
endif
set FE[Fdv]=DHv(FDv)
set kE[Fdv]=DJv(FDv)
if kE[Fdv]!=.0 then
set FQv=dQv(RE[Fdv],3)
set RE[Fdv]=FQv
set FHv=c6v(kE[Fdv])
if DQv(FHv)!=kE[Fdv]or FHv>$FF then
set Fsv=dQv(RE[Fdv],4)
set RE[Fdv]=Fsv
set Fjv=c6v(kE[Fdv]*10.)+$7FFF
if(Fjv-$7FFF)*1./$A==kE[Fdv]and Fjv>=0 and Fjv<=$FFFF then
set FSv=DEv(RE[Fdv],3)
set RE[Fdv]=FSv
endif
endif
endif
set jE[Fdv]=Drv(FDv)
set FJv=jE[Fdv]
if FJv==1 then
set Ftv=dQv(RE[Fdv],5)
set RE[Fdv]=Ftv
elseif FJv==2 then
set FTv=dQv(RE[Fdv],6)
set RE[Fdv]=FTv
elseif FJv==3 then
set Fuv=dQv(RE[Fdv],5)
set RE[Fdv]=Fuv
set FUv=dQv(RE[Fdv],6)
set RE[Fdv]=FUv
endif
set xE[Fdv]=dtv(FDv)
if xE[Fdv]!=DMv(FBv(FDv))then
endif
set mE[Fdv]=DSv(FNv(FDv))
if mE[Fdv]!=DSv(Dxv(FBv(FDv)))then
endif
set QE[Fdv]=DSv(DLv(FDv))
if QE[Fdv]!=mE[Fdv]then
endif
if TE[Fdv]!=0 then
set Fwv=dQv(RE[Fdv],7)
set RE[Fdv]=Fwv
endif
set EM=EM-1
endfunction
function FWv takes integer Fyv,destructable FYv,real Fzv,real FZv,string F_v returns nothing
set ZM[EM]=F_v
set EM=EM+1
if mg[Fyv]==0 then
if Fyv==0 then
call Cdv("Nullpointer exception when calling SingleDestructableData.build","when calling error in DestructableData, line 74")
else
call Cdv("Called SingleDestructableData.build on invalid object.","when calling error in DestructableData, line 74")
endif
endif
call FCv(Fyv,FYv,Fzv,FZv,"when calling build in DestructableData, line 74")
set EM=EM-1
endfunction
function F0v takes hashtable F1v,integer F2v,integer F3v returns player
return LoadPlayerHandle(F1v,F2v,F3v)
endfunction
function F4v takes destructable F5v returns player
return F0v(Va,C0v(F5v),Na)
endfunction
function F6v takes nothing returns integer
set g1=0
return g1
endfunction
function F7v takes nothing returns real
set q1=.0
set a1=.0
return q1
endfunction
function F8v takes integer F9v returns nothing
local integer gvv=0
local integer gev
local integer gxv
local real gov
local real grv
set RE[F9v]=gvv
set gev=0
set TE[F9v]=gev
set gxv=F6v()
set YE[F9v]=gxv
set gov=F7v()
set grv=a1
set GE[F9v]=gov
set gE[F9v]=grv
set hE[F9v]=.0
set FE[F9v]=.0
set kE[F9v]=1.
set jE[F9v]=1
set xE[F9v]=.0
set vE[F9v]=.0
set mE[F9v]=0
set QE[F9v]=0
endfunction
function giv takes integer gav,integer gnv returns nothing
call F8v(gav)
set fE[gav]=gnv
endfunction
function gVv takes string gEv returns integer
local integer gXv
set ZM[EM]=gEv
set EM=EM+1
if xg==0 then
if vg<$8000 then
set vg=vg+1
set gXv=vg
set mg[gXv]=4641
else
call Cdv("Out of memory: Could not create SingleDestructableData.","when calling error in DestructableData, line 54")
set gXv=0
endif
else
set xg=xg-1
set gXv=jg[xg]
set mg[gXv]=4641
endif
set EM=EM-1
return gXv
endfunction
function gOv takes integer gRv,string gIv returns integer
local integer gAv
set ZM[EM]=gIv
set EM=EM+1
set gAv=gVv("when calling alloc_SingleDestructableData in DestructableData, line 71")
call giv(gAv,gRv)
set EM=EM-1
return gAv
endfunction
function gNv takes integer gbv,destructable gBv,string gcv returns nothing
local integer gCv
local integer gdv
set ZM[EM]=gcv
set EM=EM+1
if C2v(gBv)and F4v(gBv)==OE[gbv]then
set gdv=rE[lE[gbv]]
set gCv=gOv(uE[lE[gbv]],"when calling new_SingleDestructableData in DestructableData, line 272")
call FWv(gCv,gBv,bE[gbv],yE[gbv],"when calling build in DestructableData, line 272")
call dlv(gdv,gCv,"when calling add in DestructableData, line 272")
endif
set EM=EM-1
endfunction
function gDv takes integer gfv,destructable gFv,string ggv returns nothing
set ZM[EM]=ggv
set EM=EM+1
if cg[gfv]==0 then
if gfv==0 then
call Cdv("Nullpointer exception when calling ForGroupCallbackD.callback","when calling error in ClosureForGroups, line 149")
else
call Cdv("Called ForGroupCallbackD.callback on invalid object.","when calling error in ClosureForGroups, line 149")
endif
endif
call gNv(gfv,gFv,"when calling callback_forDestructablesInRect_PositionedDestructableData_DestructableData in ClosureForGroups, line 149")
set EM=EM-1
endfunction
function gGv takes nothing returns integer
return Op[lp-1]
endfunction
function ghv takes string gHv returns boolean
set ZM[EM]=gHv
set EM=EM+1
call gDv(gGv(),GetEnumDestructable(),"when calling callback in ClosureForGroups, line 152")
set EM=EM-1
return false
endfunction
function gjv takes string gJv returns boolean
local boolean gkv
set ZM[EM]=gJv
set EM=EM+1
set gkv=ghv("when calling filterD in ClosureForGroups, line 181")
set EM=EM-1
return gkv
endfunction
function gKv takes nothing returns boolean
set EM=0
return gjv("ClosureForGroups, line 181")
endfunction
function glv takes nothing returns nothing
call CameraClearNoiseForPlayer(GetEnumPlayer())
endfunction
function gLv takes nothing returns boolean
return true
endfunction
function gmv takes nothing returns boolean
return GetSpellAbilityId()=='A0A5'
endfunction
function gMv takes nothing returns nothing
call SetUnitState(GetEnumUnit(),UNIT_STATE_LIFE,GetUnitState(GetEnumUnit(),UNIT_STATE_LIFE)+30*gt)
endfunction
function gpv takes nothing returns boolean
return GetSpellAbilityId()=='AOnp'
endfunction
function gPv takes nothing returns boolean
return(GetEventPlayerChatString()=="@heroboosterjets")
endfunction
function gqv takes nothing returns boolean
return(GetEventPlayerChatString()=="'heroboosterjets")
endfunction
function gQv takes nothing returns nothing
set g[GetConvertedPlayerId(GetTriggerPlayer())]=GetUnitsOfPlayerMatching(GetTriggerPlayer(),Condition(rwv))
if gqv()then
call ForGroupBJ(g[GetConvertedPlayerId(GetTriggerPlayer())],rWv)
call DestroyGroup(g[GetConvertedPlayerId(GetTriggerPlayer())])
return
elseif gPv()then
call ForGroupBJ(g[GetConvertedPlayerId(GetTriggerPlayer())],ryv)
endif
endfunction
function gsv takes nothing returns nothing
set m[1]="Abilities\\Spells\\Human\\DevotionAura\\DevotionAura.mdx"
set m[2]="Abilities\\Spells\\Human\\DivineShield\\DivineShieldTarget.mdx"
set m[3]="Abilities\\Spells\\Human\\Slow\\SlowTarget.mdx"
set m[4]="Abilities\\Spells\\NightElf\\Barkskin\\BarkSkinTarget.mdx"
set m[5]="Abilities\\Spells\\NightElf\\EntanglingRoots\\EntanglingRootsTarget.mdx"
set m[6]="Abilities\\Spells\\NightElf\\FaerieFire\\FaerieFireTarget.mdx"
set m[7]="Abilities\\Spells\\NightElf\\MoonWell\\MoonWellCasterArt.mdx"
set m[8]="Abilities\\Spells\\NightElf\\Rejuvenation\\RejuvenationTarget.mdx"
set m[9]="Abilities\\Spells\\NightElf\\MoonWell\\MoonWellCasterArt.mdx"
set m[$A]="Abilities\\Spells\\NightElf\\Starfall\\StarfallCaster.mdx"
set m[$B]="Abilities\\Spells\\NightElf\\ThornsAura\\ThornsAura.mdx"
set m[$C]="Abilities\\Spells\\NightElf\\TargetArtLumber\\TargetArtLumber.mdx"
set m[$D]="Abilities\\Spells\\Orc\\Berserker\\Berserkertarget.mdx"
set m[$E]="Abilities\\Spells\\Orc\\Bloodlust\\BloodLustTarget.mdx"
set m[$F]="Abilities\\Spells\\Orc\\CommandAura\\CommandAura.mdx"
set m[16]="Abilities\\Spells\\Orc\\Ensnare\\ensnareTarget.mdx"
set m[17]="Abilities\\Spells\\Orc\\LightningShield\\LightningShieldTarget.mdx"
set m[18]="Abilities\\Spells\\Orc\\Purge\\PurgeBuffTarget.mdx"
set m[19]="Abilities\\Spells\\Orc\\SpikeBarrier\\SpikeBarrier.mdx"
set m[20]="Abilities\\Spells\\Undead\\AntiMagicShell\\AntiMagicShell.mdx"
set m[21]="Abilities\\Spells\\Undead\\Curse\\CurseTarget.mdx"
set m[22]="Abilities\\Spells\\Undead\\Cripple\\CrippleTarget.mdx"
set m[23]="Abilities\\Spells\\Undead\\FrostArmor\\FrostArmorTarget.mdx"
set m[24]="Abilities\\Spells\\Undead\\PlagueCloud\\PlagueCloudCaster.mdx"
set m[25]="Abilities\\Spells\\Undead\\UnholyAura\\UnholyAura.mdx"
set m[26]="Abilities\\Spells\\Undead\\VampiricAura\\VampiricAura.mdx"
set m[27]="Abilities\\Spells\\Undead\\Web\\WebTarget.mdx"
set m[28]="Abilities\\Weapons\\BlackKeeperMissile\\BlackKeeperMissile.mdx"
set m[29]="Abilities\\Weapons\\Banditmissile\\Banditmissile.mdx"
set m[30]="Abilities\\Weapons\\BansheeMissile\\BansheeMissile.mdx"
set m[31]="Abilities\\Weapons\\BristleBackMissile\\BristleBackMissile.mdx"
set m[32]="Abilities\\Weapons\\Catapult\\CatapultMissile.mdx"
set m[33]="Abilities\\Weapons\\CryptFiendMissile\\CryptFiendMissile.mdx"
set m[34]="Abilities\\Weapons\\ColdArrow\\ColdArrowMissile.mdx"
set m[35]="Abilities\\Weapons\\DruidoftheTalonMissile\\DruidoftheTalonMissile.mdx"
set m[36]="Abilities\\Weapons\\Dryadmissile\\Dryadmissile.mdx"
set m[37]="Abilities\\Weapons\\FarseerMissile\\FarseerMissile.mdx"
set m[38]="Abilities\\Weapons\\FireBallMissile\\FireBallMissile.mdx"
set m[39]="Abilities\\Weapons\\FlamingArrow\\FlamingArrowMissile.mdx"
set m[40]="Abilities\\Weapons\\GargoyleMissile\\GargoyleMissile.mdx"
set m[41]="Abilities\\Weapons\\GryphonRiderMissile\\GryphonRiderMissile.mdx"
set m[42]="Abilities\\Weapons\\HarpyMissile\\HarpyMissile.mdx"
set m[43]="Abilities\\Weapons\\huntermissile\\huntermissile.mdx"
set m[44]="Abilities\\Weapons\\KeeperGroveMissile\\KeeperGroveMissile.mdx"
set m[45]="Abilities\\Weapons\\LichMissile\\LichMissile.mdx"
set m[46]="Abilities\\Weapons\\NecromancerMissile\\NecromancerMissile.mdx"
set m[47]="Abilities\\Weapons\\SearingArrow\\SearingArrowMissile.mdx"
set m[48]="Abilities\\Weapons\\WaterElementalMissile\\WaterElementalMissile.mdx"
set m[49]="Buildings\\Other\\CircleOfPower\\CircleOfPower.mdx"
set m[50]="Doodads\\Cinematic\\FireTrapUp\\FireTrapUp.mdx"
set m[51]="Doodads\\Cinematic\\FrostTrapUp\\FrostTrapUp.mdx"
set m[52]="Abilities\\Weapons\\GlaiveMissile\\GlaiveMissile.mdl"
set m[53]="Abilities\\Weapons\\ChimaeraAcidMissile\\ChimaeraAcidMissile.mdl"
set m[54]="Doodads\\Cityscape\\Props\\CrystalShield\\CrystalShield.mdx"
set m[55]="Abilities\\Weapons\\IllidanMissile\\IllidanMissile.mdl"
set m[56]="Abilities\\Spells\\Undead\\AbsorbMana\\AbsorbManaBirthMissile.mdl"
set m[57]="Abilities\\Weapons\\ZigguratFrostMissile\\ZigguratFrostMissile.mdl"
set m[58]="Doodads\\Cityscape\\Props\\MagicRunes\\MagicRunes2.mdx"
set m[59]="Doodads\\Cityscape\\Structures\\City_ColumnSingle\\City_ColumnSingle.mdx"
set m[60]="Abilities\\Weapons\\PhoenixMissile\\Phoenix_Missile.mdl"
set m[61]="Abilities\\Weapons\\AvengerMissile\\AvengerMissile.mdl"
set m[62]="Abilities\\Weapons\\DragonHawkMissile\\DragonHawkMissile.mdl"
set m[63]="Abilities\\Weapons\\PhoenixMissile\\Phoenix_Missile_mini.mdl"
set m[64]="Abilities\\Weapons\\SpiritOfVengeanceMissile\\SpiritOfVengeanceMissile.mdl"
set m[65]="Abilities\\Weapons\\FaerieDragonMissile\\FaerieDragonMissile.mdl"
set m[66]="Abilities\\Weapons\\DemonHunterMissile\\DemonHunterMissile.mdl"
set m[67]="Abilities\\Spells\\Undead\\DarkSummoning\\DarkSummonMissile.mdl"
set m[68]="Abilities\\Weapons\\ZigguratMissile\\ZigguratMissile.mdl"
set m[69]="Abilities\\Spells\\Undead\\DeathCoil\\DeathCoilMissile.mdl"
set m[70]="Abilities\\Weapons\\Axe\\AxeMissile.mdl"
set m[71]="Units\\Undead\\Tichondrius\\Tichondrius.mdx"
set m[72]="Units\\Undead\\Shade\\Shade.mdx"
set m[73]="Abilities\\Spells\\Human\\StormBolt\\StormBoltMissile.mdx"
set m[74]="Doodads\\Ashenvale\\Props\\Brazier\\Brazier.mdx"
set m[75]="Environment\\UndeadBuildingFire\\UndeadLargeBuildingFire0.mdx"
set m[76]="Environment\\SmallBuildingFire\\SmallBuildingFire0.mdx"
set m[77]="Objects\\Spawnmodels\\Orc\\OrcBlood\\OrcBloodGrunt.mdx"
set m[78]="units\\creeps\\GoblinLandMine\\GoblinLandMine.mdl"
set m[79]="Doodads\\LordaeronSummer\\Plants\\LillyPad\\LillyPad.mdx"
set m[80]="units\\nightelf\\Hippogryph\\Hippogryph.mdx"
set m[81]="grunt3cape.mdx"
set m[82]="buildings\\orc\\TrollBurrow\\TrollBurrow.mdx"
set m[83]="abilities\\weapons\\huntermissile\\huntermissile.mdx"
set m[84]="Abilities\\Spells\\Undead\\FreezingBreath\\FreezingBreathTargetArt.mdx"
set m[85]="Abilities\\Spells\\Human\\FlameStrike\\FlameStrike1.mdx"
set m[86]="Abilities\\Spells\\Undead\\Impale\\ImpaleMissTarget.mdx"
set m[87]="Abilities\\Spells\\Other\\Drain\\ManaDrainCaster.mdx"
set m[88]="Abilities\\Spells\\Other\\Drain\\ManaDrainTarget.mdx"
set m[89]="Environment\\NightElfBuildingFire\\ElfLargeBuildingFire1.mdx"
set m[90]="Environment\\LargeBuildingFire\\LargeBuildingFire1.mdx"
set m[91]="units\\human\\Footman\\Footman.mdx"
set m[92]="units\\human\\Rifleman\\Rifleman.mdx"
set m[93]="units\\creeps\\HighElfArcher\\HighElfArcher.mdx"
set m[94]="Abilities\\Spells\\Human\\CloudOfFog\\CloudOfFog.mdx"
set m[95]="units\\orc\\Grunt\\Grunt.mdl"
set m[96]="units\\orc\\RiderlessWyvern\\RiderlessWyvern.mdx"
set m[97]="Objects\\InventoryItems\\Glyph\\Glyph.mdx"
set m[98]="Abilities\\Spells\\Other\\TalkToMe\\TalkToMe.mdx"
set m[99]="Objects\\RandomObject\\RandomObject.mdl"
set Q[1]="overhead"
set Q[2]="head"
set Q[3]="chest"
set Q[4]="origin"
set Q[5]="left hand"
set Q[6]="right hand"
set Q[7]="left foot"
set Q[8]="right foot"
set Q[9]="weapon"
call DestroyTrigger(GetTriggeringTrigger())
endfunction
function gSv takes nothing returns boolean
local string gtv=GetEventPlayerChatString()
if SubString(gtv,0,5)=="idod " and S2I(SubString(gtv,5,6))<=6 and S2I(SubString(gtv,5,6))>=1 and SubString(gtv,6,7)==" " and SubString(gtv,7,StringLength(gtv))=="on" or SubString(gtv,7,StringLength(gtv))=="off" then
set gtv=null
return true
else
set gtv=null
return false
endif
endfunction
function gTv takes nothing returns boolean
return(GetSpellAbilityId()=='A0HA')
endfunction
function guv takes nothing returns boolean
return IsUnitSelected(GetFilterUnit(),GetTriggerPlayer())and GetUnitTypeId(GetFilterUnit())!='h000'
endfunction
function gUv takes nothing returns boolean
return GetSpellAbilityId()=='A0ER'
endfunction
function gwv takes nothing returns boolean
return(GetSpellAbilityId()=='A08V')
endfunction
function gWv takes nothing returns boolean
set je=$7FFFFFFF
set xe=--$80000000
return true
endfunction
function gyv takes integer eaS returns nothing
endfunction
function gYv takes integer gzv returns nothing
call gyv(gzv)
set fM[gzv]=InitHashtable()
set RM[gzv]=InitHashtable()
endfunction
function gZv takes string g_v returns integer
local integer g0v
set ZM[EM]=g_v
set EM=EM+1
if gm==0 then
if hm<$8000 then
set hm=hm+1
set g0v=hm
set Fm[g0v]=4815
else
call Cdv("Out of memory: Could not create StringHashMap.","when calling error in Utility, line 81")
set g0v=0
endif
else
set gm=gm-1
set g0v=Gm[gm]
set Fm[g0v]=4815
endif
set EM=EM-1
return g0v
endfunction
function g1v takes string g2v returns integer
local integer g3v
set ZM[EM]=g2v
set EM=EM+1
set g3v=gZv("when calling alloc_StringHashMap in Utility, line 86")
call gYv(g3v)
set EM=EM-1
return g3v
endfunction
function g4v takes trigger g5v,player g6v,string g7v,boolean g8v returns event
return TriggerRegisterPlayerChatEvent(g5v,g6v,g7v,g8v)
endfunction
function g9v takes string Gvv returns boolean
local integer Gev
local integer Gxv
local trigger Gov
local trigger Grv
set ZM[EM]=Gvv
set EM=EM+1
set kd=g1v("when calling new_StringHashMap in ScmdReader, line 15")
set jd=Ctv("when calling new_HashMap in ScmdReader, line 16")
set Gev=0
set Gxv=bj_MAX_PLAYERS-1
loop
exitwhen Gev>Gxv
set Gov=CreateTrigger()
call g4v(Gov,sa[Gev],null,false)
set Grv=Gov
call cQv(Grv,O2v)
set Gev=Gev+1
endloop
set EM=EM-1
set Gov=null
set Grv=null
return true
endfunction
function Giv takes nothing returns boolean
set EM=0
return g9v("ScmdReader, line 1")
endfunction
function Gav takes integer Gnv,real GVv returns nothing
local timer GEv=cFv()
call SaveInteger(i,y,GetHandleId(GEv),Gnv)
call TimerStart(GEv,GVv,false,cz)
set GEv=null
endfunction
function GXv takes nothing returns integer
local integer GOv=Ob
if GOv!=0 then
set Ob=bb[GOv]
else
set lb=lb+1
set GOv=lb
endif
if GOv>8190 then
return 0
endif
set Kb[GOv]=89
set bb[GOv]=-1
return GOv
endfunction
function GRv takes nothing returns integer
local integer GIv=GXv()
if GIv==0 then
return 0
endif
set Kb[GIv]=94
return GIv
endfunction
function GAv takes unit GNv returns integer
local integer Gbv=GRv()
set Ab[Gbv]=GNv
return Gbv
endfunction
function GBv takes integer Gcv,integer GCv,string Gdv,widget GDv returns nothing
local unit Gfv=CreateUnit(r[PLAYER_NEUTRAL_PASSIVE],Y,GetWidgetX(GDv),GetWidgetY(GDv),.0)
call UnitAddAbility(Gfv,Gcv)
call clv(Gfv,Gcv,GCv)
call IssueTargetOrder(Gfv,Gdv,GDv)
call Gav(GAv(Gfv),1.)
set Gfv=null
endfunction
function GFv takes nothing returns integer
local integer Ggv
if wb[0]==0 then
set Ml=Ml+1
set Ggv=Ml
else
set Ggv=wb[0]
set wb[0]=wb[wb[0]]
endif
return Ggv
endfunction
function GGv takes integer Ghv,unit GHv returns integer
local integer Gjv=GFv()
set Bl[Gjv]=Ghv
set Nl[Gjv]=GHv
return Gjv
endfunction
function GJv takes integer Gkv returns nothing
set wb[Gkv]=wb[0]
set wb[0]=Gkv
endfunction
function GKv takes integer Glv,unit GLv returns nothing
set ry=GLv
call TriggerEvaluate(wy[Glv])
endfunction
function Gmv takes timer GMv returns nothing
call PauseTimer(GMv)
set l[b]=GMv
set b=b+1
endfunction
function Gpv takes integer GPv,unit Gqv returns timer
local integer GQv=GetHandleId(Gqv)
local timer Gsv
if HaveSavedHandle(i,ub[GPv],GQv)then
set Gsv=LoadTimerHandle(i,ub[GPv],GQv)
call GJv(LoadInteger(i,y,GetHandleId(Gsv)))
call Gmv(Gsv)
call GKv(sb[GPv],Gqv)
else
call GKv(rb[GPv],Gqv)
endif
set Gsv=cFv()
call SaveInteger(i,y,GetHandleId(Gsv),GGv(GPv,Gqv))
call SaveTimerHandle(i,ub[GPv],GQv,Gsv)
set RKv=Gsv
set Gsv=null
return RKv
endfunction
function GSv takes integer Gtv,unit GTv,real Guv,integer GUv returns nothing
local timer Gwv=Gpv(Gtv,GTv)
call SaveInteger(i,ub[Gtv],GetHandleId(Gwv),GUv)
call TimerStart(Gwv,Guv,true,Bz)
set Gwv=null
set Gwv=null
endfunction
function GWv takes nothing returns nothing
local unit Gyv
if GetSpellAbilityId()!='A0MF' then
set Gyv=null
return
endif
set Gyv=GetSpellAbilityUnit()
call GBv('A0ME',GetUnitAbilityLevel(Gyv,'A0MF'),"attackonce",Gyv)
call GSv(AO,Gyv,1.,GetUnitAbilityLevel(Gyv,'A0MF')*4)
set Gyv=null
set Gyv=null
endfunction
function GYv takes nothing returns nothing
set Ju[8]=GetUnitLoc(GetEnumUnit())
call CreateNUnitsAtLoc(1,'h0LE',GetOwningPlayer(Nu),Ju[8],bj_UNIT_FACING)
call UnitAddAbilityBJ('A06C',GetLastCreatedUnit())
call IssueTargetOrderBJ(GetLastCreatedUnit(),"slow",GetEnumUnit())
call GroupAddUnitSimple(GetLastCreatedUnit(),Ku)
call SaveIntegerBJ(Du+2,0,GetHandleIdBJ(GetLastCreatedUnit()),Au)
call RemoveLocation(Ju[8])
endfunction
function Gzv takes nothing returns boolean
return true
endfunction
function GZv takes string G_v returns integer
return StringLength(G_v)
endfunction
function G0v takes hashtable G1v,integer G2v,integer G3v returns string
return LoadStr(G1v,G2v,G3v)
endfunction
function G4v takes integer G5v,integer G6v returns string
return G0v(XR,G5v,G6v)
endfunction
function G7v takes integer G8v,integer G9v,string hvv returns string
local string hev
set ZM[EM]=hvv
set EM=EM+1
if ph[G8v]==0 then
if G8v==0 then
call Cdv("Nullpointer exception when calling Table.loadString","when calling error in Table, line 57")
else
call Cdv("Called Table.loadString on invalid object.","when calling error in Table, line 57")
endif
endif
set hev=G4v(G8v,G9v)
set EM=EM-1
return hev
endfunction
function hxv takes integer hov,string hrv returns string
local string hiv
set ZM[EM]=hrv
set EM=EM+1
set hiv=G7v(RT,hov,"when calling loadString in TypeCasting, line 36")
set EM=EM-1
return hiv
endfunction
function hav takes integer hnv,string hVv returns integer
local integer hEv=Ccv(hVv)
local integer hXv=c8v(fM[hnv],hEv,-1)
local integer hOv=0
local integer hRv=hXv-1
loop
exitwhen hOv>hRv
if G0v(fM[hnv],hEv,hOv)==hVv then
return c8v(RM[hnv],hEv,hOv)
endif
set hOv=hOv+1
endloop
return 0
endfunction
function hIv takes integer hAv,string hNv,string hbv returns integer
local integer hBv
set ZM[EM]=hbv
set EM=EM+1
if Fm[hAv]==0 then
if hAv==0 then
call Cdv("Nullpointer exception when calling StringHashMap.get","when calling error in Utility, line 127")
else
call Cdv("Called StringHashMap.get on invalid object.","when calling error in Utility, line 127")
endif
endif
set hBv=hav(hAv,hNv)
set EM=EM-1
return hBv
endfunction
function hcv takes integer ECt returns nothing
endfunction
function hCv takes integer hdv returns nothing
call hcv(hdv)
endfunction
function hDv takes integer hfv,string hFv returns nothing
set ZM[EM]=hFv
set EM=EM+1
if ox[hfv]==0 then
call Cdv("Double free: object of type Agent","when calling error in ScmdDataTypes, line 576")
else
set ix[Sx]=hfv
set Sx=Sx+1
set ox[hfv]=0
endif
set EM=EM-1
endfunction
function hgv takes integer hGv,string hhv returns nothing
set ZM[EM]=hhv
set EM=EM+1
call hCv(hGv)
call hDv(hGv,"when calling dealloc_Agent in ScmdDataTypes, line 576")
set EM=EM-1
endfunction
function hHv takes integer hjv,string hJv returns nothing
set ZM[EM]=hJv
set EM=EM+1
if ox[hjv]==0 then
call Cdv("Double free: object of type Integer","when calling error in ScmdDataTypes, line 476")
else
set ix[Sx]=hjv
set Sx=Sx+1
set ox[hjv]=0
endif
set EM=EM-1
endfunction
function hkv takes integer P4t returns nothing
endfunction
function hKv takes integer hlv returns nothing
call hkv(hlv)
endfunction
function hLv takes integer hmv returns nothing
call hKv(hmv)
endfunction
function hMv takes integer hpv,string hPv returns nothing
set ZM[EM]=hPv
set EM=EM+1
call hLv(hpv)
call hHv(hpv,"when calling dealloc_Integer in ScmdDataTypes, line 476")
set EM=EM-1
endfunction
function hqv takes integer hQv,string hsv returns nothing
set ZM[EM]=hsv
set EM=EM+1
if ox[hQv]==0 then
call Cdv("Double free: object of type Vector","when calling error in ScmdDataTypes, line 1052")
else
set ix[Sx]=hQv
set Sx=Sx+1
set ox[hQv]=0
endif
set EM=EM-1
endfunction
function hSv takes integer htv,string hTv returns nothing
set ZM[EM]=hTv
set EM=EM+1
if gF[htv]==0 then
call Cdv("Double free: object of type LinkedList","when calling error in LinkedList, line 18")
else
set TF[YF]=htv
set YF=YF+1
set gF[htv]=0
endif
set EM=EM-1
endfunction
function huv takes integer VNs returns nothing
endfunction
function hUv takes integer hwv,string hWv returns nothing
set ZM[EM]=hWv
set EM=EM+1
if RF[hwv]==0 then
call Cdv("Double free: object of type LLIterator","when calling error in LinkedList, line 418")
else
set nF[dF]=hwv
set dF=dF+1
set RF[hwv]=0
endif
set EM=EM-1
endfunction
function hyv takes integer hYv,string hzv returns nothing
set ZM[EM]=hzv
set EM=EM+1
call huv(hYv)
call hUv(hYv,"when calling dealloc_LLIterator in LinkedList, line 418")
set EM=EM-1
endfunction
function hZv takes integer h_v,string h0v returns nothing
set ZM[EM]=h0v
set EM=EM+1
if RF[h_v]==0 then
if h_v==0 then
call Cdv("Nullpointer exception when calling LLIterator.LLIterator","when calling error in LinkedList, line 418")
else
call Cdv("Called LLIterator.LLIterator on invalid object.","when calling error in LinkedList, line 418")
endif
endif
call hyv(h_v,"when calling destroyLLIterator in LinkedList, line 418")
set EM=EM-1
endfunction
function h1v takes integer h2v,string h3v returns nothing
set ZM[EM]=h3v
set EM=EM+1
if yF[h2v]==0 then
call Cdv("Double free: object of type LLBackIterator","when calling error in LinkedList, line 469")
else
set bF=bF+1
set yF[h2v]=0
endif
set EM=EM-1
endfunction
function h4v takes integer tNs returns nothing
endfunction
function h5v takes integer h6v,string h7v returns nothing
set ZM[EM]=h7v
set EM=EM+1
call h4v(h6v)
call h1v(h6v,"when calling dealloc_LLBackIterator in LinkedList, line 469")
set EM=EM-1
endfunction
function h8v takes integer h9v,string Hvv returns nothing
set ZM[EM]=Hvv
set EM=EM+1
if yF[h9v]==0 then
if h9v==0 then
call Cdv("Nullpointer exception when calling LLBackIterator.LLBackIterator","when calling error in LinkedList, line 469")
else
call Cdv("Called LLBackIterator.LLBackIterator on invalid object.","when calling error in LinkedList, line 469")
endif
endif
call h5v(h9v,"when calling destroyLLBackIterator in LinkedList, line 469")
set EM=EM-1
endfunction
function Hev takes integer YNs returns nothing
endfunction
function Hxv takes integer Hov,string Hrv returns nothing
set ZM[EM]=Hrv
set EM=EM+1
if aF[Hov]==0 then
call Cdv("Double free: object of type LLEntry","when calling error in LinkedList, line 408")
else
set pF[eF]=Hov
set eF=eF+1
set aF[Hov]=0
endif
set EM=EM-1
endfunction
function Hiv takes integer Hav,string Hnv returns nothing
set ZM[EM]=Hnv
set EM=EM+1
call Hev(Hav)
call Hxv(Hav,"when calling dealloc_LLEntry in LinkedList, line 408")
set EM=EM-1
endfunction
function HVv takes integer HEv,string HXv returns nothing
set ZM[EM]=HXv
set EM=EM+1
if aF[HEv]==0 then
if HEv==0 then
call Cdv("Nullpointer exception when calling LLEntry.LLEntry","when calling error in LinkedList, line 408")
else
call Cdv("Called LLEntry.LLEntry on invalid object.","when calling error in LinkedList, line 408")
endif
endif
call Hiv(HEv,"when calling destroyLLEntry in LinkedList, line 408")
set EM=EM-1
endfunction
function HOv takes integer HRv,string HIv returns nothing
local integer HAv
set ZM[EM]=HIv
set EM=EM+1
if lP[HRv]!=0 then
call hZv(lP[HRv],"when calling dispatch_LLIterator_destroyLLIterator in LinkedList, line 393")
endif
if bP[HRv]!=0 then
call h8v(bP[HRv],"when calling dispatch_LLBackIterator_destroyLLBackIterator in LinkedList, line 395")
endif
set HAv=sP[oP[HRv]]
loop
exitwhen not(HAv!=oP[HRv])
set HAv=sP[HAv]
call HVv(rP[HAv],"when calling dispatch_LLEntry_destroyLLEntry in LinkedList, line 399")
endloop
call HVv(oP[HRv],"when calling dispatch_LLEntry_destroyLLEntry in LinkedList, line 400")
set EM=EM-1
endfunction
function HNv takes integer Hbv,string HBv returns nothing
set ZM[EM]=HBv
set EM=EM+1
call HOv(Hbv,"when calling LinkedList_onDestroy in LinkedList, line 391")
call hSv(Hbv,"when calling dealloc_LinkedList in LinkedList, line 391")
set EM=EM-1
endfunction
function Hcv takes integer HCv,string Hdv returns nothing
set ZM[EM]=Hdv
set EM=EM+1
if gF[HCv]==0 then
if HCv==0 then
call Cdv("Nullpointer exception when calling LinkedList.LinkedList","when calling error in LinkedList, line 18")
else
call Cdv("Called LinkedList.LinkedList on invalid object.","when calling error in LinkedList, line 18")
endif
endif
call HNv(HCv,"when calling destroyLinkedList in LinkedList, line 18")
set EM=EM-1
endfunction
function HDv takes integer Hfv,string HFv returns nothing
set ZM[EM]=HFv
set EM=EM+1
if uK[Hfv]!=0 then
call Hcv(uK[Hfv],"when calling dispatch_LinkedList_destroyLinkedList in ScmdDataTypes, line 192")
endif
set EM=EM-1
endfunction
function Hgv takes integer HGv,string Hhv returns nothing
set ZM[EM]=Hhv
set EM=EM+1
call HDv(HGv,"when calling Exception_onDestroy in ScmdDataTypes, line 216")
set EM=EM-1
endfunction
function HHv takes integer Hjv,string HJv returns nothing
set ZM[EM]=HJv
set EM=EM+1
if ox[Hjv]==0 then
call Cdv("Double free: object of type ClassCastException","when calling error in ScmdDataTypes, line 216")
else
set ix[Sx]=Hjv
set Sx=Sx+1
set ox[Hjv]=0
endif
set EM=EM-1
endfunction
function Hkv takes integer HKv,string Hlv returns nothing
set ZM[EM]=Hlv
set EM=EM+1
call Hgv(HKv,"when calling ClassCastException_onDestroy in ScmdDataTypes, line 216")
call HHv(HKv,"when calling dealloc_ClassCastException in ScmdDataTypes, line 216")
set EM=EM-1
endfunction
function HLv takes hashtable Hmv,integer HMv returns nothing
call FlushChildHashtable(Hmv,HMv)
endfunction
function Hpv takes integer HPv,string Hqv returns nothing
set ZM[EM]=Hqv
set EM=EM+1
if ox[HPv]==0 then
call Cdv("Double free: object of type String","when calling error in ScmdDataTypes, line 299")
else
set ix[Sx]=HPv
set Sx=Sx+1
set ox[HPv]=0
endif
set EM=EM-1
endfunction
function HQv takes integer Hsv,string HSv returns nothing
set ZM[EM]=HSv
set EM=EM+1
call hkv(Hsv)
call Hpv(Hsv,"when calling dealloc_String in ScmdDataTypes, line 299")
set EM=EM-1
endfunction
function Htv takes integer HTv returns nothing
call hcv(HTv)
endfunction
function Huv takes integer HUv,string Hwv returns nothing
set ZM[EM]=Hwv
set EM=EM+1
if ox[HUv]==0 then
call Cdv("Double free: object of type Widget","when calling error in ScmdDataTypes, line 760")
else
set ix[Sx]=HUv
set Sx=Sx+1
set ox[HUv]=0
endif
set EM=EM-1
endfunction
function HWv takes integer Hyv,string HYv returns nothing
set ZM[EM]=HYv
set EM=EM+1
call Htv(Hyv)
call Huv(Hyv,"when calling dealloc_Widget in ScmdDataTypes, line 760")
set EM=EM-1
endfunction
function Hzv takes trigger HZv returns nothing
call TriggerClearConditions(HZv)
endfunction
function H_v takes integer PXt returns nothing
endfunction
function H0v takes integer H1v,string H2v returns nothing
set ZM[EM]=H2v
set EM=EM+1
if jx[H1v]==0 then
call Cdv("Double free: object of type ReferenceCounter","when calling error in ScmdDataTypes, line 102")
else
set hx[Fx]=H1v
set Fx=Fx+1
set jx[H1v]=0
endif
set EM=EM-1
endfunction
function H3v takes integer H4v,string H5v returns nothing
set ZM[EM]=H5v
set EM=EM+1
call H_v(H4v)
call H0v(H4v,"when calling dealloc_ReferenceCounter in ScmdDataTypes, line 102")
set EM=EM-1
endfunction
function H6v takes integer H7v,string H8v returns nothing
set ZM[EM]=H8v
set EM=EM+1
if jx[H7v]==0 then
if H7v==0 then
call Cdv("Nullpointer exception when calling ReferenceCounter.ReferenceCounter","when calling error in ScmdDataTypes, line 102")
else
call Cdv("Called ReferenceCounter.ReferenceCounter on invalid object.","when calling error in ScmdDataTypes, line 102")
endif
endif
call H3v(H7v,"when calling destroyReferenceCounter in ScmdDataTypes, line 102")
set EM=EM-1
endfunction
function H9v takes integer jvv,string jev returns nothing
set ZM[EM]=jev
set EM=EM+1
if ox[jvv]==0 then
call Cdv("Double free: object of type Boolean","when calling error in ScmdDataTypes, line 352")
else
set ix[Sx]=jvv
set Sx=Sx+1
set ox[jvv]=0
endif
set EM=EM-1
endfunction
function jxv takes integer jov returns nothing
call hkv(jov)
endfunction
function jrv takes integer jiv,string jav returns nothing
set ZM[EM]=jav
set EM=EM+1
call jxv(jiv)
call H9v(jiv,"when calling dealloc_Boolean in ScmdDataTypes, line 352")
set EM=EM-1
endfunction
function jnv takes integer HLt returns nothing
endfunction
function jVv takes integer jEv returns nothing
set cU[jEv]=0
endfunction
function jXv takes integer jOv,integer jRv returns nothing
call jVv(jOv)
set oU[jOv]=jRv
endfunction
function jIv takes string jAv returns integer
local integer jNv
set ZM[EM]=jAv
set EM=EM+1
if sh==0 then
if th<$8000 then
set th=th+1
set jNv=th
set ih[jNv]=$954
else
call Cdv("Out of memory: Could not create HLIterator.","when calling error in HashList, line 125")
set jNv=0
endif
else
set sh=sh-1
set jNv=rh[sh]
set ih[jNv]=$954
endif
set EM=EM-1
return jNv
endfunction
function jbv takes integer jBv,string jcv returns integer
local integer jCv
set ZM[EM]=jcv
set EM=EM+1
set jCv=jIv("when calling alloc_HLIterator in HashList, line 129")
call jXv(jCv,jBv)
set EM=EM-1
return jCv
endfunction
function jdv takes integer jDv,string jfv returns integer
local integer jFv
set ZM[EM]=jfv
set EM=EM+1
set jFv=jbv(jDv,"when calling new_HLIterator in HashList, line 96")
set EM=EM-1
return jFv
endfunction
function jgv takes integer jGv,string jhv returns integer
local integer jHv
set ZM[EM]=jhv
set EM=EM+1
if Oh[jGv]==0 then
if jGv==0 then
call Cdv("Nullpointer exception when calling HashList.iterator","when calling error in HashList, line 95")
else
call Cdv("Called HashList.iterator on invalid object.","when calling error in HashList, line 95")
endif
endif
set jHv=jdv(jGv,"when calling iterator in HashList, line 95")
set EM=EM-1
return jHv
endfunction
function jjv takes integer jJv,string jkv returns integer
local integer jKv
set ZM[EM]=jkv
set EM=EM+1
set jKv=jgv(bU[jJv],"when calling iterator in HashMap, line 84")
set EM=EM-1
return jKv
endfunction
function jlv takes integer jLv,string jmv returns nothing
set ZM[EM]=jmv
set EM=EM+1
if ox[jLv]==0 then
call Cdv("Double free: object of type BuiltinSpecialForm","when calling error in ScmdDataTypes, line 1538")
else
set ix[Sx]=jLv
set Sx=Sx+1
set ox[jLv]=0
endif
set EM=EM-1
endfunction
function jMv takes integer jpv,integer jPv returns integer
return c8v(ne,jpv,jPv)
endfunction
function jqv takes integer jQv,integer jsv,string jSv returns integer
local integer jtv
set ZM[EM]=jSv
set EM=EM+1
if Oh[jQv]==0 then
if jQv==0 then
call Cdv("Nullpointer exception when calling HashList.get","when calling error in HashList, line 79")
else
call Cdv("Called HashList.get on invalid object.","when calling error in HashList, line 79")
endif
endif
set jtv=jMv(jQv,jsv)
set EM=EM-1
return jtv
endfunction
function jTv takes integer juv,string jUv returns integer
local integer jwv
set ZM[EM]=jUv
set EM=EM+1
set cU[juv]=cU[juv]+1
set jwv=jqv(oU[juv],cU[juv]-1,"when calling get in HashList, line 140")
set EM=EM-1
return jwv
endfunction
function jWv takes integer jyv,string jYv returns nothing
set ZM[EM]=jYv
set EM=EM+1
if Oh[jyv]==0 then
call Cdv("Double free: object of type HashList","when calling error in HashList, line 8")
else
set Sh[ch]=jyv
set ch=ch+1
set Oh[jyv]=0
endif
set EM=EM-1
endfunction
function jzv takes integer jZv returns nothing
call HLv(ne,jZv)
call HLv(de,jZv)
set OU[jZv]=0
endfunction
function j_v takes integer j0v returns nothing
call jzv(j0v)
call HLv(fe,j0v)
endfunction
function j1v takes integer j2v,string j3v returns nothing
set ZM[EM]=j3v
set EM=EM+1
if Oh[j2v]==0 then
if j2v==0 then
call Cdv("Nullpointer exception when calling HashList.clear","when calling error in HashList, line 43")
else
call Cdv("Called HashList.clear on invalid object.","when calling error in HashList, line 43")
endif
endif
if Oh[j2v]<=$966 then
call jzv(j2v)
else
call j_v(j2v)
endif
set EM=EM-1
endfunction
function j4v takes integer j5v,string j6v returns nothing
set ZM[EM]=j6v
set EM=EM+1
call j1v(j5v,"when calling clear in HashList, line 120")
set EM=EM-1
endfunction
function j7v takes integer j8v,string j9v returns nothing
set ZM[EM]=j9v
set EM=EM+1
call j4v(j8v,"when calling HashList_onDestroy in HashList, line 119")
call jWv(j8v,"when calling dealloc_HashList in HashList, line 119")
set EM=EM-1
endfunction
function Jvv takes integer Jev,string Jxv returns nothing
set ZM[EM]=Jxv
set EM=EM+1
call HLv(fe,Jev)
call j4v(Jev,"when calling HashList_onDestroy in HashSet, line 5")
set EM=EM-1
endfunction
function Jov takes integer Jrv,string Jiv returns nothing
set ZM[EM]=Jiv
set EM=EM+1
if Oh[Jrv]==0 then
call Cdv("Double free: object of type HashSet","when calling error in HashSet, line 5")
else
set Sh[ch]=Jrv
set ch=ch+1
set Oh[Jrv]=0
endif
set EM=EM-1
endfunction
function Jav takes integer Jnv,string JVv returns nothing
set ZM[EM]=JVv
set EM=EM+1
call Jvv(Jnv,"when calling HashSet_onDestroy in HashSet, line 31")
call Jov(Jnv,"when calling dealloc_HashSet in HashSet, line 31")
set EM=EM-1
endfunction
function JEv takes integer JXv,string JOv returns nothing
set ZM[EM]=JOv
set EM=EM+1
if Oh[JXv]==0 then
if JXv==0 then
call Cdv("Nullpointer exception when calling HashList.HashList","when calling error in HashList, line 8")
else
call Cdv("Called HashList.HashList on invalid object.","when calling error in HashList, line 8")
endif
endif
if Oh[JXv]<=$966 then
call j7v(JXv,"when calling destroyHashList in HashList, line 8")
else
call Jav(JXv,"when calling destroyHashSet in HashList, line 8")
endif
set EM=EM-1
endfunction
function JRv takes integer JIv,string JAv returns nothing
set ZM[EM]=JAv
set EM=EM+1
if ax[JIv]==0 then
call Cdv("Double free: object of type BuiltinData","when calling error in ScmdDataTypes, line 1376")
else
set px[ex]=JIv
set ex=ex+1
set ax[JIv]=0
endif
set EM=EM-1
endfunction
function JNv takes integer Jbv,string JBv returns nothing
set ZM[EM]=JBv
set EM=EM+1
call Hcv(jJ[Jbv],"when calling dispatch_LinkedList_destroyLinkedList in ScmdDataTypes, line 1421")
set EM=EM-1
endfunction
function Jcv takes integer JCv,string Jdv returns nothing
set ZM[EM]=Jdv
set EM=EM+1
call JNv(JCv,"when calling BuiltinData_onDestroy in ScmdDataTypes, line 1420")
call JRv(JCv,"when calling dealloc_BuiltinData in ScmdDataTypes, line 1420")
set EM=EM-1
endfunction
function JDv takes integer Jfv,string JFv returns nothing
set ZM[EM]=JFv
set EM=EM+1
if ax[Jfv]==0 then
if Jfv==0 then
call Cdv("Nullpointer exception when calling BuiltinData.BuiltinData","when calling error in ScmdDataTypes, line 1376")
else
call Cdv("Called BuiltinData.BuiltinData on invalid object.","when calling error in ScmdDataTypes, line 1376")
endif
endif
call Jcv(Jfv,"when calling destroyBuiltinData in ScmdDataTypes, line 1376")
set EM=EM-1
endfunction
function Jgv takes integer JGv,string Jhv returns boolean
local boolean JHv
set ZM[EM]=Jhv
set EM=EM+1
set JHv=cU[JGv]<dgv(oU[JGv],"when calling size in HashList, line 133")
set EM=EM-1
return JHv
endfunction
function Jjv takes integer JJv,string Jkv returns nothing
set ZM[EM]=Jkv
set EM=EM+1
if ih[JJv]==0 then
call Cdv("Double free: object of type HLIterator","when calling error in HashList, line 125")
else
set rh[sh]=JJv
set sh=sh+1
set ih[JJv]=0
endif
set EM=EM-1
endfunction
function JKv takes integer FUs returns nothing
endfunction
function Jlv takes integer JLv,string Jmv returns nothing
set ZM[EM]=Jmv
set EM=EM+1
call JKv(JLv)
call Jjv(JLv,"when calling dealloc_HLIterator in HashList, line 125")
set EM=EM-1
endfunction
function JMv takes integer Jpv,string JPv returns nothing
set ZM[EM]=JPv
set EM=EM+1
if ih[Jpv]==0 then
if Jpv==0 then
call Cdv("Nullpointer exception when calling HLIterator.HLIterator","when calling error in HashList, line 125")
else
call Cdv("Called HLIterator.HLIterator on invalid object.","when calling error in HashList, line 125")
endif
endif
call Jlv(Jpv,"when calling destroyHLIterator in HashList, line 125")
set EM=EM-1
endfunction
function Jqv takes integer JQv,string Jsv returns nothing
set ZM[EM]=Jsv
set EM=EM+1
call JMv(JQv,"when calling dispatch_HLIterator_destroyHLIterator in HashList, line 146")
set EM=EM-1
endfunction
function JSv takes integer Jtv,string JTv returns nothing
local integer Juv
local integer JUv
set ZM[EM]=JTv
set EM=EM+1
set Juv=jdv(ZJ[Jtv],"when calling iterator in ScmdDataTypes, line 1502")
loop
exitwhen not Jgv(Juv,"when calling hasNext in ScmdDataTypes, line 1502")
set JUv=jTv(Juv,"when calling next in ScmdDataTypes, line 1502")
call JDv(JUv,"when calling dispatch_BuiltinData_destroyBuiltinData in ScmdDataTypes, line 1503")
endloop
call Jqv(Juv,"when calling close in ScmdDataTypes, line 1502")
call JEv(ZJ[Jtv],"when calling dispatch_HashList_destroyHashList in ScmdDataTypes, line 1504")
if UJ[Jtv]!=0 then
call JDv(UJ[Jtv],"when calling dispatch_BuiltinData_destroyBuiltinData in ScmdDataTypes, line 1506")
endif
set EM=EM-1
endfunction
function Jwv takes integer JWv,string Jyv returns nothing
set ZM[EM]=Jyv
set EM=EM+1
call JSv(JWv,"when calling BuiltinSpecialForm_onDestroy in ScmdDataTypes, line 1538")
call jlv(JWv,"when calling dealloc_BuiltinSpecialForm in ScmdDataTypes, line 1538")
set EM=EM-1
endfunction
function JYv takes integer Jzv returns nothing
set SK[Jzv]=SK[Jzv]-1
endfunction
function JZv takes integer J_v,string J0v returns nothing
set ZM[EM]=J0v
set EM=EM+1
if jx[J_v]==0 then
if J_v==0 then
call Cdv("Nullpointer exception when calling ReferenceCounter.decrease","when calling error in ScmdDataTypes, line 109")
else
call Cdv("Called ReferenceCounter.decrease on invalid object.","when calling error in ScmdDataTypes, line 109")
endif
endif
call JYv(J_v)
set EM=EM-1
endfunction
function J1v takes integer J2v,string J3v returns nothing
set ZM[EM]=J3v
set EM=EM+1
if ox[J2v]==0 then
call Cdv("Double free: object of type Expression","when calling error in ScmdDataTypes, line 1573")
else
set ix[Sx]=J2v
set Sx=Sx+1
set ox[J2v]=0
endif
set EM=EM-1
endfunction
function J4v takes integer J5v returns nothing
call hKv(J5v)
endfunction
function J6v takes integer J7v,string J8v returns nothing
set ZM[EM]=J8v
set EM=EM+1
if ox[J7v]==0 then
call Cdv("Double free: object of type LiteralReal","when calling error in ScmdDataTypes, line 438")
else
set ix[Sx]=J7v
set Sx=Sx+1
set ox[J7v]=0
endif
set EM=EM-1
endfunction
function J9v takes integer kvv,string kev returns nothing
set ZM[EM]=kev
set EM=EM+1
call J4v(kvv)
call J6v(kvv,"when calling dealloc_LiteralReal in ScmdDataTypes, line 438")
set EM=EM-1
endfunction
function kxv takes integer kov,string krv returns nothing
set ZM[EM]=krv
set EM=EM+1
if ox[kov]==0 then
call Cdv("Double free: object of type Unit","when calling error in ScmdDataTypes, line 782")
else
set ix[Sx]=kov
set Sx=Sx+1
set ox[kov]=0
endif
set EM=EM-1
endfunction
function kiv takes integer kav returns nothing
call Htv(kav)
endfunction
function knv takes integer kVv,string kEv returns nothing
set ZM[EM]=kEv
set EM=EM+1
call kiv(kVv)
call kxv(kVv,"when calling dealloc_Unit in ScmdDataTypes, line 782")
set EM=EM-1
endfunction
function kXv takes integer kOv,string kRv returns nothing
set ZM[EM]=kRv
set EM=EM+1
if ox[kOv]==0 then
call Cdv("Double free: object of type WeatherEffect","when calling error in ScmdDataTypes, line 625")
else
set ix[Sx]=kOv
set Sx=Sx+1
set ox[kOv]=0
endif
set EM=EM-1
endfunction
function kIv takes integer kAv returns nothing
call RemoveWeatherEffect(IK[kAv])
endfunction
function kNv takes integer kbv,string kBv returns nothing
set ZM[EM]=kBv
set EM=EM+1
call kIv(kbv)
call kXv(kbv,"when calling dealloc_WeatherEffect in ScmdDataTypes, line 646")
set EM=EM-1
endfunction
function kcv takes group kCv returns nothing
call DestroyGroup(kCv)
endfunction
function kdv takes integer kDv returns nothing
call kcv(cK[kDv])
endfunction
function kfv takes integer kFv,string kgv returns nothing
set ZM[EM]=kgv
set EM=EM+1
if ox[kFv]==0 then
call Cdv("Double free: object of type Group","when calling error in ScmdDataTypes, line 730")
else
set ix[Sx]=kFv
set Sx=Sx+1
set ox[kFv]=0
endif
set EM=EM-1
endfunction
function kGv takes integer khv,string kHv returns nothing
set ZM[EM]=kHv
set EM=EM+1
call kdv(khv)
call kfv(khv,"when calling dealloc_Group in ScmdDataTypes, line 757")
set EM=EM-1
endfunction
function kjv takes integer kJv returns nothing
call KillSoundWhenDone(fK[kJv])
endfunction
function kkv takes integer kKv,string klv returns nothing
set ZM[EM]=klv
set EM=EM+1
if ox[kKv]==0 then
call Cdv("Double free: object of type Sound","when calling error in ScmdDataTypes, line 649")
else
set ix[Sx]=kKv
set Sx=Sx+1
set ox[kKv]=0
endif
set EM=EM-1
endfunction
function kLv takes integer kmv,string kMv returns nothing
set ZM[EM]=kMv
set EM=EM+1
call kjv(kmv)
call kkv(kmv,"when calling dealloc_Sound in ScmdDataTypes, line 675")
set EM=EM-1
endfunction
function kpv takes integer kPv,string kqv returns nothing
local integer kQv
local integer ksv
set ZM[EM]=kqv
set EM=EM+1
set kQv=jdv(WJ[kPv],"when calling iterator in ScmdDataTypes, line 1502")
loop
exitwhen not Jgv(kQv,"when calling hasNext in ScmdDataTypes, line 1502")
set ksv=jTv(kQv,"when calling next in ScmdDataTypes, line 1502")
call JDv(ksv,"when calling dispatch_BuiltinData_destroyBuiltinData in ScmdDataTypes, line 1503")
endloop
call Jqv(kQv,"when calling close in ScmdDataTypes, line 1502")
call JEv(WJ[kPv],"when calling dispatch_HashList_destroyHashList in ScmdDataTypes, line 1504")
if EJ[kPv]!=0 then
call JDv(EJ[kPv],"when calling dispatch_BuiltinData_destroyBuiltinData in ScmdDataTypes, line 1506")
endif
call jnv(kPv)
set EM=EM-1
endfunction
function kSv takes integer ktv,string kTv returns nothing
set ZM[EM]=kTv
set EM=EM+1
if ox[ktv]==0 then
call Cdv("Double free: object of type BuiltinFunction","when calling error in ScmdDataTypes, line 1514")
else
set ix[Sx]=ktv
set Sx=Sx+1
set ox[ktv]=0
endif
set EM=EM-1
endfunction
function kuv takes integer kUv,string kwv returns nothing
set ZM[EM]=kwv
set EM=EM+1
call kpv(kUv,"when calling BuiltinFunction_onDestroy in ScmdDataTypes, line 1514")
call kSv(kUv,"when calling dealloc_BuiltinFunction in ScmdDataTypes, line 1514")
set EM=EM-1
endfunction
function kWv takes trigger kyv,triggeraction kYv returns nothing
call TriggerRemoveAction(kyv,kYv)
endfunction
function kzv takes integer kZv,string k_v returns nothing
set ZM[EM]=k_v
set EM=EM+1
if ox[kZv]==0 then
call Cdv("Double free: object of type Function","when calling error in ScmdDataTypes, line 1300")
else
set ix[Sx]=kZv
set Sx=Sx+1
set ox[kZv]=0
endif
set EM=EM-1
endfunction
function k0v takes integer k1v,string k2v returns nothing
set ZM[EM]=k2v
set EM=EM+1
call jnv(k1v)
call kzv(k1v,"when calling dealloc_Function in ScmdDataTypes, line 1300")
set EM=EM-1
endfunction
function k3v takes hashtable k4v,integer k5v,integer k6v,string k7v returns nothing
call SaveStr(k4v,k5v,k6v,k7v)
endfunction
function k8v takes integer k9v,integer Kvv,string Kev returns nothing
call k3v(XR,k9v,Kvv,Kev)
endfunction
function Kxv takes integer Kov,integer Krv,string Kiv,string Kav returns nothing
set ZM[EM]=Kav
set EM=EM+1
if ph[Kov]==0 then
if Kov==0 then
call Cdv("Nullpointer exception when calling Table.saveString","when calling error in Table, line 60")
else
call Cdv("Called Table.saveString on invalid object.","when calling error in Table, line 60")
endif
endif
call k8v(Kov,Krv,Kiv)
set EM=EM-1
endfunction
function Knv takes hashtable KVv,integer KEv,integer KXv returns boolean
return HaveSavedString(KVv,KEv,KXv)
endfunction
function KOv takes integer KRv,integer KIv returns boolean
return Knv(XR,KRv,KIv)
endfunction
function KAv takes integer KNv,integer Kbv,string KBv returns boolean
local boolean Kcv
set ZM[EM]=KBv
set EM=EM+1
if ph[KNv]==0 then
if KNv==0 then
call Cdv("Nullpointer exception when calling Table.hasString","when calling error in Table, line 18")
else
call Cdv("Called Table.hasString on invalid object.","when calling error in Table, line 18")
endif
endif
set Kcv=KOv(KNv,Kbv)
set EM=EM-1
return Kcv
endfunction
function KCv takes string Kdv,string KDv returns integer
local integer Kfv
set ZM[EM]=KDv
set EM=EM+1
set Kfv=Ccv(Kdv)
loop
exitwhen not true
if KAv(RT,Kfv,"when calling hasString in TypeCasting, line 26")then
if G7v(RT,Kfv,"when calling loadString in TypeCasting, line 27")==Kdv then
exitwhen true
endif
else
call Kxv(RT,Kfv,Kdv,"when calling saveString in TypeCasting, line 30")
exitwhen true
endif
set Kfv=Kfv+1
endloop
set EM=EM-1
return Kfv
endfunction
function KFv takes integer Kgv returns integer
return SK[Kgv]
endfunction
function KGv takes integer Khv,string KHv returns integer
local integer Kjv
set ZM[EM]=KHv
set EM=EM+1
if jx[Khv]==0 then
if Khv==0 then
call Cdv("Nullpointer exception when calling ReferenceCounter.getUseCount","when calling error in ScmdDataTypes, line 112")
else
call Cdv("Called ReferenceCounter.getUseCount on invalid object.","when calling error in ScmdDataTypes, line 112")
endif
endif
set Kjv=KFv(Khv)
set EM=EM-1
return Kjv
endfunction
function KJv takes integer Kkv returns nothing
call Htv(Kkv)
endfunction
function KKv takes integer Klv,string KLv returns nothing
set ZM[EM]=KLv
set EM=EM+1
if ox[Klv]==0 then
call Cdv("Double free: object of type Destructable","when calling error in ScmdDataTypes, line 832")
else
set ix[Sx]=Klv
set Sx=Sx+1
set ox[Klv]=0
endif
set EM=EM-1
endfunction
function Kmv takes integer KMv,string Kpv returns nothing
set ZM[EM]=Kpv
set EM=EM+1
call KJv(KMv)
call KKv(KMv,"when calling dealloc_Destructable in ScmdDataTypes, line 832")
set EM=EM-1
endfunction
function KPv takes integer Kqv,string KQv returns nothing
set ZM[EM]=KQv
set EM=EM+1
if ox[Kqv]==0 then
call Cdv("Double free: object of type SpecialEffect","when calling error in ScmdDataTypes, line 592")
else
set ix[Sx]=Kqv
set Sx=Sx+1
set ox[Kqv]=0
endif
set EM=EM-1
endfunction
function Ksv takes effect KSv returns nothing
call DestroyEffect(KSv)
endfunction
function Ktv takes integer KTv returns nothing
call Ksv(TK[KTv])
endfunction
function Kuv takes integer KUv,string Kwv returns nothing
set ZM[EM]=Kwv
set EM=EM+1
call Ktv(KUv)
call KPv(KUv,"when calling dealloc_SpecialEffect in ScmdDataTypes, line 622")
set EM=EM-1
endfunction
function KWv takes hashtable Kyv,integer KYv,integer Kzv returns triggercondition
return LoadTriggerConditionHandle(Kyv,KYv,Kzv)
endfunction
function KZv takes integer K_v,string K0v returns nothing
set ZM[EM]=K0v
set EM=EM+1
if ox[K_v]==0 then
call Cdv("Double free: object of type Region","when calling error in ScmdDataTypes, line 708")
else
set ix[Sx]=K_v
set Sx=Sx+1
set ox[K_v]=0
endif
set EM=EM-1
endfunction
function K1v takes region K2v returns nothing
call RemoveRegion(K2v)
endfunction
function K3v takes integer K4v returns nothing
call K1v(qK[K4v])
endfunction
function K5v takes integer K6v,string K7v returns nothing
set ZM[EM]=K7v
set EM=EM+1
call K3v(K6v)
call KZv(K6v,"when calling dealloc_Region in ScmdDataTypes, line 726")
set EM=EM-1
endfunction
function K8v takes integer K9v,string lvv returns nothing
set ZM[EM]=lvv
set EM=EM+1
if gx[K9v]==0 then
call Cdv("Double free: object of type GenericSharedPointer","when calling error in ScmdDataTypes, line 100")
else
set Tx[Yx]=K9v
set Yx=Yx+1
set gx[K9v]=0
endif
set EM=EM-1
endfunction
function lev takes integer lxv,string lov returns nothing
set ZM[EM]=lov
set EM=EM+1
if Rx[lxv]==0 then
call Cdv("Double free: object of type Context","when calling error in ScmdDataTypes, line 1117")
else
set nx[dx]=lxv
set dx=dx+1
set Rx[lxv]=0
endif
set EM=EM-1
endfunction
function lrv takes integer liv,string lav returns nothing
set ZM[EM]=lav
set EM=EM+1
if ox[liv]==0 then
call Cdv("Double free: object of type Rect","when calling error in ScmdDataTypes, line 678")
else
set ix[Sx]=liv
set Sx=Sx+1
set ox[liv]=0
endif
set EM=EM-1
endfunction
function lnv takes rect lVv returns nothing
call RemoveRect(lVv)
endfunction
function lEv takes integer lXv returns nothing
call lnv(eK[lXv])
endfunction
function lOv takes integer lRv,string lIv returns nothing
set ZM[EM]=lIv
set EM=EM+1
call lEv(lRv)
call lrv(lRv,"when calling dealloc_Rect in ScmdDataTypes, line 705")
set EM=EM-1
endfunction
function lAv takes integer lNv,string lbv returns nothing
set ZM[EM]=lbv
set EM=EM+1
if ph[lNv]==0 then
call Cdv("Double free: object of type IterableMap","when calling error in HashMap, line 46")
else
set lh[bh]=lNv
set bh=bh+1
set ph[lNv]=0
endif
set EM=EM-1
endfunction
function lBv takes integer lcv returns nothing
call HLv(XR,lcv)
endfunction
function lCv takes integer ldv returns nothing
set lU[ldv]=0
call lBv(ldv)
endfunction
function lDv takes integer lfv,string lFv returns nothing
set ZM[EM]=lFv
set EM=EM+1
if not yU[lfv]then
call j1v(bU[lfv],"when calling clear in HashMap, line 73")
endif
call lCv(lfv)
set EM=EM-1
endfunction
function lgv takes integer lGv,string lhv returns nothing
set ZM[EM]=lhv
set EM=EM+1
if ph[lGv]==0 then
if lGv==0 then
call Cdv("Nullpointer exception when calling Table.flush","when calling error in Table, line 250")
else
call Cdv("Called Table.flush on invalid object.","when calling error in Table, line 250")
endif
endif
if ph[lGv]<=4898 then
if ph[lGv]<=4897 then
call lBv(lGv)
else
call lCv(lGv)
endif
else
call lDv(lGv,"when calling flush in Table, line 250")
endif
set EM=EM-1
endfunction
function lHv takes integer ljv,string lJv returns nothing
set ZM[EM]=lJv
set EM=EM+1
call lgv(ljv,"when calling flush in Table, line 254")
set EM=EM-1
endfunction
function lkv takes integer lKv,string llv returns nothing
set ZM[EM]=llv
set EM=EM+1
call lHv(lKv,"when calling Table_onDestroy in HashMap, line 8")
set EM=EM-1
endfunction
function lLv takes integer lmv,string lMv returns nothing
set ZM[EM]=lMv
set EM=EM+1
call JEv(bU[lmv],"when calling dispatch_HashList_destroyHashList in HashMap, line 131")
set yU[lmv]=true
call lkv(lmv,"when calling HashMap_onDestroy in HashMap, line 46")
set EM=EM-1
endfunction
function lpv takes integer lPv,string lqv returns nothing
set ZM[EM]=lqv
set EM=EM+1
call lLv(lPv,"when calling IterableMap_onDestroy in HashMap, line 130")
call lAv(lPv,"when calling dealloc_IterableMap in HashMap, line 130")
set EM=EM-1
endfunction
function lQv takes integer lsv,string lSv returns nothing
set ZM[EM]=lSv
set EM=EM+1
if ph[lsv]==0 then
if lsv==0 then
call Cdv("Nullpointer exception when calling IterableMap.IterableMap","when calling error in HashMap, line 46")
else
call Cdv("Called IterableMap.IterableMap on invalid object.","when calling error in HashMap, line 46")
endif
endif
call lpv(lsv,"when calling destroyIterableMap in HashMap, line 46")
set EM=EM-1
endfunction
function ltv takes integer lTv,string luv returns nothing
set ZM[EM]=luv
set EM=EM+1
if ox[lTv]==0 then
call Cdv("Double free: object of type Symbol","when calling error in ScmdDataTypes, line 242")
else
set ix[Sx]=lTv
set Sx=Sx+1
set ox[lTv]=0
endif
set EM=EM-1
endfunction
function lUv takes integer H2t returns nothing
endfunction
function lwv takes integer lWv,string lyv returns nothing
set ZM[EM]=lyv
set EM=EM+1
call lUv(lWv)
call ltv(lWv,"when calling dealloc_Symbol in ScmdDataTypes, line 242")
set EM=EM-1
endfunction
function lYv takes trigger lzv,triggercondition lZv returns nothing
call TriggerRemoveCondition(lzv,lZv)
endfunction
function l_v takes trigger l0v returns nothing
call TriggerClearActions(l0v)
endfunction
function l1v takes integer U6i returns nothing
endfunction
function l2v takes integer l3v,string l4v returns nothing
set ZM[EM]=l4v
set EM=EM+1
if ox[l3v]==0 then
call Cdv("Double free: object of type Undefined","when calling error in ScmdDataTypes, line 70")
else
set ix[Sx]=l3v
set Sx=Sx+1
set ox[l3v]=0
endif
set EM=EM-1
endfunction
function l5v takes integer l6v,string l7v returns nothing
set ZM[EM]=l7v
set EM=EM+1
call l1v(l6v)
call l2v(l6v,"when calling dealloc_Undefined in ScmdDataTypes, line 70")
set EM=EM-1
endfunction
function l8v takes integer l9v,string Lvv returns nothing
set ZM[EM]=Lvv
set EM=EM+1
if ox[l9v]==0 then
call Cdv("Double free: object of type Handle","when calling error in ScmdDataTypes, line 555")
else
set ix[Sx]=l9v
set Sx=Sx+1
set ox[l9v]=0
endif
set EM=EM-1
endfunction
function Lev takes integer Lxv,string Lov returns nothing
set ZM[EM]=Lov
set EM=EM+1
call hcv(Lxv)
call l8v(Lxv,"when calling dealloc_Handle in ScmdDataTypes, line 555")
set EM=EM-1
endfunction
function Lrv takes integer Liv,string Lav returns nothing
set ZM[EM]=Lav
set EM=EM+1
if ox[Liv]==0 then
call Cdv("Double free: object of type LiteralInteger","when calling error in ScmdDataTypes, line 493")
else
set ix[Sx]=Liv
set Sx=Sx+1
set ox[Liv]=0
endif
set EM=EM-1
endfunction
function Lnv takes integer LVv returns nothing
call hLv(LVv)
endfunction
function LEv takes integer LXv,string LOv returns nothing
set ZM[EM]=LOv
set EM=EM+1
call Lnv(LXv)
call Lrv(LXv,"when calling dealloc_LiteralInteger in ScmdDataTypes, line 493")
set EM=EM-1
endfunction
function LRv takes trigger LIv returns nothing
call DestroyTrigger(LIv)
endfunction
function LAv takes integer LNv,string Lbv returns nothing
set ZM[EM]=Lbv
set EM=EM+1
if gx[LNv]==0 then
call Cdv("Double free: object of type SharedPointer","when calling error in ScmdDataTypes, line 166")
else
set Tx[Yx]=LNv
set Yx=Yx+1
set gx[LNv]=0
endif
set EM=EM-1
endfunction
function LBv takes integer Lcv,string LCv returns nothing
set ZM[EM]=LCv
set EM=EM+1
if yx[Lcv]==0 then
call Cdv("Double free: object of type Arguments","when calling error in ScmdDataTypes, line 1243")
else
set Ox[lx]=Lcv
set lx=lx+1
set yx[Lcv]=0
endif
set EM=EM-1
endfunction
function Ldv takes integer LDv,string Lfv returns nothing
set ZM[EM]=Lfv
set EM=EM+1
if ox[LDv]==0 then
call Cdv("Double free: object of type Real","when calling error in ScmdDataTypes, line 421")
else
set ix[Sx]=LDv
set Sx=Sx+1
set ox[LDv]=0
endif
set EM=EM-1
endfunction
function LFv takes integer Lgv,string LGv returns nothing
set ZM[EM]=LGv
set EM=EM+1
call hKv(Lgv)
call Ldv(Lgv,"when calling dealloc_Real in ScmdDataTypes, line 421")
set EM=EM-1
endfunction
function Lhv takes integer LHv,string Ljv returns nothing
set ZM[EM]=Ljv
set EM=EM+1
if ox[LHv]==0 then
call Cdv("Double free: object of type Trigger","when calling error in ScmdDataTypes, line 893")
else
set ix[Sx]=LHv
set Sx=Sx+1
set ox[LHv]=0
endif
set EM=EM-1
endfunction
function LJv takes integer Lkv returns nothing
call jxv(Lkv)
endfunction
function LKv takes integer Llv,string LLv returns nothing
set ZM[EM]=LLv
set EM=EM+1
if ox[Llv]==0 then
call Cdv("Double free: object of type LiteralBoolean","when calling error in ScmdDataTypes, line 369")
else
set ix[Sx]=Llv
set Sx=Sx+1
set ox[Llv]=0
endif
set EM=EM-1
endfunction
function Lmv takes integer LMv,string Lpv returns nothing
set ZM[EM]=Lpv
set EM=EM+1
call LJv(LMv)
call LKv(LMv,"when calling dealloc_LiteralBoolean in ScmdDataTypes, line 369")
set EM=EM-1
endfunction
function LPv takes integer Lqv returns nothing
set An[Dn]=IJ[Lqv]
set Dn=Dn+1
endfunction
function LQv takes integer Lsv,string LSv returns nothing
set ZM[EM]=LSv
set EM=EM+1
if ox[Lsv]==0 then
call Cdv("Double free: object of type CameraSetup","when calling error in ScmdDataTypes, line 854")
else
set ix[Sx]=Lsv
set Sx=Sx+1
set ox[Lsv]=0
endif
set EM=EM-1
endfunction
function Ltv takes integer LTv,string Luv returns nothing
set ZM[EM]=Luv
set EM=EM+1
call LPv(LTv)
call LQv(LTv,"when calling dealloc_CameraSetup in ScmdDataTypes, line 889")
set EM=EM-1
endfunction
function LUv takes integer Lwv,string LWv returns nothing
set ZM[EM]=LWv
set EM=EM+1
if ox[Lwv]==0 then
call Cdv("Double free: object of type LiteralString","when calling error in ScmdDataTypes, line 311")
else
set ix[Sx]=Lwv
set Sx=Sx+1
set ox[Lwv]=0
endif
set EM=EM-1
endfunction
function Lyv takes integer LYv returns nothing
call hkv(LYv)
endfunction
function Lzv takes integer LZv,string L_v returns nothing
set ZM[EM]=L_v
set EM=EM+1
call Lyv(LZv)
call LUv(LZv,"when calling dealloc_LiteralString in ScmdDataTypes, line 311")
set EM=EM-1
endfunction
function L0v takes integer L1v,string L2v returns nothing
set ZM[EM]=L2v
set EM=EM+1
if ox[L1v]==0 then
call Cdv("Double free: object of type Exception","when calling error in ScmdDataTypes, line 183")
else
set ix[Sx]=L1v
set Sx=Sx+1
set ox[L1v]=0
endif
set EM=EM-1
endfunction
function L3v takes integer L4v,string L5v returns nothing
set ZM[EM]=L5v
set EM=EM+1
call HDv(L4v,"when calling Exception_onDestroy in ScmdDataTypes, line 190")
call L0v(L4v,"when calling dealloc_Exception in ScmdDataTypes, line 190")
set EM=EM-1
endfunction
function L6v takes integer L7v,string L8v returns nothing
set ZM[EM]=L8v
set EM=EM+1
if ox[L7v]==0 then
call Cdv("Double free: object of type Item","when calling error in ScmdDataTypes, line 807")
else
set ix[Sx]=L7v
set Sx=Sx+1
set ox[L7v]=0
endif
set EM=EM-1
endfunction
function L9v takes integer mvv returns nothing
call Htv(mvv)
endfunction
function mev takes integer mxv,string mov returns nothing
set ZM[EM]=mov
set EM=EM+1
call L9v(mxv)
call L6v(mxv,"when calling dealloc_Item in ScmdDataTypes, line 807")
set EM=EM-1
endfunction
function mrv takes integer miv,string mav returns nothing
set ZM[EM]=mav
set EM=EM+1
if ox[miv]==0 then
call Cdv("Double free: object of type RuntimeFunction","when calling error in ScmdDataTypes, line 1318")
else
set ix[Sx]=miv
set Sx=Sx+1
set ox[miv]=0
endif
set EM=EM-1
endfunction
function mnv takes integer mVv,string mEv returns nothing
set ZM[EM]=mEv
set EM=EM+1
if ox[mVv]==0 then
call Cdv("Double free: object of type Object","when calling error in ScmdDataTypes, line 57")
else
set ix[Sx]=mVv
set Sx=Sx+1
set ox[mVv]=0
endif
set EM=EM-1
endfunction
function mXv takes integer mOv,string mRv returns nothing
set ZM[EM]=mRv
set EM=EM+1
call mnv(mOv,"when calling dealloc_Object in ScmdDataTypes, line 57")
set EM=EM-1
endfunction
function mIv takes integer PBt returns nothing
endfunction
function mAv takes integer mNv,string mbv returns nothing
set ZM[EM]=mbv
set EM=EM+1
if ox[mNv]==0 then
call Cdv("Double free: object of type Null","when calling error in ScmdDataTypes, line 85")
else
set ix[Sx]=mNv
set Sx=Sx+1
set ox[mNv]=0
endif
set EM=EM-1
endfunction
function mBv takes integer mcv,string mCv returns nothing
set ZM[EM]=mCv
set EM=EM+1
call mIv(mcv)
call mAv(mcv,"when calling dealloc_Null in ScmdDataTypes, line 85")
set EM=EM-1
endfunction
function mdv takes trigger mDv returns nothing
call DisableTrigger(mDv)
endfunction
function mfv takes integer mFv,integer mgv,string mGv returns nothing
local integer mhv
local string mHv
local integer mjv
local integer mJv
local integer mkv
local string mKv
local integer mlv
local integer mLv
local integer mmv
local integer mMv
local integer mpv
local integer mPv
local integer mqv
local integer mQv
local integer msv
local integer mSv
if mFv==0 then
set ZM[EM]=mGv
set EM=EM+1
call mfv($F,mgv,"when calling GenericSharedPointer_onDestroy in ScmdDataTypes, line 160")
call K8v(mgv,"when calling dealloc_GenericSharedPointer in ScmdDataTypes, line 160")
set EM=EM-1
elseif mFv==1 then
set ZM[EM]=mGv
set EM=EM+1
call mfv($C,mgv,"when calling RuntimeFunction_onDestroy in ScmdDataTypes, line 1366")
call mrv(mgv,"when calling dealloc_RuntimeFunction in ScmdDataTypes, line 1366")
set EM=EM-1
elseif mFv==2 then
set ZM[EM]=mGv
set EM=EM+1
call mfv(7,sK[mgv],"when calling dispatch_Arguments_destroyArguments in ScmdDataTypes, line 1584")
if rK[mgv]!=0 then
call mfv(20,rK[mgv],"when calling dispatch_GenericSharedPointer_destroyGenericSharedPointer in ScmdDataTypes, line 1586")
endif
set EM=EM-1
elseif mFv==3 then
set ZM[EM]=mGv
set EM=EM+1
call mfv(8,mgv,"when calling Context_onDestroy in ScmdDataTypes, line 1132")
call lev(mgv,"when calling dealloc_Context in ScmdDataTypes, line 1132")
set EM=EM-1
elseif mFv==4 then
set ZM[EM]=mGv
set EM=EM+1
if Rx[mgv]==0 then
if mgv==0 then
call Cdv("Nullpointer exception when calling Context.Context","when calling error in ScmdDataTypes, line 1117")
else
call Cdv("Called Context.Context on invalid object.","when calling error in ScmdDataTypes, line 1117")
endif
endif
call mfv(3,mgv,"when calling destroyContext in ScmdDataTypes, line 1117")
set EM=EM-1
elseif mFv==5 then
set ZM[EM]=mGv
set EM=EM+1
call mfv(16,mgv,"when calling Arguments_onDestroy in ScmdDataTypes, line 1247")
call LBv(mgv,"when calling dealloc_Arguments in ScmdDataTypes, line 1247")
set EM=EM-1
elseif mFv==6 then
set ZM[EM]=mGv
set EM=EM+1
if ox[mgv]==0 then
if mgv==0 then
call Cdv("Nullpointer exception when calling Object.Object","when calling error in ScmdDataTypes, line 57")
else
call Cdv("Called Object.Object on invalid object.","when calling error in ScmdDataTypes, line 57")
endif
endif
if ox[mgv]<=$EFC then
if ox[mgv]<=$EF3 then
if ox[mgv]<=$EEF then
if ox[mgv]<=$EED then
if ox[mgv]<=$EEC then
if ox[mgv]<=$EEB then
call mXv(mgv,"when calling destroyObject in ScmdDataTypes, line 57")
else
call kuv(mgv,"when calling destroyBuiltinFunction in ScmdDataTypes, line 57")
endif
else
call Jwv(mgv,"when calling destroyBuiltinSpecialForm in ScmdDataTypes, line 57")
endif
elseif ox[mgv]<=$EEE then
call k0v(mgv,"when calling destroyFunction in ScmdDataTypes, line 57")
else
call mfv(1,mgv,"when calling destroyRuntimeFunction in ScmdDataTypes, line 57")
endif
elseif ox[mgv]<=$EF1 then
if ox[mgv]<=$EF0 then
call Ltv(mgv,"when calling destroyCameraSetup in ScmdDataTypes, line 57")
else
call L3v(mgv,"when calling destroyException in ScmdDataTypes, line 57")
endif
elseif ox[mgv]<=$EF2 then
call Hkv(mgv,"when calling destroyClassCastException in ScmdDataTypes, line 57")
else
call mfv($B,mgv,"when calling destroyExpression in ScmdDataTypes, line 57")
endif
elseif ox[mgv]<=$EF8 then
if ox[mgv]<=$EF6 then
if ox[mgv]<=$EF5 then
if ox[mgv]<=$EF4 then
call kGv(mgv,"when calling destroyGroup in ScmdDataTypes, line 57")
else
call Lev(mgv,"when calling destroyHandle in ScmdDataTypes, line 57")
endif
else
call hgv(mgv,"when calling destroyAgent in ScmdDataTypes, line 57")
endif
elseif ox[mgv]<=$EF7 then
call HWv(mgv,"when calling destroyWidget in ScmdDataTypes, line 57")
else
call Kmv(mgv,"when calling destroyDestructable in ScmdDataTypes, line 57")
endif
elseif ox[mgv]<=$EFA then
if ox[mgv]<=$EF9 then
call mev(mgv,"when calling destroyItem in ScmdDataTypes, line 57")
else
call knv(mgv,"when calling destroyUnit in ScmdDataTypes, line 57")
endif
elseif ox[mgv]<=$EFB then
call mXv(mgv,"when calling destroyObject in ScmdDataTypes, line 57")
else
call Lmv(mgv,"when calling destroyLiteralBoolean in ScmdDataTypes, line 57")
endif
elseif ox[mgv]<=$F05 then
if ox[mgv]<=$F01 then
if ox[mgv]<=$EFF then
if ox[mgv]<=$EFE then
if ox[mgv]<=$EFD then
call LEv(mgv,"when calling destroyLiteralInteger in ScmdDataTypes, line 57")
else
call J9v(mgv,"when calling destroyLiteralReal in ScmdDataTypes, line 57")
endif
else
call Lzv(mgv,"when calling destroyLiteralString in ScmdDataTypes, line 57")
endif
elseif ox[mgv]<=$F00 then
call mBv(mgv,"when calling destroyNull in ScmdDataTypes, line 57")
else
call mXv(mgv,"when calling destroyObject in ScmdDataTypes, line 57")
endif
elseif ox[mgv]<=$F03 then
if ox[mgv]<=$F02 then
call LFv(mgv,"when calling destroyReal in ScmdDataTypes, line 57")
else
call hMv(mgv,"when calling destroyInteger in ScmdDataTypes, line 57")
endif
elseif ox[mgv]<=$F04 then
call lOv(mgv,"when calling destroyRect in ScmdDataTypes, line 57")
else
call K5v(mgv,"when calling destroyRegion in ScmdDataTypes, line 57")
endif
elseif ox[mgv]<=$F0A then
if ox[mgv]<=$F08 then
if ox[mgv]<=$F07 then
if ox[mgv]<=$F06 then
call kLv(mgv,"when calling destroySound in ScmdDataTypes, line 57")
else
call Kuv(mgv,"when calling destroySpecialEffect in ScmdDataTypes, line 57")
endif
else
call HQv(mgv,"when calling destroyString in ScmdDataTypes, line 57")
endif
elseif ox[mgv]<=$F09 then
call jrv(mgv,"when calling destroyBoolean in ScmdDataTypes, line 57")
else
call lwv(mgv,"when calling destroySymbol in ScmdDataTypes, line 57")
endif
elseif ox[mgv]<=$F0C then
if ox[mgv]<=$F0B then
call mfv(18,mgv,"when calling destroyTrigger in ScmdDataTypes, line 57")
else
call l5v(mgv,"when calling destroyUndefined in ScmdDataTypes, line 57")
endif
elseif ox[mgv]<=$F0D then
call mfv(19,mgv,"when calling destroyVector in ScmdDataTypes, line 57")
else
call kNv(mgv,"when calling destroyWeatherEffect in ScmdDataTypes, line 57")
endif
set EM=EM-1
elseif mFv==7 then
set ZM[EM]=mGv
set EM=EM+1
if yx[mgv]==0 then
if mgv==0 then
call Cdv("Nullpointer exception when calling Arguments.Arguments","when calling error in ScmdDataTypes, line 1243")
else
call Cdv("Called Arguments.Arguments on invalid object.","when calling error in ScmdDataTypes, line 1243")
endif
endif
call mfv(5,mgv,"when calling destroyArguments in ScmdDataTypes, line 1243")
set EM=EM-1
elseif mFv==8 then
set ZM[EM]=mGv
set EM=EM+1
set mhv=jjv(NJ[mgv],"when calling iterator in ScmdDataTypes, line 1133")
loop
exitwhen not Jgv(mhv,"when calling hasNext in ScmdDataTypes, line 1133")
set mHv=hxv(jTv(mhv,"when calling next in ScmdDataTypes, line 1133"),"when calling stringFromIndex in ScmdDataTypes, line 1133")
call mfv(20,f3v(NJ[mgv],KCv(mHv,"when calling stringToIndex in ScmdDataTypes, line 1134"),"when calling get in ScmdDataTypes, line 1134"),"when calling dispatch_GenericSharedPointer_destroyGenericSharedPointer in ScmdDataTypes, line 1134")
endloop
call Jqv(mhv,"when calling close in ScmdDataTypes, line 1133")
call lQv(NJ[mgv],"when calling dispatch_IterableMap_destroyIterableMap in ScmdDataTypes, line 1135")
set EM=EM-1
elseif mFv==9 then
set ZM[EM]=mGv
set EM=EM+1
set mjv=jdv(UK[mgv],"when calling iterator in ScmdDataTypes, line 1113")
loop
exitwhen not Jgv(mjv,"when calling hasNext in ScmdDataTypes, line 1113")
set mJv=jTv(mjv,"when calling next in ScmdDataTypes, line 1113")
call mfv(20,mJv,"when calling dispatch_GenericSharedPointer_destroyGenericSharedPointer in ScmdDataTypes, line 1114")
endloop
call Jqv(mjv,"when calling close in ScmdDataTypes, line 1113")
call JEv(UK[mgv],"when calling dispatch_HashList_destroyHashList in ScmdDataTypes, line 1115")
set EM=EM-1
elseif mFv==$A then
set ZM[EM]=mGv
set EM=EM+1
call mfv($F,mgv,"when calling GenericSharedPointer_onDestroy in ScmdDataTypes, line 166")
set EM=EM-1
elseif mFv==$B then
set ZM[EM]=mGv
set EM=EM+1
call mfv(2,mgv,"when calling Expression_onDestroy in ScmdDataTypes, line 1583")
call J1v(mgv,"when calling dealloc_Expression in ScmdDataTypes, line 1583")
set EM=EM-1
elseif mFv==$C then
set ZM[EM]=mGv
set EM=EM+1
set mkv=jjv(dK[mgv],"when calling iterator in ScmdDataTypes, line 1367")
loop
exitwhen not Jgv(mkv,"when calling hasNext in ScmdDataTypes, line 1367")
set mKv=hxv(jTv(mkv,"when calling next in ScmdDataTypes, line 1367"),"when calling stringFromIndex in ScmdDataTypes, line 1367")
call mfv(20,f3v(dK[mgv],KCv(mKv,"when calling stringToIndex in ScmdDataTypes, line 1368"),"when calling get in ScmdDataTypes, line 1368"),"when calling dispatch_GenericSharedPointer_destroyGenericSharedPointer in ScmdDataTypes, line 1368")
endloop
call Jqv(mkv,"when calling close in ScmdDataTypes, line 1367")
call lQv(dK[mgv],"when calling dispatch_IterableMap_destroyIterableMap in ScmdDataTypes, line 1369")
call JEv(aK[mgv],"when calling dispatch_HashList_destroyHashList in ScmdDataTypes, line 1370")
call mfv(20,nK[mgv],"when calling dispatch_GenericSharedPointer_destroyGenericSharedPointer in ScmdDataTypes, line 1371")
call jnv(mgv)
set EM=EM-1
elseif mFv==$D then
set ZM[EM]=mGv
set EM=EM+1
call mdv(jK[mgv])
call lYv(jK[mgv],vK[mgv])
set mlv=0
set mLv=c8v(yd,xK[mgv],-1)-1
loop
exitwhen mlv>mLv
call lYv(jK[mgv],KWv(yd,xK[mgv],mlv))
set mlv=mlv+1
endloop
call HLv(yd,xK[mgv])
call kWv(jK[mgv],mK[mgv])
call Hzv(jK[mgv])
call l_v(jK[mgv])
call LRv(jK[mgv])
set mmv=jdv(QK[mgv],"when calling iterator in ScmdDataTypes, line 990")
loop
exitwhen not Jgv(mmv,"when calling hasNext in ScmdDataTypes, line 990")
set mMv=jTv(mmv,"when calling next in ScmdDataTypes, line 990")
call mfv(6,mMv,"when calling dispatch_Object_destroyObject in ScmdDataTypes, line 991")
endloop
call Jqv(mmv,"when calling close in ScmdDataTypes, line 990")
call JEv(QK[mgv],"when calling dispatch_HashList_destroyHashList in ScmdDataTypes, line 992")
set mpv=0
set mPv=c8v(bd,xK[mgv],-1)-1
loop
exitwhen mpv>mPv
call mfv(17,c8v(bd,xK[mgv],mpv),"when calling dispatch_SharedPointer_destroySharedPointer in ScmdDataTypes, line 994")
set mpv=mpv+1
endloop
call HLv(bd,xK[mgv])
set mqv=0
set mQv=c8v(pd,xK[mgv],-1)-1
loop
exitwhen mqv>mQv
call mfv(17,c8v(pd,xK[mgv],mqv),"when calling dispatch_SharedPointer_destroySharedPointer in ScmdDataTypes, line 997")
set mqv=mqv+1
endloop
call HLv(pd,xK[mgv])
call mfv(4,fwv(ed,xK[mgv],"when calling loadInt in ScmdDataTypes, line 999"),"when calling dispatch_Context_destroyContext in ScmdDataTypes, line 999")
set EM=EM-1
elseif mFv==$E then
set ZM[EM]=mGv
set EM=EM+1
call mfv($A,mgv,"when calling SharedPointer_onDestroy in ScmdDataTypes, line 166")
call LAv(mgv,"when calling dealloc_SharedPointer in ScmdDataTypes, line 166")
set EM=EM-1
elseif mFv==$F then
set ZM[EM]=mGv
set EM=EM+1
call JZv(iK[mgv],"when calling decrease in ScmdDataTypes, line 161")
if KGv(iK[mgv],"when calling getUseCount in ScmdDataTypes, line 162")==0 then
call mfv(6,tK[mgv],"when calling dispatch_Object_destroyObject in ScmdDataTypes, line 163")
call H6v(iK[mgv],"when calling dispatch_ReferenceCounter_destroyReferenceCounter in ScmdDataTypes, line 164")
endif
set EM=EM-1
elseif mFv==16 then
set ZM[EM]=mGv
set EM=EM+1
set msv=jdv(gJ[mgv],"when calling iterator in ScmdDataTypes, line 1248")
loop
exitwhen not Jgv(msv,"when calling hasNext in ScmdDataTypes, line 1248")
set mSv=jTv(msv,"when calling next in ScmdDataTypes, line 1248")
call mfv(20,mSv,"when calling dispatch_GenericSharedPointer_destroyGenericSharedPointer in ScmdDataTypes, line 1249")
endloop
call Jqv(msv,"when calling close in ScmdDataTypes, line 1248")
call JEv(gJ[mgv],"when calling dispatch_HashList_destroyHashList in ScmdDataTypes, line 1250")
set EM=EM-1
elseif mFv==17 then
set ZM[EM]=mGv
set EM=EM+1
if gx[mgv]==0 then
if mgv==0 then
call Cdv("Nullpointer exception when calling SharedPointer.SharedPointer","when calling error in ScmdDataTypes, line 166")
else
call Cdv("Called SharedPointer.SharedPointer on invalid object.","when calling error in ScmdDataTypes, line 166")
endif
endif
call mfv($E,mgv,"when calling destroySharedPointer in ScmdDataTypes, line 166")
set EM=EM-1
elseif mFv==18 then
set ZM[EM]=mGv
set EM=EM+1
call mfv($D,mgv,"when calling Trigger_onDestroy in ScmdDataTypes, line 980")
call Lhv(mgv,"when calling dealloc_Trigger in ScmdDataTypes, line 980")
set EM=EM-1
elseif mFv==19 then
set ZM[EM]=mGv
set EM=EM+1
call mfv(9,mgv,"when calling Vector_onDestroy in ScmdDataTypes, line 1112")
call hqv(mgv,"when calling dealloc_Vector in ScmdDataTypes, line 1112")
set EM=EM-1
elseif mFv==20 then
set ZM[EM]=mGv
set EM=EM+1
if gx[mgv]==0 then
if mgv==0 then
call Cdv("Nullpointer exception when calling GenericSharedPointer.GenericSharedPointer","when calling error in ScmdDataTypes, line 100")
else
call Cdv("Called GenericSharedPointer.GenericSharedPointer on invalid object.","when calling error in ScmdDataTypes, line 100")
endif
endif
call mfv(0,mgv,"when calling destroyGenericSharedPointer in ScmdDataTypes, line 100")
set EM=EM-1
endif
endfunction
function mtv takes integer mTv,string muv returns nothing
set ZM[EM]=muv
set EM=EM+1
if ox[mTv]==0 then
if mTv==0 then
call Cdv("Nullpointer exception when calling Expression.Expression","when calling error in ScmdDataTypes, line 1573")
else
call Cdv("Called Expression.Expression on invalid object.","when calling error in ScmdDataTypes, line 1573")
endif
endif
call mfv($B,mTv,"when calling destroyExpression in ScmdDataTypes, line 1573")
set EM=EM-1
endfunction
function mUv takes integer mwv returns integer
return uK[mwv]
endfunction
function mWv takes integer myv,string mYv returns integer
local integer mzv
set ZM[EM]=mYv
set EM=EM+1
if ox[myv]==0 then
if myv==0 then
call Cdv("Nullpointer exception when calling Exception.getStackTrace","when calling error in ScmdDataTypes, line 207")
else
call Cdv("Called Exception.getStackTrace on invalid object.","when calling error in ScmdDataTypes, line 207")
endif
endif
set mzv=mUv(myv)
set EM=EM-1
return mzv
endfunction
function mZv takes integer m_v returns integer
return tK[m_v]
endfunction
function m0v takes integer m1v,string m2v returns integer
local integer m3v
set ZM[EM]=m2v
set EM=EM+1
if gx[m1v]==0 then
if m1v==0 then
call Cdv("Nullpointer exception when calling GenericSharedPointer.get","when calling error in ScmdDataTypes, line 154")
else
call Cdv("Called GenericSharedPointer.get on invalid object.","when calling error in ScmdDataTypes, line 154")
endif
endif
set m3v=mZv(m1v)
set EM=EM-1
return m3v
endfunction
function m4v takes integer m5v,unit m6v returns nothing
set AJ[m5v]=m6v
endfunction
function m7v takes integer m8v,unit m9v,string Mvv returns nothing
set ZM[EM]=Mvv
set EM=EM+1
if Rx[m8v]==0 then
if m8v==0 then
call Cdv("Nullpointer exception when calling Context.setEnumUnit","when calling error in ScmdDataTypes, line 1160")
else
call Cdv("Called Context.setEnumUnit on invalid object.","when calling error in ScmdDataTypes, line 1160")
endif
endif
call m4v(m8v,m9v)
set EM=EM-1
endfunction
function Mev takes integer Mxv returns unit
return AJ[Mxv]
endfunction
function Mov takes integer Mrv,string Miv returns unit
local unit Mav
set ZM[EM]=Miv
set EM=EM+1
if Rx[Mrv]==0 then
if Mrv==0 then
call Cdv("Nullpointer exception when calling Context.getEnumUnit","when calling error in ScmdDataTypes, line 1163")
else
call Cdv("Called Context.getEnumUnit on invalid object.","when calling error in ScmdDataTypes, line 1163")
endif
endif
set Mav=Mev(Mrv)
set EM=EM-1
set Ifv=Mav
set Mav=null
return Ifv
endfunction
function Mnv takes integer MVv returns nothing
set SK[MVv]=SK[MVv]+1
endfunction
function MEv takes integer MXv,string MOv returns nothing
set ZM[EM]=MOv
set EM=EM+1
if jx[MXv]==0 then
if MXv==0 then
call Cdv("Nullpointer exception when calling ReferenceCounter.increase","when calling error in ScmdDataTypes, line 106")
else
call Cdv("Called ReferenceCounter.increase on invalid object.","when calling error in ScmdDataTypes, line 106")
endif
endif
call Mnv(MXv)
set EM=EM-1
endfunction
function MRv takes integer lXt returns nothing
endfunction
function MIv takes integer MAv returns nothing
call MRv(MAv)
endfunction
function MNv takes string Mbv returns integer
local integer MBv
set ZM[EM]=Mbv
set EM=EM+1
if Yx==0 then
if Gx<$8000 then
set Gx=Gx+1
set MBv=Gx
set gx[MBv]=$8E6
else
call Cdv("Out of memory: Could not create GenericSharedPointer.","when calling error in ScmdDataTypes, line 100")
set MBv=0
endif
else
set Yx=Yx-1
set MBv=Tx[Yx]
set gx[MBv]=$8E6
endif
set EM=EM-1
return MBv
endfunction
function Mcv takes string MCv returns integer
local integer Mdv
set ZM[EM]=MCv
set EM=EM+1
set Mdv=MNv("when calling alloc_GenericSharedPointer in ScmdDataTypes, line 120")
call MIv(Mdv)
set EM=EM-1
return Mdv
endfunction
function MDv takes integer Mfv,string MFv returns integer
local integer Mgv
set ZM[EM]=MFv
set EM=EM+1
set Mgv=Mcv("when calling new_GenericSharedPointer in ScmdDataTypes, line 131")
set tK[Mgv]=tK[Mfv]
set iK[Mgv]=iK[Mfv]
call MEv(iK[Mfv],"when calling increase in ScmdDataTypes, line 134")
set EM=EM-1
return Mgv
endfunction
function MGv takes integer Mhv,string MHv returns integer
local integer Mjv
set ZM[EM]=MHv
set EM=EM+1
set Mjv=MDv(Mhv,"when calling clone in ScmdDataTypes, line 172")
set EM=EM-1
return Mjv
endfunction
function MJv takes integer Mkv,string MKv returns integer
local integer Mlv
set ZM[EM]=MKv
set EM=EM+1
if gx[Mkv]==0 then
if Mkv==0 then
call Cdv("Nullpointer exception when calling SharedPointer.clone","when calling error in ScmdDataTypes, line 171")
else
call Cdv("Called SharedPointer.clone on invalid object.","when calling error in ScmdDataTypes, line 171")
endif
endif
set Mlv=MGv(Mkv,"when calling clone in ScmdDataTypes, line 171")
set EM=EM-1
return Mlv
endfunction
function MLv takes string Mmv returns integer
local integer MMv
set ZM[EM]=Mmv
set EM=EM+1
set MMv=MJv(Cn,"when calling clone in ScmdDataTypes, line 128")
set EM=EM-1
return MMv
endfunction
function Mpv takes integer MPv returns string
return GK[MPv]
endfunction
function Mqv takes integer MQv,string Msv returns string
local string MSv
set ZM[EM]=Msv
set EM=EM+1
if ox[MQv]==0 then
if MQv==0 then
call Cdv("Nullpointer exception when calling String.getInner","when calling error in ScmdDataTypes, line 349")
else
call Cdv("Called String.getInner on invalid object.","when calling error in ScmdDataTypes, line 349")
endif
endif
if ox[MQv]<=$F03 then
if ox[MQv]<=$EFF then
set MSv=Mpv(MQv)
else
set MSv=Mpv(MQv)
endif
else
set MSv=Mpv(MQv)
endif
set EM=EM-1
return MSv
endfunction
function Mtv takes hashtable MTv,integer Muv,integer MUv returns nothing
call RemoveSavedInteger(MTv,Muv,MUv)
endfunction
function Mwv takes unit MWv,string Myv,boolean MYv returns nothing
local integer Mzv=C0v(MWv)
local integer MZv=Ccv(Myv)
local integer M_v=c8v(Gn,Mzv,MZv)
local integer M0v
local integer M1v
if(MYv and M_v==0)or((not MYv)and M_v!=0)then
call AddUnitAnimationProperties(MWv,Myv,MYv)
if MYv then
set M0v=c8v(Va,Mzv,Tn)+1
call k3v(Va,Mzv,Tn+M0v*Yn,Myv)
call Cxv(Gn,Mzv,MZv,M0v)
call Cxv(Va,Mzv,Tn,M0v)
else
set M1v=c8v(Va,Mzv,Tn)
call k3v(Va,Mzv,Tn+M_v*Yn,G0v(Va,Mzv,Tn+M1v*Yn))
call Mtv(Gn,Mzv,MZv)
call Cxv(Va,Mzv,Tn,M1v-1)
endif
endif
endfunction
function M2v takes integer M3v,integer M4v,string M5v returns integer
local integer M6v
set ZM[EM]=M5v
set EM=EM+1
set M6v=m0v(jqv(gJ[M3v],M4v,"when calling get in ScmdDataTypes, line 1268"),"when calling get in ScmdDataTypes, line 1268")
set EM=EM-1
return M6v
endfunction
function M7v takes integer M8v,integer M9v,string pvv returns integer
local integer pev
set ZM[EM]=pvv
set EM=EM+1
if yx[M8v]==0 then
if M8v==0 then
call Cdv("Nullpointer exception when calling Arguments.get","when calling error in ScmdDataTypes, line 1267")
else
call Cdv("Called Arguments.get on invalid object.","when calling error in ScmdDataTypes, line 1267")
endif
endif
set pev=M2v(M8v,M9v,"when calling get in ScmdDataTypes, line 1267")
set EM=EM-1
return pev
endfunction
function pxv takes integer EFi,integer pov,integer prv,string piv returns integer
local integer pav
set ZM[EM]=piv
set EM=EM+1
call Mwv(Mov(pov,"when calling getEnumUnit in ScmdUnitBuiltins, line 807"),Mqv(M7v(prv,0,"when calling get in ScmdUnitBuiltins, line 807"),"when calling getInner in ScmdUnitBuiltins, line 807"),true)
set pav=MLv("when calling nullptr in ScmdUnitBuiltins, line 808")
set EM=EM-1
return pav
endfunction
function pnv takes integer pVv returns unit
return JJ[pVv]
endfunction
function pEv takes integer pXv,string pOv returns unit
local unit pRv
set ZM[EM]=pOv
set EM=EM+1
if Rx[pXv]==0 then
if pXv==0 then
call Cdv("Nullpointer exception when calling Context.getSpellTargetUnit","when calling error in ScmdDataTypes, line 1181")
else
call Cdv("Called Context.getSpellTargetUnit on invalid object.","when calling error in ScmdDataTypes, line 1181")
endif
endif
set pRv=pnv(pXv)
set EM=EM-1
set IGv=pRv
set pRv=null
return IGv
endfunction
function pIv takes string pAv returns integer
local integer pNv
set ZM[EM]=pAv
set EM=EM+1
if Sx==0 then
if cx<$8000 then
set cx=cx+1
set pNv=cx
set ox[pNv]=$EFA
else
call Cdv("Out of memory: Could not create Unit.","when calling error in ScmdDataTypes, line 782")
set pNv=0
endif
else
set Sx=Sx-1
set pNv=ix[Sx]
set ox[pNv]=$EFA
endif
set EM=EM-1
return pNv
endfunction
function pbv takes integer r7i returns nothing
endfunction
function pBv takes integer xCt returns nothing
endfunction
function pcv takes integer pCv,handle pdv returns nothing
call pBv(pCv)
set oK[pCv]=pdv
endfunction
function pDv takes integer F8i returns nothing
endfunction
function pfv takes integer pFv,widget pgv returns nothing
call pcv(pFv,pgv)
call pDv(pFv)
set PK[pFv]=pgv
endfunction
function pGv takes integer phv,unit pHv returns nothing
call pfv(phv,pHv)
call pbv(phv)
set ZK[phv]=pHv
endfunction
function pjv takes unit pJv,string pkv returns integer
local integer pKv
set ZM[EM]=pkv
set EM=EM+1
set pKv=pIv("when calling alloc_Unit in ScmdDataTypes, line 791")
call pGv(pKv,pJv)
set EM=EM-1
return pKv
endfunction
function plv takes string pLv returns integer
local integer pmv
set ZM[EM]=pLv
set EM=EM+1
if Yx==0 then
if Gx<$8000 then
set Gx=Gx+1
set pmv=Gx
set gx[pmv]=$8E7
else
call Cdv("Out of memory: Could not create SharedPointer.","when calling error in ScmdDataTypes, line 166")
set pmv=0
endif
else
set Yx=Yx-1
set pmv=Tx[Yx]
set gx[pmv]=$8E7
endif
set EM=EM-1
return pmv
endfunction
function pMv takes integer i1t returns nothing
endfunction
function ppv takes integer EXt returns nothing
endfunction
function pPv takes integer pqv returns nothing
call ppv(pqv)
endfunction
function pQv takes string psv returns integer
local integer pSv
set ZM[EM]=psv
set EM=EM+1
if Fx==0 then
if kx<$8000 then
set kx=kx+1
set pSv=kx
set jx[pSv]=4215
else
call Cdv("Out of memory: Could not create ReferenceCounter.","when calling error in ScmdDataTypes, line 102")
set pSv=0
endif
else
set Fx=Fx-1
set pSv=hx[Fx]
set jx[pSv]=4215
endif
set EM=EM-1
return pSv
endfunction
function ptv takes string pTv returns integer
local integer puv
set ZM[EM]=pTv
set EM=EM+1
set puv=pQv("when calling alloc_ReferenceCounter in ScmdDataTypes, line 102")
call pPv(puv)
set EM=EM-1
return puv
endfunction
function pUv takes integer pwv,integer pWv,string pyv returns nothing
set ZM[EM]=pyv
set EM=EM+1
call MRv(pwv)
set tK[pwv]=pWv
set iK[pwv]=ptv("when calling new_ReferenceCounter in ScmdDataTypes, line 124")
call MEv(iK[pwv],"when calling increase in ScmdDataTypes, line 125")
set EM=EM-1
endfunction
function pYv takes integer pzv,integer pZv,string p_v returns nothing
set ZM[EM]=p_v
set EM=EM+1
call pUv(pzv,pZv,"when calling construct_GenericSharedPointer2 in ScmdDataTypes, line 168")
call pMv(pzv)
set EM=EM-1
endfunction
function p0v takes integer p1v,string p2v returns integer
local integer p3v
set ZM[EM]=p2v
set EM=EM+1
set p3v=plv("when calling alloc_SharedPointer in ScmdDataTypes, line 168")
call pYv(p3v,p1v,"when calling construct_SharedPointer in ScmdDataTypes, line 168")
set EM=EM-1
return p3v
endfunction
function p4v takes integer ETt,integer p5v,integer UTt,string p6v returns integer
local integer p7v
set ZM[EM]=p6v
set EM=EM+1
set p7v=p0v(pjv(pEv(p5v,"when calling getSpellTargetUnit in SLangTriggerFunctions, line 100"),"when calling new_Unit in SLangTriggerFunctions, line 100"),"when calling new_SharedPointer in SLangTriggerFunctions, line 100")
set EM=EM-1
return p7v
endfunction
function p8v takes effect p9v,real Pvv returns nothing
call BlzSetSpecialEffectHeight(p9v,Pvv)
endfunction
function Pev takes integer Pxv returns effect
return TK[Pxv]
endfunction
function Pov takes integer Prv,string Piv returns effect
local effect Pav
set ZM[EM]=Piv
set EM=EM+1
if ox[Prv]==0 then
if Prv==0 then
call Cdv("Nullpointer exception when calling SpecialEffect.getInner","when calling error in ScmdDataTypes, line 619")
else
call Cdv("Called SpecialEffect.getInner on invalid object.","when calling error in ScmdDataTypes, line 619")
endif
endif
set Pav=Pev(Prv)
set EM=EM-1
set Ilv=Pav
set Pav=null
return Ilv
endfunction
function Pnv takes integer PVv returns real
return yK[PVv]
endfunction
function PEv takes integer PXv,string POv returns real
local real PRv
set ZM[EM]=POv
set EM=EM+1
if ox[PXv]==0 then
if PXv==0 then
call Cdv("Nullpointer exception when calling Real.realValue","when calling error in ScmdDataTypes, line 473")
else
call Cdv("Called Real.realValue on invalid object.","when calling error in ScmdDataTypes, line 473")
endif
endif
if ox[PXv]<=$EFE then
set PRv=Pnv(PXv)
else
set PRv=Pnv(PXv)
endif
set EM=EM-1
return PRv
endfunction
function PIv takes integer Eft,integer Zft,integer PAv,string PNv returns integer
local integer Pbv
set ZM[EM]=PNv
set EM=EM+1
call p8v(Pov(M7v(PAv,0,"when calling get in SLangSpecialEffectFunctions, line 36"),"when calling getInner in SLangSpecialEffectFunctions, line 36"),PEv(M7v(PAv,1,"when calling get in SLangSpecialEffectFunctions, line 36"),"when calling realValue in SLangSpecialEffectFunctions, line 36"))
set Pbv=MLv("when calling nullptr in SLangSpecialEffectFunctions, line 37")
set EM=EM-1
return Pbv
endfunction
function PBv takes integer Pcv returns unit
return ZK[Pcv]
endfunction
function PCv takes integer Pdv,string PDv returns unit
local unit Pfv
set ZM[EM]=PDv
set EM=EM+1
if ox[Pdv]==0 then
if Pdv==0 then
call Cdv("Nullpointer exception when calling Unit.getInner","when calling error in ScmdDataTypes, line 795")
else
call Cdv("Called Unit.getInner on invalid object.","when calling error in ScmdDataTypes, line 795")
endif
endif
set Pfv=PBv(Pdv)
set EM=EM-1
set Imv=Pfv
set Pfv=null
return Imv
endfunction
function PFv takes unit Pgv returns nothing
call RemoveUnit(Pgv)
endfunction
function PGv takes integer Egi,integer Zgi,integer Phv,string PHv returns integer
local integer Pjv
set ZM[EM]=PHv
set EM=EM+1
call PFv(PCv(M7v(Phv,0,"when calling get in ScmdUnitBuiltins, line 753"),"when calling getInner in ScmdUnitBuiltins, line 753"))
set Pjv=MLv("when calling nullptr in ScmdUnitBuiltins, line 754")
set EM=EM-1
return Pjv
endfunction
function PJv takes integer x4t returns nothing
endfunction
function Pkv takes integer PKv,string Plv returns nothing
call PJv(PKv)
set GK[PKv]=Plv
endfunction
function PLv takes string Pmv returns integer
local integer PMv
set ZM[EM]=Pmv
set EM=EM+1
if Sx==0 then
if cx<$8000 then
set cx=cx+1
set PMv=cx
set ox[PMv]=$F08
else
call Cdv("Out of memory: Could not create String.","when calling error in ScmdDataTypes, line 299")
set PMv=0
endif
else
set Sx=Sx-1
set PMv=ix[Sx]
set ox[PMv]=$F08
endif
set EM=EM-1
return PMv
endfunction
function Ppv takes string PPv,string Pqv returns integer
local integer PQv
set ZM[EM]=Pqv
set EM=EM+1
set PQv=PLv("when calling alloc_String in ScmdDataTypes, line 308")
call Pkv(PQv,PPv)
set EM=EM-1
return PQv
endfunction
function Psv takes string PSv,integer Ptv,integer PTv returns string
return SubString(PSv,Ptv,PTv)
endfunction
function Puv takes string PUv returns string
local integer Pwv=0
local integer PWv=GZv(PUv)
loop
exitwhen not(Pwv!=PWv and duv(PUv,Pwv)==" ")
set Pwv=Pwv+1
endloop
loop
exitwhen not(Pwv!=PWv and duv(PUv,PWv-1)==" ")
set PWv=PWv-1
endloop
return Psv(PUv,Pwv,PWv)
endfunction
function Pyv takes integer Ekt,integer Zkt,integer PYv,string Pzv returns integer
local integer PZv
set ZM[EM]=Pzv
set EM=EM+1
set PZv=p0v(Ppv(Puv(Mqv(M7v(PYv,0,"when calling get in ScmdCoreBuiltins, line 163"),"when calling getInner in ScmdCoreBuiltins, line 163")),"when calling new_String in ScmdCoreBuiltins, line 163"),"when calling new_SharedPointer in ScmdCoreBuiltins, line 163")
set EM=EM-1
return PZv
endfunction
function P_v takes integer P0v,string P1v returns integer
local integer P2v
set ZM[EM]=P1v
set EM=EM+1
if gx[P0v]==0 then
if P0v==0 then
call Cdv("Nullpointer exception when calling GenericSharedPointer.clone","when calling error in ScmdDataTypes, line 130")
else
call Cdv("Called GenericSharedPointer.clone on invalid object.","when calling error in ScmdDataTypes, line 130")
endif
endif
if gx[P0v]<=$8E6 then
set P2v=MDv(P0v,"when calling clone in ScmdDataTypes, line 130")
else
set P2v=MGv(P0v,"when calling clone in ScmdDataTypes, line 130")
endif
set EM=EM-1
return P2v
endfunction
function P3v takes integer P4v,integer P5v,string P6v returns nothing
local integer P7v
set ZM[EM]=P6v
set EM=EM+1
set P7v=c8v(pd,xK[P4v],-1)
call Cxv(pd,xK[P4v],-1,P7v+1)
call Cxv(pd,xK[P4v],P7v,P_v(P5v,"when calling clone in ScmdDataTypes, line 975"))
set EM=EM-1
endfunction
function P8v takes integer P9v,integer qvv,string qev returns nothing
set ZM[EM]=qev
set EM=EM+1
if ox[P9v]==0 then
if P9v==0 then
call Cdv("Nullpointer exception when calling Trigger.addAction","when calling error in ScmdDataTypes, line 972")
else
call Cdv("Called Trigger.addAction on invalid object.","when calling error in ScmdDataTypes, line 972")
endif
endif
call P3v(P9v,qvv,"when calling addAction in ScmdDataTypes, line 972")
set EM=EM-1
endfunction
function qxv takes integer DZt returns nothing
endfunction
function qov takes boolean qrv returns string
local string qiv
if qrv then
set qiv="true"
else
set qiv="false"
endif
return qiv
endfunction
function qav takes integer qnv,boolean qVv returns nothing
call Pkv(qnv,qov(qVv))
call qxv(qnv)
set hJ[qnv]=qVv
endfunction
function qEv takes string qXv returns integer
local integer qOv
set ZM[EM]=qXv
set EM=EM+1
if Sx==0 then
if cx<$8000 then
set cx=cx+1
set qOv=cx
set ox[qOv]=$F09
else
call Cdv("Out of memory: Could not create Boolean.","when calling error in ScmdDataTypes, line 352")
set qOv=0
endif
else
set Sx=Sx-1
set qOv=ix[Sx]
set ox[qOv]=$F09
endif
set EM=EM-1
return qOv
endfunction
function qRv takes boolean qIv,string qAv returns integer
local integer qNv
set ZM[EM]=qAv
set EM=EM+1
set qNv=qEv("when calling alloc_Boolean in ScmdDataTypes, line 361")
call qav(qNv,qIv)
set EM=EM-1
return qNv
endfunction
function qbv takes integer K8i,integer L8i,integer X8i,string qBv returns integer
local integer qcv
set ZM[EM]=qBv
set EM=EM+1
set qcv=p0v(qRv(IsFogMaskEnabled(),"when calling new_Boolean in ScmdFogOfWarBuiltins, line 14"),"when calling new_SharedPointer in ScmdFogOfWarBuiltins, line 14")
set EM=EM-1
return qcv
endfunction
function qCv takes integer KGi,integer qdv,integer XGi,string qDv returns integer
local integer qfv
set ZM[EM]=qDv
set EM=EM+1
set qfv=p0v(Ppv(GetHeroProperName(Mov(qdv,"when calling getEnumUnit in ScmdUnitBuiltins, line 731")),"when calling new_String in ScmdUnitBuiltins, line 731"),"when calling new_SharedPointer in ScmdUnitBuiltins, line 731")
set EM=EM-1
return qfv
endfunction
function qFv takes integer qgv returns trigger
return jK[qgv]
endfunction
function qGv takes integer qhv,string qHv returns trigger
local trigger qjv
set ZM[EM]=qHv
set EM=EM+1
if ox[qhv]==0 then
if qhv==0 then
call Cdv("Nullpointer exception when calling Trigger.getInner","when calling error in ScmdDataTypes, line 956")
else
call Cdv("Called Trigger.getInner on invalid object.","when calling error in ScmdDataTypes, line 956")
endif
endif
set qjv=qFv(qhv)
set EM=EM-1
set ILv=qjv
set qjv=null
return ILv
endfunction
function qJv takes trigger qkv,widget qKv returns event
return TriggerRegisterDeathEvent(qkv,qKv)
endfunction
function qlv takes integer qLv returns item
return bK[qLv]
endfunction
function qmv takes integer qMv returns destructable
return MJ[qMv]
endfunction
function qpv takes integer qPv returns widget
return PK[qPv]
endfunction
function qqv takes integer qQv,string qsv returns widget
local widget qSv
set ZM[EM]=qsv
set EM=EM+1
if ox[qQv]==0 then
if qQv==0 then
call Cdv("Nullpointer exception when calling Widget.getInner","when calling error in ScmdDataTypes, line 773")
else
call Cdv("Called Widget.getInner on invalid object.","when calling error in ScmdDataTypes, line 773")
endif
endif
if ox[qQv]<=$EF8 then
if ox[qQv]<=$EF7 then
set qSv=qpv(qQv)
else
set qSv=qmv(qQv)
endif
elseif ox[qQv]<=$EF9 then
set qSv=qlv(qQv)
else
set qSv=PBv(qQv)
endif
set EM=EM-1
set IMv=qSv
set qSv=null
return IMv
endfunction
function qtv takes integer KRt,integer LRt,integer qTv,string quv returns integer
local integer qUv
set ZM[EM]=quv
set EM=EM+1
call qJv(qGv(M7v(qTv,0,"when calling get in SLangTriggerFunctions, line 45"),"when calling getInner in SLangTriggerFunctions, line 45"),qqv(M7v(qTv,1,"when calling get in SLangTriggerFunctions, line 45"),"when calling getInner in SLangTriggerFunctions, line 45"))
set qUv=MLv("when calling nullptr in SLangTriggerFunctions, line 46")
set EM=EM-1
return qUv
endfunction
function qwv takes real qWv returns string
return R2S(qWv)
endfunction
function qyv takes integer qNt returns nothing
endfunction
function qYv takes integer qzv,real qZv returns nothing
call Pkv(qzv,qwv(qZv))
call qyv(qzv)
set yK[qzv]=qZv
endfunction
function q_v takes string q0v returns integer
local integer q1v
set ZM[EM]=q0v
set EM=EM+1
if Sx==0 then
if cx<$8000 then
set cx=cx+1
set q1v=cx
set ox[q1v]=$F02
else
call Cdv("Out of memory: Could not create Real.","when calling error in ScmdDataTypes, line 421")
set q1v=0
endif
else
set Sx=Sx-1
set q1v=ix[Sx]
set ox[q1v]=$F02
endif
set EM=EM-1
return q1v
endfunction
function q2v takes real q3v,string q4v returns integer
local integer q5v
set ZM[EM]=q4v
set EM=EM+1
set q5v=q_v("when calling alloc_Real in ScmdDataTypes, line 430")
call qYv(q5v,q3v)
set EM=EM-1
return q5v
endfunction
function q6v takes unit q7v returns boolean
return CYv(Va,C0v(q7v),qn)
endfunction
function q8v takes unit q9v returns real
return DFv(Va,C0v(q9v),qn)
endfunction
function Qvv takes integer Jci,integer Qev,integer Lci,string Qxv returns integer
local real Qov
local integer Qrv
set ZM[EM]=Qxv
set EM=EM+1
if q6v(Mov(Qev,"when calling getEnumUnit in ScmdUnitBuiltins, line 149"))then
set Qov=q8v(Mov(Qev,"when calling getEnumUnit in ScmdUnitBuiltins, line 149"))
else
set Qov=1.
endif
set Qrv=p0v(q2v(Qov,"when calling new_Real in ScmdUnitBuiltins, line 149"),"when calling new_SharedPointer in ScmdUnitBuiltins, line 149")
set EM=EM-1
return Qrv
endfunction
function Qiv takes unit Qav,string Qnv,widget QVv returns boolean
return IssueTargetOrder(Qav,Qnv,QVv)
endfunction
function QEv takes integer Khi,integer Lhi,integer QXv,string QOv returns integer
local integer QRv
set ZM[EM]=QOv
set EM=EM+1
set QRv=p0v(qRv(Qiv(PCv(M7v(QXv,0,"when calling get in ScmdUnitBuiltins, line 783"),"when calling getInner in ScmdUnitBuiltins, line 783"),Mqv(M7v(QXv,1,"when calling get in ScmdUnitBuiltins, line 783"),"when calling getInner in ScmdUnitBuiltins, line 783"),qqv(M7v(QXv,2,"when calling get in ScmdUnitBuiltins, line 783"),"when calling getInner in ScmdUnitBuiltins, line 783")),"when calling new_Boolean in ScmdUnitBuiltins, line 783"),"when calling new_SharedPointer in ScmdUnitBuiltins, line 783")
set EM=EM-1
return QRv
endfunction
function QIv takes integer QAv returns integer
return OK[QAv]
endfunction
function QNv takes integer Qbv,string QBv returns integer
local integer Qcv
set ZM[EM]=QBv
set EM=EM+1
if ox[Qbv]==0 then
if Qbv==0 then
call Cdv("Nullpointer exception when calling Integer.intValue","when calling error in ScmdDataTypes, line 528")
else
call Cdv("Called Integer.intValue on invalid object.","when calling error in ScmdDataTypes, line 528")
endif
endif
if ox[Qbv]<=$EFD then
set Qcv=QIv(Qbv)
else
set Qcv=QIv(Qbv)
endif
set EM=EM-1
return Qcv
endfunction
function QCv takes integer HFt,integer JFt,integer Qdv,string QDv returns integer
local integer Qfv
set ZM[EM]=QDv
set EM=EM+1
set Qfv=p0v(Ppv(Psv(Mqv(M7v(Qdv,0,"when calling get in ScmdCoreBuiltins, line 132"),"when calling getInner in ScmdCoreBuiltins, line 132"),QNv(M7v(Qdv,1,"when calling get in ScmdCoreBuiltins, line 132"),"when calling intValue in ScmdCoreBuiltins, line 132"),QNv(M7v(Qdv,2,"when calling get in ScmdCoreBuiltins, line 132"),"when calling intValue in ScmdCoreBuiltins, line 132")),"when calling new_String in ScmdCoreBuiltins, line 132"),"when calling new_SharedPointer in ScmdCoreBuiltins, line 132")
set EM=EM-1
return Qfv
endfunction
function QFv takes integer Qgv returns integer
return PJ[Qgv]
endfunction
function QGv takes integer Qhv,string QHv returns integer
local integer Qjv
set ZM[EM]=QHv
set EM=EM+1
if Rx[Qhv]==0 then
if Qhv==0 then
call Cdv("Nullpointer exception when calling Context.getPlayerId","when calling error in ScmdDataTypes, line 1157")
else
call Cdv("Called Context.getPlayerId on invalid object.","when calling error in ScmdDataTypes, line 1157")
endif
endif
set Qjv=QFv(Qhv)
set EM=EM-1
return Qjv
endfunction
function QJv takes unit Qkv returns real
return GetUnitX(Qkv)
endfunction
function QKv takes integer Qlv returns unit
return vf[Qlv]
endfunction
function QLv takes integer HWi,integer Qmv,integer KWi,string QMv returns integer
local integer Qpv
set ZM[EM]=QMv
set EM=EM+1
set Qpv=p0v(q2v(QJv(QKv(QGv(Qmv,"when calling getPlayerId in SotfrpGuiCoreUnit, line 78"))),"when calling new_Real in SotfrpGuiCoreUnit, line 78"),"when calling new_SharedPointer in SotfrpGuiCoreUnit, line 78")
set EM=EM-1
return Qpv
endfunction
function QPv takes integer Qqv,integer QQv returns boolean
return ox[QQv]==$EF9 and bK[Qqv]==bK[QQv]
endfunction
function Qsv takes integer QSv,integer Qtv returns boolean
local integer QTv=ox[Qtv]
return(QTv>=$EFC and QTv<=$EFF)or(QTv>=$F02 and QTv<=$F03)or(QTv>=$F08 and QTv<=$F09)and GK[QSv]==GK[Qtv]
endfunction
function Quv takes integer QUv,integer Qwv returns boolean
return Qsv(QUv,Qwv)
endfunction
function QWv takes integer Qyv,integer QYv returns boolean
return ox[QYv]==$EF8 and MJ[Qyv]==MJ[QYv]
endfunction
function Qzv takes integer TBt,integer YBt returns boolean
return false
endfunction
function QZv takes integer Q_v,integer Q0v returns boolean
local integer Q1v=ox[Q0v]
return Q1v>=$EF5 and Q1v<=$EFA and oK[Q_v]==oK[Q0v]
endfunction
function Q2v takes integer Q3v,integer Q4v returns boolean
return ox[Q4v]==$F0E and IK[Q3v]==IK[Q4v]
endfunction
function Q5v takes integer Q6v,integer Q7v returns boolean
return ox[Q7v]==$EF4 and cK[Q6v]==cK[Q7v]
endfunction
function Q8v takes integer Q9v,integer svv returns boolean
return ox[svv]==$EFA and ZK[Q9v]==ZK[svv]
endfunction
function sev takes integer sxv,integer sov returns boolean
local integer srv=ox[sov]
return srv==$EFD or srv==$F03 and OK[sxv]==OK[sov]
endfunction
function siv takes integer sav,integer snv returns boolean
local integer sVv=ox[snv]
return sVv==$EFC or sVv==$F09 and hJ[sav]==hJ[snv]
endfunction
function sEv takes integer f6i,integer R6i returns boolean
return false
endfunction
function sXv takes integer sOv,integer sRv returns boolean
return sev(sOv,sRv)
endfunction
function sIv takes integer sAv,integer sNv returns boolean
local integer sbv=ox[sNv]
return(sbv>=$EFD and sbv<=$EFE)or(sbv>=$F02 and sbv<=$F03)and yK[sAv]==yK[sNv]
endfunction
function sBv takes integer scv,integer sCv returns boolean
return sIv(scv,sCv)
endfunction
function sdv takes integer sDv,integer sfv returns boolean
return sDv==sfv
endfunction
function sFv takes integer sgv,integer sGv returns boolean
return ox[sGv]==$F0B and jK[sgv]==jK[sGv]
endfunction
function shv takes integer sHv,string sjv returns integer
local integer sJv
set ZM[EM]=sjv
set EM=EM+1
set sJv=dgv(UK[sHv],"when calling size in ScmdDataTypes, line 1110")
set EM=EM-1
return sJv
endfunction
function skv takes integer sKv,string slv returns integer
local integer sLv
set ZM[EM]=slv
set EM=EM+1
if ox[sKv]==0 then
if sKv==0 then
call Cdv("Nullpointer exception when calling Vector.size","when calling error in ScmdDataTypes, line 1109")
else
call Cdv("Called Vector.size on invalid object.","when calling error in ScmdDataTypes, line 1109")
endif
endif
set sLv=shv(sKv,"when calling size in ScmdDataTypes, line 1109")
set EM=EM-1
return sLv
endfunction
function smv takes integer sMv,integer spv returns boolean
local integer sPv=ox[spv]
return sPv>=$EF7 and sPv<=$EFA and PK[sMv]==PK[spv]
endfunction
function sqv takes integer sQv,integer ssv,string sSv returns integer
local integer stv
set ZM[EM]=sSv
set EM=EM+1
set stv=P_v(jqv(UK[sQv],ssv,"when calling get in ScmdDataTypes, line 1094"),"when calling clone in ScmdDataTypes, line 1094")
set EM=EM-1
return stv
endfunction
function sTv takes integer suv,integer sUv,string swv returns integer
local integer sWv
set ZM[EM]=swv
set EM=EM+1
if ox[suv]==0 then
if suv==0 then
call Cdv("Nullpointer exception when calling Vector.get","when calling error in ScmdDataTypes, line 1093")
else
call Cdv("Called Vector.get on invalid object.","when calling error in ScmdDataTypes, line 1093")
endif
endif
set sWv=sqv(suv,sUv,"when calling get in ScmdDataTypes, line 1093")
set EM=EM-1
return sWv
endfunction
function syv takes integer sYv,integer szv returns boolean
return ox[szv]==$F07 and TK[sYv]==TK[szv]
endfunction
function sZv takes integer s_v,integer s0v returns boolean
return ox[s0v]==$EF0 and IJ[s_v]==IJ[s0v]
endfunction
function s1v takes integer s2v,integer s3v returns boolean
return siv(s2v,s3v)
endfunction
function s4v takes integer s5v,integer s6v returns boolean
return ox[s6v]==$F06 and fK[s5v]==fK[s6v]
endfunction
function s7v takes integer s8v,integer s9v returns boolean
return ox[s9v]==$F05 and qK[s8v]==qK[s9v]
endfunction
function Svv takes integer Sev,integer Sxv returns boolean
return ox[Sxv]==$F04 and eK[Sev]==eK[Sxv]
endfunction
function Sov takes integer Srv,integer Siv,integer Sav,string Snv returns nothing
local boolean SVv
local integer SEv
local integer SXv
if Srv==0 then
set ZM[EM]=Snv
set EM=EM+1
if ox[Siv]==0 then
if Siv==0 then
call Cdv("Nullpointer exception when calling Object.equals","when calling error in ScmdDataTypes, line 59")
else
call Cdv("Called Object.equals on invalid object.","when calling error in ScmdDataTypes, line 59")
endif
endif
if ox[Siv]<=$F00 then
if ox[Siv]<=$EF9 then
if ox[Siv]<=$EF4 then
if ox[Siv]<=$EF0 then
if ox[Siv]<=$EEF then
set SVv=sdv(Siv,Sav)
else
set SVv=sZv(Siv,Sav)
endif
elseif ox[Siv]<=$EF3 then
set SVv=sdv(Siv,Sav)
else
set SVv=Q5v(Siv,Sav)
endif
elseif ox[Siv]<=$EF7 then
if ox[Siv]<=$EF6 then
set SVv=QZv(Siv,Sav)
else
set SVv=smv(Siv,Sav)
endif
elseif ox[Siv]<=$EF8 then
set SVv=QWv(Siv,Sav)
else
set SVv=QPv(Siv,Sav)
endif
elseif ox[Siv]<=$EFD then
if ox[Siv]<=$EFB then
if ox[Siv]<=$EFA then
set SVv=Q8v(Siv,Sav)
else
set SVv=sdv(Siv,Sav)
endif
elseif ox[Siv]<=$EFC then
set SVv=s1v(Siv,Sav)
else
set SVv=sXv(Siv,Sav)
endif
elseif ox[Siv]<=$EFF then
if ox[Siv]<=$EFE then
set SVv=sBv(Siv,Sav)
else
set SVv=Quv(Siv,Sav)
endif
else
set SVv=Qzv(Siv,Sav)
endif
elseif ox[Siv]<=$F07 then
if ox[Siv]<=$F04 then
if ox[Siv]<=$F02 then
if ox[Siv]<=$F01 then
set SVv=sdv(Siv,Sav)
else
set SVv=sIv(Siv,Sav)
endif
elseif ox[Siv]<=$F03 then
set SVv=sev(Siv,Sav)
else
set SVv=Svv(Siv,Sav)
endif
elseif ox[Siv]<=$F06 then
if ox[Siv]<=$F05 then
set SVv=s7v(Siv,Sav)
else
set SVv=s4v(Siv,Sav)
endif
else
set SVv=syv(Siv,Sav)
endif
elseif ox[Siv]<=$F0B then
if ox[Siv]<=$F09 then
if ox[Siv]<=$F08 then
set SVv=Qsv(Siv,Sav)
else
set SVv=siv(Siv,Sav)
endif
elseif ox[Siv]<=$F0A then
set SVv=sdv(Siv,Sav)
else
set SVv=sFv(Siv,Sav)
endif
elseif ox[Siv]<=$F0D then
if ox[Siv]<=$F0C then
set SVv=sEv(Siv,Sav)
else
call Sov(1,Siv,Sav,"when calling equals in ScmdDataTypes, line 59")
set SVv=Rjv
endif
else
set SVv=Q2v(Siv,Sav)
endif
set EM=EM-1
set Rjv=SVv
return
elseif Srv==1 then
set ZM[EM]=Snv
set EM=EM+1
if not(ox[Sav]==$F0D)then
set EM=EM-1
set Rjv=false
return
endif
set SEv=Sav
if skv(Siv,"when calling size in ScmdDataTypes, line 1071")!=skv(SEv,"when calling size in ScmdDataTypes, line 1071")then
set EM=EM-1
set Rjv=false
return
endif
set SXv=0
loop
exitwhen not(SXv<skv(Siv,"when calling size in ScmdDataTypes, line 1074"))
call Sov(0,m0v(sTv(Siv,SXv,"when calling get in ScmdDataTypes, line 1075"),"when calling get in ScmdDataTypes, line 1075"),m0v(sTv(SEv,SXv,"when calling get in ScmdDataTypes, line 1075"),"when calling get in ScmdDataTypes, line 1075"),"when calling equals in ScmdDataTypes, line 1075")
if not Rjv then
set EM=EM-1
set Rjv=false
return
endif
set SXv=SXv+1
endloop
set EM=EM-1
set Rjv=true
return
endif
endfunction
function SOv takes integer SRv,string SIv returns integer
local integer SAv
set ZM[EM]=SIv
set EM=EM+1
set SAv=dgv(gJ[SRv],"when calling size in ScmdDataTypes, line 1262")
set EM=EM-1
return SAv
endfunction
function SNv takes integer Sbv,string SBv returns integer
local integer Scv
set ZM[EM]=SBv
set EM=EM+1
if yx[Sbv]==0 then
if Sbv==0 then
call Cdv("Nullpointer exception when calling Arguments.size","when calling error in ScmdDataTypes, line 1261")
else
call Cdv("Called Arguments.size on invalid object.","when calling error in ScmdDataTypes, line 1261")
endif
endif
set Scv=SOv(Sbv,"when calling size in ScmdDataTypes, line 1261")
set EM=EM-1
return Scv
endfunction
function SCv takes integer PWt,integer AWt,integer Sdv,string SDv returns integer
local boolean Sfv
local integer SFv
local integer Sgv
local integer SGv
set ZM[EM]=SDv
set EM=EM+1
set Sfv=true
set SFv=1
set Sgv=SNv(Sdv,"when calling size in ScmdCoreBuiltins, line 369")-1
loop
exitwhen SFv>Sgv
call Sov(0,M7v(Sdv,SFv,"when calling get in ScmdCoreBuiltins, line 370"),M7v(Sdv,SFv-1,"when calling get in ScmdCoreBuiltins, line 370"),"when calling equals in ScmdCoreBuiltins, line 370")
set Sfv=Rjv
if not Sfv then
exitwhen true
endif
set SFv=SFv+1
endloop
set SGv=p0v(qRv(Sfv,"when calling new_Boolean in ScmdCoreBuiltins, line 373"),"when calling new_SharedPointer in ScmdCoreBuiltins, line 373")
set EM=EM-1
return SGv
endfunction
function Shv takes unit SHv returns integer
return BlzGetUnitMaxMana(SHv)
endfunction
function Sjv takes string SJv returns integer
local integer Skv
set ZM[EM]=SJv
set EM=EM+1
if Sx==0 then
if cx<$8000 then
set cx=cx+1
set Skv=cx
set ox[Skv]=$F03
else
call Cdv("Out of memory: Could not create Integer.","when calling error in ScmdDataTypes, line 476")
set Skv=0
endif
else
set Sx=Sx-1
set Skv=ix[Sx]
set ox[Skv]=$F03
endif
set EM=EM-1
return Skv
endfunction
function SKv takes integer Slv,real SLv,string Smv returns nothing
call Pkv(Slv,Smv)
call qyv(Slv)
set yK[Slv]=SLv
endfunction
function SMv takes integer Spv returns string
return I2S(Spv)
endfunction
function SPv takes integer wVt returns nothing
endfunction
function Sqv takes integer SQv,integer Ssv returns nothing
call SKv(SQv,DQv(Ssv),SMv(Ssv))
call SPv(SQv)
set OK[SQv]=Ssv
endfunction
function SSv takes integer Stv,string STv returns integer
local integer Suv
set ZM[EM]=STv
set EM=EM+1
set Suv=Sjv("when calling alloc_Integer in ScmdDataTypes, line 485")
call Sqv(Suv,Stv)
set EM=EM-1
return Suv
endfunction
function SUv takes integer Hbi,integer Swv,integer Kbi,string SWv returns integer
local integer Syv
set ZM[EM]=SWv
set EM=EM+1
set Syv=p0v(SSv(Shv(Mov(Swv,"when calling getEnumUnit in ScmdUnitBuiltins, line 290")),"when calling new_Integer in ScmdUnitBuiltins, line 290"),"when calling new_SharedPointer in ScmdUnitBuiltins, line 290")
set EM=EM-1
return Syv
endfunction
function SYv takes unit Szv,unitintegerfield SZv,integer S_v returns boolean
return BlzSetUnitIntegerField(Szv,SZv,S_v)
endfunction
function S0v takes unit S1v,string S2v returns boolean
local armortype S3v=ARMOR_TYPE_WHOKNOWS
local boolean S4v=true
local string S5v=S2v
local boolean S6v
if S5v=="ethereal" then
set S3v=ARMOR_TYPE_ETHREAL
elseif S5v=="flesh" then
set S3v=ARMOR_TYPE_FLESH
elseif S5v=="metal" then
set S3v=ARMOR_TYPE_METAL
elseif S5v=="stone" then
set S3v=ARMOR_TYPE_STONE
elseif S5v=="whoknows" then
set S3v=ARMOR_TYPE_WHOKNOWS
elseif S5v=="wood" then
set S3v=ARMOR_TYPE_WOOD
else
set S4v=false
endif
if S4v then
set S6v=SYv(S1v,UNIT_IF_ARMOR_TYPE,C0v(S3v))
else
set S6v=false
endif
set S3v=null
return S6v
endfunction
function S7v takes integer Hni,integer Jni,integer S8v,string S9v returns integer
local integer tvv
set ZM[EM]=S9v
set EM=EM+1
set tvv=p0v(qRv(S0v(PCv(M7v(S8v,0,"when calling get in ScmdUnitBuiltins, line 517"),"when calling getInner in ScmdUnitBuiltins, line 517"),Mqv(M7v(S8v,1,"when calling get in ScmdUnitBuiltins, line 517"),"when calling getInner in ScmdUnitBuiltins, line 517")),"when calling new_Boolean in ScmdUnitBuiltins, line 517"),"when calling new_SharedPointer in ScmdUnitBuiltins, line 517")
set EM=EM-1
return tvv
endfunction
function tev takes unit txv,integer tov,integer trv returns nothing
call BlzSetUnitDiceSides(txv,tov,trv)
endfunction
function tiv takes integer Hpi,integer Jpi,integer tav,string tnv returns integer
local integer tVv
set ZM[EM]=tnv
set EM=EM+1
call tev(PCv(M7v(tav,0,"when calling get in ScmdUnitBuiltins, line 347"),"when calling getInner in ScmdUnitBuiltins, line 347"),QNv(M7v(tav,1,"when calling get in ScmdUnitBuiltins, line 347"),"when calling intValue in ScmdUnitBuiltins, line 347"),QNv(M7v(tav,2,"when calling get in ScmdUnitBuiltins, line 347"),"when calling intValue in ScmdUnitBuiltins, line 347"))
set tVv=MLv("when calling nullptr in ScmdUnitBuiltins, line 348")
set EM=EM-1
return tVv
endfunction
function tEv takes unit tXv,real tOv,integer tRv returns nothing
call BlzSetUnitAttackCooldown(tXv,tOv,tRv)
endfunction
function tIv takes integer Hqi,integer tAv,integer tNv,string tbv returns integer
local integer tBv
set ZM[EM]=tbv
set EM=EM+1
call tEv(Mov(tAv,"when calling getEnumUnit in ScmdUnitBuiltins, line 401"),PEv(M7v(tNv,0,"when calling get in ScmdUnitBuiltins, line 401"),"when calling realValue in ScmdUnitBuiltins, line 401"),QNv(M7v(tNv,1,"when calling get in ScmdUnitBuiltins, line 401"),"when calling intValue in ScmdUnitBuiltins, line 401"))
set tBv=MLv("when calling nullptr in ScmdUnitBuiltins, line 402")
set EM=EM-1
return tBv
endfunction
function tcv takes integer Hri,integer Jri,integer tCv,string tdv returns integer
local integer tDv
set ZM[EM]=tdv
set EM=EM+1
call SetMusicPlayPosition(QNv(M7v(tCv,0,"when calling get in ScmdSoundFunctions, line 15"),"when calling intValue in ScmdSoundFunctions, line 15"))
set tDv=MLv("when calling nullptr in ScmdSoundFunctions, line 16")
set EM=EM-1
return tDv
endfunction
function tfv takes integer nKt returns nothing
endfunction
function tFv takes integer tgv,string tGv returns nothing
call tfv(tgv)
set wK[tgv]=tGv
set uK[tgv]=0
endfunction
function thv takes string tHv returns integer
local integer tjv
set ZM[EM]=tHv
set EM=EM+1
if Sx==0 then
if cx<$8000 then
set cx=cx+1
set tjv=cx
set ox[tjv]=$EF1
else
call Cdv("Out of memory: Could not create Exception.","when calling error in ScmdDataTypes, line 183")
set tjv=0
endif
else
set Sx=Sx-1
set tjv=ix[Sx]
set ox[tjv]=$EF1
endif
set EM=EM-1
return tjv
endfunction
function tJv takes string tkv,string tKv returns integer
local integer tlv
set ZM[EM]=tKv
set EM=EM+1
set tlv=thv("when calling alloc_Exception in ScmdDataTypes, line 194")
call tFv(tlv,tkv)
set EM=EM-1
return tlv
endfunction
function tLv takes string tmv returns integer
local integer tMv
set ZM[EM]=tmv
set EM=EM+1
set tMv=p0v(tJv("Wrong color name","when calling new_Exception in ScmdUnitBuiltins, line 15"),"when calling new_SharedPointer in ScmdUnitBuiltins, line 15")
set EM=EM-1
return tMv
endfunction
function tpv takes playercolor tPv returns integer
local integer tqv=0
local integer tQv=0
local integer tsv=bj_MAX_PLAYER_SLOTS-1
loop
exitwhen tQv>tsv
if Oa[tQv]==tPv then
set tqv=tQv
exitwhen true
endif
set tQv=tQv+1
endloop
return tqv
endfunction
function tSv takes unit ttv,playercolor tTv returns nothing
call SetUnitColor(ttv,tTv)
endfunction
function tuv takes unit tUv,playercolor twv returns nothing
call tSv(tUv,twv)
call Cxv(Va,C0v(tUv),cn,tpv(twv))
endfunction
function tWv takes integer tyv returns playercolor
return Oa[tyv]
endfunction
function tYv takes string tzv returns string
return StringCase(tzv,false)
endfunction
function tZv takes string t_v returns playercolor
local playercolor t0v=null
local integer t1v=0
local integer t2v=kp
loop
exitwhen t1v>t2v
if tYv(t_v)==mp[t1v]then
set t0v=tWv(t1v)
exitwhen true
endif
set t1v=t1v+1
endloop
set Rlv=t0v
set t0v=null
return Rlv
endfunction
function t3v takes integer Uti,integer Iti,integer t4v,string t5v returns integer
local string t6v
local playercolor t7v
local playercolor t8v
local boolean t9v
local integer Tvv
local integer Tev
set ZM[EM]=t5v
set EM=EM+1
set t6v=tYv(Mqv(M7v(t4v,1,"when calling get in ScmdUnitBuiltins, line 65"),"when calling getInner in ScmdUnitBuiltins, line 65"))
if t6v=="black" then
set t8v=ia
else
set t8v=tZv(t6v)
endif
set t7v=t8v
set t9v=t7v!=null or tYv(t6v)=="red"
if t9v then
call tuv(PCv(M7v(t4v,0,"when calling get in ScmdUnitBuiltins, line 69"),"when calling getInner in ScmdUnitBuiltins, line 69"),t7v)
endif
if t9v then
set Tvv=MLv("when calling nullptr in ScmdUnitBuiltins, line 70")
else
set Tvv=tLv("when calling newWCNException in ScmdUnitBuiltins, line 70")
endif
set Tev=Tvv
set EM=EM-1
set t7v=null
set t8v=null
return Tev
endfunction
function Txv takes string Tov returns integer
local integer Trv
set ZM[EM]=Tov
set EM=EM+1
if ch==0 then
if oh<$8000 then
set oh=oh+1
set Trv=oh
set Oh[Trv]=$966
else
call Cdv("Out of memory: Could not create HashList.","when calling error in HashList, line 8")
set Trv=0
endif
else
set ch=ch-1
set Trv=Sh[ch]
set Oh[Trv]=$966
endif
set EM=EM-1
return Trv
endfunction
function Tiv takes integer Tav returns nothing
set OU[Tav]=0
endfunction
function Tnv takes integer TVv returns nothing
call Tiv(TVv)
endfunction
function TEv takes string TXv returns integer
local integer TOv
set ZM[EM]=TXv
set EM=EM+1
set TOv=Txv("when calling alloc_HashList in HashList, line 112")
call Tnv(TOv)
set EM=EM-1
return TOv
endfunction
function TRv takes string TIv,string TAv returns integer
local integer TNv
local integer Tbv
local integer TBv
set ZM[EM]=TAv
set EM=EM+1
set TNv=TEv("when calling new_HashList in SotFRP_AbilList, line 15")
set Tbv=0
set TBv=Dd-1
loop
exitwhen Tbv>TBv
if Jd[Tbv]==TIv then
call dlv(TNv,Hd[Tbv],"when calling add in SotFRP_AbilList, line 18")
endif
set Tbv=Tbv+1
endloop
set EM=EM-1
return TNv
endfunction
function Tcv takes string TCv,string Tdv returns integer
local integer TDv
local integer Tfv
local integer TFv
set ZM[EM]=Tdv
set EM=EM+1
set TDv=TEv("when calling new_HashList in SotFRP_HeroAbilList, line 22")
set Tfv=0
set TFv=Kd-1
loop
exitwhen Tfv>TFv
if Xd[Tfv]==TCv then
call dlv(TDv,Ld[Tfv],"when calling add in SotFRP_HeroAbilList, line 25")
endif
set Tfv=Tfv+1
endloop
set EM=EM-1
return TDv
endfunction
function Tgv takes string TGv,integer Thv returns string
return SubString(TGv,Thv,GZv(TGv))
endfunction
function THv takes string Tjv,string TJv returns integer
local integer Tkv
local integer TKv
set ZM[EM]=TJv
set EM=EM+1
if Psv(Tjv,0,4)=="hero" then
set Tkv=Tcv(Tgv(Tjv,4),"when calling getRegisteredHeroAbilityIdByName in SotFRP_AbilitySystem, line 12")
else
set Tkv=TRv(Tjv,"when calling getRegisteredAbilityIdByName in SotFRP_AbilitySystem, line 12")
endif
set TKv=Tkv
set EM=EM-1
return TKv
endfunction
function Tlv takes unit TLv,integer Tmv returns boolean
return UnitRemoveAbility(TLv,Tmv)
endfunction
function TMv takes unit Tpv,integer TPv returns boolean
local integer Tqv
local integer TQv
local integer Tsv
local integer TSv
local integer Ttv
local integer TTv
if Tlv(Tpv,TPv)then
set Tqv=C0v(Tpv)
set TQv=c8v(Va,Tqv,dn)
set Tsv=1
set TSv=TQv
loop
exitwhen Tsv>TSv
if c8v(Va,Tqv,dn+Tsv*Yn)==TPv then
call Cxv(Va,Tqv,dn+Tsv*Yn,c8v(Va,Tqv,dn+TQv*Yn))
call Cxv(Va,Tqv,dn,TQv-1)
return true
endif
set Tsv=Tsv+1
endloop
set Ttv=1
set TTv=c8v(Va,Tqv,Rn)
loop
exitwhen Ttv>TTv
if c8v(Va,Tqv,Rn+Ttv*Yn)==TPv then
call Cxv(Va,Tqv,Rn+Ttv*Yn,c8v(Va,Tqv,Rn+TQv*Yn))
call Cxv(Va,Tqv,Rn,TQv-1)
exitwhen true
endif
set Ttv=Ttv+1
endloop
set TQv=c8v(Va,Tqv,fn)+1
call Cxv(Va,Tqv,fn,TQv)
call Cxv(Va,Tqv,fn+TQv*Yn,TPv)
return true
endif
return false
endfunction
function Tuv takes unit TUv,string Twv,string TWv returns nothing
local integer Tyv
local integer TYv
local integer Tzv
set ZM[EM]=TWv
set EM=EM+1
set Tyv=THv(Twv,"when calling getAbilityIdByName in SotFRP_AbilitySystem, line 21")
set TYv=jdv(Tyv,"when calling iterator in SotFRP_AbilitySystem, line 22")
loop
exitwhen not Jgv(TYv,"when calling hasNext in SotFRP_AbilitySystem, line 22")
set Tzv=jTv(TYv,"when calling next in SotFRP_AbilitySystem, line 22")
call TMv(TUv,Tzv)
endloop
call Jqv(TYv,"when calling close in SotFRP_AbilitySystem, line 22")
call JEv(Tyv,"when calling dispatch_HashList_destroyHashList in SotFRP_AbilitySystem, line 24")
set EM=EM-1
endfunction
function TZv takes integer Hvi,integer Jvi,integer T_v,string T0v returns integer
local integer T1v
set ZM[EM]=T0v
set EM=EM+1
call Tuv(PCv(M7v(T_v,0,"when calling get in SotFRP_AbilitySystem, line 62"),"when calling getInner in SotFRP_AbilitySystem, line 62"),Mqv(M7v(T_v,1,"when calling get in SotFRP_AbilitySystem, line 62"),"when calling getInner in SotFRP_AbilitySystem, line 62"),"when calling removeAbility in SotFRP_AbilitySystem, line 62")
set T1v=MLv("when calling nullptr in SotFRP_AbilitySystem, line 63")
set EM=EM-1
return T1v
endfunction
function T2v takes integer ZFt,integer UFt,integer T3v,string T4v returns integer
local integer T5v
set ZM[EM]=T4v
set EM=EM+1
set T5v=p0v(Ppv(Tgv(Mqv(M7v(T3v,0,"when calling get in ScmdCoreBuiltins, line 130"),"when calling getInner in ScmdCoreBuiltins, line 130"),QNv(M7v(T3v,1,"when calling get in ScmdCoreBuiltins, line 130"),"when calling intValue in ScmdCoreBuiltins, line 130")),"when calling new_String in ScmdCoreBuiltins, line 130"),"when calling new_SharedPointer in ScmdCoreBuiltins, line 130")
set EM=EM-1
return T5v
endfunction
function T6v takes real T7v returns real
return T7v*by
endfunction
function T8v takes unit T9v,real uvv returns nothing
call SetUnitFacing(T9v,T6v(uvv))
endfunction
function uev takes unit uxv returns real
return GetUnitY(uxv)
endfunction
function uov takes unit urv returns real
set S3=QJv(urv)
set c3=uev(urv)
return S3
endfunction
function uiv takes real uav returns real
set PM=uav
return PM
endfunction
function unv takes real uVv,real uEv,real uXv,real uOv returns real
set G9=uiv(Atan2(uOv-uEv,uXv-uVv))
return G9
endfunction
function uRv takes integer ZWi,integer uIv,integer uAv,string uNv returns integer
local integer ubv
set ZM[EM]=uNv
set EM=EM+1
call T8v(PCv(M7v(uAv,0,"when calling get in SotfrpGuiCoreUnit, line 73"),"when calling getInner in SotfrpGuiCoreUnit, line 73"),unv(uov(PCv(M7v(uAv,0,"when calling get in SotfrpGuiCoreUnit, line 73"),"when calling getInner in SotfrpGuiCoreUnit, line 73")),c3,uov(QKv(QGv(uIv,"when calling getPlayerId in SotfrpGuiCoreUnit, line 73"))),c3))
set ubv=MLv("when calling nullptr in SotfrpGuiCoreUnit, line 74")
set EM=EM-1
return ubv
endfunction
function uBv takes unit ucv,integer uCv returns nothing
call BlzSetUnitMaxMana(ucv,uCv)
endfunction
function udv takes integer Zbi,integer Ubi,integer uDv,string ufv returns integer
local integer uFv
set ZM[EM]=ufv
set EM=EM+1
call uBv(PCv(M7v(uDv,0,"when calling get in ScmdUnitBuiltins, line 286"),"when calling getInner in ScmdUnitBuiltins, line 286"),QNv(M7v(uDv,1,"when calling get in ScmdUnitBuiltins, line 286"),"when calling intValue in ScmdUnitBuiltins, line 286"))
set uFv=MLv("when calling nullptr in ScmdUnitBuiltins, line 287")
set EM=EM-1
return uFv
endfunction
function ugv takes integer Zni,integer uGv,integer uhv,string uHv returns integer
local integer ujv
set ZM[EM]=uHv
set EM=EM+1
set ujv=p0v(qRv(S0v(Mov(uGv,"when calling getEnumUnit in ScmdUnitBuiltins, line 515"),Mqv(M7v(uhv,0,"when calling get in ScmdUnitBuiltins, line 515"),"when calling getInner in ScmdUnitBuiltins, line 515")),"when calling new_Boolean in ScmdUnitBuiltins, line 515"),"when calling new_SharedPointer in ScmdUnitBuiltins, line 515")
set EM=EM-1
return ujv
endfunction
function uJv takes integer Zpi,integer ukv,integer uKv,string ulv returns integer
local integer uLv
set ZM[EM]=ulv
set EM=EM+1
call tev(Mov(ukv,"when calling getEnumUnit in ScmdUnitBuiltins, line 344"),QNv(M7v(uKv,0,"when calling get in ScmdUnitBuiltins, line 344"),"when calling intValue in ScmdUnitBuiltins, line 344"),QNv(M7v(uKv,1,"when calling get in ScmdUnitBuiltins, line 344"),"when calling intValue in ScmdUnitBuiltins, line 344"))
set uLv=MLv("when calling nullptr in ScmdUnitBuiltins, line 345")
set EM=EM-1
return uLv
endfunction
function umv takes unit uMv returns integer
return GetUnitTypeId(uMv)
endfunction
function upv takes unit uPv returns boolean
return c2v(Va,C0v(uPv),on)
endfunction
function uqv takes string uQv returns integer
return S2I(uQv)
endfunction
function usv takes integer uSv,string utv returns integer
return uqv(d2v(uSv,utv))
endfunction
function uTv takes integer uuv returns integer
return usv(uuv,"def")
endfunction
function uUv takes unit uwv returns integer
local integer uWv
if upv(uwv)then
set uWv=c8v(Va,C0v(uwv),on)
else
set uWv=uTv(umv(uwv))
endif
return uWv
endfunction
function uyv takes integer Zqi,integer Uqi,integer uYv,string uzv returns integer
local integer uZv
set ZM[EM]=uzv
set EM=EM+1
set uZv=p0v(SSv(uUv(PCv(M7v(uYv,0,"when calling get in ScmdUnitBuiltins, line 398"),"when calling getInner in ScmdUnitBuiltins, line 398")),"when calling new_Integer in ScmdUnitBuiltins, line 398"),"when calling new_SharedPointer in ScmdUnitBuiltins, line 398")
set EM=EM-1
return uZv
endfunction
function u_v takes integer Zri,integer Uri,integer u0v,string u1v returns integer
local integer u2v
set ZM[EM]=u1v
set EM=EM+1
call PlayMusicEx(Mqv(M7v(u0v,0,"when calling get in ScmdSoundFunctions, line 11"),"when calling getInner in ScmdSoundFunctions, line 11"),QNv(M7v(u0v,1,"when calling get in ScmdSoundFunctions, line 11"),"when calling intValue in ScmdSoundFunctions, line 11"),QNv(M7v(u0v,2,"when calling get in ScmdSoundFunctions, line 11"),"when calling intValue in ScmdSoundFunctions, line 11"))
set u2v=MLv("when calling nullptr in ScmdSoundFunctions, line 12")
set EM=EM-1
return u2v
endfunction
function u3v takes integer Zvi,integer u4v,integer u5v,string u6v returns integer
local integer u7v
set ZM[EM]=u6v
set EM=EM+1
call Tuv(Mov(u4v,"when calling getEnumUnit in SotFRP_AbilitySystem, line 59"),Mqv(M7v(u5v,0,"when calling get in SotFRP_AbilitySystem, line 59"),"when calling getInner in SotFRP_AbilitySystem, line 59"),"when calling removeAbility in SotFRP_AbilitySystem, line 59")
set u7v=MLv("when calling nullptr in SotFRP_AbilitySystem, line 60")
set EM=EM-1
return u7v
endfunction
function u8v takes integer xFt,integer vFt,integer u9v,string Uvv returns integer
local integer Uev
set ZM[EM]=Uvv
set EM=EM+1
set Uev=p0v(SSv(Ccv(Mqv(M7v(u9v,0,"when calling get in ScmdCoreBuiltins, line 127"),"when calling getInner in ScmdCoreBuiltins, line 127")),"when calling new_Integer in ScmdCoreBuiltins, line 127"),"when calling new_SharedPointer in ScmdCoreBuiltins, line 127")
set EM=EM-1
return Uev
endfunction
function Uxv takes integer xWi,integer Uov,integer mWi,string Urv returns integer
local integer Uiv
set ZM[EM]=Urv
set EM=EM+1
call T8v(Mov(Uov,"when calling getEnumUnit in SotfrpGuiCoreUnit, line 70"),unv(uov(Mov(Uov,"when calling getEnumUnit in SotfrpGuiCoreUnit, line 70")),c3,uov(QKv(QGv(Uov,"when calling getPlayerId in SotfrpGuiCoreUnit, line 70"))),c3))
set Uiv=MLv("when calling nullptr in SotfrpGuiCoreUnit, line 71")
set EM=EM-1
return Uiv
endfunction
function Uav takes integer xbi,integer Unv,integer UVv,string UEv returns integer
local integer UXv
set ZM[EM]=UEv
set EM=EM+1
call uBv(Mov(Unv,"when calling getEnumUnit in ScmdUnitBuiltins, line 283"),QNv(M7v(UVv,0,"when calling get in ScmdUnitBuiltins, line 283"),"when calling intValue in ScmdUnitBuiltins, line 283"))
set UXv=MLv("when calling nullptr in ScmdUnitBuiltins, line 284")
set EM=EM-1
return UXv
endfunction
function UOv takes unit URv,string UIv returns boolean
local defensetype UAv=DEFENSE_TYPE_NONE
local boolean UNv=true
local string Ubv=UIv
local boolean UBv
if Ubv=="light" then
set UAv=DEFENSE_TYPE_LIGHT
elseif Ubv=="medium" then
set UAv=DEFENSE_TYPE_MEDIUM
elseif Ubv=="large" or Ubv=="heavy" then
set UAv=DEFENSE_TYPE_LARGE
elseif Ubv=="fort" or Ubv=="fortified" then
set UAv=DEFENSE_TYPE_FORT
elseif Ubv=="hero" then
set UAv=DEFENSE_TYPE_HERO
elseif Ubv=="divine" then
set UAv=DEFENSE_TYPE_DIVINE
elseif Ubv=="none" or Ubv=="unarmored" then
set UAv=DEFENSE_TYPE_NONE
else
set UNv=false
endif
if UNv then
set UBv=SYv(URv,UNIT_IF_DEFENSE_TYPE,C0v(UAv))
else
set UBv=false
endif
set UAv=null
return UBv
endfunction
function Ucv takes integer xni,integer vni,integer UCv,string Udv returns integer
local integer UDv
set ZM[EM]=Udv
set EM=EM+1
set UDv=p0v(qRv(UOv(PCv(M7v(UCv,0,"when calling get in ScmdUnitBuiltins, line 490"),"when calling getInner in ScmdUnitBuiltins, line 490"),Mqv(M7v(UCv,1,"when calling get in ScmdUnitBuiltins, line 490"),"when calling getInner in ScmdUnitBuiltins, line 490")),"when calling new_Boolean in ScmdUnitBuiltins, line 490"),"when calling new_SharedPointer in ScmdUnitBuiltins, line 490")
set EM=EM-1
return UDv
endfunction
function Ufv takes unit UFv,integer Ugv returns integer
return BlzGetUnitBaseDamage(UFv,Ugv)
endfunction
function UGv takes integer xpi,integer vpi,integer Uhv,string UHv returns integer
local integer Ujv
set ZM[EM]=UHv
set EM=EM+1
set Ujv=p0v(SSv(Ufv(PCv(M7v(Uhv,0,"when calling get in ScmdUnitBuiltins, line 341"),"when calling getInner in ScmdUnitBuiltins, line 341"),QNv(M7v(Uhv,1,"when calling get in ScmdUnitBuiltins, line 341"),"when calling intValue in ScmdUnitBuiltins, line 341")),"when calling new_Integer in ScmdUnitBuiltins, line 341"),"when calling new_SharedPointer in ScmdUnitBuiltins, line 341")
set EM=EM-1
return Ujv
endfunction
function UJv takes integer xqi,integer Ukv,integer mqi,string UKv returns integer
local integer Ulv
set ZM[EM]=UKv
set EM=EM+1
set Ulv=p0v(SSv(uUv(Mov(Ukv,"when calling getEnumUnit in ScmdUnitBuiltins, line 396")),"when calling new_Integer in ScmdUnitBuiltins, line 396"),"when calling new_SharedPointer in ScmdUnitBuiltins, line 396")
set EM=EM-1
return Ulv
endfunction
function ULv takes integer xri,integer vri,integer Umv,string UMv returns integer
local integer Upv
set ZM[EM]=UMv
set EM=EM+1
call PlayMusic(Mqv(M7v(Umv,0,"when calling get in ScmdSoundFunctions, line 7"),"when calling getInner in ScmdSoundFunctions, line 7"))
set Upv=MLv("when calling nullptr in ScmdSoundFunctions, line 8")
set EM=EM-1
return Upv
endfunction
function UPv takes unit Uqv,integer UQv,integer Usv returns nothing
call SetUnitAbilityLevel(Uqv,UQv,Usv)
endfunction
function USv takes unit Utv,integer UTv returns integer
return GetUnitAbilityLevel(Utv,UTv)
endfunction
function Uuv takes unit UUv,integer Uwv,integer UWv returns nothing
local integer Uyv=USv(UUv,Uwv)
local integer UYv
local integer Uzv
local integer UZv
local integer U_v
local integer U0v
local integer U1v
if UWv>0 and Uyv>0 and UWv!=Uyv then
call UPv(UUv,Uwv,UWv)
set UYv=C0v(UUv)
set Uzv=c8v(Va,UYv,dn)
set UZv=1
set U_v=Uzv
loop
exitwhen UZv>U_v
if c8v(Va,UYv,dn+UZv*Yn)==Uwv then
return
endif
set UZv=UZv+1
endloop
set Uzv=c8v(Va,UYv,Rn)
set U0v=1
set U1v=Uzv
loop
exitwhen U0v>U1v
if c8v(Va,UYv,Rn+U0v*Yn)==Uwv then
return
endif
set U0v=U0v+1
endloop
set Uzv=Uzv+1
call Cxv(Va,UYv,Rn,Uzv)
call Cxv(Va,UYv,Rn+Uzv*Yn,Uwv)
endif
endfunction
function U2v takes unit U3v,string U4v,integer U5v,string U6v returns nothing
local integer U7v
local integer U8v
local integer U9v
set ZM[EM]=U6v
set EM=EM+1
set U7v=THv(U4v,"when calling getAbilityIdByName in SotFRP_AbilitySystem, line 27")
set U8v=jdv(U7v,"when calling iterator in SotFRP_AbilitySystem, line 28")
loop
exitwhen not Jgv(U8v,"when calling hasNext in SotFRP_AbilitySystem, line 28")
set U9v=jTv(U8v,"when calling next in SotFRP_AbilitySystem, line 28")
call Uuv(U3v,U9v,U5v)
endloop
call Jqv(U8v,"when calling close in SotFRP_AbilitySystem, line 28")
call JEv(U7v,"when calling dispatch_HashList_destroyHashList in SotFRP_AbilitySystem, line 30")
set EM=EM-1
endfunction
function wvv takes unit wev,integer wxv,boolean wov returns boolean
return UnitMakeAbilityPermanent(wev,wov,wxv)
endfunction
function wrv takes unit wiv,integer wav returns boolean
return UnitAddAbility(wiv,wav)
endfunction
function wnv takes unit wVv,integer wEv returns boolean
local integer wXv
local integer wOv
local integer wRv
local integer wIv
if wrv(wVv,wEv)then
call wvv(wVv,wEv,true)
set wXv=C0v(wVv)
set wOv=c8v(Va,wXv,fn)
set wRv=1
set wIv=wOv
loop
exitwhen wRv>wIv
if c8v(Va,wXv,fn+wRv*Yn)==wEv then
call Cxv(Va,wXv,fn+wRv*Yn,c8v(Va,wXv,fn+wOv*Yn))
call Cxv(Va,wXv,fn,wOv-1)
set wOv=c8v(Va,wXv,Rn)+1
call Cxv(Va,wXv,Rn,wOv)
call Cxv(Va,wXv,Rn+wOv*Yn,wEv)
return true
endif
set wRv=wRv+1
endloop
set wOv=c8v(Va,wXv,dn)+1
call Cxv(Va,wXv,dn,wOv)
call Cxv(Va,wXv,dn+wOv*Yn,wEv)
return true
endif
return false
endfunction
function wAv takes unit wNv,string wbv,string wBv returns nothing
local integer wcv
local integer wCv
local integer wdv
set ZM[EM]=wBv
set EM=EM+1
set wcv=THv(wbv,"when calling getAbilityIdByName in SotFRP_AbilitySystem, line 15")
set wCv=jdv(wcv,"when calling iterator in SotFRP_AbilitySystem, line 16")
loop
exitwhen not Jgv(wCv,"when calling hasNext in SotFRP_AbilitySystem, line 16")
set wdv=jTv(wCv,"when calling next in SotFRP_AbilitySystem, line 16")
call wnv(wNv,wdv)
endloop
call Jqv(wCv,"when calling close in SotFRP_AbilitySystem, line 16")
call JEv(wcv,"when calling dispatch_HashList_destroyHashList in SotFRP_AbilitySystem, line 18")
set EM=EM-1
endfunction
function wDv takes integer kvi,integer jvi,integer wfv,string wFv returns integer
local unit wgv
local unit wGv
local integer whv
set ZM[EM]=wFv
set EM=EM+1
set wgv=PCv(M7v(wfv,0,"when calling get in SotFRP_AbilitySystem, line 55"),"when calling getInner in SotFRP_AbilitySystem, line 55")
call wAv(wgv,Mqv(M7v(wfv,1,"when calling get in SotFRP_AbilitySystem, line 55"),"when calling getInner in SotFRP_AbilitySystem, line 55"),"when calling addAbility in SotFRP_AbilitySystem, line 55")
set wGv=wgv
call U2v(wGv,Mqv(M7v(wfv,1,"when calling get in SotFRP_AbilitySystem, line 55"),"when calling getInner in SotFRP_AbilitySystem, line 55"),QNv(M7v(wfv,2,"when calling get in SotFRP_AbilitySystem, line 55"),"when calling intValue in SotFRP_AbilitySystem, line 55"),"when calling setAbilityLevel in SotFRP_AbilitySystem, line 55")
set whv=MLv("when calling nullptr in SotFRP_AbilitySystem, line 56")
set EM=EM-1
set wgv=null
set wGv=null
return whv
endfunction
function wHv takes string wjv returns integer
local integer wJv
set ZM[EM]=wjv
set EM=EM+1
if Sx==0 then
if cx<$8000 then
set cx=cx+1
set wJv=cx
set ox[wJv]=$EF3
else
call Cdv("Out of memory: Could not create Expression.","when calling error in ScmdDataTypes, line 1573")
set wJv=0
endif
else
set Sx=Sx-1
set wJv=ix[Sx]
set ox[wJv]=$EF3
endif
set EM=EM-1
return wJv
endfunction
function wkv takes string wKv returns integer
local integer wlv
set ZM[EM]=wKv
set EM=EM+1
if lx==0 then
if bx<$8000 then
set bx=bx+1
set wlv=bx
set yx[wlv]=736
else
call Cdv("Out of memory: Could not create Arguments.","when calling error in ScmdDataTypes, line 1243")
set wlv=0
endif
else
set lx=lx-1
set wlv=Ox[lx]
set yx[wlv]=736
endif
set EM=EM-1
return wlv
endfunction
function wLv takes integer wmv,string wMv returns nothing
set ZM[EM]=wMv
set EM=EM+1
set gJ[wmv]=TEv("when calling new_HashList in ScmdDataTypes, line 1245")
set EM=EM-1
endfunction
function wpv takes integer wPv,string wqv returns nothing
set ZM[EM]=wqv
set EM=EM+1
call wLv(wPv,"when calling Arguments_init in ScmdDataTypes, line 1243")
set EM=EM-1
endfunction
function wQv takes string wsv returns integer
local integer wSv
set ZM[EM]=wsv
set EM=EM+1
set wSv=wkv("when calling alloc_Arguments in ScmdDataTypes, line 1243")
call wpv(wSv,"when calling construct_Arguments in ScmdDataTypes, line 1243")
set EM=EM-1
return wSv
endfunction
function wtv takes integer wTv,string wuv returns nothing
set ZM[EM]=wuv
set EM=EM+1
set sK[wTv]=wQv("when calling new_Arguments in ScmdDataTypes, line 1581")
set EM=EM-1
endfunction
function wUv takes integer wwv,integer wWv,string wyv returns nothing
set ZM[EM]=wyv
set EM=EM+1
call wtv(wwv,"when calling Expression_init in ScmdDataTypes, line 1591")
set rK[wwv]=P_v(wWv,"when calling clone in ScmdDataTypes, line 1592")
set EM=EM-1
endfunction
function wYv takes integer wzv,string wZv returns integer
local integer w_v
set ZM[EM]=wZv
set EM=EM+1
set w_v=wHv("when calling alloc_Expression in ScmdDataTypes, line 1591")
call wUv(w_v,wzv,"when calling construct_Expression2 in ScmdDataTypes, line 1591")
set EM=EM-1
return w_v
endfunction
function w0v takes unit w1v,integer w2v,integer w3v,integer w4v,integer w5v returns nothing
call SetUnitVertexColor(w1v,w2v,w3v,w4v,w5v)
endfunction
function w6v takes unit w7v,integer w8v,integer w9v,integer Wvv,integer Wev returns nothing
local integer Wxv
call w0v(w7v,w8v,w9v,Wvv,Wev)
set Wxv=C0v(w7v)
call Cxv(Va,Wxv,ln,w8v)
call Cxv(Va,Wxv,bn,w9v)
call Cxv(Va,Wxv,yn,Wvv)
call Cxv(Va,Wxv,pn,Wev)
endfunction
function Wov takes integer TSi,integer Wrv,integer Wiv,string Wav returns integer
local integer Wnv
set ZM[EM]=Wav
set EM=EM+1
call w6v(Mov(Wrv,"when calling getEnumUnit in ScmdUnitBuiltins, line 111"),QNv(M7v(Wiv,0,"when calling get in ScmdUnitBuiltins, line 111"),"when calling intValue in ScmdUnitBuiltins, line 111"),QNv(M7v(Wiv,1,"when calling get in ScmdUnitBuiltins, line 111"),"when calling intValue in ScmdUnitBuiltins, line 111"),QNv(M7v(Wiv,2,"when calling get in ScmdUnitBuiltins, line 111"),"when calling intValue in ScmdUnitBuiltins, line 111"),QNv(M7v(Wiv,3,"when calling get in ScmdUnitBuiltins, line 111"),"when calling intValue in ScmdUnitBuiltins, line 111"))
set Wnv=MLv("when calling nullptr in ScmdUnitBuiltins, line 112")
set EM=EM-1
return Wnv
endfunction
function WVv takes widget WEv returns real
return GetWidgetX(WEv)
endfunction
function WXv takes integer TTi,integer YTi,integer WOv,string WRv returns integer
local integer WIv
set ZM[EM]=WRv
set EM=EM+1
set WIv=p0v(q2v(WVv(qqv(M7v(WOv,0,"when calling get in ScmdUnitBuiltins, line 660"),"when calling getInner in ScmdUnitBuiltins, line 660")),"when calling new_Real in ScmdUnitBuiltins, line 660"),"when calling new_SharedPointer in ScmdUnitBuiltins, line 660")
set EM=EM-1
return WIv
endfunction
function WAv takes unit WNv,boolean Wbv returns integer
return GetHeroAgi(WNv,Wbv)
endfunction
function WBv takes integer Wcv returns boolean
return hJ[Wcv]
endfunction
function WCv takes integer Wdv,string WDv returns boolean
local boolean Wfv
set ZM[EM]=WDv
set EM=EM+1
if ox[Wdv]==0 then
if Wdv==0 then
call Cdv("Nullpointer exception when calling Boolean.booleanValue","when calling error in ScmdDataTypes, line 404")
else
call Cdv("Called Boolean.booleanValue on invalid object.","when calling error in ScmdDataTypes, line 404")
endif
endif
if ox[Wdv]<=$EFC then
set Wfv=WBv(Wdv)
else
set Wfv=WBv(Wdv)
endif
set EM=EM-1
return Wfv
endfunction
function WFv takes integer Tfi,integer Wgv,integer WGv,string Whv returns integer
local integer WHv
set ZM[EM]=Whv
set EM=EM+1
set WHv=p0v(SSv(WAv(Mov(Wgv,"when calling getEnumUnit in ScmdUnitBuiltins, line 592"),WCv(M7v(WGv,0,"when calling get in ScmdUnitBuiltins, line 592"),"when calling booleanValue in ScmdUnitBuiltins, line 592")),"when calling new_Integer in ScmdUnitBuiltins, line 592"),"when calling new_SharedPointer in ScmdUnitBuiltins, line 592")
set EM=EM-1
return WHv
endfunction
function Wjv takes integer Tvi,integer Yvi,integer WJv,string Wkv returns integer
local integer WKv
set ZM[EM]=Wkv
set EM=EM+1
call wAv(PCv(M7v(WJv,0,"when calling get in SotFRP_AbilitySystem, line 52"),"when calling getInner in SotFRP_AbilitySystem, line 52"),Mqv(M7v(WJv,1,"when calling get in SotFRP_AbilitySystem, line 52"),"when calling getInner in SotFRP_AbilitySystem, line 52"),"when calling addAbility in SotFRP_AbilitySystem, line 52")
set WKv=MLv("when calling nullptr in SotFRP_AbilitySystem, line 53")
set EM=EM-1
return WKv
endfunction
function Wlv takes integer WLv,string Wmv returns item
local item WMv
set ZM[EM]=Wmv
set EM=EM+1
if ox[WLv]==0 then
if WLv==0 then
call Cdv("Nullpointer exception when calling Item.getInner","when calling error in ScmdDataTypes, line 820")
else
call Cdv("Called Item.getInner on invalid object.","when calling error in ScmdDataTypes, line 820")
endif
endif
set WMv=qlv(WLv)
set EM=EM-1
set Ikv=WMv
set WMv=null
return Ikv
endfunction
function Wpv takes item WPv,string Wqv returns nothing
call BlzSetItemTooltip(WPv,Wqv)
endfunction
function WQv takes integer d0i,integer f0i,integer Wsv,string WSv returns integer
local integer Wtv
set ZM[EM]=WSv
set EM=EM+1
call Wpv(Wlv(M7v(Wsv,0,"when calling get in ScmdItemBuiltins, line 30"),"when calling getInner in ScmdItemBuiltins, line 30"),Mqv(M7v(Wsv,1,"when calling get in ScmdItemBuiltins, line 30"),"when calling getInner in ScmdItemBuiltins, line 30"))
set Wtv=MLv("when calling nullptr in ScmdItemBuiltins, line 31")
set EM=EM-1
return Wtv
endfunction
function WTv takes integer Wuv,integer WUv,integer Wwv,string WWv returns nothing
set ZM[EM]=WWv
set EM=EM+1
if ph[Wuv]==0 then
if Wuv==0 then
call Cdv("Nullpointer exception when calling IterableMap.put","when calling error in HashMap, line 59")
else
call Cdv("Called IterableMap.put on invalid object.","when calling error in HashMap, line 59")
endif
endif
call fLv(Wuv,WUv,Wwv,"when calling put in HashMap, line 59")
set EM=EM-1
endfunction
function Wyv takes integer WYv,string Wzv,integer WZv,string W_v returns nothing
local integer W0v
set ZM[EM]=W_v
set EM=EM+1
set W0v=f3v(NJ[WYv],KCv(Wzv,"when calling stringToIndex in ScmdDataTypes, line 1221"),"when calling get in ScmdDataTypes, line 1221")
if W0v!=0 then
call mfv(20,W0v,"when calling dispatch_GenericSharedPointer_destroyGenericSharedPointer in ScmdDataTypes, line 1223")
endif
call WTv(NJ[WYv],KCv(Wzv,"when calling stringToIndex in ScmdDataTypes, line 1224"),WZv,"when calling put in ScmdDataTypes, line 1224")
set EM=EM-1
endfunction
function W1v takes integer W2v,string W3v,integer W4v,string W5v returns nothing
set ZM[EM]=W5v
set EM=EM+1
if Rx[W2v]==0 then
if W2v==0 then
call Cdv("Nullpointer exception when calling Context.assign","when calling error in ScmdDataTypes, line 1220")
else
call Cdv("Called Context.assign on invalid object.","when calling error in ScmdDataTypes, line 1220")
endif
endif
call Wyv(W2v,W3v,W4v,"when calling assign in ScmdDataTypes, line 1220")
set EM=EM-1
endfunction
function W6v takes string W7v returns integer
local integer W8v
set ZM[EM]=W7v
set EM=EM+1
if Rm==0 then
if Tm<$8000 then
set Tm=Tm+1
set W8v=Tm
set Ym[W8v]=4814
else
call Cdv("Out of memory: Could not create StringHashList.","when calling error in Utility, line 188")
set W8v=0
endif
else
set Rm=Rm-1
set W8v=fm[Rm]
set Ym[W8v]=4814
endif
set EM=EM-1
return W8v
endfunction
function W9v takes integer yvv returns nothing
set dM[yvv]=0
endfunction
function yev takes integer yxv returns nothing
call W9v(yxv)
endfunction
function yov takes string yrv returns integer
local integer yiv
set ZM[EM]=yrv
set EM=EM+1
set yiv=W6v("when calling alloc_StringHashList in Utility, line 261")
call yev(yiv)
set EM=EM-1
return yiv
endfunction
function yav takes integer ynv,string yVv returns nothing
local integer yEv
set ZM[EM]=yVv
set EM=EM+1
set yEv=0
set CX[ynv]=yEv
set VX[ynv]=false
set BX[ynv]=false
set NX[ynv]=g1v("when calling new_StringHashMap in StringTable, line 50")
set MX[ynv]=yov("when calling new_StringHashList in StringTable, line 51")
set EM=EM-1
endfunction
function yXv takes integer yOv,string yRv returns nothing
set ZM[EM]=yRv
set EM=EM+1
call yav(yOv,"when calling StringTable_init in StringTable, line 43")
set EM=EM-1
endfunction
function yIv takes string yAv returns integer
local integer yNv
set ZM[EM]=yAv
set EM=EM+1
if Tg==0 then
if Yg<$8000 then
set Yg=Yg+1
set yNv=Yg
set Gg[yNv]=$6DB
else
call Cdv("Out of memory: Could not create StringTable.","when calling error in StringTable, line 43")
set yNv=0
endif
else
set Tg=Tg-1
set yNv=Rg[Tg]
set Gg[yNv]=$6DB
endif
set EM=EM-1
return yNv
endfunction
function ybv takes string yBv returns integer
local integer ycv
set ZM[EM]=yBv
set EM=EM+1
set ycv=yIv("when calling alloc_StringTable in StringTable, line 43")
call yXv(ycv,"when calling construct_StringTable in StringTable, line 43")
set EM=EM-1
return ycv
endfunction
function yCv takes string ydv returns integer
local integer yDv
set ZM[EM]=ydv
set EM=EM+1
if YF==0 then
if GF<$8000 then
set GF=GF+1
set yDv=GF
set gF[yDv]=$D20
else
call Cdv("Out of memory: Could not create LinkedList.","when calling error in LinkedList, line 18")
set yDv=0
endif
else
set YF=YF-1
set yDv=TF[YF]
set gF[yDv]=$D20
endif
set EM=EM-1
return yDv
endfunction
function yfv takes integer qNs returns nothing
endfunction
function yFv takes integer ygv,integer yGv,integer yhv,integer yHv returns nothing
call yfv(ygv)
set uP[ygv]=yGv
set rP[ygv]=yhv
set sP[ygv]=yHv
endfunction
function yjv takes string yJv returns integer
local integer ykv
set ZM[EM]=yJv
set EM=EM+1
if eF==0 then
if qF<$8000 then
set qF=qF+1
set ykv=qF
set aF[ykv]=$CAD
else
call Cdv("Out of memory: Could not create LLEntry.","when calling error in LinkedList, line 408")
set ykv=0
endif
else
set eF=eF-1
set ykv=pF[eF]
set aF[ykv]=$CAD
endif
set EM=EM-1
return ykv
endfunction
function yKv takes integer ylv,integer yLv,integer ymv,string yMv returns integer
local integer ypv
set ZM[EM]=yMv
set EM=EM+1
set ypv=yjv("when calling alloc_LLEntry in LinkedList, line 413")
call yFv(ypv,ylv,yLv,ymv)
set EM=EM-1
return ypv
endfunction
function yPv takes integer yqv,string yQv returns nothing
set ZM[EM]=yQv
set EM=EM+1
set oP[yqv]=yKv(0,0,0,"when calling new_LLEntry in LinkedList, line 19")
set OP[yqv]=0
set lP[yqv]=0
set bP[yqv]=0
set EM=EM-1
endfunction
function ysv takes integer ySv,string ytv returns nothing
set ZM[EM]=ytv
set EM=EM+1
call yPv(ySv,"when calling LinkedList_init in LinkedList, line 32")
set sP[oP[ySv]]=oP[ySv]
set rP[oP[ySv]]=oP[ySv]
set EM=EM-1
endfunction
function yTv takes string yuv returns integer
local integer yUv
set ZM[EM]=yuv
set EM=EM+1
set yUv=yCv("when calling alloc_LinkedList in LinkedList, line 32")
call ysv(yUv,"when calling construct_LinkedList2 in LinkedList, line 32")
set EM=EM-1
return yUv
endfunction
function ywv takes nothing returns integer
set i2=0
set S2=.0
set c2=.0
set o2=.0
set O2=.0
set l2=.0
return i2
endfunction
function yWv takes nothing returns integer
set u4=0
return u4
endfunction
function yyv takes nothing returns integer
set o4=0
set O4=0
set l4=0
set b4=0
set y4=0
set p4=0
set e4=yWv()
return o4
endfunction
function yYv takes nothing returns integer
set Q2=0
set W2=0
set E2=.0
set Z2=0
set U2=0
return Q2
endfunction
function yzv takes nothing returns integer
set I2=0
set P2=0
set A2=yYv()
set D2=W2
set H2=E2
set J2=Z2
set K2=U2
set L2=yYv()
set X2=W2
set C2=E2
set V2=Z2
set B2=U2
set N2=0
set M2=0
set w5=0
set u5=0
set r5=0
return I2
endfunction
function yZv takes nothing returns integer
set m4=0
set Q4=.0
set W4=0
set E4=0
set Z4=0
set U4=0
set I4=0
set P4=.0
return m4
endfunction
function y_v takes integer y0v,string y1v returns nothing
local integer y2v
local integer y3v
local integer y4v
local integer y5v
local integer y6v
local integer y7v
local integer y8v
local integer y9v
local integer Yvv
local integer Yev
local integer Yxv
local real Yov
local integer Yrv
local integer Yiv
local integer Yav
local integer Ynv
local integer YVv
local real YEv
local integer YXv
local real YOv
local real YRv
local real YIv
local real YAv
local real YNv
local integer Ybv
local integer YBv
local integer Ycv
local integer YCv
local real Ydv
local integer YDv
local integer Yfv
local integer YFv
local integer Ygv
local real YGv
local integer Yhv
local integer YHv
local integer Yjv
local integer YJv
local integer Ykv
local integer YKv
local integer Ylv
local integer YLv
local real Ymv
local real YMv
set ZM[EM]=y1v
set EM=EM+1
set y2v=0
set YV[y0v]=y2v
set y3v=0
set GV[y0v]=y3v
set gV[y0v]=0
set y4v=yyv()
set y5v=O4
set y6v=l4
set y7v=b4
set y8v=y4
set y9v=p4
set Yvv=e4
set hV[y0v]=y4v
set FV[y0v]=y5v
set kV[y0v]=y6v
set jV[y0v]=y7v
set xV[y0v]=y8v
set vV[y0v]=y9v
set mV[y0v]=Yvv
set Yev=yWv()
set QV[y0v]=Yev
set Yxv=yZv()
set Yov=Q4
set Yrv=W4
set Yiv=E4
set Yav=Z4
set Ynv=U4
set YVv=I4
set YEv=P4
set WV[y0v]=Yxv
set EV[y0v]=Yov
set ZV[y0v]=Yrv
set UV[y0v]=Yiv
set IV[y0v]=Yav
set PV[y0v]=Ynv
set AV[y0v]=YVv
set DV[y0v]=YEv
set YXv=ywv()
set YOv=S2
set YRv=c2
set YIv=o2
set YAv=O2
set YNv=l2
set HV[y0v]=YXv
set JV[y0v]=YOv
set KV[y0v]=YRv
set LV[y0v]=YIv
set XV[y0v]=YAv
set CV[y0v]=YNv
set Ybv=yzv()
set YBv=P2
set Ycv=A2
set YCv=D2
set Ydv=H2
set YDv=J2
set Yfv=K2
set YFv=L2
set Ygv=X2
set YGv=C2
set Yhv=V2
set YHv=B2
set Yjv=N2
set YJv=M2
set Ykv=w5
set YKv=u5
set Ylv=r5
set VV[y0v]=Ybv
set BV[y0v]=YBv
set NV[y0v]=Ycv
set MV[y0v]=YCv
set wB[y0v]=Ydv
set uB[y0v]=YDv
set rB[y0v]=Yfv
set sB[y0v]=YFv
set tB[y0v]=Ygv
set iB[y0v]=YGv
set SB[y0v]=Yhv
set cB[y0v]=YHv
set oB[y0v]=Yjv
set OB[y0v]=YJv
set lB[y0v]=Ykv
set bB[y0v]=YKv
set yB[y0v]=Ylv
set pB[y0v]=yTv("when calling new_LinkedList in UnitData, line 1037")
set eB[y0v]=yTv("when calling new_LinkedList in UnitData, line 1038")
set YLv=0
set qB[y0v]=YLv
set aB[y0v]=0
set nB[y0v]=0
set Ymv=F7v()
set YMv=a1
set dB[y0v]=Ymv
set fB[y0v]=YMv
set RB[y0v]=0
set TB[y0v]=0
set YB[y0v]=yTv("when calling new_LinkedList in UnitData, line 1049")
set EM=EM-1
endfunction
function Ypv takes integer YPv,integer Yqv,string YQv returns nothing
set ZM[EM]=YQv
set EM=EM+1
call y_v(YPv,"when calling SingleUnitData_init in UnitData, line 1058")
set TV[YPv]=Yqv
set EM=EM-1
endfunction
function Ysv takes string YSv returns integer
local integer Ytv
set ZM[EM]=YSv
set EM=EM+1
if Pv==0 then
if Av<$8000 then
set Av=Av+1
set Ytv=Av
set Dv[Ytv]=4646
else
call Cdv("Out of memory: Could not create SingleUnitData.","when calling error in UnitData, line 1018")
set Ytv=0
endif
else
set Pv=Pv-1
set Ytv=Iv[Pv]
set Dv[Ytv]=4646
endif
set EM=EM-1
return Ytv
endfunction
function YTv takes integer Yuv,string YUv returns integer
local integer Ywv
set ZM[EM]=YUv
set EM=EM+1
set Ywv=Ysv("when calling alloc_SingleUnitData in UnitData, line 1058")
call Ypv(Ywv,Yuv,"when calling construct_SingleUnitData in UnitData, line 1058")
set EM=EM-1
return Ywv
endfunction
function YWv takes integer Yyv returns boolean
return OP[Yyv]==0
endfunction
function YYv takes integer Yzv,string YZv returns boolean
local boolean Y_v
set ZM[EM]=YZv
set EM=EM+1
if gF[Yzv]==0 then
if Yzv==0 then
call Cdv("Nullpointer exception when calling LinkedList.isEmpty","when calling error in LinkedList, line 151")
else
call Cdv("Called LinkedList.isEmpty on invalid object.","when calling error in LinkedList, line 151")
endif
endif
set Y_v=YWv(Yzv)
set EM=EM-1
return Y_v
endfunction
function Y0v takes integer Y1v,integer Y2v returns integer
set m2=dpv(Y1v,Y2v)
return m2
endfunction
function Y3v takes integer Y4v returns boolean
return nJ[Y4v]<=dJ[Y4v]
endfunction
function Y5v takes string Y6v returns integer
local integer Y7v
set ZM[EM]=Y6v
set EM=EM+1
if jh==0 then
if xh<$8000 then
set xh=xh+1
set Y7v=xh
set vh[Y7v]=4642
else
call Cdv("Out of memory: Could not create SingleItemData.","when calling error in ItemData, line 44")
set Y7v=0
endif
else
set jh=jh-1
set Y7v=kh[jh]
set vh[Y7v]=4642
endif
set EM=EM-1
return Y7v
endfunction
function Y8v takes integer Y9v returns nothing
local integer zvv=0
local integer zev
local integer zxv
local integer zov
local integer zrv
local integer ziv
local integer zav
set hU[Y9v]=zvv
set zev=0
set FU[Y9v]=zev
set kU[Y9v]=0
set jU[Y9v]=0
set xU[Y9v]=.0
set zxv=yWv()
set vU[Y9v]=zxv
set zov=yWv()
set mU[Y9v]=zov
set zrv=yWv()
set QU[Y9v]=zrv
set ziv=yWv()
set WU[Y9v]=ziv
set zav=yWv()
set EU[Y9v]=zav
endfunction
function znv takes integer zVv,integer zEv returns nothing
call Y8v(zVv)
set gU[zVv]=zEv
endfunction
function zXv takes integer zOv,string zRv returns integer
local integer zIv
set ZM[EM]=zRv
set EM=EM+1
set zIv=Y5v("when calling alloc_SingleItemData in ItemData, line 59")
call znv(zIv,zOv)
set EM=EM-1
return zIv
endfunction
function zAv takes unit zNv returns string
return GetUnitName(zNv)
endfunction
function zbv takes integer zBv returns integer
return zBv
endfunction
function zcv takes unit zCv returns boolean
return IsUnitPaused(zCv)
endfunction
function zdv takes integer zDv,integer zfv,string zFv returns nothing
local integer zgv
set ZM[EM]=zFv
set EM=EM+1
set zgv=yKv(zfv,rP[oP[zDv]],oP[zDv],"when calling new_LLEntry in LinkedList, line 40")
set sP[rP[oP[zDv]]]=zgv
set rP[oP[zDv]]=zgv
set OP[zDv]=OP[zDv]+1
set EM=EM-1
endfunction
function zGv takes integer zhv,integer zHv,string zjv returns nothing
set ZM[EM]=zjv
set EM=EM+1
if gF[zhv]==0 then
if zhv==0 then
call Cdv("Nullpointer exception when calling LinkedList.add","when calling error in LinkedList, line 38")
else
call Cdv("Called LinkedList.add on invalid object.","when calling error in LinkedList, line 38")
endif
endif
call zdv(zhv,zHv,"when calling add in LinkedList, line 38")
set EM=EM-1
endfunction
function zJv takes unit zkv returns integer
return BlzGetUnitMaxHP(zkv)
endfunction
function zKv takes integer PYt returns nothing
endfunction
function zlv takes integer zLv,unit zmv,integer zMv returns nothing
call zKv(zLv)
set aJ[zLv]=C0v(zmv)
set dJ[zLv]=zMv+c8v(Va,aJ[zLv],zMv)*Yn
set nJ[zLv]=zMv+Yn
endfunction
function zpv takes string zPv returns integer
local integer zqv
set ZM[EM]=zPv
set EM=EM+1
if Ij==0 then
if Pj<$8000 then
set Pj=Pj+1
set zqv=Pj
set Aj[zqv]=654
else
call Cdv("Out of memory: Could not create AbilityIterator.","when calling error in SaveableHandles, line 533")
set zqv=0
endif
else
set Ij=Ij-1
set zqv=Uj[Ij]
set Aj[zqv]=654
endif
set EM=EM-1
return zqv
endfunction
function zQv takes unit zsv,integer zSv,string ztv returns integer
local integer zTv
set ZM[EM]=ztv
set EM=EM+1
set zTv=zpv("when calling alloc_AbilityIterator in SaveableHandles, line 538")
call zlv(zTv,zsv,zSv)
set EM=EM-1
return zTv
endfunction
function zuv takes unit zUv,string zwv returns integer
local integer zWv
set ZM[EM]=zwv
set EM=EM+1
set zWv=zQv(zUv,Rn,"when calling new_AbilityIterator in SaveableHandles, line 561")
set EM=EM-1
return zWv
endfunction
function zyv takes integer NYt returns nothing
endfunction
function zYv takes integer zzv,string zZv returns nothing
set ZM[EM]=zZv
set EM=EM+1
if Aj[zzv]==0 then
call Cdv("Double free: object of type AbilityIterator","when calling error in SaveableHandles, line 533")
else
set Uj[Ij]=zzv
set Ij=Ij+1
set Aj[zzv]=0
endif
set EM=EM-1
endfunction
function z_v takes integer z0v,string z1v returns nothing
set ZM[EM]=z1v
set EM=EM+1
call zyv(z0v)
call zYv(z0v,"when calling dealloc_AbilityIterator in SaveableHandles, line 533")
set EM=EM-1
endfunction
function z2v takes integer z3v,string z4v returns nothing
set ZM[EM]=z4v
set EM=EM+1
if Aj[z3v]==0 then
if z3v==0 then
call Cdv("Nullpointer exception when calling AbilityIterator.AbilityIterator","when calling error in SaveableHandles, line 533")
else
call Cdv("Called AbilityIterator.AbilityIterator on invalid object.","when calling error in SaveableHandles, line 533")
endif
endif
call z_v(z3v,"when calling destroyAbilityIterator in SaveableHandles, line 533")
set EM=EM-1
endfunction
function z5v takes integer z6v,string z7v returns nothing
set ZM[EM]=z7v
set EM=EM+1
call z2v(z6v,"when calling dispatch_AbilityIterator_destroyAbilityIterator in SaveableHandles, line 552")
set EM=EM-1
endfunction
function z8v takes integer z9v,integer Zvv returns integer
set M5=dpv(z9v,Zvv)
return M5
endfunction
function Zev takes unit Zxv returns string
return GetHeroProperName(Zxv)
endfunction
function Zov takes unit Zrv,boolean Ziv returns integer
return GetHeroInt(Zrv,Ziv)
endfunction
function Zav takes unit Znv,boolean ZVv returns integer
return GetHeroStr(Znv,ZVv)
endfunction
function ZEv takes integer ZXv,integer ZOv returns integer
set c4=dpv(ZXv,ZOv)
return c4
endfunction
function ZRv takes integer ZIv,integer ZAv returns integer
set S4=dpv(ZIv,ZAv)
return S4
endfunction
function ZNv takes unit Zbv,integer ZBv,boolean Zcv returns nothing
call SetHeroXP(Zbv,ZBv,Zcv)
endfunction
function ZCv takes integer Zdv,string ZDv returns nothing
call k3v(BT,Zdv,dM[Zdv],ZDv)
set dM[Zdv]=dM[Zdv]+1
endfunction
function Zfv takes integer ZFv,string Zgv,string ZGv returns nothing
set ZM[EM]=ZGv
set EM=EM+1
if Ym[ZFv]==0 then
if ZFv==0 then
call Cdv("Nullpointer exception when calling StringHashList.add","when calling error in Utility, line 194")
else
call Cdv("Called StringHashList.add on invalid object.","when calling error in Utility, line 194")
endif
endif
call ZCv(ZFv,Zgv)
set EM=EM-1
endfunction
function Zhv takes integer ZHv,string Zjv returns boolean
local integer ZJv=Ccv(Zjv)
local integer Zkv=c8v(fM[ZHv],ZJv,-1)
local integer ZKv=0
local integer Zlv=Zkv-1
loop
exitwhen ZKv>Zlv
if G0v(fM[ZHv],ZJv,ZKv)==Zjv then
return true
endif
set ZKv=ZKv+1
endloop
return false
endfunction
function ZLv takes integer Zmv,string ZMv,string Zpv returns boolean
local boolean ZPv
set ZM[EM]=Zpv
set EM=EM+1
if Fm[Zmv]==0 then
if Zmv==0 then
call Cdv("Nullpointer exception when calling StringHashMap.has","when calling error in Utility, line 119")
else
call Cdv("Called StringHashMap.has on invalid object.","when calling error in Utility, line 119")
endif
endif
set ZPv=Zhv(Zmv,ZMv)
set EM=EM-1
return ZPv
endfunction
function Zqv takes integer ZQv,string Zsv,integer ZSv returns boolean
local integer Ztv=Ccv(Zsv)
local integer ZTv=c8v(fM[ZQv],Ztv,-1)
local boolean Zuv=false
local integer ZUv=0
local integer Zwv=ZTv-1
loop
exitwhen ZUv>Zwv
if G0v(fM[ZQv],Ztv,ZUv)==Zsv then
call Cxv(RM[ZQv],Ztv,ZUv,ZSv)
set Zuv=true
exitwhen true
endif
set ZUv=ZUv+1
endloop
if not Zuv then
call Cxv(fM[ZQv],Ztv,-1,ZTv+1)
call k3v(fM[ZQv],Ztv,ZTv,Zsv)
call Cxv(RM[ZQv],Ztv,ZTv,ZSv)
endif
return not Zuv
endfunction
function ZWv takes integer Zyv,string ZYv,integer Zzv,string ZZv returns boolean
local boolean Z_v
set ZM[EM]=ZZv
set EM=EM+1
if Fm[Zyv]==0 then
if Zyv==0 then
call Cdv("Nullpointer exception when calling StringHashMap.put","when calling error in Utility, line 90")
else
call Cdv("Called StringHashMap.put on invalid object.","when calling error in Utility, line 90")
endif
endif
set Z_v=Zqv(Zyv,ZYv,Zzv)
set EM=EM-1
return Z_v
endfunction
function Z0v takes integer Z1v returns integer
return dM[Z1v]
endfunction
function Z2v takes integer Z3v,string Z4v returns integer
local integer Z5v
set ZM[EM]=Z4v
set EM=EM+1
if Ym[Z3v]==0 then
if Z3v==0 then
call Cdv("Nullpointer exception when calling StringHashList.size","when calling error in Utility, line 231")
else
call Cdv("Called StringHashList.size on invalid object.","when calling error in Utility, line 231")
endif
endif
set Z5v=Z0v(Z3v)
set EM=EM-1
return Z5v
endfunction
function Z6v takes integer Z7v,string Z8v,string Z9v returns integer
local integer vve
local integer vee
local integer vxe
local integer voe
set ZM[EM]=Z9v
set EM=EM+1
if ZLv(NX[Z7v],Z8v,"when calling has in StringTable, line 54")then
set vxe=hIv(NX[Z7v],Z8v,"when calling get in StringTable, line 55")
set vee=vxe
set EM=EM-1
set zb=vee
return zb
endif
call ZWv(NX[Z7v],Z8v,Z2v(MX[Z7v],"when calling size in StringTable, line 56"),"when calling put in StringTable, line 56")
call Zfv(MX[Z7v],Z8v,"when calling add in StringTable, line 57")
set voe=Z2v(MX[Z7v],"when calling size in StringTable, line 58")-1
set vve=voe
set EM=EM-1
set zb=vve
return zb
endfunction
function vre takes integer vie,string vae,string vne returns integer
local integer vVe
local integer vEe
set ZM[EM]=vne
set EM=EM+1
if Gg[vie]==0 then
if vie==0 then
call Cdv("Nullpointer exception when calling StringTable.addString","when calling error in StringTable, line 53")
else
call Cdv("Called StringTable.addString on invalid object.","when calling error in StringTable, line 53")
endif
endif
set vEe=Z6v(vie,vae,"when calling addString in StringTable, line 53")
set vVe=vEe
set EM=EM-1
set q4=vVe
return q4
endfunction
function vXe takes unit vOe returns integer
return GetHeroXP(vOe)
endfunction
function vRe takes unit vIe returns boolean
return IsSuspendedXP(vIe)
endfunction
function vAe takes player vNe,integer vbe,real vBe,real vce,real vCe returns unit
return CreateUnit(vNe,vbe,vBe,vce,T6v(vCe))
endfunction
function vde takes real vDe returns real
set UM=vDe*ly
return UM
endfunction
function vfe takes unit vFe,integer vge,string vGe returns integer
local integer vhe
local integer vHe
local integer vje
local integer vJe
local unit vke
local unit vKe
local integer vle
local integer vLe
local integer vme
local integer vMe
local integer vpe
local integer vPe
local integer vqe
local integer vQe
local integer vse
local integer vSe
local integer vte
local integer vTe
local integer vue
local integer vUe
local integer vwe
local integer vWe
local integer vye
local integer vYe
local integer vze
local integer vZe
set ZM[EM]=vGe
set EM=EM+1
set vhe=umv(vFe)
set vpe=0
set vHe=vpe
set vPe=0
set vje=vPe
set vJe=vXe(vFe)
if vRe(vFe)then
set vqe=ZRv(vHe,0)
set vHe=vqe
endif
set vKe=vAe(Ty,vhe,.0,.0,vde(.0))
call ZNv(vKe,vJe,false)
set vke=vKe
set vle=Zav(vFe,false)
if vle!=Zav(vke,false)then
set vQe=ZRv(vHe,1)
set vHe=vQe
if vle>$FF then
set vse=ZRv(vHe,2)
set vHe=vse
if vle>$FFFF then
set vSe=ZRv(vHe,7)
set vHe=vSe
set vte=ZEv(vje,0)
set vje=vte
endif
endif
endif
set vLe=WAv(vFe,false)
if vLe!=WAv(vke,false)then
set vTe=ZRv(vHe,3)
set vHe=vTe
if vLe>$FF then
set vue=ZRv(vHe,4)
set vHe=vue
if vLe>$FFFF then
set vUe=ZRv(vHe,7)
set vHe=vUe
set vwe=ZEv(vje,1)
set vje=vwe
endif
endif
endif
set vme=Zov(vFe,false)
if vme!=Zov(vke,false)then
set vWe=ZRv(vHe,5)
set vHe=vWe
if vme>$FF then
set vye=ZRv(vHe,6)
set vHe=vye
if vme>$FFFF then
set vYe=ZRv(vHe,7)
set vHe=vYe
set vze=ZEv(vje,2)
set vje=vze
endif
endif
endif
call PFv(vke)
set vZe=vre(vge,Zev(vFe),"when calling addString in UnitData, line 97")
set vMe=vZe
set EM=EM-1
set a4=vHe
set n4=vje
set d4=vJe
set f4=vle
set R4=vLe
set T4=vme
set Y4=vMe
set vke=null
set vKe=null
return a4
endfunction
function v_e takes integer v0e returns integer
return usv(v0e,"defType")
endfunction
function v1e takes unit v2e returns boolean
return CYv(Va,C0v(v2e),On)
endfunction
function v3e takes unit v4e returns integer
local integer v5e=C0v(v4e)
set m1=c8v(Va,v5e,ln)
set Q1=c8v(Va,v5e,bn)
set W1=c8v(Va,v5e,yn)
set E1=c8v(Va,v5e,pn)
return m1
endfunction
function v6e takes unit v7e returns boolean
return c2v(Va,C0v(v7e),ln)
endfunction
function v8e takes unit v9e returns playercolor
return tWv(c8v(Va,C0v(v9e),cn))
endfunction
function eve takes unit eee returns boolean
return c2v(Va,C0v(eee),cn)
endfunction
function exe takes unit eoe returns boolean
return CYv(Va,C0v(eoe),an)
endfunction
function ere takes unit eie returns real
return DFv(Va,C0v(eie),On)
endfunction
function eae takes integer ene,integer eVe returns integer
set v4=dpv(ene,eVe)
return v4
endfunction
function eEe takes unit eXe returns real
return DFv(Va,C0v(eXe),an)
endfunction
function eOe takes unit eRe returns integer
local integer eIe=0
local integer eAe=eIe
local real eNe=.0
local integer ebe
local integer eBe
local integer ece
local integer eCe
local integer ede
local integer eDe
local integer efe
local real eFe
local integer ege
local integer eGe
local integer ehe
local integer eHe
local integer eje
local integer eJe
local integer eke
local integer eKe
local integer ele
local integer eLe
local integer eme
local integer eMe
local integer epe
local integer ePe
local integer eqe
local integer eQe
local integer ese
local integer eSe
if exe(eRe)then
set ehe=eae(eAe,0)
set eAe=ehe
set eNe=eEe(eRe)
set ebe=c6v(eNe)
if DQv(ebe)==eNe and ebe<=$FF then
set eHe=eae(eAe,1)
set eAe=eHe
else
set eBe=c6v(eNe*10.)
if eBe*1./$A==eNe and eBe<=$FFFF then
set eje=eae(eAe,2)
set eAe=eje
endif
endif
endif
set ece=0
if eve(eRe)then
set eJe=eae(eAe,3)
set eAe=eJe
set ece=tpv(v8e(eRe))
endif
set eke=0
set eKe=0
set ele=0
set eLe=0
set eCe=eke
set ede=eKe
set eDe=ele
set efe=eLe
if v6e(eRe)then
set eme=eae(eAe,4)
set eAe=eme
set eMe=v3e(eRe)
set epe=Q1
set ePe=W1
set eqe=E1
set eCe=eMe
set ede=epe
set eDe=ePe
set efe=eqe
endif
set eFe=.0
if v1e(eRe)then
set eQe=eae(eAe,5)
set eAe=eQe
set eFe=ere(eRe)
set ege=c6v(eFe*100.)
if ege*1./'d'==eFe and ege>=0 and ege<=$FF then
set ese=eae(eAe,6)
set eAe=ese
else
set eGe=c6v(eFe*1000.)+$7FFF
if(eGe-$7FFF)*1./$3E8==eFe and eGe>=0 and eGe<=$FFFF then
set eSe=eae(eAe,7)
set eAe=eSe
endif
endif
endif
set A4=eAe
set D4=eNe
set H4=ece
set J4=eCe
set K4=ede
set L4=eDe
set X4=efe
set C4=eFe
return A4
endfunction
function ete takes unit eTe returns boolean
return CYv(Va,C0v(eTe),nn)
endfunction
function eue takes real eUe returns real
set IM=eUe*ly
return IM
endfunction
function ewe takes unit eWe returns real
set y2=eue(GetUnitDefaultPropWindow(eWe))
return y2
endfunction
function eye takes unit eYe returns real
return DFv(Va,C0v(eYe),nn)
endfunction
function eze takes unit eZe returns real
return GetUnitDefaultTurnSpeed(eZe)
endfunction
function e_e takes unit e0e returns real
set b2=GetUnitPropWindow(e0e)
return b2
endfunction
function e1e takes unit e2e returns real
return DFv(Va,C0v(e2e),en)
endfunction
function e3e takes integer e4e,integer e5e returns integer
set t2=dpv(e4e,e5e)
return t2
endfunction
function e6e takes real e7e returns real
return e7e
endfunction
function e8e takes unit e9e returns real
return GetUnitTurnSpeed(e9e)
endfunction
function xve takes unit xee returns boolean
return CYv(Va,C0v(xee),en)
endfunction
function xxe takes unit xoe returns integer
local integer xre=0
local integer xie=xre
local real xae=.0
local integer xne
local real xVe
local real xEe
local integer xXe
local integer xOe
local real xRe
local real xIe
local integer xAe
local integer xNe
local integer xbe
local integer xBe
local integer xce
local integer xCe
local integer xde
local integer xDe
if xve(xoe)then
set xAe=e3e(xie,0)
set xie=xAe
set xae=e1e(xoe)
set xne=c6v(xae*10.)
if xne*1./$A==xae and xne<=$FFFF then
set xNe=e3e(xie,1)
set xie=xNe
endif
endif
set xVe=.0
if e8e(xoe)!=eze(xoe)then
set xbe=e3e(xie,2)
set xie=xbe
set xVe=e8e(xoe)
endif
set xEe=.0
if q6v(xoe)then
set xBe=e3e(xie,3)
set xie=xBe
set xEe=q8v(xoe)
set xXe=c6v(xEe*100.)
if xXe*1./'d'==xEe and xXe<=$FF then
set xce=e3e(xie,4)
set xie=xce
else
set xOe=c6v(xEe*1000.)
if xOe*1./$3E8==xEe and xOe<=$FFFF then
set xCe=e3e(xie,5)
set xie=xCe
endif
endif
endif
set xRe=.0
if ete(xoe)then
set xde=e3e(xie,6)
set xie=xde
set xRe=eye(xoe)
endif
set xIe=.0
if e_e(xoe)!=ewe(xoe)then
set xDe=e3e(xie,7)
set xie=xDe
set xIe=e6e(e_e(xoe))
endif
set p2=xie
set e2=xae
set q2=xVe
set a2=xEe
set n2=xRe
set d2=xIe
return p2
endfunction
function xfe takes integer gGt returns nothing
endfunction
function xFe takes integer xge,string xGe returns nothing
set ZM[EM]=xGe
set EM=EM+1
if Kj[xge]==0 then
call Cdv("Double free: object of type AnimationPropertiesIterator","when calling error in SaveableHandles, line 566")
else
set Dj[Hj]=xge
set Hj=Hj+1
set Kj[xge]=0
endif
set EM=EM-1
endfunction
function xhe takes integer xHe,string xje returns nothing
set ZM[EM]=xje
set EM=EM+1
call xfe(xHe)
call xFe(xHe,"when calling dealloc_AnimationPropertiesIterator in SaveableHandles, line 566")
set EM=EM-1
endfunction
function xJe takes integer xke,string xKe returns nothing
set ZM[EM]=xKe
set EM=EM+1
if Kj[xke]==0 then
if xke==0 then
call Cdv("Nullpointer exception when calling AnimationPropertiesIterator.AnimationPropertiesIterator","when calling error in SaveableHandles, line 566")
else
call Cdv("Called AnimationPropertiesIterator.AnimationPropertiesIterator on invalid object.","when calling error in SaveableHandles, line 566")
endif
endif
call xhe(xke,"when calling destroyAnimationPropertiesIterator in SaveableHandles, line 566")
set EM=EM-1
endfunction
function xle takes integer xLe,string xme returns nothing
set ZM[EM]=xme
set EM=EM+1
call xJe(xLe,"when calling dispatch_AnimationPropertiesIterator_destroyAnimationPropertiesIterator in SaveableHandles, line 585")
set EM=EM-1
endfunction
function xMe takes integer xpe,integer xPe,integer xqe,string xQe returns nothing
if xPe<0 or xPe>=6 then
call Cdv("Index out of Bounds",xQe)
elseif xPe<=2 then
if xPe<=1 then
if xPe<=0 then
set az[xpe]=xqe
else
set nz[xpe]=xqe
endif
else
set Vz[xpe]=xqe
endif
elseif xPe<=4 then
if xPe<=3 then
set Ez[xpe]=xqe
else
set Xz[xpe]=xqe
endif
else
set Oz[xpe]=xqe
endif
endfunction
function xse takes integer xSe returns integer
return usv(xSe,"armor")
endfunction
function xte takes integer xTe,integer xue returns integer
set w6=Dav(xTe,xue)
return w6
endfunction
function xUe takes unit xwe,unitstate xWe returns real
return GetUnitState(xwe,xWe)
endfunction
function xye takes unit xYe returns real
return xUe(xYe,UNIT_STATE_LIFE)
endfunction
function xze takes unit xZe,unittype x_e returns boolean
return IsUnitType(xZe,x_e)
endfunction
function x0e takes integer x1e,integer x2e returns integer
set j2=dpv(x1e,x2e)
return j2
endfunction
function x3e takes unit x4e returns integer
local integer x5e=0
local integer x6e=x5e
local integer x7e
if xze(x4e,UNIT_TYPE_TOWNHALL)then
set x7e=x0e(x6e,0)
set x6e=x7e
endif
set v2=x6e
return v2
endfunction
function x8e takes unit x9e,integer ove returns boolean
return GetUnitAbilityLevel(x9e,ove)>0
endfunction
function oee takes unit oxe,integer ooe returns boolean
local integer ore=ooe
if ore==0 then
return x8e(oxe,'AaI0')
elseif ore==1 then
return x8e(oxe,'AaI1')
elseif ore==2 then
return x8e(oxe,'AAI2')
else
return false
endif
endfunction
function oie takes integer oae,integer one returns integer
return usv(oae,"dice"+SMv(one))
endfunction
function oVe takes unit oEe,integer oXe returns integer
return BlzGetUnitDiceSides(oEe,oXe)
endfunction
function oOe takes integer oRe,integer oIe returns real
return d9v(oRe,"cool"+SMv(oIe))
endfunction
function oAe takes unit oNe,integer obe returns real
return BlzGetUnitAttackCooldown(oNe,obe)
endfunction
function oBe takes unit oce,integer oCe returns integer
return BlzGetUnitDiceNumber(oce,oCe)
endfunction
function ode takes integer oDe,integer ofe returns integer
return usv(oDe,"sides"+SMv(ofe))
endfunction
function oFe takes integer oge,integer oGe returns integer
return usv(oge,"dmgplus"+SMv(oGe))
endfunction
function ohe takes integer oHe,integer oje returns integer
set h5=dpv(oHe,oje)
return h5
endfunction
function oJe takes unit oke,integer oKe returns integer
local integer ole=umv(oke)
local integer oLe=Ufv(oke,oKe)
local real ome=oAe(oke,oKe)
local integer oMe=oVe(oke,oKe)
local integer ope=oBe(oke,oKe)
local integer oPe=0
local integer oqe=oPe
local integer oQe
local integer ose
local integer oSe
local integer ote
local integer oTe
local integer oue
local integer oUe
local integer owe
local integer oWe
if oLe!=oFe(ole,oKe)then
set ose=ohe(oqe,0)
set oqe=ose
if oLe>$FF or oLe<0 then
set oSe=ohe(oqe,1)
set oqe=oSe
endif
endif
if ome!=oOe(ole,oKe)then
set ote=ohe(oqe,2)
set oqe=ote
set oQe=c6v(ome*100.)
if oQe*1./'d'==ome and oQe<=$FF then
set oTe=ohe(oqe,3)
set oqe=oTe
endif
endif
if oMe!=ode(ole,oKe)then
set oue=ohe(oqe,4)
set oqe=oue
if oMe>$FF then
set oUe=ohe(oqe,5)
set oqe=oUe
endif
endif
if ope!=oie(ole,oKe)then
set owe=ohe(oqe,6)
set oqe=owe
if ope>$FF then
set oWe=ohe(oqe,7)
set oqe=oWe
endif
endif
set s5=oqe
set t5=oLe
set i5=ome
set S5=oMe
set c5=ope
return s5
endfunction
function oye takes integer oYe,integer oze returns integer
set h2=dpv(oYe,oze)
return h2
endfunction
function oZe takes integer o_e returns integer
local integer o0e=0
local integer o1e=o0e
local integer o2e
local integer o3e
local integer o4e
local integer o5e
local integer o6e
local integer o7e
local integer o8e
local integer o9e
if IsUnitIdType(o_e,UNIT_TYPE_GIANT)then
set o2e=oye(o1e,0)
set o1e=o2e
endif
if IsUnitIdType(o_e,UNIT_TYPE_SUMMONED)then
set o3e=oye(o1e,1)
set o1e=o3e
endif
if IsUnitIdType(o_e,UNIT_TYPE_UNDEAD)then
set o4e=oye(o1e,2)
set o1e=o4e
endif
if IsUnitIdType(o_e,UNIT_TYPE_MECHANICAL)then
set o5e=oye(o1e,3)
set o1e=o5e
endif
if IsUnitIdType(o_e,UNIT_TYPE_PEON)then
set o6e=oye(o1e,4)
set o1e=o6e
endif
if IsUnitIdType(o_e,UNIT_TYPE_SAPPER)then
set o7e=oye(o1e,5)
set o1e=o7e
endif
if IsUnitIdType(o_e,UNIT_TYPE_ANCIENT)then
set o8e=oye(o1e,6)
set o1e=o8e
endif
if IsUnitIdType(o_e,UNIT_TYPE_TAUREN)then
set o9e=oye(o1e,7)
set o1e=o9e
endif
set F2=o1e
return F2
endfunction
function rve takes integer ree,string rxe returns nothing
set ZM[EM]=rxe
set EM=EM+1
if Aj[ree]==0 then
if ree==0 then
call Cdv("Nullpointer exception when calling AbilityIterator.close","when calling error in SaveableHandles, line 551")
else
call Cdv("Called AbilityIterator.close on invalid object.","when calling error in SaveableHandles, line 551")
endif
endif
call z5v(ree,"when calling close in SaveableHandles, line 551")
set EM=EM-1
endfunction
function roe takes unit rre returns integer
local integer rie=0
local integer rae=rie
local integer rne
local integer rVe
local integer rEe
local integer rXe
local integer rOe
local integer rRe
local integer rIe
local integer rAe
if xze(rre,UNIT_TYPE_GIANT)then
set rne=oye(rae,0)
set rae=rne
endif
if xze(rre,UNIT_TYPE_SUMMONED)then
set rVe=oye(rae,1)
set rae=rVe
endif
if xze(rre,UNIT_TYPE_UNDEAD)then
set rEe=oye(rae,2)
set rae=rEe
endif
if xze(rre,UNIT_TYPE_MECHANICAL)then
set rXe=oye(rae,3)
set rae=rXe
endif
if xze(rre,UNIT_TYPE_PEON)then
set rOe=oye(rae,4)
set rae=rOe
endif
if xze(rre,UNIT_TYPE_SAPPER)then
set rRe=oye(rae,5)
set rae=rRe
endif
if xze(rre,UNIT_TYPE_ANCIENT)then
set rIe=oye(rae,6)
set rae=rIe
endif
if xze(rre,UNIT_TYPE_TAUREN)then
set rAe=oye(rae,7)
set rae=rAe
endif
set k2=rae
return k2
endfunction
function rNe takes integer rbe returns integer
local integer rBe=0
local integer rce=rBe
local integer rCe
if IsUnitIdType(rbe,UNIT_TYPE_TOWNHALL)then
set rCe=x0e(rce,0)
set rce=rCe
endif
set x2=rce
return x2
endfunction
function rde takes unit rDe returns integer
return UnitInventorySize(rDe)
endfunction
function rfe takes unit rFe,string rge returns integer
local integer rGe
set ZM[EM]=rge
set EM=EM+1
set rGe=zQv(rFe,fn,"when calling new_AbilityIterator in SaveableHandles, line 558")
set EM=EM-1
return rGe
endfunction
function rhe takes integer rHe returns integer
return usv(rHe,"manaN")
endfunction
function rje takes unit rJe,string rke returns integer
local integer rKe
set ZM[EM]=rke
set EM=EM+1
set rKe=zQv(rJe,dn,"when calling new_AbilityIterator in SaveableHandles, line 564")
set EM=EM-1
return rKe
endfunction
function rle takes integer rLe returns integer
return usv(rLe,"HP")
endfunction
function rme takes integer rMe,string rpe returns boolean
local boolean rPe
set ZM[EM]=rpe
set EM=EM+1
if Aj[rMe]==0 then
if rMe==0 then
call Cdv("Nullpointer exception when calling AbilityIterator.hasNext","when calling error in SaveableHandles, line 543")
else
call Cdv("Called AbilityIterator.hasNext on invalid object.","when calling error in SaveableHandles, line 543")
endif
endif
set rPe=Y3v(rMe)
set EM=EM-1
return rPe
endfunction
function rqe takes unit rQe,string rse returns integer
local integer rSe
local integer rte
local integer rTe
local integer rue
local integer rUe
local real rwe
local integer rWe
local integer rye
local integer rYe
local integer rze
local real rZe
local integer r_e
local integer r0e
local integer r1e
local integer r2e
local real r3e
local integer r4e
local integer r5e
local integer r6e
local integer r7e
local integer r8e
local integer r9e
local integer ive
local integer iee
local integer ixe
local integer ioe
local integer ire
local integer iie
local integer iae
local integer ine
local integer iVe
local integer iEe
local integer iXe
local integer iOe
local real iRe
local integer iIe
local integer iAe
local integer iNe
local integer ibe
local real iBe
local integer ice
local integer iCe
local integer ide
local integer iDe
local integer ife
local real iFe
local integer ige
local integer iGe
local integer ihe
local integer iHe
local real ije
local integer iJe
local integer ike
local integer iKe
local integer ile
local integer iLe
local integer ime
local real iMe
local integer ipe
local integer iPe
local integer iqe
local integer iQe
local integer ise
local integer iSe
local integer ite
local integer iTe
local integer iue
local integer iUe
local integer iwe
local integer iWe
local integer iye
local integer iYe
local integer ize
set ZM[EM]=rse
set EM=EM+1
set rSe=umv(rQe)
set iie=0
set rte=iie
set rTe=0
if rde(rQe)!=0 then
set iae=Y0v(rte,0)
set rte=iae
set rTe=rde(rQe)
endif
if oee(rQe,0)then
set ine=Y0v(rte,1)
set rte=ine
endif
if oee(rQe,1)then
set iVe=Y0v(rte,2)
set rte=iVe
endif
if oee(rQe,2)then
set iEe=Y0v(rte,3)
set rte=iEe
endif
set iXe=yYv()
set iOe=W2
set iRe=E2
set iIe=Z2
set iAe=U2
set rue=iXe
set rUe=iOe
set rwe=iRe
set rWe=iIe
set rye=iAe
set iNe=oJe(rQe,0)
set ibe=t5
set iBe=i5
set ice=S5
set iCe=c5
set rYe=iNe
set rze=ibe
set rZe=iBe
set r_e=ice
set r0e=iCe
if rYe!=0 then
set ide=Y0v(rte,4)
set rte=ide
set iDe=rYe
set ife=rze
set iFe=rZe
set ige=r_e
set iGe=r0e
set rue=iDe
set rUe=ife
set rwe=iFe
set rWe=ige
set rye=iGe
endif
set ihe=yYv()
set iHe=W2
set ije=E2
set iJe=Z2
set ike=U2
set r1e=ihe
set r2e=iHe
set r3e=ije
set r4e=iJe
set r5e=ike
set iKe=oJe(rQe,1)
set r6e=iKe
if r6e!=0 then
set ile=Y0v(rte,5)
set rte=ile
set iLe=rYe
set ime=rze
set iMe=rZe
set ipe=r_e
set iPe=r0e
set r1e=iLe
set r2e=ime
set r3e=iMe
set r4e=ipe
set r5e=iPe
endif
set r7e=0
if upv(rQe)then
set iqe=Y0v(rte,6)
set rte=iqe
set r7e=uUv(rQe)
if r7e>=0 and r7e<=$FF then
set iQe=Y0v(rte,7)
set rte=iQe
endif
endif
set r8e=zJv(rQe)
if r8e!=rle(rSe)then
set ise=Y0v(rte,8)
set rte=ise
if r8e<=$FFFF then
set iSe=Y0v(rte,9)
set rte=iSe
endif
endif
set r9e=Shv(rQe)
if r9e!=rhe(rSe)then
set ite=Y0v(rte,$A)
set rte=ite
if r9e<=$FFFF then
set iTe=Y0v(rte,$B)
set rte=iTe
endif
endif
set ive=rfe(rQe,"when calling removedAbilities in UnitData, line 616")
if rme(ive,"when calling hasNext in UnitData, line 617")then
set iue=Y0v(rte,$C)
set rte=iue
endif
call rve(ive,"when calling close in UnitData, line 619")
set iee=zuv(rQe,"when calling modifiedAbilities in UnitData, line 620")
if rme(iee,"when calling hasNext in UnitData, line 621")then
set iUe=Y0v(rte,$D)
set rte=iUe
else
set ixe=rje(rQe,"when calling addedAbilities in UnitData, line 624")
if rme(ixe,"when calling hasNext in UnitData, line 625")then
set iwe=Y0v(rte,$D)
set rte=iwe
endif
call rve(ixe,"when calling close in UnitData, line 627")
endif
call rve(iee,"when calling close in UnitData, line 628")
set iWe=roe(rQe)
set ioe=iWe
if ioe!=oZe(rSe)then
set iye=Y0v(rte,$E)
set rte=iye
endif
set iYe=x3e(rQe)
set ire=iYe
if ire!=rNe(rSe)then
set ize=Y0v(rte,$F)
set rte=ize
endif
set EM=EM-1
set o5=rte
set O5=rTe
set l5=rue
set b5=rUe
set y5=rwe
set p5=rWe
set e5=rye
set q5=r1e
set a5=r2e
set n5=r3e
set d5=r4e
set f5=r5e
set R5=r7e
set T5=r8e
set Y5=r9e
set G5=ioe
set g5=ire
return o5
endfunction
function iZe takes item i_e returns integer
return GetItemTypeId(i_e)
endfunction
function i0e takes item i1e returns boolean
return cZv(Va,C0v(i1e),tn)
endfunction
function i2e takes integer i3e,integer i4e returns integer
set M3=dpv(i3e,i4e)
return M3
endfunction
function i5e takes item i6e returns nothing
call RemoveItem(i6e)
endfunction
function i7e takes item i8e returns boolean
local boolean i9e
if cWv(Va,C0v(i8e),sn)then
set i9e=cZv(Va,C0v(i8e),sn)
else
set i9e=true
endif
return i9e
endfunction
function ave takes item aee returns string
return BlzGetItemDescription(aee)
endfunction
function axe takes item aoe returns boolean
return IsItemInvulnerable(aoe)
endfunction
function are takes item aie returns string
return BlzGetItemIconPath(aie)
endfunction
function aae takes widget ane returns real
return GetWidgetLife(ane)
endfunction
function aVe takes item aEe returns string
return BlzGetItemTooltip(aEe)
endfunction
function aXe takes item aOe returns integer
return GetItemCharges(aOe)
endfunction
function aRe takes integer aIe,integer aAe returns integer
set N3=dpv(aIe,aAe)
return N3
endfunction
function aNe takes item abe returns boolean
return IsItemPawnable(abe)
endfunction
function aBe takes item ace returns string
return GetItemName(ace)
endfunction
function aCe takes real ade,real aDe returns real
set w1=ade
set u1=aDe
set r1=.0
return w1
endfunction
function afe takes integer aFe,real age,real aGe,real EGu returns item
return CreateItem(aFe,age,aGe)
endfunction
function ahe takes integer aHe,real aje,real aJe returns item
return afe(aHe,aCe(aje,aJe),u1,r1)
endfunction
function ake takes item aKe returns string
return BlzGetItemExtendedTooltip(aKe)
endfunction
function ale takes integer aLe returns integer
return usv(aLe,"HP")
endfunction
function ame takes integer aMe,item ape,string aPe returns nothing
local integer aqe
local item aQe
local integer ase
local integer aSe
local integer ate
local integer aTe
local integer aue
local integer aUe
local integer awe
local integer aWe
local integer aye
local integer aYe
local integer aze
local integer aZe
local integer a_e
local integer a0e
local integer a1e
local integer a2e
local integer a3e
local integer a4e
local integer a5e
local integer a6e
local integer a7e
set ZM[EM]=aPe
set EM=EM+1
set kU[aMe]=iZe(ape)
set ase=0
set hU[aMe]=ase
if axe(ape)then
set aSe=aRe(hU[aMe],0)
set hU[aMe]=aSe
endif
if i0e(ape)then
set ate=aRe(hU[aMe],1)
set hU[aMe]=ate
endif
if i7e(ape)then
set aTe=aRe(hU[aMe],2)
set hU[aMe]=aTe
endif
if aNe(ape)then
set aue=aRe(hU[aMe],3)
set hU[aMe]=aue
endif
set jU[aMe]=aXe(ape)
set aqe=jU[aMe]
if aqe==0 then
set aUe=aRe(hU[aMe],4)
set hU[aMe]=aUe
elseif aqe==1 then
set awe=aRe(hU[aMe],5)
set hU[aMe]=awe
elseif jU[aMe]>$FF then
set aWe=aRe(hU[aMe],6)
set hU[aMe]=aWe
if jU[aMe]>$FFFF then
set aye=aRe(hU[aMe],4)
set hU[aMe]=aye
endif
endif
if aae(ape)!=DQv(ale(kU[aMe]))then
set aYe=i2e(FU[aMe],0)
set FU[aMe]=aYe
set xU[aMe]=aae(ape)
endif
set aQe=ahe(kU[aMe],.0,.0)
if aBe(ape)!=aBe(aQe)then
set aze=i2e(FU[aMe],1)
set FU[aMe]=aze
set aZe=vre(gU[aMe],aBe(ape),"when calling addString in ItemData, line 93")
set vU[aMe]=aZe
endif
if ave(ape)!=ave(aQe)then
set a_e=i2e(FU[aMe],2)
set FU[aMe]=a_e
set a0e=vre(gU[aMe],ave(ape),"when calling addString in ItemData, line 96")
set mU[aMe]=a0e
endif
if aVe(ape)!=aVe(aQe)then
set a1e=i2e(FU[aMe],3)
set FU[aMe]=a1e
set a2e=vre(gU[aMe],aVe(ape),"when calling addString in ItemData, line 99")
set QU[aMe]=a2e
endif
if ake(ape)!=ake(aQe)then
set a3e=i2e(FU[aMe],4)
set FU[aMe]=a3e
set a4e=vre(gU[aMe],ake(ape),"when calling addString in ItemData, line 102")
set WU[aMe]=a4e
endif
if are(ape)!=are(aQe)then
set a5e=i2e(FU[aMe],5)
set FU[aMe]=a5e
set a6e=vre(gU[aMe],are(ape),"when calling addString in ItemData, line 105")
set EU[aMe]=a6e
endif
call i5e(aQe)
if FU[aMe]!=0 then
set a7e=aRe(hU[aMe],7)
set hU[aMe]=a7e
endif
set EM=EM-1
set aQe=null
endfunction
function a8e takes integer a9e,item nve,string nee returns nothing
set ZM[EM]=nee
set EM=EM+1
if vh[a9e]==0 then
if a9e==0 then
call Cdv("Nullpointer exception when calling SingleItemData.build","when calling error in ItemData, line 62")
else
call Cdv("Called SingleItemData.build on invalid object.","when calling error in ItemData, line 62")
endif
endif
call ame(a9e,nve,"when calling build in ItemData, line 62")
set EM=EM-1
endfunction
function nxe takes unit noe,integer nre returns item
return UnitItemInSlot(noe,nre)
endfunction
function nie takes unit nae,unitintegerfield nne returns integer
return BlzGetUnitIntegerField(nae,nne)
endfunction
function nVe takes integer pGt returns nothing
endfunction
function nEe takes integer nXe,unit nOe,integer nRe returns nothing
call nVe(nXe)
set fJ[nXe]=C0v(nOe)
set TJ[nXe]=nRe+c8v(Va,fJ[nXe],nRe)*Yn
set RJ[nXe]=nRe+Yn
endfunction
function nIe takes string nAe returns integer
local integer nNe
set ZM[EM]=nAe
set EM=EM+1
if Hj==0 then
if Jj<$8000 then
set Jj=Jj+1
set nNe=Jj
set Kj[nNe]=704
else
call Cdv("Out of memory: Could not create AnimationPropertiesIterator.","when calling error in SaveableHandles, line 566")
set nNe=0
endif
else
set Hj=Hj-1
set nNe=Dj[Hj]
set Kj[nNe]=704
endif
set EM=EM-1
return nNe
endfunction
function nbe takes unit nBe,integer nce,string nCe returns integer
local integer nde
set ZM[EM]=nCe
set EM=EM+1
set nde=nIe("when calling alloc_AnimationPropertiesIterator in SaveableHandles, line 571")
call nEe(nde,nBe,nce)
set EM=EM-1
return nde
endfunction
function nDe takes unit nfe,string nFe returns integer
local integer nge
set ZM[EM]=nFe
set EM=EM+1
set nge=nbe(nfe,Tn,"when calling new_AnimationPropertiesIterator in SaveableHandles, line 591")
set EM=EM-1
return nge
endfunction
function nGe takes integer nhe,integer nHe returns integer
set N5=dpv(nhe,nHe)
return N5
endfunction
function nje takes unit nJe returns boolean
return cZv(Va,C0v(nJe),Sn)
endfunction
function nke takes integer nKe returns string
local string nle=G0v(Va,fJ[nKe],RJ[nKe])
set RJ[nKe]=RJ[nKe]+Yn
return nle
endfunction
function nLe takes unit nme returns boolean
return cWv(Va,C0v(nme),Sn)
endfunction
function nMe takes integer npe returns nothing
local integer nPe=0
set pV[npe]=nPe
set eV[npe]=0
set qV[npe]=0
set aV[npe]=0
set nV[npe]=.0
endfunction
function nqe takes integer nQe returns nothing
call nMe(nQe)
endfunction
function nse takes string nSe returns integer
local integer nte
set ZM[EM]=nSe
set EM=EM+1
if Ev==0 then
if Zv<$8000 then
set Zv=Zv+1
set nte=Zv
set Uv[nte]=4639
else
call Cdv("Out of memory: Could not create SingleAbilityData.","when calling error in UnitData, line 877")
set nte=0
endif
else
set Ev=Ev-1
set nte=Wv[Ev]
set Uv[nte]=4639
endif
set EM=EM-1
return nte
endfunction
function nTe takes string nue returns integer
local integer nUe
set ZM[EM]=nue
set EM=EM+1
set nUe=nse("when calling alloc_SingleAbilityData in UnitData, line 886")
call nqe(nUe)
set EM=EM-1
return nUe
endfunction
function nwe takes integer nWe returns boolean
return RJ[nWe]<=TJ[nWe]
endfunction
function nye takes integer nYe,integer nze returns integer
set u6=dpv(nYe,nze)
return u6
endfunction
function nZe takes unit n_e,integer n0e,integer n1e returns real
return BlzGetUnitAbilityCooldown(n_e,n0e,n1e)
endfunction
function n2e takes integer n3e,integer n4e returns integer
set B5=dpv(n3e,n4e)
return B5
endfunction
function n5e takes unit n6e,integer n7e,integer n8e returns integer
return BlzGetUnitAbilityManaCost(n6e,n7e,n8e)
endfunction
function n9e takes integer Vve,integer Vee returns boolean
return BlzBitAnd(Vve,Gy[Vee])!=0
endfunction
function Vxe takes integer Voe,integer Vre returns boolean
return n9e(Voe,Vre)
endfunction
function Vie takes integer Vae,unit Vne,integer VVe returns nothing
local integer VEe
local integer VXe
local integer VOe
local integer VRe
local integer VIe
local integer VAe
local integer VNe
local integer Vbe
set eV[Vae]=VVe
set qV[Vae]=USv(Vne,eV[Vae])
set VEe=qV[Vae]
if VEe==1 then
set VXe=n2e(pV[Vae],0)
set pV[Vae]=VXe
elseif VEe==2 then
set VOe=n2e(pV[Vae],1)
set pV[Vae]=VOe
elseif VEe==3 then
set VRe=n2e(pV[Vae],2)
set pV[Vae]=VRe
elseif VEe==4 then
set VIe=n2e(pV[Vae],3)
set pV[Vae]=VIe
endif
set aV[Vae]=n5e(Vne,VVe,qV[Vae]-1)
if aV[Vae]!=BlzGetAbilityManaCost(VVe,qV[Vae]-1)then
set VAe=n2e(pV[Vae],4)
set pV[Vae]=VAe
endif
set nV[Vae]=nZe(Vne,VVe,qV[Vae]-1)
if nV[Vae]!=BlzGetAbilityCooldown(VVe,qV[Vae]-1)then
set VNe=n2e(pV[Vae],5)
set pV[Vae]=VNe
endif
if(not Vxe(pV[Vae],4))or aV[Vae]<=$FF and(not Vxe(pV[Vae],4))or(c6v(nV[Vae]*2.)*1./2==nV[Vae]and nV[Vae]*2.<=255.)then
set Vbe=n2e(pV[Vae],6)
set pV[Vae]=Vbe
endif
endfunction
function VBe takes integer Vce,unit VCe,integer Vde,string VDe returns nothing
set ZM[EM]=VDe
set EM=EM+1
if Uv[Vce]==0 then
if Vce==0 then
call Cdv("Nullpointer exception when calling SingleAbilityData.build","when calling error in UnitData, line 888")
else
call Cdv("Called SingleAbilityData.build on invalid object.","when calling error in UnitData, line 888")
endif
endif
call Vie(Vce,VCe,Vde)
set EM=EM-1
endfunction
function Vfe takes unit VFe returns real
return xUe(VFe,UNIT_STATE_MANA)
endfunction
function Vge takes integer VGe returns integer
local integer Vhe=c8v(Va,aJ[VGe],nJ[VGe])
set nJ[VGe]=nJ[VGe]+Yn
return Vhe
endfunction
function VHe takes integer Vje returns integer
return Vje
endfunction
function VJe takes integer Vke,unit VKe,string Vle returns nothing
local integer VLe
local integer Vme
local item VMe
local integer Vpe
local integer VPe
local integer Vqe
local integer VQe
local integer Vse
local integer VSe
local integer Vte
local integer VTe
local integer Vue
local integer VUe
local string Vwe
local integer VWe
local integer Vye
local integer VYe
local integer Vze
local integer VZe
local integer V_e
local integer V0e
local integer V1e
local integer V2e
local integer V3e
local integer V4e
local integer V5e
local integer V6e
local integer V7e
local integer V8e
local integer V9e
local integer Eve
local integer Eee
local integer Exe
local real Eoe
local integer Ere
local integer Eie
local integer Eae
local integer Ene
local integer EVe
local real EEe
local integer EXe
local integer EOe
local real ERe
local real EIe
local real EAe
local real ENe
local real Ebe
local integer EBe
local integer Ece
local integer ECe
local integer Ede
local integer EDe
local real Efe
local integer EFe
local integer Ege
local integer EGe
local integer Ehe
local real EHe
local integer Eje
local integer EJe
local integer Eke
local integer EKe
local integer Ele
local integer ELe
local integer Eme
local integer EMe
local integer Epe
local integer EPe
local integer Eqe
local integer EQe
local integer Ese
local integer ESe
local integer Ete
local integer ETe
local integer Eue
local real EUe
local real Ewe
local integer EWe
local integer Eye
local integer EYe
local integer Eze
local integer EZe
set ZM[EM]=Vle
set EM=EM+1
set VZe=0
set YV[Vke]=VZe
set V_e=0
set GV[Vke]=V_e
set gV[Vke]=umv(VKe)
if x8e(VKe,Sy)then
set V0e=nGe(YV[Vke],0)
set YV[Vke]=V0e
endif
if zcv(VKe)then
set V1e=nGe(YV[Vke],1)
set YV[Vke]=V1e
endif
if IsHeroUnitId(gV[Vke])then
set V2e=nGe(YV[Vke],2)
set YV[Vke]=V2e
set V3e=vfe(VKe,TV[Vke],"when calling getHeroParameters in UnitData, line 1073")
set V4e=n4
set V5e=d4
set V6e=f4
set V7e=R4
set V8e=T4
set V9e=Y4
set hV[Vke]=V3e
set FV[Vke]=V4e
set kV[Vke]=V5e
set jV[Vke]=V6e
set xV[Vke]=V7e
set vV[Vke]=V8e
set mV[Vke]=V9e
endif
if zAv(VKe)!=GetObjectName(gV[Vke])then
set Eve=nGe(YV[Vke],3)
set YV[Vke]=Eve
set Eee=vre(TV[Vke],zAv(VKe),"when calling addString in UnitData, line 1077")
set QV[Vke]=Eee
endif
set Exe=eOe(VKe)
set Eoe=D4
set Ere=H4
set Eie=J4
set Eae=K4
set Ene=L4
set EVe=X4
set EEe=C4
set WV[Vke]=Exe
set EV[Vke]=Eoe
set ZV[Vke]=Ere
set UV[Vke]=Eie
set IV[Vke]=Eae
set PV[Vke]=Ene
set AV[Vke]=EVe
set DV[Vke]=EEe
if WV[Vke]!=0 then
set EXe=nGe(YV[Vke],4)
set YV[Vke]=EXe
endif
set EOe=xxe(VKe)
set ERe=e2
set EIe=q2
set EAe=a2
set ENe=n2
set Ebe=d2
set HV[Vke]=EOe
set JV[Vke]=ERe
set KV[Vke]=EIe
set LV[Vke]=EAe
set XV[Vke]=ENe
set CV[Vke]=Ebe
if HV[Vke]!=0 then
set EBe=nGe(YV[Vke],5)
set YV[Vke]=EBe
endif
set Ece=rqe(VKe,"when calling getStats in UnitData, line 1086")
set ECe=O5
set Ede=l5
set EDe=b5
set Efe=y5
set EFe=p5
set Ege=e5
set EGe=q5
set Ehe=a5
set EHe=n5
set Eje=d5
set EJe=f5
set Eke=R5
set EKe=T5
set Ele=Y5
set ELe=G5
set Eme=g5
set VV[Vke]=Ece
set BV[Vke]=ECe
set NV[Vke]=Ede
set MV[Vke]=EDe
set wB[Vke]=Efe
set uB[Vke]=EFe
set rB[Vke]=Ege
set sB[Vke]=EGe
set tB[Vke]=Ehe
set iB[Vke]=EHe
set SB[Vke]=Eje
set cB[Vke]=EJe
set oB[Vke]=Eke
set OB[Vke]=EKe
set lB[Vke]=Ele
set bB[Vke]=ELe
set yB[Vke]=Eme
if VV[Vke]!=0 then
set EMe=nGe(YV[Vke],6)
set YV[Vke]=EMe
set VLe=0
set Vme=BV[Vke]-1
loop
exitwhen VLe>Vme
set VMe=nxe(VKe,VLe)
if VMe!=null then
set Vpe=zXv(TV[Vke],"when calling new_SingleItemData in UnitData, line 1092")
call a8e(Vpe,VMe,"when calling build in UnitData, line 1092")
call xMe(Vke,VLe,Vpe,"when writing array SingleUnitData_items in UnitData, line 1092")
else
call xMe(Vke,VLe,0,"when writing array SingleUnitData_items in UnitData, line 1094")
endif
set VLe=VLe+1
endloop
endif
if DSv(xye(VKe))!=zJv(VKe)then
set Epe=z8v(qB[Vke],0)
set qB[Vke]=Epe
set aB[Vke]=DSv(xye(VKe))
if aB[Vke]<=$FFFF then
set EPe=z8v(qB[Vke],1)
set qB[Vke]=EPe
if aB[Vke]<=$FF then
set Eqe=xte(qB[Vke],0)
set qB[Vke]=Eqe
endif
endif
endif
if DSv(Vfe(VKe))!=Shv(VKe)then
set EQe=z8v(qB[Vke],2)
set qB[Vke]=EQe
set nB[Vke]=DSv(Vfe(VKe))
if nB[Vke]<=$FFFF then
set Ese=Y0v(qB[Vke],$B)
set qB[Vke]=Ese
if nB[Vke]<=$FF then
set ESe=xte(qB[Vke],2)
set qB[Vke]=ESe
endif
endif
endif
if qB[Vke]!=0 then
set Ete=nye(GV[Vke],0)
set GV[Vke]=Ete
endif
if nLe(VKe)and(not nje(VKe))then
set ETe=nye(GV[Vke],1)
set GV[Vke]=ETe
endif
set VPe=zbv(rfe(VKe,"when calling removedAbilities in UnitData, line 1117"))
loop
exitwhen not Y3v(VPe)
set Vqe=Vge(VPe)
if Vqe!=Sy then
call zGv(pB[Vke],Vqe,"when calling add in UnitData, line 1119")
endif
endloop
call z5v(VPe,"when calling close in UnitData, line 1117")
set VQe=zbv(zuv(VKe,"when calling modifiedAbilities in UnitData, line 1120"))
loop
exitwhen not Y3v(VQe)
set Vse=Vge(VQe)
set Vye=eB[Vke]
set VSe=nTe("when calling new_SingleAbilityData in UnitData, line 1121")
call VBe(VSe,VKe,Vse,"when calling build in UnitData, line 1121")
call zGv(Vye,VSe,"when calling add in UnitData, line 1121")
endloop
call z5v(VQe,"when calling close in UnitData, line 1120")
set Vte=zbv(rje(VKe,"when calling addedAbilities in UnitData, line 1122"))
loop
exitwhen not Y3v(Vte)
set VTe=Vge(Vte)
if VTe!=Sy then
set VYe=eB[Vke]
set Vue=nTe("when calling new_SingleAbilityData in UnitData, line 1124")
call VBe(Vue,VKe,VTe,"when calling build in UnitData, line 1124")
call zGv(VYe,Vue,"when calling add in UnitData, line 1124")
endif
endloop
call z5v(Vte,"when calling close in UnitData, line 1122")
if WaygateIsActive(VKe)then
set Eue=nye(GV[Vke],2)
set GV[Vke]=Eue
set EUe=FRv(DRv(WaygateGetDestinationX(VKe),WaygateGetDestinationY(VKe),uov(VKe),c3),d9)
set Ewe=R1
set dB[Vke]=EUe
set fB[Vke]=Ewe
endif
if nie(VKe,UNIT_IF_ARMOR_TYPE)!=xse(gV[Vke])then
set EWe=nye(GV[Vke],3)
set GV[Vke]=EWe
set RB[Vke]=nie(VKe,UNIT_IF_ARMOR_TYPE)
endif
if nie(VKe,UNIT_IF_DEFENSE_TYPE)!=v_e(gV[Vke])then
set Eye=nye(GV[Vke],4)
set GV[Vke]=Eye
set TB[Vke]=nie(VKe,UNIT_IF_DEFENSE_TYPE)
endif
set VUe=VHe(nDe(VKe,"when calling animationProperties in UnitData, line 1137"))
loop
exitwhen not nwe(VUe)
set Vwe=nke(VUe)
set Vze=YB[Vke]
set EYe=vre(TV[Vke],Vwe,"when calling addString in UnitData, line 1138")
set VWe=EYe
call zGv(Vze,VWe,"when calling add in UnitData, line 1138")
endloop
call xle(VUe,"when calling close in UnitData, line 1137")
if not YYv(YB[Vke],"when calling isEmpty in UnitData, line 1139")then
set Eze=nye(GV[Vke],5)
set GV[Vke]=Eze
endif
if GV[Vke]!=0 then
set EZe=nGe(YV[Vke],7)
set YV[Vke]=EZe
endif
set EM=EM-1
set VMe=null
endfunction
function E_e takes integer E0e,unit E1e,string E2e returns nothing
set ZM[EM]=E2e
set EM=EM+1
if Dv[E0e]==0 then
if E0e==0 then
call Cdv("Nullpointer exception when calling SingleUnitData.build","when calling error in UnitData, line 1061")
else
call Cdv("Called SingleUnitData.build on invalid object.","when calling error in UnitData, line 1061")
endif
endif
call VJe(E0e,E1e,"when calling build in UnitData, line 1061")
set EM=EM-1
endfunction
function E3e takes integer E4e returns integer
set iP[E4e]=sP[iP[E4e]]
return uP[iP[E4e]]
endfunction
function E5e takes integer t0S returns nothing
endfunction
function E6e takes integer E7e,string E8e returns nothing
set ZM[EM]=E8e
set EM=EM+1
if Uv[E7e]==0 then
call Cdv("Double free: object of type SingleAbilityData","when calling error in UnitData, line 877")
else
set Wv[Ev]=E7e
set Ev=Ev+1
set Uv[E7e]=0
endif
set EM=EM-1
endfunction
function E9e takes integer Xve,string Xee returns nothing
set ZM[EM]=Xee
set EM=EM+1
call E5e(Xve)
call E6e(Xve,"when calling dealloc_SingleAbilityData in UnitData, line 877")
set EM=EM-1
endfunction
function Xxe takes integer Xoe,string Xre returns nothing
set ZM[EM]=Xre
set EM=EM+1
if Uv[Xoe]==0 then
if Xoe==0 then
call Cdv("Nullpointer exception when calling SingleAbilityData.SingleAbilityData","when calling error in UnitData, line 877")
else
call Cdv("Called SingleAbilityData.SingleAbilityData on invalid object.","when calling error in UnitData, line 877")
endif
endif
call E9e(Xoe,"when calling destroySingleAbilityData in UnitData, line 877")
set EM=EM-1
endfunction
function Xie takes integer Xae returns boolean
return sP[iP[Xae]]!=tP[Xae]
endfunction
function Xne takes integer XVe returns nothing
set cP[XVe]=true
endfunction
function XEe takes integer XXe returns integer
return oP[XXe]
endfunction
function XOe takes integer XRe,string XIe returns integer
local integer XAe
set ZM[EM]=XIe
set EM=EM+1
if gF[XRe]==0 then
if XRe==0 then
call Cdv("Nullpointer exception when calling LinkedList.getDummy","when calling error in LinkedList, line 374")
else
call Cdv("Called LinkedList.getDummy on invalid object.","when calling error in LinkedList, line 374")
endif
endif
set XAe=XEe(XRe)
set EM=EM-1
return XAe
endfunction
function XNe takes integer Xbe,string XBe returns nothing
set ZM[EM]=XBe
set EM=EM+1
set tP[Xbe]=XOe(SP[Xbe],"when calling getDummy in LinkedList, line 434")
set iP[Xbe]=tP[Xbe]
set EM=EM-1
endfunction
function Xce takes integer XCe,string Xde returns nothing
set ZM[EM]=Xde
set EM=EM+1
if RF[XCe]==0 then
if XCe==0 then
call Cdv("Nullpointer exception when calling LLIterator.reset","when calling error in LinkedList, line 433")
else
call Cdv("Called LLIterator.reset on invalid object.","when calling error in LinkedList, line 433")
endif
endif
call XNe(XCe,"when calling reset in LinkedList, line 433")
set EM=EM-1
endfunction
function XDe takes integer Xfe,integer XFe,string Xge returns nothing
set ZM[EM]=Xge
set EM=EM+1
call Xne(Xfe)
set SP[Xfe]=XFe
call Xce(Xfe,"when calling reset in LinkedList, line 426")
set EM=EM-1
endfunction
function XGe takes string Xhe returns integer
local integer XHe
set ZM[EM]=Xhe
set EM=EM+1
if dF==0 then
if fF<$8000 then
set fF=fF+1
set XHe=fF
set RF[XHe]=$CAE
else
call Cdv("Out of memory: Could not create LLIterator.","when calling error in LinkedList, line 418")
set XHe=0
endif
else
set dF=dF-1
set XHe=nF[dF]
set RF[XHe]=$CAE
endif
set EM=EM-1
return XHe
endfunction
function Xje takes integer XJe,string Xke returns integer
local integer XKe
set ZM[EM]=Xke
set EM=EM+1
set XKe=XGe("when calling alloc_LLIterator in LinkedList, line 424")
call XDe(XKe,XJe,"when calling construct_LLIterator in LinkedList, line 424")
set EM=EM-1
return XKe
endfunction
function Xle takes integer XLe,string Xme returns integer
local integer XMe
set ZM[EM]=Xme
set EM=EM+1
set XMe=Xje(XLe,"when calling new_LLIterator in LinkedList, line 177")
set EM=EM-1
return XMe
endfunction
function Xpe takes integer XPe,string Xqe returns nothing
set ZM[EM]=Xqe
set EM=EM+1
if cP[XPe]then
call hZv(XPe,"when calling dispatch_LLIterator_destroyLLIterator in LinkedList, line 467")
endif
set EM=EM-1
endfunction
function XQe takes integer Xse,string XSe returns nothing
local integer Xte
local integer XTe
set ZM[EM]=XSe
set EM=EM+1
call Hcv(YB[Xse],"when calling dispatch_LinkedList_destroyLinkedList in UnitData, line 1052")
set Xte=Xle(eB[Xse],"when calling iterator in UnitData, line 1053")
loop
exitwhen not Xie(Xte)
set XTe=E3e(Xte)
call Xxe(XTe,"when calling dispatch_SingleAbilityData_destroySingleAbilityData in UnitData, line 1054")
endloop
call Xpe(Xte,"when calling close in UnitData, line 1053")
call Hcv(eB[Xse],"when calling dispatch_LinkedList_destroyLinkedList in UnitData, line 1055")
call Hcv(pB[Xse],"when calling dispatch_LinkedList_destroyLinkedList in UnitData, line 1056")
set EM=EM-1
endfunction
function Xue takes integer XUe,string Xwe returns nothing
set ZM[EM]=Xwe
set EM=EM+1
if Dv[XUe]==0 then
call Cdv("Double free: object of type SingleUnitData","when calling error in UnitData, line 1018")
else
set Iv[Pv]=XUe
set Pv=Pv+1
set Dv[XUe]=0
endif
set EM=EM-1
endfunction
function XWe takes integer Xye,string XYe returns nothing
set ZM[EM]=XYe
set EM=EM+1
call XQe(Xye,"when calling SingleUnitData_onDestroy in UnitData, line 1051")
call Xue(Xye,"when calling dealloc_SingleUnitData in UnitData, line 1051")
set EM=EM-1
endfunction
function Xze takes integer XZe,string X_e returns nothing
set ZM[EM]=X_e
set EM=EM+1
if Dv[XZe]==0 then
if XZe==0 then
call Cdv("Nullpointer exception when calling SingleUnitData.SingleUnitData","when calling error in UnitData, line 1018")
else
call Cdv("Called SingleUnitData.SingleUnitData on invalid object.","when calling error in UnitData, line 1018")
endif
endif
call XWe(XZe,"when calling destroySingleUnitData in UnitData, line 1018")
set EM=EM-1
endfunction
function X0e takes integer X1e,string X2e returns nothing
set ZM[EM]=X2e
set EM=EM+1
if Gg[X1e]==0 then
call Cdv("Double free: object of type StringTable","when calling error in StringTable, line 43")
else
set Rg[Tg]=X1e
set Tg=Tg+1
set Gg[X1e]=0
endif
set EM=EM-1
endfunction
function X3e takes integer X4e returns nothing
call HLv(BT,X4e)
set dM[X4e]=0
endfunction
function X5e takes integer X6e,string X7e returns nothing
set ZM[EM]=X7e
set EM=EM+1
if Ym[X6e]==0 then
if X6e==0 then
call Cdv("Nullpointer exception when calling StringHashList.clear","when calling error in Utility, line 209")
else
call Cdv("Called StringHashList.clear on invalid object.","when calling error in Utility, line 209")
endif
endif
call X3e(X6e)
set EM=EM-1
endfunction
function X8e takes integer X9e,string Ove returns nothing
set ZM[EM]=Ove
set EM=EM+1
call X5e(X9e,"when calling clear in Utility, line 269")
set EM=EM-1
endfunction
function Oee takes integer Oxe,string Ooe returns nothing
set ZM[EM]=Ooe
set EM=EM+1
if Ym[Oxe]==0 then
call Cdv("Double free: object of type StringHashList","when calling error in Utility, line 188")
else
set fm[Rm]=Oxe
set Rm=Rm+1
set Ym[Oxe]=0
endif
set EM=EM-1
endfunction
function Ore takes integer Oie,string Oae returns nothing
set ZM[EM]=Oae
set EM=EM+1
call X8e(Oie,"when calling StringHashList_onDestroy in Utility, line 268")
call Oee(Oie,"when calling dealloc_StringHashList in Utility, line 268")
set EM=EM-1
endfunction
function One takes integer OVe,string OEe returns nothing
set ZM[EM]=OEe
set EM=EM+1
if Ym[OVe]==0 then
if OVe==0 then
call Cdv("Nullpointer exception when calling StringHashList.StringHashList","when calling error in Utility, line 188")
else
call Cdv("Called StringHashList.StringHashList on invalid object.","when calling error in Utility, line 188")
endif
endif
call Ore(OVe,"when calling destroyStringHashList in Utility, line 188")
set EM=EM-1
endfunction
function OXe takes hashtable OOe returns nothing
call FlushParentHashtable(OOe)
endfunction
function ORe takes integer OIe returns nothing
call OXe(fM[OIe])
call OXe(RM[OIe])
endfunction
function OAe takes integer ONe,string Obe returns nothing
set ZM[EM]=Obe
set EM=EM+1
if Fm[ONe]==0 then
call Cdv("Double free: object of type StringHashMap","when calling error in Utility, line 81")
else
set Gm[gm]=ONe
set gm=gm+1
set Fm[ONe]=0
endif
set EM=EM-1
endfunction
function OBe takes integer Oce,string OCe returns nothing
set ZM[EM]=OCe
set EM=EM+1
call ORe(Oce)
call OAe(Oce,"when calling dealloc_StringHashMap in Utility, line 135")
set EM=EM-1
endfunction
function Ode takes integer ODe,string Ofe returns nothing
set ZM[EM]=Ofe
set EM=EM+1
if Fm[ODe]==0 then
if ODe==0 then
call Cdv("Nullpointer exception when calling StringHashMap.StringHashMap","when calling error in Utility, line 81")
else
call Cdv("Called StringHashMap.StringHashMap on invalid object.","when calling error in Utility, line 81")
endif
endif
call OBe(ODe,"when calling destroyStringHashMap in Utility, line 81")
set EM=EM-1
endfunction
function OFe takes integer Oge,string OGe returns nothing
set ZM[EM]=OGe
set EM=EM+1
call Ode(NX[Oge],"when calling dispatch_StringHashMap_destroyStringHashMap in StringTable, line 106")
call One(MX[Oge],"when calling dispatch_StringHashList_destroyStringHashList in StringTable, line 107")
set EM=EM-1
endfunction
function Ohe takes integer OHe,string Oje returns nothing
set ZM[EM]=Oje
set EM=EM+1
call OFe(OHe,"when calling StringTable_onDestroy in StringTable, line 105")
call X0e(OHe,"when calling dealloc_StringTable in StringTable, line 105")
set EM=EM-1
endfunction
function OJe takes integer Oke,string OKe returns nothing
set ZM[EM]=OKe
set EM=EM+1
if Gg[Oke]==0 then
if Oke==0 then
call Cdv("Nullpointer exception when calling StringTable.StringTable","when calling error in StringTable, line 43")
else
call Cdv("Called StringTable.StringTable on invalid object.","when calling error in StringTable, line 43")
endif
endif
call Ohe(Oke,"when calling destroyStringTable in StringTable, line 43")
set EM=EM-1
endfunction
function Ole takes unit OLe,integer Ome,integer OMe,real Ope returns nothing
call BlzSetUnitAbilityCooldown(OLe,Ome,OMe,Ope)
endfunction
function OPe takes unit Oqe,integer OQe,integer Ose,integer OSe returns nothing
call BlzSetUnitAbilityManaCost(Oqe,OQe,Ose,OSe)
endfunction
function Ote takes integer OTe,unit Oue returns nothing
call wnv(Oue,eV[OTe])
call Uuv(Oue,eV[OTe],qV[OTe])
if Vxe(pV[OTe],4)then
call OPe(Oue,eV[OTe],qV[OTe]-1,aV[OTe])
endif
if Vxe(pV[OTe],5)then
call Ole(Oue,eV[OTe],qV[OTe]-1,nV[OTe])
endif
endfunction
function OUe takes integer Owe,unit OWe,string Oye returns nothing
set ZM[EM]=Oye
set EM=EM+1
if Uv[Owe]==0 then
if Owe==0 then
call Cdv("Nullpointer exception when calling SingleAbilityData.apply","when calling error in UnitData, line 913")
else
call Cdv("Called SingleAbilityData.apply on invalid object.","when calling error in UnitData, line 913")
endif
endif
call Ote(Owe,OWe)
set EM=EM-1
endfunction
function OYe takes unit Oze,unitstate OZe,real O_e returns nothing
call SetUnitState(Oze,OZe,O_e)
endfunction
function O0e takes unit O1e,real O2e returns nothing
call OYe(O1e,UNIT_STATE_LIFE,O2e)
endfunction
function O3e takes unit O4e returns nothing
call PauseUnit(O4e,true)
endfunction
function O5e takes integer O6e,integer O7e returns boolean
return n9e(O6e,O7e)
endfunction
function O8e takes unit O9e,integer Rve returns nothing
call SetHeroStr(O9e,Rve,true)
endfunction
function Ree takes integer Rxe,integer Roe returns string
return G0v(BT,Rxe,Roe)
endfunction
function Rre takes integer Rie,integer Rae,string Rne returns string
local string RVe
set ZM[EM]=Rne
set EM=EM+1
if Ym[Rie]==0 then
if Rie==0 then
call Cdv("Nullpointer exception when calling StringHashList.get","when calling error in Utility, line 243")
else
call Cdv("Called StringHashList.get on invalid object.","when calling error in Utility, line 243")
endif
endif
set RVe=Ree(Rie,Rae)
set EM=EM-1
return RVe
endfunction
function REe takes integer RXe,integer ROe,string RRe returns string
local string RIe
set ZM[EM]=RRe
set EM=EM+1
set RIe=Rre(MX[RXe],ROe,"when calling get in StringTable, line 61")
set EM=EM-1
return RIe
endfunction
function RAe takes integer RNe,integer Rbe,string RBe returns string
local string Rce
set ZM[EM]=RBe
set EM=EM+1
if Gg[RNe]==0 then
if RNe==0 then
call Cdv("Nullpointer exception when calling StringTable.getString","when calling error in StringTable, line 60")
else
call Cdv("Called StringTable.getString on invalid object.","when calling error in StringTable, line 60")
endif
endif
set Rce=REe(RNe,Rbe,"when calling getString in StringTable, line 60")
set EM=EM-1
return Rce
endfunction
function RCe takes integer Rde,integer RDe returns boolean
return n9e(Rde,RDe)
endfunction
function Rfe takes unit RFe,string Rge returns nothing
call BlzSetHeroProperName(RFe,Rge)
endfunction
function RGe takes unit Rhe,boolean RHe returns nothing
call SuspendHeroXP(Rhe,RHe)
endfunction
function Rje takes unit RJe,integer Rke,integer gmr,integer RKe,integer Rle,integer RLe,integer Rme,integer RMe,integer Rpe,string RPe returns nothing
set ZM[EM]=RPe
set EM=EM+1
call RGe(RJe,RCe(Rke,0))
call ZNv(RJe,RKe,false)
if RCe(Rke,1)then
call O8e(RJe,Rle)
endif
if RCe(Rke,3)then
call O8e(RJe,RLe)
endif
if RCe(Rke,5)then
call O8e(RJe,Rme)
endif
call Rfe(RJe,RAe(Rpe,RMe,"when calling getString in UnitData, line 112"))
set EM=EM-1
endfunction
function Rqe takes unit RQe,real Rse returns nothing
call OYe(RQe,UNIT_STATE_MANA,Rse)
endfunction
function RSe takes unit Rte,boolean RTe returns nothing
call SetUnitInvulnerable(Rte,RTe)
endfunction
function Rue takes unit RUe,real Rwe returns nothing
call SetUnitY(RUe,Rwe)
endfunction
function RWe takes unit Rye,real RYe returns nothing
call SetUnitX(Rye,RYe)
endfunction
function Rze takes unit RZe,real R_e,real R0e returns nothing
local unit R1e=RZe
local unit R2e
call RWe(R1e,R_e)
set R2e=R1e
call Rue(R2e,R0e)
set R1e=null
set R2e=null
endfunction
function R3e takes integer R4e,integer R5e returns boolean
return n9e(R4e,R5e)
endfunction
function R6e takes item R7e,boolean R8e returns nothing
call SetItemDropOnDeath(R7e,R8e)
endfunction
function R9e takes item Ive,boolean Iee returns nothing
call R6e(Ive,Iee)
call ctv(Va,C0v(Ive),tn,Iee)
endfunction
function Ixe takes item Ioe,boolean Ire returns nothing
call SetItemDroppable(Ioe,Ire)
endfunction
function Iie takes item Iae,boolean Ine returns nothing
call Ixe(Iae,Ine)
call ctv(Va,C0v(Iae),sn,Ine)
endfunction
function IVe takes integer IEe,integer IXe returns boolean
return n9e(IEe,IXe)
endfunction
function IOe takes item IRe,string IIe returns nothing
call BlzSetItemDescription(IRe,IIe)
endfunction
function IAe takes item INe,string Ibe returns nothing
call BlzSetItemIconPath(INe,Ibe)
endfunction
function IBe takes widget Ice,real ICe returns nothing
call SetWidgetLife(Ice,ICe)
endfunction
function Ide takes integer IDe,integer Ife returns boolean
return n9e(IDe,Ife)
endfunction
function IFe takes item Ige,string IGe returns nothing
call BlzSetItemExtendedTooltip(Ige,IGe)
endfunction
function Ihe takes item IHe,string Ije returns nothing
call BlzSetItemName(IHe,Ije)
endfunction
function IJe takes item Ike,integer IKe returns nothing
call SetItemCharges(Ike,IKe)
endfunction
function Ile takes item ILe,boolean Ime returns nothing
call SetItemInvulnerable(ILe,Ime)
endfunction
function IMe takes item Ipe,boolean IPe returns nothing
call SetItemPawnable(Ipe,IPe)
endfunction
function Iqe takes integer IQe,real Ise,real ISe,string Ite returns item
local item ITe
local item Iue
local item IUe
local item Iwe
local item IWe
local item Iye
set ZM[EM]=Ite
set EM=EM+1
set ITe=ahe(kU[IQe],Ise,ISe)
set Iue=ITe
call Ile(Iue,Ide(hU[IQe],0))
set IUe=Iue
call R9e(IUe,Ide(hU[IQe],1))
set Iwe=IUe
call Iie(Iwe,Ide(hU[IQe],2))
set IWe=Iwe
call IMe(IWe,Ide(hU[IQe],3))
set Iye=IWe
call IJe(Iye,jU[IQe])
if IVe(FU[IQe],0)then
call IBe(ITe,xU[IQe])
endif
if IVe(FU[IQe],1)then
call Ihe(ITe,RAe(gU[IQe],vU[IQe],"when calling getString in ItemData, line 123"))
endif
if IVe(FU[IQe],2)then
call IOe(ITe,RAe(gU[IQe],mU[IQe],"when calling getString in ItemData, line 125"))
endif
if IVe(FU[IQe],3)then
call Wpv(ITe,RAe(gU[IQe],QU[IQe],"when calling getString in ItemData, line 127"))
endif
if IVe(FU[IQe],4)then
call IFe(ITe,RAe(gU[IQe],WU[IQe],"when calling getString in ItemData, line 129"))
endif
if IVe(FU[IQe],5)then
call IAe(ITe,RAe(gU[IQe],EU[IQe],"when calling getString in ItemData, line 131"))
endif
set EM=EM-1
set R9v=ITe
set ITe=null
set Iue=null
set IUe=null
set Iwe=null
set IWe=null
set Iye=null
return R9v
endfunction
function IYe takes real Ize,real IZe returns real
set n1=Ize
set d1=IZe
return n1
endfunction
function I_e takes real I0e,real I1e,real I2e,real I3e returns real
set o1=I0e+I2e
set O1=I1e+I3e
return o1
endfunction
function I4e takes integer I5e,real I6e,real I7e,string I8e returns item
local item I9e
set ZM[EM]=I8e
set EM=EM+1
set I9e=Iqe(I5e,I_e(I6e,I7e,IYe(ZU[I5e],UU[I5e]),d1),O1,"when calling create in ItemData, line 210")
set EM=EM-1
set Iev=I9e
set I9e=null
return Iev
endfunction
function Ave takes integer Aee,real Axe,real Aoe,string Are returns item
local item Aie
set ZM[EM]=Are
set EM=EM+1
if vh[Aee]==0 then
if Aee==0 then
call Cdv("Nullpointer exception when calling SingleItemData.create","when calling error in ItemData, line 111")
else
call Cdv("Called SingleItemData.create on invalid object.","when calling error in ItemData, line 111")
endif
endif
if vh[Aee]<=4642 then
set Aie=Iqe(Aee,Axe,Aoe,"when calling create in ItemData, line 111")
else
set Aie=I4e(Aee,Axe,Aoe,"when calling create in ItemData, line 111")
endif
set EM=EM-1
set Ibv=Aie
set Aie=null
return Ibv
endfunction
function Aae takes integer Ane,string AVe returns item
local item AEe
set ZM[EM]=AVe
set EM=EM+1
set AEe=Ave(Ane,.0,.0,"when calling create in ItemData, line 135")
set EM=EM-1
set Ivv=AEe
set AEe=null
return Ivv
endfunction
function AXe takes integer AOe,string ARe returns item
local item AIe
set ZM[EM]=ARe
set EM=EM+1
if vh[AOe]==0 then
if AOe==0 then
call Cdv("Nullpointer exception when calling SingleItemData.create","when calling error in ItemData, line 134")
else
call Cdv("Called SingleItemData.create on invalid object.","when calling error in ItemData, line 134")
endif
endif
set AIe=Aae(AOe,"when calling create in ItemData, line 134")
set EM=EM-1
set IBv=AIe
set AIe=null
return IBv
endfunction
function AAe takes unit ANe,item Abe,integer ABe returns boolean
return UnitDropItemSlot(ANe,Abe,ABe)
endfunction
function Ace takes integer ACe,integer Ade returns boolean
return n9e(ACe,Ade)
endfunction
function ADe takes integer Afe,integer AFe returns boolean
return n9e(Afe,AFe)
endfunction
function Age takes unit AGe,real Ahe returns nothing
call SetUnitPropWindow(AGe,e6e(Ahe))
endfunction
function AHe takes unit Aje,real AJe returns nothing
call SetUnitMoveSpeed(Aje,AJe)
endfunction
function Ake takes hashtable AKe,integer Ale,integer ALe,real Ame returns nothing
call SaveReal(AKe,Ale,ALe,Ame)
endfunction
function AMe takes unit Ape,real APe returns nothing
call AHe(Ape,APe)
call Ake(Va,C0v(Ape),en,APe)
endfunction
function Aqe takes unit AQe,real Ase returns nothing
call SetUnitBlendTime(AQe,Ase)
call Ake(Va,C0v(AQe),nn,Ase)
endfunction
function ASe takes unit Ate,real ATe returns nothing
call SetUnitTurnSpeed(Ate,ATe)
endfunction
function Aue takes unit AUe,real Awe returns nothing
call SetUnitTimeScale(AUe,Awe)
endfunction
function AWe takes unit Aye,real AYe returns nothing
call Aue(Aye,AYe)
call Ake(Va,C0v(Aye),qn,AYe)
endfunction
function Aze takes unit AZe,integer A_e,real A0e,real A1e,real A2e,real A3e,real A4e returns nothing
if ADe(A_e,0)then
call AMe(AZe,A0e)
endif
if ADe(A_e,2)then
call ASe(AZe,A1e)
endif
if ADe(A_e,3)then
call AWe(AZe,A2e)
endif
if ADe(A_e,6)then
call Aqe(AZe,A3e)
endif
if ADe(A_e,7)then
call Age(AZe,uiv(A4e))
endif
endfunction
function A5e takes integer A6e,integer A7e returns boolean
return n9e(A6e,A7e)
endfunction
function A8e takes unit A9e,item Nve returns boolean
return UnitAddItem(A9e,Nve)
endfunction
function Nee takes unit Nxe,string Noe returns nothing
call BlzSetUnitName(Nxe,Noe)
endfunction
function Nre takes unit Nie,integer Nae,integer Nne,integer NVe,integer NEe returns nothing
call w6v(Nie,Nae,Nne,NVe,NEe)
endfunction
function NXe takes unit NOe,real NRe returns nothing
call SetUnitScale(NOe,NRe,NRe,NRe)
endfunction
function NIe takes unit NAe,real NNe returns nothing
call NXe(NAe,NNe)
call Ake(Va,C0v(NAe),On,NNe)
endfunction
function Nbe takes unit NBe,real Nce,real NCe returns nothing
call SetUnitFlyHeight(NBe,Nce,NCe)
endfunction
function Nde takes unit NDe,real Nfe returns nothing
if wrv(NDe,'Amrf')then
call Tlv(NDe,'Amrf')
endif
call Nbe(NDe,Nfe,Fa)
call Ake(Va,C0v(NDe),an,Nfe)
endfunction
function NFe takes integer Nge,integer NGe returns boolean
return n9e(Nge,NGe)
endfunction
function Nhe takes unit NHe,integer Nje,real NJe,integer Nke,integer NKe,integer Nle,integer NLe,integer Nme,real NMe returns nothing
if NFe(Nje,0)then
call Nde(NHe,NJe)
endif
if NFe(Nje,3)then
call tuv(NHe,tWv(Nke))
endif
if NFe(Nje,4)then
call Nre(NHe,NKe,Nle,NLe,Nme)
endif
if NFe(Nje,5)then
call NIe(NHe,NMe)
endif
endfunction
function Npe takes unit NPe,boolean Nqe returns nothing
call SetUnitPathing(NPe,Nqe)
endfunction
function NQe takes unit Nse,boolean NSe returns nothing
call Npe(Nse,NSe)
call ctv(Va,C0v(Nse),Sn,NSe)
endfunction
function Nte takes unit NTe,unittype Nue,boolean NUe returns nothing
if NUe then
call UnitAddType(NTe,Nue)
else
call UnitRemoveType(NTe,Nue)
endif
endfunction
function Nwe takes integer NWe,integer Nye returns boolean
return n9e(NWe,Nye)
endfunction
function NYe takes unit Nze,integer NZe returns nothing
call Nte(Nze,UNIT_TYPE_TOWNHALL,Nwe(NZe,0))
endfunction
function N_e takes integer N0e,integer N1e returns boolean
return n9e(N0e,N1e)
endfunction
function N2e takes unit N3e,integer N4e,integer N5e returns nothing
call BlzSetUnitDiceNumber(N3e,N4e,N5e)
endfunction
function N6e takes unit N7e,integer N8e,integer N9e returns nothing
call BlzSetUnitBaseDamage(N7e,N8e,N9e)
endfunction
function bve takes unit bee,integer bxe,integer boe,real bre,integer bie,integer bae,integer bne returns nothing
if N_e(bxe,0)then
call N6e(bee,boe,bne)
endif
if N_e(bxe,2)then
call tEv(bee,bre,bne)
endif
if N_e(bxe,4)then
call tev(bee,bie,bne)
endif
if N_e(bxe,6)then
call N2e(bee,bae,bne)
endif
endfunction
function bVe takes unit bEe,integer bXe returns nothing
call BlzSetUnitMaxHP(bEe,bXe)
endfunction
function bOe takes unit bRe returns real
return xUe(bRe,UNIT_STATE_MAX_MANA)
endfunction
function bIe takes real bAe returns real
return Cos(bAe)
endfunction
function bNe takes destructable bbe returns nothing
call RemoveDestructable(bbe)
endfunction
function bBe takes real bce returns real
return Sin(bce)
endfunction
function bCe takes unit bde,real bDe,real bfe returns nothing
call SetUnitPosition(bde,bDe,bfe)
endfunction
function bFe takes unit bge,integer bGe,boolean bhe returns nothing
local integer bHe=bGe
local real bje
local real bJe
local real bke
if bHe==1 then
set bje=QJv(bge)
set bJe=uev(bge)
set bke=GetUnitFacing(bge)
call bCe(bge,bje,bJe)
call SetUnitFacing(bge,bke)
set bke=e6e(vde(bke))
set bje=bje+10.*bIe(bke)
set bJe=bJe+10.*bBe(bke)
set bj_lastCreatedDestructable=CreateDestructable('Dumm',bje,bJe,.0,1.,0)
if bhe then
call wrv(bge,'AAI1')
call Qiv(bge,"grabtree",bj_lastCreatedDestructable)
call Tlv(bge,'AAI1')
call Tlv(bge,'AaI0')
call wrv(bge,'AaI1')
else
call wrv(bge,'AAI0')
call Qiv(bge,"grabtree",bj_lastCreatedDestructable)
call Tlv(bge,'AAI0')
call Tlv(bge,'AaI1')
call wrv(bge,'AaI0')
endif
call bNe(bj_lastCreatedDestructable)
set bj_lastCreatedDestructable=null
elseif bHe==2 then
if bhe then
call wrv(bge,'AAI2')
else
call Tlv(bge,'AAI2')
endif
endif
endfunction
function bKe takes unit ble,real bLe returns nothing
call BlzSetUnitArmor(ble,bLe)
endfunction
function bme takes unit bMe returns real
return BlzGetUnitArmor(bMe)
endfunction
function bpe takes unit bPe,integer bqe returns nothing
call bKe(bPe,bme(bPe)+(bqe-uUv(bPe)))
call Cxv(Va,C0v(bPe),on,bqe)
endfunction
function bQe takes integer bse,integer bSe returns boolean
return n9e(bse,bSe)
endfunction
function bte takes unit bTe,integer bue returns nothing
call Nte(bTe,UNIT_TYPE_GIANT,bQe(bue,0))
call Nte(bTe,UNIT_TYPE_SUMMONED,bQe(bue,1))
call Nte(bTe,UNIT_TYPE_UNDEAD,bQe(bue,2))
call Nte(bTe,UNIT_TYPE_MECHANICAL,bQe(bue,3))
call Nte(bTe,UNIT_TYPE_PEON,bQe(bue,4))
call Nte(bTe,UNIT_TYPE_SAPPER,bQe(bue,5))
call Nte(bTe,UNIT_TYPE_ANCIENT,bQe(bue,6))
endfunction
function bUe takes integer bwe,integer bWe returns integer
local integer bye=je
local integer bYe
if bwe<bye then
set bYe=bwe
else
set bYe=bye
endif
set bye=bYe
if bWe<bye then
set bYe=bWe
else
set bYe=bye
endif
set bye=bYe
return bye
endfunction
function bze takes unit bZe,integer b_e returns nothing
local integer b0e=rde(bZe)
local item array b1e
local integer b2e
local integer b3e
local integer b4e
local integer b5e
local integer b6e
if b0e!=0 then
set b2e=0
set b3e=b0e-1
loop
exitwhen b2e>b3e
set b1e[b2e]=nxe(bZe,b2e)
set b2e=b2e+1
endloop
call Tlv(bZe,KT[b0e])
endif
if b_e>0 then
set b4e=bUe(b_e,6)
call wrv(bZe,KT[b4e])
call wvv(bZe,KT[b4e],true)
set b5e=0
set b6e=b4e-1
loop
exitwhen b5e>b6e
call A8e(bZe,b1e[b5e])
call AAe(bZe,b1e[b5e],b5e)
set b5e=b5e+1
endloop
endif
endfunction
function b7e takes unit b8e returns real
return xUe(b8e,UNIT_STATE_MAX_LIFE)
endfunction
function b9e takes unit Bve,integer Bee,integer Bxe,integer Boe,integer Bre,real Bie,integer Bae,integer Bne,integer BVe,integer BEe,real BXe,integer BOe,integer BRe,integer BIe,integer BAe,integer BNe,integer Bbe,integer BBe returns nothing
if O5e(Bee,0)then
call bze(Bve,Bxe)
endif
if O5e(Bee,1)then
call bFe(Bve,1,false)
elseif O5e(Bee,2)then
call bFe(Bve,1,true)
endif
call bFe(Bve,2,O5e(Bee,3))
if O5e(Bee,4)then
call bve(Bve,Boe,Bre,Bie,Bae,Bne,0)
endif
if O5e(Bee,5)then
call bve(Bve,BVe,BEe,BXe,BOe,BRe,1)
endif
if O5e(Bee,6)then
call bpe(Bve,BIe)
endif
if O5e(Bee,8)then
call bVe(Bve,BAe)
endif
call O0e(Bve,b7e(Bve))
if O5e(Bee,$A)then
call uBv(Bve,BNe)
endif
call Rqe(Bve,bOe(Bve))
if O5e(Bee,$E)then
call bte(Bve,Bbe)
endif
if O5e(Bee,$F)then
call NYe(Bve,BBe)
endif
endfunction
function Bce takes integer BCe,integer Bde,string BDe returns integer
local integer Bfe
if Bde<0 or Bde>=6 then
call Cdv("Index out of Bounds",BDe)
elseif Bde<=2 then
if Bde<=1 then
if Bde<=0 then
set Bfe=az[BCe]
else
set Bfe=nz[BCe]
endif
else
set Bfe=Vz[BCe]
endif
elseif Bde<=4 then
if Bde<=3 then
set Bfe=Ez[BCe]
else
set Bfe=Xz[BCe]
endif
else
set Bfe=Oz[BCe]
endif
return Bfe
endfunction
function BFe takes integer Bge,player BGe,real Bhe,real BHe,real Bje,string BJe returns unit
local unit Bke
local unit BKe
local integer Ble
local integer BLe
local item Bme
local integer BMe
local integer Bpe
local integer BPe
local integer Bqe
local integer BQe
local integer Bse
set ZM[EM]=BJe
set EM=EM+1
set BKe=CreateUnit(BGe,gV[Bge],Bhe,BHe,Bje)
call RSe(BKe,Ace(YV[Bge],0))
set Bke=BKe
if Ace(YV[Bge],2)then
call Rje(Bke,hV[Bge],FV[Bge],kV[Bge],jV[Bge],xV[Bge],vV[Bge],mV[Bge],TV[Bge],"when calling setHeroParameters in UnitData, line 1150")
endif
if Ace(YV[Bge],3)then
call Nee(Bke,RAe(TV[Bge],QV[Bge],"when calling getString in UnitData, line 1153"))
endif
call Nhe(Bke,WV[Bge],EV[Bge],ZV[Bge],UV[Bge],IV[Bge],PV[Bge],AV[Bge],DV[Bge])
call Aze(Bke,HV[Bge],JV[Bge],KV[Bge],LV[Bge],XV[Bge],CV[Bge])
call b9e(Bke,VV[Bge],BV[Bge],NV[Bge],MV[Bge],wB[Bge],uB[Bge],rB[Bge],sB[Bge],tB[Bge],iB[Bge],SB[Bge],cB[Bge],oB[Bge],OB[Bge],lB[Bge],bB[Bge],yB[Bge])
set Ble=0
set BLe=BV[Bge]-1
loop
exitwhen Ble>BLe
if Bce(Bge,Ble,"when reading array SingleUnitData_items in  in UnitData, line 1160")!=0 then
set Bme=AXe(Bce(Bge,Ble,"when reading array SingleUnitData_items in  in UnitData, line 1161"),"when calling create in UnitData, line 1161")
call A8e(Bke,Bme)
call AAe(Bke,Bme,Ble)
endif
set Ble=Ble+1
endloop
if O5e(VV[Bge],$C)then
set BMe=Xle(pB[Bge],"when calling iterator in UnitData, line 1166")
loop
exitwhen not Xie(BMe)
set Bpe=E3e(BMe)
call TMv(Bke,Bpe)
endloop
call Xpe(BMe,"when calling close in UnitData, line 1166")
endif
if O5e(VV[Bge],$D)then
set BPe=Xle(eB[Bge],"when calling iterator in UnitData, line 1169")
loop
exitwhen not Xie(BPe)
set Bqe=E3e(BPe)
call OUe(Bqe,Bke,"when calling apply in UnitData, line 1170")
endloop
call Xpe(BPe,"when calling close in UnitData, line 1169")
endif
if Ace(YV[Bge],1)then
call O3e(Bke)
endif
if A5e(qB[Bge],0)or A5e(qB[Bge],1)then
call O0e(Bke,DQv(aB[Bge]))
endif
if A5e(qB[Bge],2)or A5e(qB[Bge],3)then
call Rqe(Bke,DQv(nB[Bge]))
endif
call NQe(Bke,not R3e(GV[Bge],1))
call Rze(Bke,Bhe,BHe)
if R3e(GV[Bge],2)then
call WaygateActivate(Bke,true)
call WaygateSetDestination(Bke,Bhe+dB[Bge],BHe+fB[Bge])
endif
if R3e(GV[Bge],3)then
call SYv(Bke,UNIT_IF_ARMOR_TYPE,RB[Bge])
endif
if R3e(GV[Bge],4)then
call SYv(Bke,UNIT_IF_DEFENSE_TYPE,TB[Bge])
endif
if R3e(GV[Bge],5)then
set BQe=Xle(YB[Bge],"when calling iterator in UnitData, line 1194")
loop
exitwhen not Xie(BQe)
set Bse=E3e(BQe)
call Mwv(Bke,RAe(TV[Bge],Bse,"when calling getString in UnitData, line 1195"),true)
endloop
call Xpe(BQe,"when calling close in UnitData, line 1194")
endif
if IsUnitType(Bke,UNIT_TYPE_STRUCTURE)then
call UnitAddType(Bke,UNIT_TYPE_SUMMONED)
endif
set EM=EM-1
set IVv=Bke
set Bke=null
set BKe=null
set Bme=null
return IVv
endfunction
function BSe takes integer Bte,player BTe,real Bue,real BUe,real Bwe,string BWe returns unit
local unit Bye
set ZM[EM]=BWe
set EM=EM+1
if Dv[Bte]==0 then
if Bte==0 then
call Cdv("Nullpointer exception when calling SingleUnitData.create","when calling error in UnitData, line 1145")
else
call Cdv("Called SingleUnitData.create on invalid object.","when calling error in UnitData, line 1145")
endif
endif
set Bye=BFe(Bte,BTe,Bue,BUe,Bwe,"when calling create in UnitData, line 1145")
set EM=EM-1
set IWv=Bye
set Bye=null
return IWv
endfunction
function BYe takes integer pEi,integer Bze,integer BZe,string B_e returns integer
local unit B0e
local integer B1e
local integer B2e
local integer B3e
local integer B4e
local integer B5e
set ZM[EM]=B_e
set EM=EM+1
set B0e=PCv(M7v(BZe,0,"when calling get in SotfrpGuiCoreUnit, line 93"),"when calling getInner in SotfrpGuiCoreUnit, line 93")
set B1e=QGv(Bze,"when calling getPlayerId in SotfrpGuiCoreUnit, line 94")
set B2e=ybv("when calling new_StringTable in SotfrpGuiCoreUnit, line 95")
set B3e=YTv(B2e,"when calling new_SingleUnitData in SotfrpGuiCoreUnit, line 96")
call E_e(B3e,B0e,"when calling build in SotfrpGuiCoreUnit, line 96")
set B4e=B3e
call BSe(B4e,sa[B1e],uov(QKv(B1e)),c3,GetUnitFacing(B0e),"when calling create in SotfrpGuiCoreUnit, line 96")
call Xze(B4e,"when calling dispatch_SingleUnitData_destroySingleUnitData in SotfrpGuiCoreUnit, line 96")
call OJe(B2e,"when calling dispatch_StringTable_destroyStringTable in SotfrpGuiCoreUnit, line 97")
set B5e=MLv("when calling nullptr in SotfrpGuiCoreUnit, line 99")
set EM=EM-1
set B0e=null
return B5e
endfunction
function B6e takes string B7e,string B8e returns integer
local integer B9e
set ZM[EM]=B8e
set EM=EM+1
set B9e=p0v(tJv(B7e,"when calling new_Exception in ScmdDataTypes, line 199"),"when calling new_SharedPointer in ScmdDataTypes, line 199")
set EM=EM-1
return B9e
endfunction
function cve takes integer Q2t returns nothing
endfunction
function cee takes integer cxe,string coe returns nothing
call cve(cxe)
set hK[cxe]=coe
endfunction
function cre takes string cie returns integer
local integer cae
set ZM[EM]=cie
set EM=EM+1
if Sx==0 then
if cx<$8000 then
set cx=cx+1
set cae=cx
set ox[cae]=$F0A
else
call Cdv("Out of memory: Could not create Symbol.","when calling error in ScmdDataTypes, line 242")
set cae=0
endif
else
set Sx=Sx-1
set cae=ix[Sx]
set ox[cae]=$F0A
endif
set EM=EM-1
return cae
endfunction
function cne takes string cVe,string cEe returns integer
local integer cXe
set ZM[EM]=cEe
set EM=EM+1
set cXe=cre("when calling alloc_Symbol in ScmdDataTypes, line 253")
call cee(cXe,cVe)
set EM=EM-1
return cXe
endfunction
function cOe takes integer x6i returns nothing
endfunction
function cRe takes integer cIe returns nothing
call cOe(cIe)
endfunction
function cAe takes string cNe returns integer
local integer cbe
set ZM[EM]=cNe
set EM=EM+1
if Sx==0 then
if cx<$8000 then
set cx=cx+1
set cbe=cx
set ox[cbe]=$F0C
else
call Cdv("Out of memory: Could not create Undefined.","when calling error in ScmdDataTypes, line 70")
set cbe=0
endif
else
set Sx=Sx-1
set cbe=ix[Sx]
set ox[cbe]=$F0C
endif
set EM=EM-1
return cbe
endfunction
function cBe takes string cce returns integer
local integer cCe
set ZM[EM]=cce
set EM=EM+1
set cCe=cAe("when calling alloc_Undefined in ScmdDataTypes, line 74")
call cRe(cCe)
set EM=EM-1
return cCe
endfunction
function cde takes integer cDe,integer cfe,string cFe returns integer
local integer cge
local integer cGe
local integer che
set ZM[EM]=cFe
set EM=EM+1
set cge=hIv(Od[cfe],hK[cDe],"when calling get in ScmdDataTypes, line 281")
if cge==0 then
set cGe=p0v(cBe("when calling new_Undefined in ScmdDataTypes, line 283"),"when calling new_SharedPointer in ScmdDataTypes, line 283")
set EM=EM-1
return cGe
endif
set che=P_v(FK[cge],"when calling clone in ScmdDataTypes, line 284")
set EM=EM-1
return che
endfunction
function cHe takes integer cje,integer cJe,string cke returns integer
local integer cKe
set ZM[EM]=cke
set EM=EM+1
if ox[cje]==0 then
if cje==0 then
call Cdv("Nullpointer exception when calling Symbol.resolve","when calling error in ScmdDataTypes, line 280")
else
call Cdv("Called Symbol.resolve on invalid object.","when calling error in ScmdDataTypes, line 280")
endif
endif
set cKe=cde(cje,cJe,"when calling resolve in ScmdDataTypes, line 280")
set EM=EM-1
return cKe
endfunction
function cle takes integer cLe,string cme returns nothing
set ZM[EM]=cme
set EM=EM+1
call mfv(20,FK[cLe],"when calling dispatch_GenericSharedPointer_destroyGenericSharedPointer in ScmdDataTypes, line 240")
set EM=EM-1
endfunction
function cMe takes integer cpe,string cPe returns nothing
set ZM[EM]=cPe
set EM=EM+1
if Ux[cpe]==0 then
call Cdv("Double free: object of type SymbolData","when calling error in ScmdDataTypes, line 226")
else
set Wx[Ex]=cpe
set Ex=Ex+1
set Ux[cpe]=0
endif
set EM=EM-1
endfunction
function cqe takes integer cQe,string cse returns nothing
set ZM[EM]=cse
set EM=EM+1
call cle(cQe,"when calling SymbolData_onDestroy in ScmdDataTypes, line 239")
call cMe(cQe,"when calling dealloc_SymbolData in ScmdDataTypes, line 239")
set EM=EM-1
endfunction
function cSe takes integer cte,string cTe returns nothing
set ZM[EM]=cTe
set EM=EM+1
if Ux[cte]==0 then
if cte==0 then
call Cdv("Nullpointer exception when calling SymbolData.SymbolData","when calling error in ScmdDataTypes, line 226")
else
call Cdv("Called SymbolData.SymbolData on invalid object.","when calling error in ScmdDataTypes, line 226")
endif
endif
call cqe(cte,"when calling destroySymbolData in ScmdDataTypes, line 226")
set EM=EM-1
endfunction
function cue takes string cUe returns integer
local integer cwe
set ZM[EM]=cUe
set EM=EM+1
if Ex==0 then
if Zx<$8000 then
set Zx=Zx+1
set cwe=Zx
set Ux[cwe]=4872
else
call Cdv("Out of memory: Could not create SymbolData.","when calling error in ScmdDataTypes, line 226")
set cwe=0
endif
else
set Ex=Ex-1
set cwe=Wx[Ex]
set Ux[cwe]=4872
endif
set EM=EM-1
return cwe
endfunction
function cWe takes integer K2t returns nothing
endfunction
function cye takes integer cYe,string r5i,string s5i,integer cze,boolean cZe returns nothing
call cWe(cYe)
set FK[cYe]=cze
set kK[cYe]=cZe
endfunction
function c_e takes string c0e,string c1e,integer c2e,boolean c3e,string c4e returns integer
local integer c5e
set ZM[EM]=c4e
set EM=EM+1
set c5e=cue("when calling alloc_SymbolData in ScmdDataTypes, line 233")
call cye(c5e,c0e,c1e,c2e,c3e)
set EM=EM-1
return c5e
endfunction
function c6e takes integer c7e,string c8e,string c9e,string Cve,integer Cee,boolean Cxe,string Coe returns boolean
local integer Cre
set ZM[EM]=Coe
set EM=EM+1
set Cre=hIv(Od[c7e],c8e,"when calling get in ScmdDataTypes, line 263")
if Cre!=0 then
if kK[Cre]then
set EM=EM-1
return false
endif
call cSe(Cre,"when calling dispatch_SymbolData_destroySymbolData in ScmdDataTypes, line 267")
endif
call ZWv(Od[c7e],c8e,c_e(c9e,Cve,Cee,Cxe,"when calling new_SymbolData in ScmdDataTypes, line 268"),"when calling put in ScmdDataTypes, line 268")
set EM=EM-1
return true
endfunction
function Cie takes integer Cae,string Cne,string CVe,string CEe,integer CXe,string COe returns boolean
local boolean CRe
set ZM[EM]=COe
set EM=EM+1
set CRe=c6e(Cae,Cne,CVe,CEe,CXe,false,"when calling assign in ScmdDataTypes, line 272")
set EM=EM-1
return CRe
endfunction
function CIe takes integer CAe,string CNe,integer Cbe,string CBe returns boolean
local boolean Cce
set ZM[EM]=CBe
set EM=EM+1
set Cce=Cie(CAe,CNe,null,null,Cbe,"when calling assign in ScmdDataTypes, line 278")
set EM=EM-1
return Cce
endfunction
function CCe takes integer Cde,string CDe returns nothing
set ZM[EM]=CDe
set EM=EM+1
if ox[Cde]==0 then
if Cde==0 then
call Cdv("Nullpointer exception when calling Symbol.Symbol","when calling error in ScmdDataTypes, line 242")
else
call Cdv("Called Symbol.Symbol on invalid object.","when calling error in ScmdDataTypes, line 242")
endif
endif
call lwv(Cde,"when calling destroySymbol in ScmdDataTypes, line 242")
set EM=EM-1
endfunction
function Cfe takes integer yEt,integer CFe,integer Cge,string CGe returns integer
local integer Che
local integer CHe
local integer Cje
local integer CJe
local integer Cke
local integer CKe
local integer Cle
set ZM[EM]=CGe
set EM=EM+1
set Che=cne(Mqv(M7v(Cge,1,"when calling get in ScmdCoreBuiltins, line 381"),"when calling getInner in ScmdCoreBuiltins, line 381"),"when calling new_Symbol in ScmdCoreBuiltins, line 381")
set CHe=cHe(Che,QGv(CFe,"when calling getPlayerId in ScmdCoreBuiltins, line 382"),"when calling resolve in ScmdCoreBuiltins, line 382")
call CCe(Che,"when calling dispatch_Symbol_destroySymbol in ScmdCoreBuiltins, line 383")
set CKe=ox[m0v(CHe,"when calling get in ScmdCoreBuiltins, line 384")]
if(CKe>=$EEA and CKe<=$EEC)or(CKe>=$EEC and CKe<=$EEF)then
if CIe(QGv(CFe,"when calling getPlayerId in ScmdCoreBuiltins, line 384"),Mqv(M7v(Cge,0,"when calling get in ScmdCoreBuiltins, line 384"),"when calling getInner in ScmdCoreBuiltins, line 384"),P_v(CHe,"when calling clone in ScmdCoreBuiltins, line 384"),"when calling assign in ScmdCoreBuiltins, line 384")then
set CJe=MLv("when calling nullptr in ScmdCoreBuiltins, line 384")
else
set CJe=B6e("Symbol is protected","when calling wrap in ScmdCoreBuiltins, line 384")
endif
set Cke=CJe
else
set Cke=B6e("Cannot assign an alias to non-callable","when calling wrap in ScmdCoreBuiltins, line 384")
endif
set Cje=Cke
call mfv(20,CHe,"when calling dispatch_GenericSharedPointer_destroyGenericSharedPointer in ScmdCoreBuiltins, line 385")
set Cle=Cje
set EM=EM-1
return Cle
endfunction
function CLe takes integer nGi,integer Cme,integer CMe,string Cpe returns integer
local string CPe
local integer Cqe
set ZM[EM]=Cpe
set EM=EM+1
set CPe=Mqv(M7v(CMe,0,"when calling get in ScmdUnitBuiltins, line 715"),"when calling getInner in ScmdUnitBuiltins, line 715")
if CPe!=null then
call Rfe(Mov(Cme,"when calling getEnumUnit in ScmdUnitBuiltins, line 717"),CPe)
endif
set Cqe=MLv("when calling nullptr in ScmdUnitBuiltins, line 718")
set EM=EM-1
return Cqe
endfunction
function CQe takes integer Cse returns integer
return c6v(yK[Cse])
endfunction
function CSe takes integer Cte,string CTe returns integer
local integer Cue
set ZM[EM]=CTe
set EM=EM+1
if ox[Cte]==0 then
if Cte==0 then
call Cdv("Nullpointer exception when calling Real.intValue","when calling error in ScmdDataTypes, line 470")
else
call Cdv("Called Real.intValue on invalid object.","when calling error in ScmdDataTypes, line 470")
endif
endif
if ox[Cte]<=$EFE then
if ox[Cte]<=$EFD then
set Cue=QIv(Cte)
else
set Cue=CQe(Cte)
endif
elseif ox[Cte]<=$F02 then
set Cue=CQe(Cte)
else
set Cue=QIv(Cte)
endif
set EM=EM-1
return Cue
endfunction
function CUe takes integer qQt,integer aQt,integer Cwe,string CWe returns integer
local integer Cye
local integer CYe
local integer Cze
local integer CZe
set ZM[EM]=CWe
set EM=EM+1
set Cye=CSe(M7v(Cwe,0,"when calling get in ScmdCoreBuiltins, line 303"),"when calling intValue in ScmdCoreBuiltins, line 303")
if Cye==0 then
set Cze=0
else
if Cye>0 then
set CYe=GetRandomInt(0,Cye-1)
else
set CYe=GetRandomInt(Cye+1,0)
endif
set Cze=CYe
endif
set CZe=p0v(SSv(Cze,"when calling new_Integer in ScmdCoreBuiltins, line 304"),"when calling new_SharedPointer in ScmdCoreBuiltins, line 304")
set EM=EM-1
return CZe
endfunction
function C_e takes unit C0e returns nothing
if x8e(C0e,'AaI0')then
call bFe(C0e,1,false)
elseif x8e(C0e,'AaI1')then
call bFe(C0e,1,true)
endif
endfunction
function C1e takes unit C2e,boolean C3e,boolean C4e returns nothing
call UnitRemoveBuffs(C2e,C3e,C4e)
call C_e(C2e)
endfunction
function C5e takes integer dRi,integer C6e,integer C7e,string C8e returns integer
local integer C9e
set ZM[EM]=C8e
set EM=EM+1
call C1e(Mov(C6e,"when calling getEnumUnit in ScmdUnitBuiltins, line 631"),WCv(M7v(C7e,0,"when calling get in ScmdUnitBuiltins, line 631"),"when calling booleanValue in ScmdUnitBuiltins, line 631"),WCv(M7v(C7e,1,"when calling get in ScmdUnitBuiltins, line 631"),"when calling booleanValue in ScmdUnitBuiltins, line 631"))
set C9e=MLv("when calling nullptr in ScmdUnitBuiltins, line 632")
set EM=EM-1
return C9e
endfunction
function dve takes real dee,real dxe,real doe returns real
local real dre
local real die
if dee<=dxe then
set die=dxe
else
if dee>=doe then
set dre=doe
else
set dre=dee
endif
set die=dre
endif
return die
endfunction
function dae takes integer dYi,integer fYi,integer dne,string dVe returns integer
local integer dEe
set ZM[EM]=dVe
set EM=EM+1
call Rue(PCv(M7v(dne,0,"when calling get in ScmdUnitBuiltins, line 686"),"when calling getInner in ScmdUnitBuiltins, line 686"),dve(uev(PCv(M7v(dne,0,"when calling get in ScmdUnitBuiltins, line 686"),"when calling getInner in ScmdUnitBuiltins, line 686"))+PEv(M7v(dne,1,"when calling get in ScmdUnitBuiltins, line 686"),"when calling realValue in ScmdUnitBuiltins, line 686"),VT,CT))
set dEe=MLv("when calling nullptr in ScmdUnitBuiltins, line 687")
set EM=EM-1
return dEe
endfunction
function dXe takes integer dci,integer dOe,integer Rci,string dRe returns integer
local integer dIe
set ZM[EM]=dRe
set EM=EM+1
set dIe=p0v(q2v(e8e(Mov(dOe,"when calling getEnumUnit in ScmdUnitBuiltins, line 137")),"when calling new_Real in ScmdUnitBuiltins, line 137"),"when calling new_SharedPointer in ScmdUnitBuiltins, line 137")
set EM=EM-1
return dIe
endfunction
function dAe takes unit dNe,integer dbe,boolean dBe returns nothing
call SetHeroLevel(dNe,dbe,dBe)
endfunction
function dce takes unit dCe,integer dde returns boolean
return UnitStripHeroLevel(dCe,dde)
endfunction
function dDe takes unit dfe returns integer
local integer dFe
if xze(dfe,UNIT_TYPE_HERO)then
set dFe=GetHeroLevel(dfe)
else
set dFe=GetUnitLevel(dfe)
endif
return dFe
endfunction
function dge takes integer adi,integer ndi,integer dGe,string dhe returns integer
local unit dHe
local integer dje
local integer dJe
set ZM[EM]=dhe
set EM=EM+1
set dHe=PCv(M7v(dGe,0,"when calling get in ScmdUnitBuiltins, line 559"),"when calling getInner in ScmdUnitBuiltins, line 559")
set dje=QNv(M7v(dGe,1,"when calling get in ScmdUnitBuiltins, line 560"),"when calling intValue in ScmdUnitBuiltins, line 560")
if dje>=dDe(dHe)then
call dAe(dHe,dje,false)
else
call dce(dHe,dDe(dHe)-dje)
endif
set dJe=MLv("when calling nullptr in ScmdUnitBuiltins, line 565")
set EM=EM-1
set dHe=null
return dJe
endfunction
function dke takes integer mBt returns nothing
endfunction
function dKe takes integer dle returns nothing
call dke(dle)
endfunction
function dLe takes string dme returns integer
local integer dMe
set ZM[EM]=dme
set EM=EM+1
if Sx==0 then
if cx<$8000 then
set cx=cx+1
set dMe=cx
set ox[dMe]=$F00
else
call Cdv("Out of memory: Could not create Null.","when calling error in ScmdDataTypes, line 85")
set dMe=0
endif
else
set Sx=Sx-1
set dMe=ix[Sx]
set ox[dMe]=$F00
endif
set EM=EM-1
return dMe
endfunction
function dpe takes string dPe returns integer
local integer dqe
set ZM[EM]=dPe
set EM=EM+1
set dqe=dLe("when calling alloc_Null in ScmdDataTypes, line 89")
call dKe(dqe)
set EM=EM-1
return dqe
endfunction
function dQe takes integer dnt,integer dse,integer dSe,string dte returns integer
local integer dTe
set ZM[EM]=dte
set EM=EM+1
if ta==sa[QGv(dse,"when calling getPlayerId in SLangPlayerFunctions, line 56")]then
call SetCameraField(CAMERA_FIELD_TARGET_DISTANCE,PEv(M7v(dSe,0,"when calling get in SLangPlayerFunctions, line 57"),"when calling realValue in SLangPlayerFunctions, line 57"),2.)
endif
set dTe=p0v(dpe("when calling new_Null in SLangPlayerFunctions, line 58"),"when calling new_SharedPointer in SLangPlayerFunctions, line 58")
set EM=EM-1
return dTe
endfunction
function due takes integer doi,integer dUe,integer dwe,string dWe returns integer
local integer dye
set ZM[EM]=dWe
set EM=EM+1
call Aqe(Mov(dUe,"when calling getEnumUnit in ScmdUnitBuiltins, line 162"),PEv(M7v(dwe,0,"when calling get in ScmdUnitBuiltins, line 162"),"when calling realValue in ScmdUnitBuiltins, line 162"))
set dye=MLv("when calling nullptr in ScmdUnitBuiltins, line 163")
set EM=EM-1
return dye
endfunction
function dYe takes integer U0i,integer I0i,integer dze,string dZe returns integer
local integer d_e
set ZM[EM]=dZe
set EM=EM+1
call IJe(Wlv(M7v(dze,0,"when calling get in ScmdItemBuiltins, line 42"),"when calling getInner in ScmdItemBuiltins, line 42"),QNv(M7v(dze,1,"when calling get in ScmdItemBuiltins, line 42"),"when calling intValue in ScmdItemBuiltins, line 42"))
set d_e=MLv("when calling nullptr in ScmdItemBuiltins, line 43")
set EM=EM-1
return d_e
endfunction
function d0e takes integer URi,integer IRi,integer d1e,string d2e returns integer
local integer d3e
set ZM[EM]=d2e
set EM=EM+1
call SetUnitFacing(PCv(M7v(d1e,0,"when calling get in ScmdUnitBuiltins, line 641"),"when calling getInner in ScmdUnitBuiltins, line 641"),PEv(M7v(d1e,1,"when calling get in ScmdUnitBuiltins, line 641"),"when calling realValue in ScmdUnitBuiltins, line 641"))
set d3e=MLv("when calling nullptr in ScmdUnitBuiltins, line 642")
set EM=EM-1
return d3e
endfunction
function d4e takes integer X7i returns string
return"WeatherEffect { }"
endfunction
function d5e takes group d6e returns integer
return BlzGroupGetSize(d6e)
endfunction
function d7e takes integer d8e returns string
return"Group { size: "+SMv(d5e(cK[d8e]))+" }"
endfunction
function d9e takes integer Dve returns string
return GK[Dve]
endfunction
function Dee takes integer Dxe returns string
return d9e(Dxe)
endfunction
function Doe takes integer Dre returns string
return d9e(Dre)
endfunction
function Die takes integer PPt returns integer
return In
endfunction
function Dae takes integer R4t returns integer
return cd
endfunction
function Dne takes integer DVe returns integer
return Dae(DVe)
endfunction
function DEe takes integer WZt returns integer
return Zn
endfunction
function DXe takes integer Y3t returns integer
return td
endfunction
function DOe takes integer Y6i returns integer
return nd
endfunction
function DRe takes integer LCt returns integer
return Nn
endfunction
function DIe takes integer DAe returns integer
return DRe(DAe)
endfunction
function DNe takes integer K7i returns integer
return Rd
endfunction
function Dbe takes integer KXt returns integer
return Vn
endfunction
function DBe takes integer NVt returns integer
return Mn
endfunction
function Dce takes integer SNt returns integer
return ud
endfunction
function DCe takes integer Dde returns integer
return Dce(Dde)
endfunction
function DDe takes integer f5i returns integer
return ld
endfunction
function Dfe takes integer f8i returns integer
return Td
endfunction
function DFe takes integer ZEt returns integer
return En
endfunction
function Dge takes integer L6i returns integer
return dd
endfunction
function DGe takes integer nIt returns integer
return Un
endfunction
function Dhe takes integer pMt returns integer
return rd
endfunction
function DHe takes integer d2t returns integer
return od
endfunction
function Dje takes integer gBt returns integer
return wd
endfunction
function DJe takes integer gCt returns integer
return Bn
endfunction
function Dke takes integer kJt returns integer
return Hn
endfunction
function DKe takes integer vDt returns integer
return Jn
endfunction
function Dle takes integer a7i returns integer
return fd
endfunction
function DLe takes integer e1t returns integer
return id
endfunction
function Dme takes integer u3t returns integer
return sd
endfunction
function DMe takes integer x1t returns integer
return Sd
endfunction
function Dpe takes integer xKt returns integer
return Kn
endfunction
function DPe takes integer MJt returns integer
return Jn
endfunction
function Dqe takes integer bDt returns integer
return Pn
endfunction
function DQe takes integer Dse returns integer
return DEe(Dse)
endfunction
function DSe takes integer Dte,string DTe returns integer
local integer Due
set ZM[EM]=DTe
set EM=EM+1
if ox[Dte]==0 then
if Dte==0 then
call Cdv("Nullpointer exception when calling Object.getTypeToken","when calling error in ScmdDataTypes, line 65")
else
call Cdv("Called Object.getTypeToken on invalid object.","when calling error in ScmdDataTypes, line 65")
endif
endif
if ox[Dte]<=$EFD then
if ox[Dte]<=$EF4 then
if ox[Dte]<=$EF0 then
if ox[Dte]<=$EED then
if ox[Dte]<=$EEC then
set Due=DGe(Dte)
else
set Due=Die(Dte)
endif
elseif ox[Dte]<=$EEF then
set Due=DXe(Dte)
else
set Due=Dqe(Dte)
endif
elseif ox[Dte]<=$EF2 then
if ox[Dte]<=$EF1 then
set Due=DPe(Dte)
else
set Due=DKe(Dte)
endif
elseif ox[Dte]<=$EF3 then
set Due=Dpe(Dte)
else
set Due=Dbe(Dte)
endif
elseif ox[Dte]<=$EF8 then
if ox[Dte]<=$EF6 then
if ox[Dte]<=$EF5 then
set Due=DJe(Dte)
else
set Due=DFe(Dte)
endif
elseif ox[Dte]<=$EF7 then
set Due=Dfe(Dte)
else
set Due=Dke(Dte)
endif
elseif ox[Dte]<=$EFA then
if ox[Dte]<=$EF9 then
set Due=DBe(Dte)
else
set Due=Dge(Dte)
endif
elseif ox[Dte]<=$EFC then
set Due=DQe(Dte)
else
set Due=DIe(Dte)
endif
elseif ox[Dte]<=$F06 then
if ox[Dte]<=$F02 then
if ox[Dte]<=$EFF then
if ox[Dte]<=$EFE then
set Due=DCe(Dte)
else
set Due=Dne(Dte)
endif
elseif ox[Dte]<=$F00 then
set Due=Dje(Dte)
else
set Due=Dce(Dte)
endif
elseif ox[Dte]<=$F04 then
if ox[Dte]<=$F03 then
set Due=DRe(Dte)
else
set Due=Dhe(Dte)
endif
elseif ox[Dte]<=$F05 then
set Due=Dme(Dte)
else
set Due=DLe(Dte)
endif
elseif ox[Dte]<=$F0A then
if ox[Dte]<=$F08 then
if ox[Dte]<=$F07 then
set Due=DMe(Dte)
else
set Due=Dae(Dte)
endif
elseif ox[Dte]<=$F09 then
set Due=DEe(Dte)
else
set Due=DHe(Dte)
endif
elseif ox[Dte]<=$F0C then
if ox[Dte]<=$F0B then
set Due=DDe(Dte)
else
set Due=DOe(Dte)
endif
elseif ox[Dte]<=$F0D then
set Due=Dle(Dte)
else
set Due=DNe(Dte)
endif
set EM=EM-1
return Due
endfunction
function DUe takes integer Dwe returns string
return WK[Dwe]
endfunction
function DWe takes integer Dye,string DYe returns string
local string Dze
set ZM[EM]=DYe
set EM=EM+1
if Qx[Dye]==0 then
if Dye==0 then
call Cdv("Nullpointer exception when calling GenericTypeToken.getName","when calling error in ScmdDataTypes, line 16")
else
call Cdv("Called GenericTypeToken.getName on invalid object.","when calling error in ScmdDataTypes, line 16")
endif
endif
set Dze=DUe(Dye)
set EM=EM-1
return Dze
endfunction
function DZe takes integer D_e,string D0e returns string
local string D1e
set ZM[EM]=D0e
set EM=EM+1
set D1e=DWe(DSe(D_e,"when calling getTypeToken in ScmdDataTypes, line 68"),"when calling getName in ScmdDataTypes, line 68")+" { }"
set EM=EM-1
return D1e
endfunction
function D2e takes integer D3e returns string
return"SpecialEffect { modelName: \""+YK[D3e]+"\" }"
endfunction
function D4e takes integer D5e returns string
return hK[D5e]
endfunction
function D6e takes integer D7e returns string
return"Unit { name: \""+zAv(ZK[D7e])+"\" }"
endfunction
function D8e takes integer T5i returns string
return"Trigger { }"
endfunction
function D9e takes rect fve returns real
return GetRectMaxY(fve)
endfunction
function fee takes rect fxe returns real
return GetRectMinX(fxe)
endfunction
function foe takes rect fre returns real
return GetRectMinY(fre)
endfunction
function fie takes rect fae returns real
return GetRectMaxX(fae)
endfunction
function fne takes integer fVe returns string
return"Rect { minX: "+qwv(fee(eK[fVe]))+", minY: "+qwv(foe(eK[fVe]))+", maxX: "+qwv(fie(eK[fVe]))+", maxY: "+qwv(D9e(eK[fVe]))+" }"
endfunction
function fEe takes integer fXe returns string
return d9e(fXe)
endfunction
function fOe takes integer g6i returns string
return"undefined"
endfunction
function fRe takes integer fIe returns string
return d9e(fIe)
endfunction
function fAe takes integer FBt returns string
return"null"
endfunction
function fNe takes integer fbe returns string
return"Sound { fileName: \""+RK[fbe]+"\" }"
endfunction
function fBe takes integer s3t returns string
return"Region { }"
endfunction
function fce takes integer fCe returns string
return"Item { name: \""+aBe(bK[fCe])+"\" }"
endfunction
function fde takes destructable fDe returns string
return GetDestructableName(fDe)
endfunction
function ffe takes integer fFe returns string
return"Destructable { name: \""+fde(MJ[fFe])+"\" }"
endfunction
function fge takes integer fGe,integer fhe,string fHe returns nothing
local string fje
local integer fJe
local string fke
local string fKe
local string fle
if fGe==0 then
set ZM[EM]=fHe
set EM=EM+1
set fje=""
if skv(fhe,"when calling size in ScmdDataTypes, line 1082")>0 then
set fKe=fje
call fge(1,m0v(sTv(fhe,0,"when calling get in ScmdDataTypes, line 1083"),"when calling get in ScmdDataTypes, line 1083"),"when calling toString in ScmdDataTypes, line 1083")
set fje=fKe+RHv
set fJe=1
loop
exitwhen not(fJe<skv(fhe,"when calling size in ScmdDataTypes, line 1085"))
set fle=fje
call fge(1,m0v(sTv(fhe,fJe,"when calling get in ScmdDataTypes, line 1086"),"when calling get in ScmdDataTypes, line 1086"),"when calling toString in ScmdDataTypes, line 1086")
set fje=fle+", "+RHv
set fJe=fJe+1
endloop
endif
set EM=EM-1
set RHv="["+fje+"]"
return
elseif fGe==1 then
set ZM[EM]=fHe
set EM=EM+1
if ox[fhe]==0 then
if fhe==0 then
call Cdv("Nullpointer exception when calling Object.toString","when calling error in ScmdDataTypes, line 67")
else
call Cdv("Called Object.toString on invalid object.","when calling error in ScmdDataTypes, line 67")
endif
endif
if ox[fhe]<=$F00 then
if ox[fhe]<=$EFA then
if ox[fhe]<=$EF7 then
if ox[fhe]<=$EF4 then
if ox[fhe]<=$EF3 then
set fke=DZe(fhe,"when calling toString in ScmdDataTypes, line 67")
else
set fke=d7e(fhe)
endif
else
set fke=DZe(fhe,"when calling toString in ScmdDataTypes, line 67")
endif
elseif ox[fhe]<=$EF9 then
if ox[fhe]<=$EF8 then
set fke=ffe(fhe)
else
set fke=fce(fhe)
endif
else
set fke=D6e(fhe)
endif
elseif ox[fhe]<=$EFD then
if ox[fhe]<=$EFC then
if ox[fhe]<=$EFB then
set fke=DZe(fhe,"when calling toString in ScmdDataTypes, line 67")
else
set fke=fEe(fhe)
endif
else
set fke=fRe(fhe)
endif
elseif ox[fhe]<=$EFF then
if ox[fhe]<=$EFE then
set fke=Dee(fhe)
else
set fke=Doe(fhe)
endif
else
set fke=fAe(fhe)
endif
elseif ox[fhe]<=$F07 then
if ox[fhe]<=$F04 then
if ox[fhe]<=$F03 then
if ox[fhe]<=$F01 then
set fke=DZe(fhe,"when calling toString in ScmdDataTypes, line 67")
else
set fke=d9e(fhe)
endif
else
set fke=fne(fhe)
endif
elseif ox[fhe]<=$F06 then
if ox[fhe]<=$F05 then
set fke=fBe(fhe)
else
set fke=fNe(fhe)
endif
else
set fke=D2e(fhe)
endif
elseif ox[fhe]<=$F0B then
if ox[fhe]<=$F0A then
if ox[fhe]<=$F09 then
set fke=d9e(fhe)
else
set fke=D4e(fhe)
endif
else
set fke=D8e(fhe)
endif
elseif ox[fhe]<=$F0D then
if ox[fhe]<=$F0C then
set fke=fOe(fhe)
else
call fge(0,fhe,"when calling toString in ScmdDataTypes, line 67")
set fke=RHv
endif
else
set fke=d4e(fhe)
endif
set EM=EM-1
set RHv=fke
return
endif
endfunction
function fLe takes integer UYi,integer IYi,integer fme,string fMe returns integer
local integer fpe
set ZM[EM]=fMe
set EM=EM+1
set fpe=p0v(qRv(IsHeroUnitId(QNv(M7v(fme,0,"when calling get in ScmdUnitBuiltins, line 696"),"when calling intValue in ScmdUnitBuiltins, line 696")),"when calling new_Boolean in ScmdUnitBuiltins, line 696"),"when calling new_SharedPointer in ScmdUnitBuiltins, line 696")
set EM=EM-1
return fpe
endfunction
function fPe takes integer Uci,integer Ici,integer fqe,string fQe returns integer
local integer fse
set ZM[EM]=fQe
set EM=EM+1
call AWe(PCv(M7v(fqe,0,"when calling get in ScmdUnitBuiltins, line 145"),"when calling getInner in ScmdUnitBuiltins, line 145"),PEv(M7v(fqe,1,"when calling get in ScmdUnitBuiltins, line 145"),"when calling realValue in ScmdUnitBuiltins, line 145"))
set fse=MLv("when calling nullptr in ScmdUnitBuiltins, line 146")
set EM=EM-1
return fse
endfunction
function fSe takes integer Udi,integer fte,integer fTe,string fue returns integer
local integer fUe
set ZM[EM]=fue
set EM=EM+1
call O8e(Mov(fte,"when calling getEnumUnit in ScmdUnitBuiltins, line 573"),QNv(M7v(fTe,0,"when calling get in ScmdUnitBuiltins, line 573"),"when calling intValue in ScmdUnitBuiltins, line 573"))
set fUe=MLv("when calling nullptr in ScmdUnitBuiltins, line 574")
set EM=EM-1
return fUe
endfunction
function fwe takes integer P1t returns nothing
endfunction
function fWe takes integer fye,string fYe,real fze,real fZe returns nothing
call fwe(fye)
set TK[fye]=AddSpecialEffect(fYe,fze,fZe)
set YK[fye]=fYe
endfunction
function f_e takes string f0e returns integer
local integer f1e
set ZM[EM]=f0e
set EM=EM+1
if Sx==0 then
if cx<$8000 then
set cx=cx+1
set f1e=cx
set ox[f1e]=$F07
else
call Cdv("Out of memory: Could not create SpecialEffect.","when calling error in ScmdDataTypes, line 592")
set f1e=0
endif
else
set Sx=Sx-1
set f1e=ix[Sx]
set ox[f1e]=$F07
endif
set EM=EM-1
return f1e
endfunction
function f2e takes string f3e,real f4e,real f5e,string f6e returns integer
local integer f7e
set ZM[EM]=f6e
set EM=EM+1
set f7e=f_e("when calling alloc_SpecialEffect in ScmdDataTypes, line 602")
call fWe(f7e,f3e,f4e,f5e)
set EM=EM-1
return f7e
endfunction
function f8e takes integer Udt,integer Idt,integer f9e,string Fve returns integer
local integer Fee
set ZM[EM]=Fve
set EM=EM+1
set Fee=p0v(f2e(Mqv(M7v(f9e,0,"when calling get in SLangSpecialEffectFunctions, line 7"),"when calling getInner in SLangSpecialEffectFunctions, line 7"),PEv(M7v(f9e,1,"when calling get in SLangSpecialEffectFunctions, line 7"),"when calling realValue in SLangSpecialEffectFunctions, line 7"),PEv(M7v(f9e,2,"when calling get in SLangSpecialEffectFunctions, line 7"),"when calling realValue in SLangSpecialEffectFunctions, line 7"),"when calling new_SpecialEffect in SLangSpecialEffectFunctions, line 7"),"when calling new_SharedPointer in SLangSpecialEffectFunctions, line 7")
set EM=EM-1
return Fee
endfunction
function Fxe takes integer Uoi,integer Ioi,integer Foe,string Fre returns integer
local integer Fie
set ZM[EM]=Fre
set EM=EM+1
call bze(PCv(M7v(Foe,0,"when calling get in ScmdUnitBuiltins, line 172"),"when calling getInner in ScmdUnitBuiltins, line 172"),QNv(M7v(Foe,1,"when calling get in ScmdUnitBuiltins, line 172"),"when calling intValue in ScmdUnitBuiltins, line 172"))
set Fie=MLv("when calling nullptr in ScmdUnitBuiltins, line 173")
set EM=EM-1
return Fie
endfunction
function Fae takes integer Fne returns camerasetup
return IJ[Fne]
endfunction
function FVe takes integer FEe,string FXe returns camerasetup
local camerasetup FOe
set ZM[EM]=FXe
set EM=EM+1
if ox[FEe]==0 then
if FEe==0 then
call Cdv("Nullpointer exception when calling CameraSetup.getInner","when calling error in ScmdDataTypes, line 886")
else
call Cdv("Called CameraSetup.getInner on invalid object.","when calling error in ScmdDataTypes, line 886")
endif
endif
set FOe=Fae(FEe)
set EM=EM-1
set IDv=FOe
set FOe=null
return IDv
endfunction
function FRe takes integer QGt,integer WGt,integer FIe,string FAe returns integer
local integer FNe
set ZM[EM]=FAe
set EM=EM+1
call CameraSetupSetField(FVe(M7v(FIe,0,"when calling get in ScmdCameraSetupBuiltins, line 10"),"when calling getInner in ScmdCameraSetupBuiltins, line 10"),ConvertCameraField(QNv(M7v(FIe,1,"when calling get in ScmdCameraSetupBuiltins, line 10"),"when calling intValue in ScmdCameraSetupBuiltins, line 10")),PEv(M7v(FIe,2,"when calling get in ScmdCameraSetupBuiltins, line 10"),"when calling realValue in ScmdCameraSetupBuiltins, line 10"),PEv(M7v(FIe,3,"when calling get in ScmdCameraSetupBuiltins, line 10"),"when calling realValue in ScmdCameraSetupBuiltins, line 10"))
set FNe=MLv("when calling nullptr in ScmdCameraSetupBuiltins, line 11")
set EM=EM-1
return FNe
endfunction
function Fbe takes integer QOi,integer FBe,integer EOi,string Fce returns integer
local integer FCe
set ZM[EM]=Fce
set EM=EM+1
set FCe=p0v(pjv(Mov(FBe,"when calling getEnumUnit in ScmdUnitBuiltins, line 226"),"when calling new_Unit in ScmdUnitBuiltins, line 226"),"when calling new_SharedPointer in ScmdUnitBuiltins, line 226")
set EM=EM-1
return FCe
endfunction
function Fde takes integer FDe,string Ffe returns nothing
set ZM[EM]=Ffe
set EM=EM+1
if BY[FDe]==0 then
call Cdv("Double free: object of type ForForceCallback","when calling error in Execute, line 9")
else
set XY[CY]=FDe
set CY=CY+1
set BY[FDe]=0
endif
set EM=EM-1
endfunction
function FFe takes integer Fge,string FGe returns nothing
set ZM[EM]=FGe
set EM=EM+1
call Fde(Fge,"when calling dealloc_ForForceCallback in Execute, line 9")
set EM=EM-1
endfunction
function Fhe takes integer FHe,string Fje returns nothing
set ZM[EM]=Fje
set EM=EM+1
if BY[FHe]==0 then
if FHe==0 then
call Cdv("Nullpointer exception when calling ForForceCallback.ForForceCallback","when calling error in Execute, line 9")
else
call Cdv("Called ForForceCallback.ForForceCallback on invalid object.","when calling error in Execute, line 9")
endif
endif
call FFe(FHe,"when calling destroyForForceCallback in Execute, line 9")
set EM=EM-1
endfunction
function FJe takes string Fke returns nothing
set ZM[EM]=Fke
set EM=EM+1
set re=re-1
call Fhe(ue[re],"when calling dispatch_ForForceCallback_destroyForForceCallback in Execute, line 33")
set EM=EM-1
endfunction
function FKe takes nothing returns boolean
return we[re]
endfunction
function Fle takes integer FLe returns nothing
set ue[re]=FLe
set we[re]=false
set re=re+1
endfunction
function Fme takes force FMe,code Fpe returns nothing
call ForForce(FMe,Fpe)
endfunction
function FPe takes integer Fqe,string FQe returns boolean
local boolean Fse
local boolean FSe
set ZM[EM]=FQe
set EM=EM+1
call Fle(Fqe)
set Fse=Np
set Np=true
call Fme(Mp,Otv)
set Np=Fse
call FJe("when calling popCallback in Execute, line 101")
set FSe=FKe()
set EM=EM-1
return FSe
endfunction
function Fte takes integer FTe,string Fue returns nothing
set ZM[EM]=Fue
set EM=EM+1
if not FPe(FTe,"when calling try in Execute, line 78")then
call Cdv("execute: thread has crashed. caused by:
| - "+Bp,"when calling error in Execute, line 79")
endif
set EM=EM-1
endfunction
function FUe takes string Fwe returns integer
local integer FWe
set ZM[EM]=Fwe
set EM=EM+1
if CY==0 then
if VY<$8000 then
set VY=VY+1
set FWe=VY
set BY[FWe]=$85D
else
call Cdv("Out of memory: Could not create ForForceCallback_execute_SotFRP_SaveLoad.","when calling error in SotFRP_SaveLoad, line 81")
set FWe=0
endif
else
set CY=CY-1
set FWe=XY[CY]
set BY[FWe]=$85D
endif
set EM=EM-1
return FWe
endfunction
function Fye takes boolexpr FYe returns nothing
call DestroyBoolExpr(FYe)
endfunction
function Fze takes boolexpr FZe,boolexpr F_e returns boolexpr
return And(FZe,F_e)
endfunction
function F0e takes player F1e,rect F2e,boolexpr F3e returns group
local group F4e=CreateGroup()
local boolexpr F5e
set ua=F1e
set F5e=Fze(ra,F3e)
call GroupEnumUnitsInRect(F4e,F2e,F5e)
call Fye(F5e)
set Rqv=F4e
set F4e=null
set F5e=null
return Rqv
endfunction
function F6e takes group F7e returns unit
local unit F8e=FirstOfGroup(F7e)
call GroupRemoveUnit(F7e,F8e)
set Rpv=F8e
set F8e=null
return Rpv
endfunction
function F9e takes group gve returns boolean
return FirstOfGroup(gve)!=null
endfunction
function gee takes integer gxe,rect goe,string gre returns nothing
local group gie
local unit gae
local group gne
local integer gVe
set ZM[EM]=gre
set EM=EM+1
call Preload(ff)
set gie=F0e(sa[gxe],goe,Filter(O7v))
set gne=gie
loop
exitwhen not F9e(gne)
set gae=F6e(gne)
set gVe=FUe("when calling alloc_ForForceCallback_execute_SotFRP_SaveLoad in SotFRP_SaveLoad, line 81")
set fL[gVe]=gae
set RL[gVe]=goe
call Fte(gVe,"when calling execute in SotFRP_SaveLoad, line 81")
endloop
call kcv(gie)
call Preload(Rf)
set EM=EM-1
set gie=null
set gae=null
set gne=null
endfunction
function gEe takes integer gXe returns rect
return eK[gXe]
endfunction
function gOe takes integer gRe,string gIe returns rect
local rect gAe
set ZM[EM]=gIe
set EM=EM+1
if ox[gRe]==0 then
if gRe==0 then
call Cdv("Nullpointer exception when calling Rect.getInner","when calling error in ScmdDataTypes, line 702")
else
call Cdv("Called Rect.getInner on invalid object.","when calling error in ScmdDataTypes, line 702")
endif
endif
set gAe=gEe(gRe)
set EM=EM-1
set IKv=gAe
set gAe=null
return IKv
endfunction
function gNe takes integer QQi,integer gbe,integer gBe,string gce returns integer
local integer gCe
set ZM[EM]=gce
set EM=EM+1
call PreloadGenClear()
call gee(QGv(gbe,"when calling getPlayerId in SotFRP_SaveLoad, line 133"),gOe(M7v(gBe,0,"when calling get in SotFRP_SaveLoad, line 133"),"when calling getInner in SotFRP_SaveLoad, line 133"),"when calling writeUnits in SotFRP_SaveLoad, line 133")
if ta==sa[QGv(gbe,"when calling getPlayerId in SotFRP_SaveLoad, line 134")]then
call PreloadGenEnd("SotFRP\\Save\\"+Mqv(M7v(gBe,1,"when calling get in SotFRP_SaveLoad, line 135"),"when calling getInner in SotFRP_SaveLoad, line 135")+".pld")
endif
set gCe=p0v(dpe("when calling new_Null in SotFRP_SaveLoad, line 136"),"when calling new_SharedPointer in SotFRP_SaveLoad, line 136")
set EM=EM-1
return gCe
endfunction
function gde takes integer QWt,integer WWt,integer gDe,string gfe returns integer
local integer gFe
set ZM[EM]=gfe
set EM=EM+1
set gFe=p0v(qRv(not WCv(M7v(gDe,0,"when calling get in ScmdCoreBuiltins, line 365"),"when calling booleanValue in ScmdCoreBuiltins, line 365"),"when calling new_Boolean in ScmdCoreBuiltins, line 365"),"when calling new_SharedPointer in ScmdCoreBuiltins, line 365")
set EM=EM-1
return gFe
endfunction
function gge takes unit gGe,unitweaponrealfield ghe,integer gHe,real gje returns boolean
return BlzSetUnitWeaponRealField(gGe,ghe,gHe,gje)
endfunction
function gJe takes integer Qai,integer Wai,integer gke,string gKe returns integer
local integer gle
set ZM[EM]=gKe
set EM=EM+1
call gge(PCv(M7v(gke,0,"when calling get in ScmdUnitBuiltins, line 421"),"when calling getInner in ScmdUnitBuiltins, line 421"),UNIT_WEAPON_RF_ATTACK_RANGE,QNv(M7v(gke,2,"when calling get in ScmdUnitBuiltins, line 421"),"when calling intValue in ScmdUnitBuiltins, line 421"),PEv(M7v(gke,1,"when calling get in ScmdUnitBuiltins, line 421"),"when calling realValue in ScmdUnitBuiltins, line 421"))
set gle=MLv("when calling nullptr in ScmdUnitBuiltins, line 422")
set EM=EM-1
return gle
endfunction
function gLe takes integer Qei,integer gme,integer gMe,string gpe returns integer
local integer gPe
set ZM[EM]=gpe
set EM=EM+1
call bpe(Mov(gme,"when calling getEnumUnit in ScmdUnitBuiltins, line 368"),QNv(M7v(gMe,0,"when calling get in ScmdUnitBuiltins, line 368"),"when calling intValue in ScmdUnitBuiltins, line 368"))
set gPe=MLv("when calling nullptr in ScmdUnitBuiltins, line 369")
set EM=EM-1
return gPe
endfunction
function gqe takes integer Qii,integer gQe,integer Eii,string gse returns integer
local integer gSe
set ZM[EM]=gse
set EM=EM+1
set gSe=p0v(q2v(T6v(ewe(Mov(gQe,"when calling getEnumUnit in ScmdUnitBuiltins, line 92"))),"when calling new_Real in ScmdUnitBuiltins, line 92"),"when calling new_SharedPointer in ScmdUnitBuiltins, line 92")
set EM=EM-1
return gSe
endfunction
function gte takes integer Dyt,integer Hyt,string gTe returns string
return"|cff808040[SYS]|r "+gTe
endfunction
function gue takes integer gUe returns string
local integer gwe=gUe/16
local integer gWe=gUe-gwe*16
return Qp[gwe]+Qp[gWe]
endfunction
function gye takes integer gYe,integer gze,integer gZe returns string
return"|cff"+gue(gYe)+gue(gze)+gue(gZe)
endfunction
function g_e takes player g0e returns playercolor
return GetPlayerColor(g0e)
endfunction
function g1e takes integer g2e,integer g3e,integer g4e,integer Hlu returns integer
set p3=g2e
set e3=g3e
set q3=g4e
return p3
endfunction
function g5e takes playercolor g6e returns integer
local integer g7e
local integer g8e
local integer g9e
local integer Gve
local integer Gee
local integer Gxe
local integer Goe
local integer Gre
local integer Gie
local integer Gae
if tpv(g6e)<=kp then
set Gve=tpv(g6e)
set Gee=jp[Gve]
set Gxe=xp[Gve]
set Goe=vp[Gve]
set g7e=Gee
set g8e=Gxe
set g9e=Goe
else
set Gre=g1e(dp,fp,Rp,Tp)
set Gie=e3
set Gae=q3
set g7e=Gre
set g8e=Gie
set g9e=Gae
endif
set l3=g7e
set b3=g8e
set y3=g9e
return l3
endfunction
function Gne takes player GVe returns string
return gye(g5e(g_e(GVe)),b3,y3)+GetPlayerName(GVe)+"|r"
endfunction
function GEe takes integer Qyt,integer GXe,string GOe returns string
return"|cff808040[OOC]|r "+Gne(sa[GXe])+": "+GOe
endfunction
function GRe takes integer jyt,integer GIe,string GAe returns string
return"|cFF808040[|r"+gye(g5e(g_e(sa[GIe])),b3,y3)+"IC|r"+"|cFF808040]|r "+GAe
endfunction
function GNe takes integer Gbe,integer GBe,string Gce,string GCe returns string
local string Gde
set ZM[EM]=GCe
set EM=EM+1
if bj[Gbe]==0 then
if Gbe==0 then
call Cdv("Nullpointer exception when calling IMessageFormatter.call","when calling error in SLangChatSystem, line 133")
else
call Cdv("Called IMessageFormatter.call on invalid object.","when calling error in SLangChatSystem, line 133")
endif
endif
if bj[Gbe]<=$BA9 then
if bj[Gbe]<=$BA8 then
set Gde=GRe(Gbe,GBe,Gce)
else
set Gde=GEe(Gbe,GBe,Gce)
endif
else
set Gde=gte(Gbe,GBe,Gce)
endif
set EM=EM-1
return Gde
endfunction
function GDe takes string Gfe,real GFe,player Gge returns nothing
call DisplayTimedTextToPlayer(Gge,.0,.0,GFe,Gfe)
endfunction
function GGe takes integer Ghe,integer GHe,string Gje returns nothing
set ZM[EM]=Gje
set EM=EM+1
set sP[rP[GHe]]=sP[GHe]
set rP[sP[GHe]]=rP[GHe]
call HVv(GHe,"when calling dispatch_LLEntry_destroyLLEntry in LinkedList, line 388")
set OP[Ghe]=OP[Ghe]-1
set EM=EM-1
endfunction
function GJe takes integer Gke,integer GKe,string Gle returns nothing
set ZM[EM]=Gle
set EM=EM+1
if gF[Gke]==0 then
if Gke==0 then
call Cdv("Nullpointer exception when calling LinkedList.removeEntry","when calling error in LinkedList, line 385")
else
call Cdv("Called LinkedList.removeEntry on invalid object.","when calling error in LinkedList, line 385")
endif
endif
call GGe(Gke,GKe,"when calling removeEntry in LinkedList, line 385")
set EM=EM-1
endfunction
function GLe takes integer Gme,string GMe returns integer
local integer Gpe
local integer GPe
set ZM[EM]=GMe
set EM=EM+1
set Gpe=sP[oP[Gme]]
set GPe=0
if Gpe!=oP[Gme]then
set GPe=uP[Gpe]
call GJe(Gme,Gpe,"when calling removeEntry in LinkedList, line 94")
endif
set EM=EM-1
return GPe
endfunction
function Gqe takes integer GQe,string Gse returns integer
local integer GSe
set ZM[EM]=Gse
set EM=EM+1
if gF[GQe]==0 then
if GQe==0 then
call Cdv("Nullpointer exception when calling LinkedList.dequeue","when calling error in LinkedList, line 89")
else
call Cdv("Called LinkedList.dequeue on invalid object.","when calling error in LinkedList, line 89")
endif
endif
set GSe=GLe(GQe,"when calling dequeue in LinkedList, line 89")
set EM=EM-1
return GSe
endfunction
function Gte takes framehandle GTe,string Gue returns nothing
call BlzFrameSetText(GTe,Gue)
endfunction
function GUe takes integer Gwe,integer GWe returns integer
local integer Gye=oP[Gwe]
local integer GYe=0
local integer Gze=GWe
loop
exitwhen GYe>Gze
set Gye=sP[Gye]
set GYe=GYe+1
endloop
return Gye
endfunction
function GZe takes integer G_e,integer G0e,string G1e returns integer
local integer G2e
set ZM[EM]=G1e
set EM=EM+1
if gF[G_e]==0 then
if G_e==0 then
call Cdv("Nullpointer exception when calling LinkedList.getEntry","when calling error in LinkedList, line 378")
else
call Cdv("Called LinkedList.getEntry on invalid object.","when calling error in LinkedList, line 378")
endif
endif
set G2e=GUe(G_e,G0e)
set EM=EM-1
return G2e
endfunction
function G3e takes integer G4e,integer G5e,string G6e returns integer
local integer G7e
set ZM[EM]=G6e
set EM=EM+1
set G7e=uP[GZe(G4e,G5e,"when calling getEntry in LinkedList, line 63")]
set EM=EM-1
return G7e
endfunction
function G8e takes integer G9e,integer hve,string hee returns integer
local integer hxe
set ZM[EM]=hee
set EM=EM+1
if gF[G9e]==0 then
if G9e==0 then
call Cdv("Nullpointer exception when calling LinkedList.get","when calling error in LinkedList, line 62")
else
call Cdv("Called LinkedList.get on invalid object.","when calling error in LinkedList, line 62")
endif
endif
set hxe=G3e(G9e,hve,"when calling get in LinkedList, line 62")
set EM=EM-1
return hxe
endfunction
function hoe takes integer hre,integer hie,string hae returns string
local integer hne
local string hVe
local integer hEe
set ZM[EM]=hae
set EM=EM+1
set hEe=tJ[hre]
if SJ[hre]>Xa then
set hne=hie-SJ[hre]+Xa
else
set hne=hie
endif
set hVe=hxv(G8e(hEe,hne,"when calling get in SLangChatSystem, line 117"),"when calling stringFromIndex in SLangChatSystem, line 117")
set EM=EM-1
return hVe
endfunction
function hXe takes integer hOe,integer hRe,string hIe returns string
local string hAe
set ZM[EM]=hIe
set EM=EM+1
if mj[hOe]==0 then
if hOe==0 then
call Cdv("Nullpointer exception when calling Log.get","when calling error in SLangChatSystem, line 116")
else
call Cdv("Called Log.get on invalid object.","when calling error in SLangChatSystem, line 116")
endif
endif
set hAe=hoe(hOe,hRe,"when calling get in SLangChatSystem, line 116")
set EM=EM-1
return hAe
endfunction
function hNe takes integer hbe,string hBe returns integer
local integer hce
set ZM[EM]=hBe
set EM=EM+1
if gF[hbe]==0 then
if hbe==0 then
call Cdv("Nullpointer exception when calling LinkedList.iterator","when calling error in LinkedList, line 176")
else
call Cdv("Called LinkedList.iterator on invalid object.","when calling error in LinkedList, line 176")
endif
endif
set hce=Xle(hbe,"when calling iterator in LinkedList, line 176")
set EM=EM-1
return hce
endfunction
function hCe takes integer hde,string hDe returns nothing
set ZM[EM]=hDe
set EM=EM+1
if RF[hde]==0 then
if hde==0 then
call Cdv("Nullpointer exception when calling LLIterator.close","when calling error in LinkedList, line 465")
else
call Cdv("Called LLIterator.close on invalid object.","when calling error in LinkedList, line 465")
endif
endif
call Xpe(hde,"when calling close in LinkedList, line 465")
set EM=EM-1
endfunction
function hfe takes integer hFe,string hge returns boolean
local boolean hGe
set ZM[EM]=hge
set EM=EM+1
if RF[hFe]==0 then
if hFe==0 then
call Cdv("Nullpointer exception when calling LLIterator.hasNext","when calling error in LinkedList, line 452")
else
call Cdv("Called LLIterator.hasNext on invalid object.","when calling error in LinkedList, line 452")
endif
endif
set hGe=Xie(hFe)
set EM=EM-1
return hGe
endfunction
function hhe takes integer hHe,string hje,string hJe returns string
local string hke
local boolean hKe
local integer hle
local string hLe
local integer hme
set ZM[EM]=hJe
set EM=EM+1
set hke=""
set hKe=true
set hle=hNe(hHe,"when calling iterator in LinkedList, line 544")
set hme=hle
loop
exitwhen not Xie(hme)
set hLe=hxv(E3e(hme),"when calling stringFromIndex in LinkedList, line 546")
if hfe(hle,"when calling hasNext in LinkedList, line 547")or(not hKe)then
set hke=hke+hLe+hje
else
set hke=hke+hLe
set hKe=false
endif
endloop
call hCe(hle,"when calling close in LinkedList, line 553")
set EM=EM-1
return hke
endfunction
function hMe takes integer hpe,string hPe returns string
local string hqe
set ZM[EM]=hPe
set EM=EM+1
set hqe=hhe(hpe,"","when calling joinBy in LinkedList, line 573")
set EM=EM-1
return hqe
endfunction
function hQe takes integer hse,string hSe returns nothing
local string hte
set ZM[EM]=hSe
set EM=EM+1
if pJ[hse]then
set hte=hXe(lJ[hse],yJ[hse],"when calling get in SLangChatSystem, line 69")
if bJ[hse]<La then
call zGv(eJ[hse],KCv(hte,"when calling stringToIndex in SLangChatSystem, line 72"),"when calling add in SLangChatSystem, line 72")
set bJ[hse]=bJ[hse]+1
else
call hxv(Gqe(eJ[hse],"when calling dequeue in SLangChatSystem, line 77"),"when calling stringFromIndex in SLangChatSystem, line 77")
call zGv(eJ[hse],KCv(hte,"when calling stringToIndex in SLangChatSystem, line 79"),"when calling add in SLangChatSystem, line 79")
endif
set yJ[hse]=yJ[hse]+1
call Gte(OJ[hse],hMe(eJ[hse],"when calling join in SLangChatSystem, line 82"))
endif
set EM=EM-1
endfunction
function hTe takes integer hue,string hUe returns nothing
set ZM[EM]=hUe
set EM=EM+1
if Zj[hue]==0 then
if hue==0 then
call Cdv("Nullpointer exception when calling LogBoard.refresh","when calling error in SLangChatSystem, line 66")
else
call Cdv("Called LogBoard.refresh on invalid object.","when calling error in SLangChatSystem, line 66")
endif
endif
call hQe(hue,"when calling refresh in SLangChatSystem, line 66")
set EM=EM-1
endfunction
function hwe takes integer hWe returns integer
return OP[hWe]
endfunction
function hye takes integer hYe,string hze returns integer
local integer hZe
set ZM[EM]=hze
set EM=EM+1
if gF[hYe]==0 then
if hYe==0 then
call Cdv("Nullpointer exception when calling LinkedList.size","when calling error in LinkedList, line 147")
else
call Cdv("Called LinkedList.size on invalid object.","when calling error in LinkedList, line 147")
endif
endif
set hZe=hwe(hYe)
set EM=EM-1
return hZe
endfunction
function h_e takes integer h0e,string h1e,string h2e returns nothing
local integer h3e
local integer h4e
set ZM[EM]=h2e
set EM=EM+1
set SJ[h0e]=SJ[h0e]+1
if hye(tJ[h0e],"when calling size in SLangChatSystem, line 107")==Xa then
call hxv(Gqe(tJ[h0e],"when calling dequeue in SLangChatSystem, line 108"),"when calling stringFromIndex in SLangChatSystem, line 108")
endif
call zGv(tJ[h0e],KCv("|cFFFFCC00"+SMv(SJ[h0e])+".|r "+h1e+"|n","when calling stringToIndex in SLangChatSystem, line 109"),"when calling add in SLangChatSystem, line 109")
set h3e=jdv(iJ[h0e],"when calling iterator in SLangChatSystem, line 110")
loop
exitwhen not Jgv(h3e,"when calling hasNext in SLangChatSystem, line 110")
set h4e=jTv(h3e,"when calling next in SLangChatSystem, line 110")
call hTe(h4e,"when calling refresh in SLangChatSystem, line 111")
endloop
call Jqv(h3e,"when calling close in SLangChatSystem, line 110")
set EM=EM-1
endfunction
function h5e takes integer h6e,string h7e,string h8e returns nothing
set ZM[EM]=h8e
set EM=EM+1
if mj[h6e]==0 then
if h6e==0 then
call Cdv("Nullpointer exception when calling Log.add","when calling error in SLangChatSystem, line 105")
else
call Cdv("Called Log.add on invalid object.","when calling error in SLangChatSystem, line 105")
endif
endif
call h_e(h6e,h7e,"when calling add in SLangChatSystem, line 105")
set EM=EM-1
endfunction
function h9e takes string Hve,string Hee returns integer
local integer Hxe=0
local integer Hoe=GZv(Hve)-GZv(Hee)
loop
exitwhen Hxe>Hoe
if Psv(Hve,Hxe,Hxe+GZv(Hee))==Hee then
return Hxe
endif
set Hxe=Hxe+1
endloop
return-1
endfunction
function Hre takes string Hie,string Hae,integer Hne returns integer
local integer HVe=Hne
local integer HEe=GZv(Hie)-GZv(Hae)
loop
exitwhen HVe>HEe
if Psv(Hie,HVe,HVe+GZv(Hae))==Hae then
return HVe
endif
set HVe=HVe+1
endloop
return-1
endfunction
function HXe takes string HOe,string HRe,string HIe returns string
local string HAe=HOe
local integer HNe
if GZv(HRe)>0 then
set HNe=h9e(HOe,HRe)
loop
exitwhen not(HNe!=-1)
set HAe=Psv(HAe,0,HNe)+HIe+Psv(HAe,HNe+GZv(HRe),GZv(HAe))
set HNe=Hre(HAe,HRe,HNe+GZv(HIe))
endloop
endif
return HAe
endfunction
function Hbe takes integer HBe,integer Hce,string HCe,player Hde,string HDe returns nothing
local string Hfe
set ZM[EM]=HDe
set EM=EM+1
set Hfe=HXe(GNe(rJ[HBe],Hce,HCe,"when calling call in SLangChatSystem, line 148"),"|n"," ")
call GDe(Hfe,60.,Hde)
call h5e(sJ[HBe],Hfe,"when calling add in SLangChatSystem, line 150")
set EM=EM-1
endfunction
function HFe takes integer Hge,integer HGe,string Hhe,player HHe,string Hje returns nothing
set ZM[EM]=Hje
set EM=EM+1
if kj[Hge]==0 then
if Hge==0 then
call Cdv("Nullpointer exception when calling Channel.send","when calling error in SLangChatSystem, line 147")
else
call Cdv("Called Channel.send on invalid object.","when calling error in SLangChatSystem, line 147")
endif
endif
call Hbe(Hge,HGe,Hhe,HHe,"when calling send in SLangChatSystem, line 147")
set EM=EM-1
endfunction
function HJe takes integer Qpt,integer Hke,integer HKe,string Hle returns integer
local integer HLe
set ZM[EM]=Hle
set EM=EM+1
call HFe(Ha,QGv(Hke,"when calling getPlayerId in SLangChatSystem, line 203"),Mqv(M7v(HKe,0,"when calling get in SLangChatSystem, line 203"),"when calling getInner in SLangChatSystem, line 203"),ta,"when calling send in SLangChatSystem, line 203")
set HLe=MLv("when calling nullptr in SLangChatSystem, line 204")
set EM=EM-1
return HLe
endfunction
function Hme takes player HMe returns integer
return GetPlayerId(HMe)
endfunction
function Hpe takes player HPe returns integer
return se[Hme(HPe)]
endfunction
function Hqe takes player HQe,real Hse returns nothing
set rZ[Hpe(HQe)]=Hse
endfunction
function HSe takes integer Qsi,integer Hte,integer HTe,string Hue returns integer
local integer HUe
set ZM[EM]=Hue
set EM=EM+1
call Hqe(sa[QGv(Hte,"when calling getPlayerId in ScmdSystemsSettingsBuiltins, line 17")],PEv(M7v(HTe,0,"when calling get in ScmdSystemsSettingsBuiltins, line 17"),"when calling realValue in ScmdSystemsSettingsBuiltins, line 17"))
set HUe=MLv("when calling nullptr in ScmdSystemsSettingsBuiltins, line 18")
set EM=EM-1
return HUe
endfunction
function Hwe takes integer Qui,integer Wui,integer HWe,string Hye returns integer
local integer HYe
set ZM[EM]=Hye
set EM=EM+1
set HYe=p0v(q2v(fie(gOe(M7v(HWe,0,"when calling get in ScmdRectBuiltins, line 14"),"when calling getInner in ScmdRectBuiltins, line 14")),"when calling new_Real in ScmdRectBuiltins, line 14"),"when calling new_SharedPointer in ScmdRectBuiltins, line 14")
set EM=EM-1
return HYe
endfunction
function Hze takes integer Qyi,integer Wyi,integer HZe,string H_e returns integer
local integer H0e
set ZM[EM]=H_e
set EM=EM+1
call Rqe(PCv(M7v(HZe,0,"when calling get in ScmdUnitBuiltins, line 310"),"when calling getInner in ScmdUnitBuiltins, line 310"),PEv(M7v(HZe,1,"when calling get in ScmdUnitBuiltins, line 310"),"when calling realValue in ScmdUnitBuiltins, line 310"))
set H0e=MLv("when calling nullptr in ScmdUnitBuiltins, line 311")
set EM=EM-1
return H0e
endfunction
function H1e takes integer I8i,integer P8i,integer H2e,string H3e returns integer
local integer H4e
set ZM[EM]=H3e
set EM=EM+1
call FogMaskEnable(WCv(M7v(H2e,0,"when calling get in ScmdFogOfWarBuiltins, line 10"),"when calling booleanValue in ScmdFogOfWarBuiltins, line 10"))
set H4e=MLv("when calling nullptr in ScmdFogOfWarBuiltins, line 11")
set EM=EM-1
return H4e
endfunction
function H5e takes integer IGi,integer PGi,integer H6e,string H7e returns integer
local integer H8e
set ZM[EM]=H7e
set EM=EM+1
set H8e=p0v(Ppv(zAv(PCv(M7v(H6e,0,"when calling get in ScmdUnitBuiltins, line 728"),"when calling getInner in ScmdUnitBuiltins, line 728")),"when calling new_String in ScmdUnitBuiltins, line 728"),"when calling new_SharedPointer in ScmdUnitBuiltins, line 728")
set EM=EM-1
return H8e
endfunction
function H9e takes trigger jve returns boolean
return IsTriggerEnabled(jve)
endfunction
function jee takes integer IRt,integer PRt,integer jxe,string joe returns integer
local integer jre
set ZM[EM]=joe
set EM=EM+1
set jre=p0v(qRv(H9e(qGv(M7v(jxe,0,"when calling get in SLangTriggerFunctions, line 20"),"when calling getInner in SLangTriggerFunctions, line 20")),"when calling new_Boolean in SLangTriggerFunctions, line 20"),"when calling new_SharedPointer in SLangTriggerFunctions, line 20")
set EM=EM-1
return jre
endfunction
function jie takes integer Ihi,integer jae,integer jne,string jVe returns integer
local integer jEe
set ZM[EM]=jVe
set EM=EM+1
set jEe=p0v(qRv(Qiv(Mov(jae,"when calling getEnumUnit in ScmdUnitBuiltins, line 781"),Mqv(M7v(jne,0,"when calling get in ScmdUnitBuiltins, line 781"),"when calling getInner in ScmdUnitBuiltins, line 781"),qqv(M7v(jne,1,"when calling get in ScmdUnitBuiltins, line 781"),"when calling getInner in ScmdUnitBuiltins, line 781")),"when calling new_Boolean in ScmdUnitBuiltins, line 781"),"when calling new_SharedPointer in ScmdUnitBuiltins, line 781")
set EM=EM-1
return jEe
endfunction
function jXe takes playercolor jOe returns string
local string jRe
if tpv(jOe)<=kp then
set jRe=mp[tpv(jOe)]
else
set jRe=Fp
endif
return jRe
endfunction
function jIe takes integer Int,integer jAe,integer Ant,string jNe returns integer
local integer jbe
set ZM[EM]=jNe
set EM=EM+1
set jbe=p0v(Ppv(jXe(g_e(sa[QGv(jAe,"when calling getPlayerId in SLangPlayerFunctions, line 87")])),"when calling new_String in SLangPlayerFunctions, line 87"),"when calling new_SharedPointer in SLangPlayerFunctions, line 87")
set EM=EM-1
return jbe
endfunction
function jBe takes integer PGt,integer AGt,integer jce,string jCe returns integer
local integer jde
set ZM[EM]=jCe
set EM=EM+1
call CameraSetupSetDestPosition(FVe(M7v(jce,0,"when calling get in ScmdCameraSetupBuiltins, line 14"),"when calling getInner in ScmdCameraSetupBuiltins, line 14"),PEv(M7v(jce,1,"when calling get in ScmdCameraSetupBuiltins, line 14"),"when calling realValue in ScmdCameraSetupBuiltins, line 14"),PEv(M7v(jce,2,"when calling get in ScmdCameraSetupBuiltins, line 14"),"when calling realValue in ScmdCameraSetupBuiltins, line 14"),PEv(M7v(jce,3,"when calling get in ScmdCameraSetupBuiltins, line 14"),"when calling realValue in ScmdCameraSetupBuiltins, line 14"))
set jde=MLv("when calling nullptr in ScmdCameraSetupBuiltins, line 15")
set EM=EM-1
return jde
endfunction
function jDe takes player jfe,boolexpr jFe returns group
local group jge=CreateGroup()
call GroupEnumUnitsOfPlayer(jge,jfe,jFe)
set RPv=jge
set jge=null
return RPv
endfunction
function jGe takes string jhe returns integer
local integer jHe
set ZM[EM]=jhe
set EM=EM+1
if Sx==0 then
if cx<$8000 then
set cx=cx+1
set jHe=cx
set ox[jHe]=$EF4
else
call Cdv("Out of memory: Could not create Group.","when calling error in ScmdDataTypes, line 730")
set jHe=0
endif
else
set Sx=Sx-1
set jHe=ix[Sx]
set ox[jHe]=$EF4
endif
set EM=EM-1
return jHe
endfunction
function jje takes integer uCt returns nothing
endfunction
function jJe takes integer jke,group jKe returns nothing
call jje(jke)
set cK[jke]=jKe
endfunction
function jle takes group jLe,string jme returns integer
local integer jMe
set ZM[EM]=jme
set EM=EM+1
set jMe=jGe("when calling alloc_Group in ScmdDataTypes, line 742")
call jJe(jMe,jLe)
set EM=EM-1
return jMe
endfunction
function jpe takes integer POi,integer jPe,integer DOi,string jqe returns integer
local integer jQe
set ZM[EM]=jqe
set EM=EM+1
set jQe=p0v(jle(jDe(sa[QGv(jPe,"when calling getPlayerId in ScmdUnitBuiltins, line 229")],Filter(RFv)),"when calling new_Group in ScmdUnitBuiltins, line 229"),"when calling new_SharedPointer in ScmdUnitBuiltins, line 229")
set EM=EM-1
return jQe
endfunction
function jse takes rect jSe returns real
return GetRectCenterX(jSe)
endfunction
function jte takes rect jTe returns real
return GetRectCenterY(jTe)
endfunction
function jue takes rect jUe returns nothing
call Preload(Gf)
set Ff=DQv(DSv((jse(jUe)-64.)/128.))*128.+64.
set kf=DQv(DSv((jte(jUe)-64.)/128.))*128.+64.
call EnumDestructablesInRect(jUe,jf,O8v)
call Preload(gf)
endfunction
function jwe takes integer PQi,integer jWe,integer jye,string jYe returns integer
local integer jze
set ZM[EM]=jYe
set EM=EM+1
call PreloadGenClear()
call jue(gOe(M7v(jye,0,"when calling get in SotFRP_SaveLoad, line 140"),"when calling getInner in SotFRP_SaveLoad, line 140"))
if ta==sa[QGv(jWe,"when calling getPlayerId in SotFRP_SaveLoad, line 141")]then
call PreloadGenEnd("SotFRP\\Save\\"+Mqv(M7v(jye,1,"when calling get in SotFRP_SaveLoad, line 142"),"when calling getInner in SotFRP_SaveLoad, line 142")+".pld")
endif
set jze=p0v(dpe("when calling new_Null in SotFRP_SaveLoad, line 143"),"when calling new_SharedPointer in SotFRP_SaveLoad, line 143")
set EM=EM-1
return jze
endfunction
function jZe takes string j_e returns integer
local integer j0e
set ZM[EM]=j_e
set EM=EM+1
if Sx==0 then
if cx<$8000 then
set cx=cx+1
set j0e=cx
set ox[j0e]=$F0D
else
call Cdv("Out of memory: Could not create Vector.","when calling error in ScmdDataTypes, line 1052")
set j0e=0
endif
else
set Sx=Sx-1
set j0e=ix[Sx]
set ox[j0e]=$F0D
endif
set EM=EM-1
return j0e
endfunction
function j1e takes integer x7i returns nothing
endfunction
function j2e takes integer j3e,string j4e returns nothing
set ZM[EM]=j4e
set EM=EM+1
call j1e(j3e)
set UK[j3e]=TEv("when calling new_HashList in ScmdDataTypes, line 1062")
set EM=EM-1
endfunction
function j5e takes string j6e returns integer
local integer j7e
set ZM[EM]=j6e
set EM=EM+1
set j7e=jZe("when calling alloc_Vector in ScmdDataTypes, line 1061")
call j2e(j7e,"when calling construct_Vector in ScmdDataTypes, line 1061")
set EM=EM-1
return j7e
endfunction
function j8e takes integer j9e,integer Jve,string Jee returns integer
local integer Jxe
set ZM[EM]=Jee
set EM=EM+1
set Jxe=jqv(gJ[j9e],Jve,"when calling get in ScmdDataTypes, line 1277")
set EM=EM-1
return Jxe
endfunction
function Joe takes integer Jre,integer Jie,string Jae returns integer
local integer Jne
set ZM[EM]=Jae
set EM=EM+1
if yx[Jre]==0 then
if Jre==0 then
call Cdv("Nullpointer exception when calling Arguments.getPtr","when calling error in ScmdDataTypes, line 1276")
else
call Cdv("Called Arguments.getPtr on invalid object.","when calling error in ScmdDataTypes, line 1276")
endif
endif
set Jne=j8e(Jre,Jie,"when calling getPtr in ScmdDataTypes, line 1276")
set EM=EM-1
return Jne
endfunction
function JVe takes integer JEe,integer JXe,string JOe returns nothing
set ZM[EM]=JOe
set EM=EM+1
call dlv(UK[JEe],JXe,"when calling add in ScmdDataTypes, line 1104")
set EM=EM-1
endfunction
function JRe takes integer JIe,integer JAe,string JNe returns nothing
set ZM[EM]=JNe
set EM=EM+1
if ox[JIe]==0 then
if JIe==0 then
call Cdv("Nullpointer exception when calling Vector.push","when calling error in ScmdDataTypes, line 1102")
else
call Cdv("Called Vector.push on invalid object.","when calling error in ScmdDataTypes, line 1102")
endif
endif
call JVe(JIe,JAe,"when calling push in ScmdDataTypes, line 1102")
set EM=EM-1
endfunction
function Jbe takes integer WQt,integer EQt,integer JBe,string Jce returns integer
local integer JCe
local integer Jde
local integer JDe
local integer Jfe
local integer JFe
local integer Jge
set ZM[EM]=Jce
set EM=EM+1
set JCe=j5e("when calling new_Vector in ScmdCoreBuiltins, line 314")
set Jde=0
set JDe=skv(M7v(JBe,0,"when calling get in ScmdCoreBuiltins, line 315"),"when calling size in ScmdCoreBuiltins, line 315")-1
loop
exitwhen Jde>JDe
call JRe(JCe,P_v(sTv(M7v(JBe,0,"when calling get in ScmdCoreBuiltins, line 316"),Jde,"when calling get in ScmdCoreBuiltins, line 316"),"when calling clone in ScmdCoreBuiltins, line 316"),"when calling push in ScmdCoreBuiltins, line 316")
set Jde=Jde+1
endloop
set Jfe=1
set JFe=SNv(JBe,"when calling size in ScmdCoreBuiltins, line 317")-1
loop
exitwhen Jfe>JFe
call JRe(JCe,MJv(Joe(JBe,Jfe,"when calling getPtr in ScmdCoreBuiltins, line 318"),"when calling clone in ScmdCoreBuiltins, line 318"),"when calling push in ScmdCoreBuiltins, line 318")
set Jfe=Jfe+1
endloop
set Jge=p0v(JCe,"when calling new_SharedPointer in ScmdCoreBuiltins, line 319")
set EM=EM-1
return Jge
endfunction
function JGe takes unit Jhe,unitweaponrealfield JHe,integer Jje returns real
return BlzGetUnitWeaponRealField(Jhe,JHe,Jje)
endfunction
function JJe takes integer Pai,integer Jke,integer JKe,string Jle returns integer
local integer JLe
set ZM[EM]=Jle
set EM=EM+1
set JLe=p0v(q2v(JGe(Mov(Jke,"when calling getEnumUnit in ScmdUnitBuiltins, line 425"),UNIT_WEAPON_RF_ATTACK_RANGE,QNv(M7v(JKe,0,"when calling get in ScmdUnitBuiltins, line 425"),"when calling intValue in ScmdUnitBuiltins, line 425")),"when calling new_Real in ScmdUnitBuiltins, line 425"),"when calling new_SharedPointer in ScmdUnitBuiltins, line 425")
set EM=EM-1
return JLe
endfunction
function Jme takes integer Pei,integer Aei,integer JMe,string Jpe returns integer
local integer JPe
set ZM[EM]=Jpe
set EM=EM+1
call bpe(PCv(M7v(JMe,0,"when calling get in ScmdUnitBuiltins, line 371"),"when calling getInner in ScmdUnitBuiltins, line 371"),QNv(M7v(JMe,1,"when calling get in ScmdUnitBuiltins, line 371"),"when calling intValue in ScmdUnitBuiltins, line 371"))
set JPe=MLv("when calling nullptr in ScmdUnitBuiltins, line 372")
set EM=EM-1
return JPe
endfunction
function Jqe takes integer Pii,integer Aii,integer JQe,string Jse returns integer
local integer JSe
set ZM[EM]=Jse
set EM=EM+1
set JSe=p0v(q2v(T6v(ewe(PCv(M7v(JQe,0,"when calling get in ScmdUnitBuiltins, line 94"),"when calling getInner in ScmdUnitBuiltins, line 94"))),"when calling new_Real in ScmdUnitBuiltins, line 94"),"when calling new_SharedPointer in ScmdUnitBuiltins, line 94")
set EM=EM-1
return JSe
endfunction
function Jte takes string JTe returns boolean
local string Jue=JTe
local integer JUe
if Jue=="hp" then
set JUe=0
elseif Jue=="damage" then
set JUe=1
elseif Jue=="mana" then
set JUe=2
elseif Jue=="death" then
set JUe=3
elseif Jue=="orders" then
set JUe=4
else
set J1=false
set K1=0
return J1
endif
set J1=true
set K1=JUe
return J1
endfunction
function Jwe takes string JWe returns integer
local integer Jye
set ZM[EM]=JWe
set EM=EM+1
if ug==0 then
if rg<$8000 then
set rg=rg+1
set Jye=rg
set sg[Jye]=$87B
else
call Cdv("Out of memory: Could not create ForGroupCallback_forUnitsSelected_setArgumentsTypes_registerBuiltin_ScmdUnitParamLinkingBuiltins.","when calling error in ScmdUnitParamLinkingBuiltins, line 191")
set Jye=0
endif
else
set ug=ug-1
set Jye=wg[ug]
set sg[Jye]=$87B
endif
set EM=EM-1
return Jye
endfunction
function JYe takes integer Jze,string JZe returns nothing
set ZM[EM]=JZe
set EM=EM+1
if sg[Jze]==0 then
call Cdv("Double free: object of type ForGroupCallback","when calling error in ClosureForGroups, line 3")
else
set wg[ug]=Jze
set ug=ug+1
set sg[Jze]=0
endif
set EM=EM-1
endfunction
function J_e takes integer J0e,string J1e returns nothing
set ZM[EM]=J1e
set EM=EM+1
call JYe(J0e,"when calling dealloc_ForGroupCallback in ClosureForGroups, line 3")
set EM=EM-1
endfunction
function J2e takes integer J3e,string J4e returns nothing
set ZM[EM]=J4e
set EM=EM+1
if sg[J3e]==0 then
if J3e==0 then
call Cdv("Nullpointer exception when calling ForGroupCallback.ForGroupCallback","when calling error in ClosureForGroups, line 3")
else
call Cdv("Called ForGroupCallback.ForGroupCallback on invalid object.","when calling error in ClosureForGroups, line 3")
endif
endif
call J_e(J3e,"when calling destroyForGroupCallback in ClosureForGroups, line 3")
set EM=EM-1
endfunction
function J5e takes group J6e returns nothing
call GroupClear(J6e)
endfunction
function J7e takes string J8e returns nothing
set ZM[EM]=J8e
set EM=EM+1
call J5e(sp)
set ip=ip-1
call J2e(tp[ip],"when calling dispatch_ForGroupCallback_destroyForGroupCallback in ClosureForGroups, line 30")
set EM=EM-1
endfunction
function J9e takes integer kve returns nothing
set tp[ip]=kve
set ip=ip+1
set cp=0
set Sp=je
endfunction
function kee takes player kxe,integer koe,string kre returns nothing
set ZM[EM]=kre
set EM=EM+1
call J9e(koe)
call GroupEnumUnitsSelected(sp,kxe,op)
call J7e("when calling popCallback in ClosureForGroups, line 129")
set EM=EM-1
endfunction
function kie takes integer vji,integer kae,integer kne,string kVe returns integer
local boolean kEe
local integer kXe
local integer kOe
local integer kRe
local integer kIe
local player kAe
local boolean kNe
local integer kbe
local integer kBe
set ZM[EM]=kVe
set EM=EM+1
set kNe=Jte(Mqv(M7v(kne,0,"when calling get in ScmdUnitParamLinkingBuiltins, line 189"),"when calling getInner in ScmdUnitParamLinkingBuiltins, line 189"))
set kbe=K1
set kEe=kNe
set kXe=kbe
if kEe then
set kAe=sa[QGv(kae,"when calling getPlayerId in ScmdUnitParamLinkingBuiltins, line 191")]
set kOe=Jwe("when calling alloc_ForGroupCallback_forUnitsSelected_setArgumentsTypes_registerBuiltin_ScmdUnitParamLinkingBuiltins in ScmdUnitParamLinkingBuiltins, line 191")
set eL[kOe]=kae
set kBe=kXe
set qL[kOe]=kBe
call kee(kAe,kOe,"when calling forUnitsSelected in ScmdUnitParamLinkingBuiltins, line 191")
endif
if kEe then
set kRe=MLv("when calling nullptr in ScmdUnitParamLinkingBuiltins, line 194")
else
set kRe=B6e("unknown parameter","when calling wrap in ScmdUnitParamLinkingBuiltins, line 194")
endif
set kIe=kRe
set EM=EM-1
set kAe=null
return kIe
endfunction
function kce takes string kCe returns integer
local integer kde
set ZM[EM]=kCe
set EM=EM+1
if Xj==0 then
if Cj<$8000 then
set Cj=Cj+1
set kde=Cj
set Vj[kde]=$C46
else
call Cdv("Out of memory: Could not create IntBinOp_reduceNumbers_setVariadicArgumentTypes_registerProtectedBuiltin_ScmdCoreBuiltins.","when calling error in ScmdCoreBuiltins, line 211")
set kde=0
endif
else
set Xj=Xj-1
set kde=Lj[Xj]
set Vj[kde]=$C46
endif
set EM=EM-1
return kde
endfunction
function kDe takes string kfe returns integer
local integer kFe
set ZM[EM]=kfe
set EM=EM+1
if Nj==0 then
if Mj<$8000 then
set Mj=Mj+1
set kFe=Mj
set wx[kFe]=4161
else
call Cdv("Out of memory: Could not create RealBinOp_reduceNumbers_setVariadicArgumentTypes_registerProtectedBuiltin_ScmdCoreBuiltins.","when calling error in ScmdCoreBuiltins, line 211")
set kFe=0
endif
else
set Nj=Nj-1
set kFe=Bj[Nj]
set wx[kFe]=4161
endif
set EM=EM-1
return kFe
endfunction
function kge takes integer kGe,string khe returns real
local real kHe
set ZM[EM]=khe
set EM=EM+1
if ox[kGe]==0 then
if kGe==0 then
call Cdv("Nullpointer exception when calling Number.realValue","when calling error in ScmdDataTypes, line 411")
else
call Cdv("Called Number.realValue on invalid object.","when calling error in ScmdDataTypes, line 411")
endif
endif
if ox[kGe]<=$EFE then
set kHe=Pnv(kGe)
else
set kHe=Pnv(kGe)
endif
set EM=EM-1
return kHe
endfunction
function kje takes integer Uvt,integer kJe,integer kke returns integer
return bUe(kJe,kke)
endfunction
function kKe takes integer Ljt,integer kle,integer kLe returns integer
return kle+kLe
endfunction
function kme takes integer bxt,integer kMe,integer kpe returns integer
return kMe*kpe
endfunction
function kPe takes integer kqe,integer kQe returns integer
local integer kse=xe
local integer kSe
if kqe>kse then
set kSe=kqe
else
set kSe=kse
endif
set kse=kSe
if kQe>kse then
set kSe=kQe
else
set kSe=kse
endif
set kse=kSe
return kse
endfunction
function kte takes integer avt,integer kTe,integer kue returns integer
return kPe(kTe,kue)
endfunction
function kUe takes integer kwe,integer kWe,integer kye,string kYe returns integer
local integer kze
set ZM[EM]=kYe
set EM=EM+1
if Vj[kwe]==0 then
if kwe==0 then
call Cdv("Nullpointer exception when calling IntBinOp.apply","when calling error in ScmdCoreBuiltins, line 189")
else
call Cdv("Called IntBinOp.apply on invalid object.","when calling error in ScmdCoreBuiltins, line 189")
endif
endif
if Vj[kwe]<=$C45 then
if Vj[kwe]<=$C44 then
set kze=kte(kwe,kWe,kye)
else
set kze=kje(kwe,kWe,kye)
endif
elseif Vj[kwe]<=$C46 then
set kze=kKe(kwe,kWe,kye)
else
set kze=kme(kwe,kWe,kye)
endif
set EM=EM-1
return kze
endfunction
function kZe takes integer k_e,string k0e returns integer
local integer k1e
set ZM[EM]=k0e
set EM=EM+1
if ox[k_e]==0 then
if k_e==0 then
call Cdv("Nullpointer exception when calling Number.intValue","when calling error in ScmdDataTypes, line 409")
else
call Cdv("Called Number.intValue on invalid object.","when calling error in ScmdDataTypes, line 409")
endif
endif
if ox[k_e]<=$EFE then
if ox[k_e]<=$EFD then
set k1e=QIv(k_e)
else
set k1e=CQe(k_e)
endif
elseif ox[k_e]<=$F02 then
set k1e=CQe(k_e)
else
set k1e=QIv(k_e)
endif
set EM=EM-1
return k1e
endfunction
function k2e takes real k3e,real k4e returns real
local real k5e=ka
local real k6e
if k3e>k5e then
set k6e=k3e
else
set k6e=k5e
endif
set k5e=k6e
if k4e>k5e then
set k6e=k4e
else
set k6e=k5e
endif
set k5e=k6e
return k5e
endfunction
function k7e takes integer Rvt,real k8e,real k9e returns real
return k2e(k8e,k9e)
endfunction
function Kve takes real Kee,real Kxe returns real
local real Koe=Fa
local real Kre
if Kee<Koe then
set Kre=Kee
else
set Kre=Koe
endif
set Koe=Kre
if Kxe<Koe then
set Kre=Kxe
else
set Kre=Koe
endif
set Koe=Kre
return Koe
endfunction
function Kie takes integer Dvt,real Kae,real Kne returns real
return Kve(Kae,Kne)
endfunction
function KVe takes integer qxt,real KEe,real KXe returns real
return KEe*KXe
endfunction
function KOe takes integer Bjt,real KRe,real KIe returns real
return KRe+KIe
endfunction
function KAe takes integer KNe,real Kbe,real KBe,string Kce returns real
local real KCe
set ZM[EM]=Kce
set EM=EM+1
if wx[KNe]==0 then
if KNe==0 then
call Cdv("Nullpointer exception when calling RealBinOp.apply","when calling error in ScmdCoreBuiltins, line 192")
else
call Cdv("Called RealBinOp.apply on invalid object.","when calling error in ScmdCoreBuiltins, line 192")
endif
endif
if wx[KNe]<=4160 then
if wx[KNe]<=4159 then
set KCe=k7e(KNe,Kbe,KBe)
else
set KCe=Kie(KNe,Kbe,KBe)
endif
elseif wx[KNe]<=4161 then
set KCe=KOe(KNe,Kbe,KBe)
else
set KCe=KVe(KNe,Kbe,KBe)
endif
set EM=EM-1
return KCe
endfunction
function Kde takes integer KDe,integer Kfe,integer KFe,real Kge,integer KGe,string Khe returns integer
local boolean KHe
local integer Kje
local integer KJe
local integer Kke
local real KKe
local integer Kle
local integer KLe
local integer Kme
local integer KMe
local integer Kpe
local integer KPe
local integer Kqe
set ZM[EM]=Khe
set EM=EM+1
set KHe=false
set Kje=0
set KJe=SNv(KDe,"when calling size in ScmdCoreBuiltins, line 196")-1
loop
exitwhen Kje>KJe
set KPe=ox[M7v(KDe,Kje,"when calling get in ScmdCoreBuiltins, line 197")]
if not(KPe==$EFD or KPe==$F03)then
set KHe=true
endif
set Kje=Kje+1
endloop
set Kke=Kfe
set KKe=Kge
if KHe then
set Kle=0
set KLe=SNv(KDe,"when calling size in ScmdCoreBuiltins, line 202")-1
loop
exitwhen Kle>KLe
set KKe=KAe(KGe,KKe,kge(M7v(KDe,Kle,"when calling get in ScmdCoreBuiltins, line 203"),"when calling realValue in ScmdCoreBuiltins, line 203"),"when calling apply in ScmdCoreBuiltins, line 203")
set Kle=Kle+1
endloop
else
set Kme=0
set KMe=SNv(KDe,"when calling size in ScmdCoreBuiltins, line 205")-1
loop
exitwhen Kme>KMe
set Kke=kUe(KFe,Kke,kZe(M7v(KDe,Kme,"when calling get in ScmdCoreBuiltins, line 206"),"when calling intValue in ScmdCoreBuiltins, line 206"),"when calling apply in ScmdCoreBuiltins, line 206")
set Kme=Kme+1
endloop
endif
if KHe then
set Kpe=q2v(KKe,"when calling new_Real in ScmdCoreBuiltins, line 207")
else
set Kpe=SSv(Kke,"when calling new_Integer in ScmdCoreBuiltins, line 207")
endif
set Kqe=p0v(Kpe,"when calling new_SharedPointer in ScmdCoreBuiltins, line 207")
set EM=EM-1
return Kqe
endfunction
function KQe takes integer Ejt,integer Zjt,integer Kse,string KSe returns integer
local integer Kte
local integer KTe
local integer Kue
local integer KUe
local integer Kwe
set ZM[EM]=KSe
set EM=EM+1
set KUe=Kse
set Kte=kce("when calling alloc_IntBinOp_reduceNumbers_setVariadicArgumentTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdCoreBuiltins, line 211")
set Kwe=Kte
set KTe=kDe("when calling alloc_RealBinOp_reduceNumbers_setVariadicArgumentTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdCoreBuiltins, line 211")
set Kue=Kde(KUe,0,Kwe,.0,KTe,"when calling reduceNumbers in ScmdCoreBuiltins, line 211")
set EM=EM-1
return Kue
endfunction
function KWe takes group Kye,unit KYe returns nothing
call GroupAddUnit(Kye,KYe)
endfunction
function Kze takes integer xli,integer KZe,integer K_e,string K0e returns integer
local group K1e
local integer K2e
local player K3e
local integer K4e
local real K5e
local real K6e
local real K7e
local integer K8e
local integer K9e
local integer lve
set ZM[EM]=K0e
set EM=EM+1
set K1e=CreateGroup()
set K2e=QNv(M7v(K_e,0,"when calling get in ScmdUnitBuiltins, line 253"),"when calling intValue in ScmdUnitBuiltins, line 253")
set K3e=sa[QGv(KZe,"when calling getPlayerId in ScmdUnitBuiltins, line 254")]
set K4e=UnitId(Mqv(M7v(K_e,1,"when calling get in ScmdUnitBuiltins, line 255"),"when calling getInner in ScmdUnitBuiltins, line 255"))
set K5e=dve(PEv(M7v(K_e,2,"when calling get in ScmdUnitBuiltins, line 256"),"when calling realValue in ScmdUnitBuiltins, line 256"),XT,LT)
set K6e=dve(PEv(M7v(K_e,3,"when calling get in ScmdUnitBuiltins, line 257"),"when calling realValue in ScmdUnitBuiltins, line 257"),VT,CT)
set K7e=PEv(M7v(K_e,4,"when calling get in ScmdUnitBuiltins, line 258"),"when calling realValue in ScmdUnitBuiltins, line 258")
set K8e=0
set K9e=K2e-1
loop
exitwhen K8e>K9e
call KWe(K1e,CreateUnit(K3e,K4e,K5e,K6e,K7e))
set K8e=K8e+1
endloop
set lve=p0v(jle(K1e,"when calling new_Group in ScmdUnitBuiltins, line 261"),"when calling new_SharedPointer in ScmdUnitBuiltins, line 261")
set EM=EM-1
set K1e=null
set K3e=null
return lve
endfunction
function lee takes integer Pui,integer Aui,integer lxe,string loe returns integer
local integer lre
set ZM[EM]=loe
set EM=EM+1
set lre=p0v(q2v(D9e(gOe(M7v(lxe,0,"when calling get in ScmdRectBuiltins, line 17"),"when calling getInner in ScmdRectBuiltins, line 17")),"when calling new_Real in ScmdRectBuiltins, line 17"),"when calling new_SharedPointer in ScmdRectBuiltins, line 17")
set EM=EM-1
return lre
endfunction
function lie takes integer Pyi,integer lae,integer Dyi,string lne returns integer
local integer lVe
set ZM[EM]=lne
set EM=EM+1
set lVe=p0v(q2v(Vfe(Mov(lae,"when calling getEnumUnit in ScmdUnitBuiltins, line 314")),"when calling new_Real in ScmdUnitBuiltins, line 314"),"when calling new_SharedPointer in ScmdUnitBuiltins, line 314")
set EM=EM-1
return lVe
endfunction
function lEe takes integer lXe,integer lOe,string lRe returns nothing
set ZM[EM]=lRe
set EM=EM+1
call zGv(lXe,lOe,"when calling add in LinkedList, line 82")
set EM=EM-1
endfunction
function lIe takes integer lAe,integer lNe,string lbe returns nothing
set ZM[EM]=lbe
set EM=EM+1
if gF[lAe]==0 then
if lAe==0 then
call Cdv("Nullpointer exception when calling LinkedList.push","when calling error in LinkedList, line 81")
else
call Cdv("Called LinkedList.push on invalid object.","when calling error in LinkedList, line 81")
endif
endif
call lEe(lAe,lNe,"when calling push in LinkedList, line 81")
set EM=EM-1
endfunction
function lBe takes integer lce,string lCe,string lde returns nothing
local integer lDe
set ZM[EM]=lde
set EM=EM+1
if uK[lce]!=0 then
call lIe(uK[lce],KCv(lCe,"when calling stringToIndex in ScmdDataTypes, line 212"),"when calling push in ScmdDataTypes, line 212")
else
set lDe=yTv("when calling new_LinkedList in ScmdDataTypes, line 214")
call lIe(lDe,KCv(lCe,"when calling stringToIndex in ScmdDataTypes, line 214"),"when calling push in ScmdDataTypes, line 214")
set uK[lce]=lDe
endif
set EM=EM-1
endfunction
function lfe takes integer lFe,string lge,string lGe returns nothing
set ZM[EM]=lGe
set EM=EM+1
if ox[lFe]==0 then
if lFe==0 then
call Cdv("Nullpointer exception when calling Exception.pushToTrace","when calling error in ScmdDataTypes, line 210")
else
call Cdv("Called Exception.pushToTrace on invalid object.","when calling error in ScmdDataTypes, line 210")
endif
endif
call lBe(lFe,lge,"when calling pushToTrace in ScmdDataTypes, line 210")
set EM=EM-1
endfunction
function lhe takes integer lHe,integer lje,string lJe returns nothing
local integer lke
set ZM[EM]=lJe
set EM=EM+1
set lke=c8v(bd,xK[lHe],-1)
call Cxv(bd,xK[lHe],-1,lke+1)
call Cxv(bd,xK[lHe],lke,P_v(lje,"when calling clone in ScmdDataTypes, line 965"))
set EM=EM-1
endfunction
function lKe takes integer lle,integer lLe,string lme returns nothing
set ZM[EM]=lme
set EM=EM+1
if ox[lle]==0 then
if lle==0 then
call Cdv("Nullpointer exception when calling Trigger.addCondition","when calling error in ScmdDataTypes, line 962")
else
call Cdv("Called Trigger.addCondition on invalid object.","when calling error in ScmdDataTypes, line 962")
endif
endif
call lhe(lle,lLe,"when calling addCondition in ScmdDataTypes, line 962")
set EM=EM-1
endfunction
function lMe takes string lpe returns integer
local integer lPe
set ZM[EM]=lpe
set EM=EM+1
if Sx==0 then
if cx<$8000 then
set cx=cx+1
set lPe=cx
set ox[lPe]=$EF9
else
call Cdv("Out of memory: Could not create Item.","when calling error in ScmdDataTypes, line 807")
set lPe=0
endif
else
set Sx=Sx-1
set lPe=ix[Sx]
set ox[lPe]=$EF9
endif
set EM=EM-1
return lPe
endfunction
function lqe takes integer cBt returns nothing
endfunction
function lQe takes integer lse,item lSe returns nothing
call pfv(lse,lSe)
call lqe(lse)
set bK[lse]=lSe
endfunction
function lte takes item lTe,string lue returns integer
local integer lUe
set ZM[EM]=lue
set EM=EM+1
set lUe=lMe("when calling alloc_Item in ScmdDataTypes, line 816")
call lQe(lUe,lTe)
set EM=EM-1
return lUe
endfunction
function lwe takes integer A9i,integer D9i,integer lWe,string lye returns integer
local integer lYe
set ZM[EM]=lye
set EM=EM+1
set lYe=p0v(lte(nxe(PCv(M7v(lWe,0,"when calling get in ScmdItemBuiltins, line 11"),"when calling getInner in ScmdItemBuiltins, line 11"),QNv(M7v(lWe,1,"when calling get in ScmdItemBuiltins, line 11"),"when calling intValue in ScmdItemBuiltins, line 11")),"when calling new_Item in ScmdItemBuiltins, line 11"),"when calling new_SharedPointer in ScmdItemBuiltins, line 11")
set EM=EM-1
return lYe
endfunction
function lze takes integer ASi,integer DSi,integer lZe,string l_e returns integer
local integer l0e
set ZM[EM]=l_e
set EM=EM+1
call AMe(PCv(M7v(lZe,0,"when calling get in ScmdUnitBuiltins, line 121"),"when calling getInner in ScmdUnitBuiltins, line 121"),PEv(M7v(lZe,1,"when calling get in ScmdUnitBuiltins, line 121"),"when calling realValue in ScmdUnitBuiltins, line 121"))
set l0e=MLv("when calling nullptr in ScmdUnitBuiltins, line 122")
set EM=EM-1
return l0e
endfunction
function l1e takes integer ATi,integer l2e,integer HTi,string l3e returns integer
local integer l4e
set ZM[EM]=l3e
set EM=EM+1
set l4e=p0v(q2v(uev(Mov(l2e,"when calling getEnumUnit in ScmdUnitBuiltins, line 670")),"when calling new_Real in ScmdUnitBuiltins, line 670"),"when calling new_SharedPointer in ScmdUnitBuiltins, line 670")
set EM=EM-1
return l4e
endfunction
function l5e takes string l6e returns integer
local integer l7e
set ZM[EM]=l6e
set EM=EM+1
set l7e=p0v(tJv("Wrong color name","when calling new_Exception in SLangPlayerFunctions, line 17"),"when calling new_SharedPointer in SLangPlayerFunctions, line 17")
set EM=EM-1
return l7e
endfunction
function l8e takes playercolor l9e returns player
local integer Lve=0
local integer Lee=bj_MAX_PLAYER_SLOTS-1
loop
exitwhen Lve>Lee
if g_e(sa[Lve])==l9e then
return sa[Lve]
endif
set Lve=Lve+1
endloop
return null
endfunction
function Lxe takes integer Iat,integer Loe,integer Lre,string Lie returns integer
local player Lae
local integer Lne
local integer LVe
set ZM[EM]=Lie
set EM=EM+1
set Lae=l8e(tZv(Mqv(M7v(Lre,0,"when calling get in SLangPlayerFunctions, line 35"),"when calling getInner in SLangPlayerFunctions, line 35")))
if Lae!=null then
call SetPlayerAllianceStateAllyBJ(sa[QGv(Loe,"when calling getPlayerId in SLangPlayerFunctions, line 37")],Lae,WCv(M7v(Lre,1,"when calling get in SLangPlayerFunctions, line 37"),"when calling booleanValue in SLangPlayerFunctions, line 37"))
endif
if Lae!=null then
set Lne=p0v(dpe("when calling new_Null in SLangPlayerFunctions, line 38"),"when calling new_SharedPointer in SLangPlayerFunctions, line 38")
else
set Lne=l5e("when calling newWCNException in SLangPlayerFunctions, line 38")
endif
set LVe=Lne
set EM=EM-1
set Lae=null
return LVe
endfunction
function LEe takes unit LXe,integer LOe returns nothing
call SetHeroInt(LXe,LOe,true)
endfunction
function LRe takes integer Afi,integer Dfi,integer LIe,string LAe returns integer
local integer LNe
set ZM[EM]=LAe
set EM=EM+1
call LEe(PCv(M7v(LIe,0,"when calling get in ScmdUnitBuiltins, line 600"),"when calling getInner in ScmdUnitBuiltins, line 600"),QNv(M7v(LIe,1,"when calling get in ScmdUnitBuiltins, line 600"),"when calling intValue in ScmdUnitBuiltins, line 600"))
set LNe=MLv("when calling nullptr in ScmdUnitBuiltins, line 601")
set EM=EM-1
return LNe
endfunction
function Lbe takes integer Umt,integer Imt,integer LBe,string Lce returns integer
local integer LCe
local integer Lde
local integer LDe
local boolean Lfe
set ZM[EM]=Lce
set EM=EM+1
set LCe=ox[M7v(LBe,0,"when calling get in ScmdCoreBuiltins, line 291")]
if(LCe>=$EFD and LCe<=$EFE)or(LCe>=$F02 and LCe<=$F03)then
set Lde=ox[M7v(LBe,0,"when calling get in ScmdCoreBuiltins, line 291")]
set Lfe=not(Lde==$EFD or Lde==$F03)
else
set Lfe=false
endif
set LDe=p0v(qRv(Lfe,"when calling new_Boolean in ScmdCoreBuiltins, line 291"),"when calling new_SharedPointer in ScmdCoreBuiltins, line 291")
set EM=EM-1
return LDe
endfunction
function LFe takes integer X9i,integer C9i,integer Lge,string LGe returns integer
local integer Lhe
set ZM[EM]=LGe
set EM=EM+1
call R9e(Wlv(M7v(Lge,0,"when calling get in ScmdItemBuiltins, line 14"),"when calling getInner in ScmdItemBuiltins, line 14"),WCv(M7v(Lge,1,"when calling get in ScmdItemBuiltins, line 14"),"when calling booleanValue in ScmdItemBuiltins, line 14"))
set Lhe=MLv("when calling nullptr in ScmdItemBuiltins, line 15")
set EM=EM-1
return Lhe
endfunction
function LHe takes unit Lje returns real
return GetUnitMoveSpeed(Lje)
endfunction
function LJe takes integer XSi,integer Lke,integer VSi,string LKe returns integer
local integer Lle
set ZM[EM]=LKe
set EM=EM+1
set Lle=p0v(q2v(LHe(Mov(Lke,"when calling getEnumUnit in ScmdUnitBuiltins, line 125")),"when calling new_Real in ScmdUnitBuiltins, line 125"),"when calling new_SharedPointer in ScmdUnitBuiltins, line 125")
set EM=EM-1
return Lle
endfunction
function LLe takes widget Lme returns real
return GetWidgetY(Lme)
endfunction
function LMe takes integer XTi,integer CTi,integer Lpe,string LPe returns integer
local integer Lqe
set ZM[EM]=LPe
set EM=EM+1
set Lqe=p0v(q2v(LLe(qqv(M7v(Lpe,0,"when calling get in ScmdUnitBuiltins, line 672"),"when calling getInner in ScmdUnitBuiltins, line 672")),"when calling new_Real in ScmdUnitBuiltins, line 672"),"when calling new_SharedPointer in ScmdUnitBuiltins, line 672")
set EM=EM-1
return Lqe
endfunction
function LQe takes integer Xfi,integer Lse,integer LSe,string Lte returns integer
local integer LTe
set ZM[EM]=Lte
set EM=EM+1
set LTe=p0v(SSv(Zov(Mov(Lse,"when calling getEnumUnit in ScmdUnitBuiltins, line 604"),WCv(M7v(LSe,0,"when calling get in ScmdUnitBuiltins, line 604"),"when calling booleanValue in ScmdUnitBuiltins, line 604")),"when calling new_Integer in ScmdUnitBuiltins, line 604"),"when calling new_SharedPointer in ScmdUnitBuiltins, line 604")
set EM=EM-1
return LTe
endfunction
function Lue takes integer Egt,integer Zgt,integer LUe,string Lwe returns integer
local boolean LWe
local integer Lye
local integer LYe
local integer Lze
local real LZe
local integer L_e
local integer L0e
local integer L1e
local integer L2e
local integer L3e
local integer L4e
local integer L5e
set ZM[EM]=Lwe
set EM=EM+1
set LWe=false
set Lye=0
set LYe=SNv(LUe,"when calling size in ScmdCoreBuiltins, line 27")-1
loop
exitwhen Lye>LYe
set L4e=ox[M7v(LUe,Lye,"when calling get in ScmdCoreBuiltins, line 28")]
if not(L4e==$EFD or L4e==$F03)then
set LWe=true
endif
set Lye=Lye+1
endloop
set Lze=1
set LZe=1.
if LWe then
set L_e=0
set L0e=SNv(LUe,"when calling size in ScmdCoreBuiltins, line 33")-1
loop
exitwhen L_e>L0e
set LZe=LZe*kge(M7v(LUe,L_e,"when calling get in ScmdCoreBuiltins, line 34"),"when calling realValue in ScmdCoreBuiltins, line 34")
set L_e=L_e+1
endloop
else
set L1e=0
set L2e=SNv(LUe,"when calling size in ScmdCoreBuiltins, line 36")-1
loop
exitwhen L1e>L2e
set Lze=Lze*kZe(M7v(LUe,L1e,"when calling get in ScmdCoreBuiltins, line 37"),"when calling intValue in ScmdCoreBuiltins, line 37")
set L1e=L1e+1
endloop
endif
if LWe then
set L3e=q2v(LZe,"when calling new_Real in ScmdCoreBuiltins, line 38")
else
set L3e=SSv(Lze,"when calling new_Integer in ScmdCoreBuiltins, line 38")
endif
set L5e=p0v(L3e,"when calling new_SharedPointer in ScmdCoreBuiltins, line 38")
set EM=EM-1
return L5e
endfunction
function L6e takes integer LGt,integer L7e,integer L8e,string L9e returns integer
local integer mve
set ZM[EM]=L9e
set EM=EM+1
if ta==sa[QGv(L7e,"when calling getPlayerId in ScmdCameraSetupBuiltins, line 18")]then
call CameraSetupApply(FVe(M7v(L8e,0,"when calling get in ScmdCameraSetupBuiltins, line 19"),"when calling getInner in ScmdCameraSetupBuiltins, line 19"),WCv(M7v(L8e,1,"when calling get in ScmdCameraSetupBuiltins, line 19"),"when calling booleanValue in ScmdCameraSetupBuiltins, line 19"),WCv(M7v(L8e,2,"when calling get in ScmdCameraSetupBuiltins, line 19"),"when calling booleanValue in ScmdCameraSetupBuiltins, line 19"))
endif
set mve=MLv("when calling nullptr in ScmdCameraSetupBuiltins, line 20")
set EM=EM-1
return mve
endfunction
function mee takes integer LOi,integer mxe,integer COi,string moe returns integer
local integer mre
set ZM[EM]=moe
set EM=EM+1
set mre=p0v(jle(jDe(sa[QGv(mxe,"when calling getPlayerId in ScmdUnitBuiltins, line 232")],Filter(Rgv)),"when calling new_Group in ScmdUnitBuiltins, line 232"),"when calling new_SharedPointer in ScmdUnitBuiltins, line 232")
set EM=EM-1
return mre
endfunction
function mie takes rect mae returns nothing
call Preload(Tf)
set Ff=DQv(DSv((jse(mae)-64.)/128.))*128.+64.
set kf=DQv(DSv((jte(mae)-64.)/128.))*128.+64.
call EnumItemsInRect(mae,null,O9v)
call Preload(Yf)
endfunction
function mne takes integer LQi,integer mVe,integer mEe,string mXe returns integer
local integer mOe
set ZM[EM]=mXe
set EM=EM+1
call PreloadGenClear()
call mie(gOe(M7v(mEe,0,"when calling get in SotFRP_SaveLoad, line 147"),"when calling getInner in SotFRP_SaveLoad, line 147"))
if ta==sa[QGv(mVe,"when calling getPlayerId in SotFRP_SaveLoad, line 148")]then
call PreloadGenEnd("SotFRP\\Save\\"+Mqv(M7v(mEe,1,"when calling get in SotFRP_SaveLoad, line 149"),"when calling getInner in SotFRP_SaveLoad, line 149")+".pld")
endif
set mOe=p0v(dpe("when calling new_Null in SotFRP_SaveLoad, line 150"),"when calling new_SharedPointer in SotFRP_SaveLoad, line 150")
set EM=EM-1
return mOe
endfunction
function mRe takes integer Lai,integer Xai,integer mIe,string mAe returns integer
local integer mNe
set ZM[EM]=mAe
set EM=EM+1
set mNe=p0v(q2v(JGe(PCv(M7v(mIe,0,"when calling get in ScmdUnitBuiltins, line 427"),"when calling getInner in ScmdUnitBuiltins, line 427"),UNIT_WEAPON_RF_ATTACK_RANGE,QNv(M7v(mIe,1,"when calling get in ScmdUnitBuiltins, line 427"),"when calling intValue in ScmdUnitBuiltins, line 427")),"when calling new_Real in ScmdUnitBuiltins, line 427"),"when calling new_SharedPointer in ScmdUnitBuiltins, line 427")
set EM=EM-1
return mNe
endfunction
function mbe takes unit mBe,unitrealfield mce,real mCe returns boolean
return BlzSetUnitRealField(mBe,mce,mCe)
endfunction
function mde takes integer Lei,integer mDe,integer mfe,string mFe returns integer
local integer mge
set ZM[EM]=mFe
set EM=EM+1
call mbe(Mov(mDe,"when calling getEnumUnit in ScmdUnitBuiltins, line 375"),UNIT_RF_HIT_POINTS_REGENERATION_RATE,PEv(M7v(mfe,0,"when calling get in ScmdUnitBuiltins, line 375"),"when calling realValue in ScmdUnitBuiltins, line 375"))
set mge=MLv("when calling nullptr in ScmdUnitBuiltins, line 376")
set EM=EM-1
return mge
endfunction
function mGe takes integer Lii,integer mhe,integer mHe,string mje returns integer
local integer mJe
set ZM[EM]=mje
set EM=EM+1
call NIe(Mov(mhe,"when calling getEnumUnit in ScmdUnitBuiltins, line 97"),PEv(M7v(mHe,0,"when calling get in ScmdUnitBuiltins, line 97"),"when calling realValue in ScmdUnitBuiltins, line 97"))
set mJe=MLv("when calling nullptr in ScmdUnitBuiltins, line 98")
set EM=EM-1
return mJe
endfunction
function mke takes integer mKe returns group
return cK[mKe]
endfunction
function mle takes integer mLe,string mme returns group
local group mMe
set ZM[EM]=mme
set EM=EM+1
if ox[mLe]==0 then
if mLe==0 then
call Cdv("Nullpointer exception when calling Group.getInner","when calling error in ScmdDataTypes, line 754")
else
call Cdv("Called Group.getInner on invalid object.","when calling error in ScmdDataTypes, line 754")
endif
endif
set mMe=mke(mLe)
set EM=EM-1
set IJv=mMe
set mMe=null
return IJv
endfunction
function mpe takes integer Lli,integer mPe,integer mqe,string mQe returns integer
local integer mse
set ZM[EM]=mQe
set EM=EM+1
call KWe(mle(M7v(mqe,0,"when calling get in ScmdUnitBuiltins, line 264"),"when calling getInner in ScmdUnitBuiltins, line 264"),Mov(mPe,"when calling getEnumUnit in ScmdUnitBuiltins, line 264"))
set mse=MLv("when calling nullptr in ScmdUnitBuiltins, line 265")
set EM=EM-1
return mse
endfunction
function mSe takes integer Lui,integer Xui,integer mte,string mTe returns integer
local integer mue
set ZM[EM]=mTe
set EM=EM+1
set mue=p0v(q2v(fee(gOe(M7v(mte,0,"when calling get in ScmdRectBuiltins, line 20"),"when calling getInner in ScmdRectBuiltins, line 20")),"when calling new_Real in ScmdRectBuiltins, line 20"),"when calling new_SharedPointer in ScmdRectBuiltins, line 20")
set EM=EM-1
return mue
endfunction
function mUe takes integer Lvt,integer Xvt,integer mwe,string mWe returns integer
local integer mye
set ZM[EM]=mWe
set EM=EM+1
set mye=p0v(SSv(kZe(M7v(mwe,0,"when calling get in ScmdCoreBuiltins, line 270"),"when calling intValue in ScmdCoreBuiltins, line 270"),"when calling new_Integer in ScmdCoreBuiltins, line 270"),"when calling new_SharedPointer in ScmdCoreBuiltins, line 270")
set EM=EM-1
return mye
endfunction
function mYe takes integer Lyi,integer Xyi,integer mze,string mZe returns integer
local integer m_e
set ZM[EM]=mZe
set EM=EM+1
set m_e=p0v(q2v(Vfe(PCv(M7v(mze,0,"when calling get in ScmdUnitBuiltins, line 316"),"when calling getInner in ScmdUnitBuiltins, line 316")),"when calling new_Real in ScmdUnitBuiltins, line 316"),"when calling new_SharedPointer in ScmdUnitBuiltins, line 316")
set EM=EM-1
return m_e
endfunction
function m0e takes integer m1e returns integer
return UK[m1e]
endfunction
function m2e takes integer m3e,string m4e returns integer
local integer m5e
set ZM[EM]=m4e
set EM=EM+1
if ox[m3e]==0 then
if m3e==0 then
call Cdv("Nullpointer exception when calling Vector.toHashList","when calling error in ScmdDataTypes, line 1090")
else
call Cdv("Called Vector.toHashList on invalid object.","when calling error in ScmdDataTypes, line 1090")
endif
endif
set m5e=m0e(m3e)
set EM=EM-1
return m5e
endfunction
function m6e takes integer t9i,integer i9i,integer S9i,string m7e returns integer
local integer m8e
set ZM[EM]=m7e
set EM=EM+1
set m8e=p0v(qRv(IsFogEnabled(),"when calling new_Boolean in ScmdFogOfWarBuiltins, line 21"),"when calling new_SharedPointer in ScmdFogOfWarBuiltins, line 21")
set EM=EM-1
return m8e
endfunction
function m9e takes unit Mve,string Mee returns nothing
call QueueUnitAnimation(Mve,Mee)
endfunction
function Mxe takes integer tFi,integer iFi,integer Moe,string Mre returns integer
local integer Mie
set ZM[EM]=Mre
set EM=EM+1
call m9e(PCv(M7v(Moe,0,"when calling get in ScmdUnitBuiltins, line 789"),"when calling getInner in ScmdUnitBuiltins, line 789"),Mqv(M7v(Moe,1,"when calling get in ScmdUnitBuiltins, line 789"),"when calling getInner in ScmdUnitBuiltins, line 789"))
set Mie=MLv("when calling nullptr in ScmdUnitBuiltins, line 790")
set EM=EM-1
return Mie
endfunction
function Mae takes integer sGi,integer Mne,integer MVe,string MEe returns integer
local string MXe
local integer MOe
set ZM[EM]=MEe
set EM=EM+1
set MXe=Mqv(M7v(MVe,0,"when calling get in ScmdUnitBuiltins, line 704"),"when calling getInner in ScmdUnitBuiltins, line 704")
if MXe!=null then
call Nee(Mov(Mne,"when calling getEnumUnit in ScmdUnitBuiltins, line 706"),MXe)
endif
set MOe=MLv("when calling nullptr in ScmdUnitBuiltins, line 707")
set EM=EM-1
return MOe
endfunction
function MRe takes integer MIe,string MAe returns integer
local integer MNe
set ZM[EM]=MAe
set EM=EM+1
set MNe=jgv(gJ[MIe],"when calling iterator in ScmdDataTypes, line 1265")
set EM=EM-1
return MNe
endfunction
function Mbe takes integer tgi,integer MBe,integer Sgi,string Mce returns integer
local integer MCe
set ZM[EM]=Mce
set EM=EM+1
call O3e(Mov(MBe,"when calling getEnumUnit in ScmdUnitBuiltins, line 736"))
set MCe=MLv("when calling nullptr in ScmdUnitBuiltins, line 737")
set EM=EM-1
return MCe
endfunction
function Mde takes integer ujt,integer rjt,integer MDe,string Mfe returns integer
local integer MFe
local integer Mge
local integer MGe
local boolean Mhe
set ZM[EM]=Mfe
set EM=EM+1
set MFe=ox[M7v(MDe,0,"when calling get in ScmdCoreBuiltins, line 172")]
if(MFe>=$EFC and MFe<=$EFF)or(MFe>=$F02 and MFe<=$F03)or(MFe>=$F08 and MFe<=$F09)then
set Mge=ox[M7v(MDe,0,"when calling get in ScmdCoreBuiltins, line 172")]
set Mhe=not((Mge>=$EFD and Mge<=$EFE)or(Mge>=$F02 and Mge<=$F03))
else
set Mhe=false
endif
set MGe=p0v(qRv(Mhe,"when calling new_Boolean in ScmdCoreBuiltins, line 172"),"when calling new_SharedPointer in ScmdCoreBuiltins, line 172")
set EM=EM-1
return MGe
endfunction
function MHe takes integer rnt,integer Mje,integer MJe,string Mke returns integer
local player MKe
local integer Mle
local integer MLe
set ZM[EM]=Mke
set EM=EM+1
set MKe=l8e(tZv(Mqv(M7v(MJe,0,"when calling get in SLangPlayerFunctions, line 45"),"when calling getInner in SLangPlayerFunctions, line 45")))
if MKe!=null then
call SetPlayerAlliance(sa[QGv(Mje,"when calling getPlayerId in SLangPlayerFunctions, line 47")],MKe,ALLIANCE_SHARED_VISION,WCv(M7v(MJe,1,"when calling get in SLangPlayerFunctions, line 47"),"when calling booleanValue in SLangPlayerFunctions, line 47"))
endif
if MKe!=null then
set Mle=p0v(dpe("when calling new_Null in SLangPlayerFunctions, line 48"),"when calling new_SharedPointer in SLangPlayerFunctions, line 48")
else
set Mle=l5e("when calling newWCNException in SLangPlayerFunctions, line 48")
endif
set MLe=Mle
set EM=EM-1
set MKe=null
return MLe
endfunction
function Mme takes integer W9i,integer MMe,integer Mpe,string MPe returns integer
local integer Mqe
set ZM[EM]=MPe
set EM=EM+1
set Mqe=p0v(lte(nxe(Mov(MMe,"when calling getEnumUnit in ScmdItemBuiltins, line 9"),QNv(M7v(Mpe,0,"when calling get in ScmdItemBuiltins, line 9"),"when calling intValue in ScmdItemBuiltins, line 9")),"when calling new_Item in ScmdItemBuiltins, line 9"),"when calling new_SharedPointer in ScmdItemBuiltins, line 9")
set EM=EM-1
return Mqe
endfunction
function MQe takes integer WSi,integer Mse,integer MSe,string Mte returns integer
local integer MTe
set ZM[EM]=Mte
set EM=EM+1
call AMe(Mov(Mse,"when calling getEnumUnit in ScmdUnitBuiltins, line 118"),PEv(M7v(MSe,0,"when calling get in ScmdUnitBuiltins, line 118"),"when calling realValue in ScmdUnitBuiltins, line 118"))
set MTe=MLv("when calling nullptr in ScmdUnitBuiltins, line 119")
set EM=EM-1
return MTe
endfunction
function Mue takes integer WTi,integer ETi,integer MUe,string Mwe returns integer
local integer MWe
set ZM[EM]=Mwe
set EM=EM+1
call Rue(PCv(M7v(MUe,0,"when calling get in ScmdUnitBuiltins, line 666"),"when calling getInner in ScmdUnitBuiltins, line 666"),dve(PEv(M7v(MUe,1,"when calling get in ScmdUnitBuiltins, line 666"),"when calling realValue in ScmdUnitBuiltins, line 666"),VT,CT))
set MWe=MLv("when calling nullptr in ScmdUnitBuiltins, line 667")
set EM=EM-1
return MWe
endfunction
function Mye takes integer Wfi,integer MYe,integer Mze,string MZe returns integer
local integer M_e
set ZM[EM]=MZe
set EM=EM+1
call LEe(Mov(MYe,"when calling getEnumUnit in ScmdUnitBuiltins, line 597"),QNv(M7v(Mze,0,"when calling get in ScmdUnitBuiltins, line 597"),"when calling intValue in ScmdUnitBuiltins, line 597"))
set M_e=MLv("when calling nullptr in ScmdUnitBuiltins, line 598")
set EM=EM-1
return M_e
endfunction
function M0e takes integer M1e returns string
return pK[M1e]
endfunction
function M2e takes integer M3e returns string
return FJ[M3e]
endfunction
function M4e takes integer M5e returns string
return gK[M5e]
endfunction
function M6e takes integer M7e returns string
return lK[M7e]
endfunction
function M8e takes integer M9e,string pve returns string
local string pee
set ZM[EM]=pve
set EM=EM+1
if ox[M9e]==0 then
if M9e==0 then
call Cdv("Nullpointer exception when calling Literal.getPreviousWhitespaces","when calling error in ScmdDataTypes, line 297")
else
call Cdv("Called Literal.getPreviousWhitespaces on invalid object.","when calling error in ScmdDataTypes, line 297")
endif
endif
if ox[M9e]<=$EFD then
if ox[M9e]<=$EFC then
set pee=M2e(M9e)
else
set pee=M6e(M9e)
endif
elseif ox[M9e]<=$EFE then
set pee=M0e(M9e)
else
set pee=M4e(M9e)
endif
set EM=EM-1
return pee
endfunction
function pxe takes string poe,string pre returns integer
local integer pie
local integer pae
local integer pne
local integer pVe
set ZM[EM]=pre
set EM=EM+1
set pie=0
if GZv(poe)!=4 then
call Cdv("Fourchar value must be 4 chars long","when calling error in ObjectIds, line 36")
else
set pae=1
set pne=0
loop
exitwhen pne>3
set pVe=h9e(aq,duv(poe,3-pne))
set pie=pie+pae*pVe
set pae=pae*256
set pne=pne+1
endloop
endif
set EM=EM-1
return pie
endfunction
function pEe takes string pXe,string pOe returns integer
local integer pRe
set ZM[EM]=pOe
set EM=EM+1
set pRe=pxe(pXe,"when calling fromRawCode in ObjectIds, line 47")
set EM=EM-1
return pRe
endfunction
function pIe takes integer pAe,string pNe returns integer
local integer pbe
set ZM[EM]=pNe
set EM=EM+1
set pbe=MNv("when calling alloc_GenericSharedPointer in ScmdDataTypes, line 122")
call pUv(pbe,pAe,"when calling construct_GenericSharedPointer2 in ScmdDataTypes, line 122")
set EM=EM-1
return pbe
endfunction
function pBe takes integer h9i,integer F9i,integer pce,string pCe returns integer
local string pde
local integer pDe
local integer pfe
set ZM[EM]=pCe
set EM=EM+1
set pde=Mqv(M7v(pce,0,"when calling get in ScmdFogOfWarBuiltins, line 42"),"when calling getInner in ScmdFogOfWarBuiltins, line 42")
if GZv(pde)==4 then
set pDe=SSv(pEe(pde,"when calling fromRawCode in ScmdFogOfWarBuiltins, line 43"),"when calling new_Integer in ScmdFogOfWarBuiltins, line 43")
else
set pDe=tJv("Raw code must be 4 chars long","when calling new_Exception in ScmdFogOfWarBuiltins, line 43")
endif
set pfe=pIe(pDe,"when calling new_GenericSharedPointer in ScmdFogOfWarBuiltins, line 43")
set EM=EM-1
return pfe
endfunction
function pFe takes integer pge,destructable pGe returns nothing
set CJ[pge]=pGe
endfunction
function phe takes integer pHe,destructable pje,string pJe returns nothing
set ZM[EM]=pJe
set EM=EM+1
if Rx[pHe]==0 then
if pHe==0 then
call Cdv("Nullpointer exception when calling Context.setSpellTargetDestructable","when calling error in ScmdDataTypes, line 1196")
else
call Cdv("Called Context.setSpellTargetDestructable on invalid object.","when calling error in ScmdDataTypes, line 1196")
endif
endif
call pFe(pHe,pje)
set EM=EM-1
endfunction
function pke takes integer pKe returns real
return LJ[pKe]
endfunction
function ple takes integer pLe,string pme returns real
local real pMe
set ZM[EM]=pme
set EM=EM+1
if Rx[pLe]==0 then
if pLe==0 then
call Cdv("Nullpointer exception when calling Context.getSpellTargetY","when calling error in ScmdDataTypes, line 1193")
else
call Cdv("Called Context.getSpellTargetY on invalid object.","when calling error in ScmdDataTypes, line 1193")
endif
endif
set pMe=pke(pLe)
set EM=EM-1
return pMe
endfunction
function ppe takes integer pPe,item pqe returns nothing
set VJ[pPe]=pqe
endfunction
function pQe takes integer pse,item pSe,string pte returns nothing
set ZM[EM]=pte
set EM=EM+1
if Rx[pse]==0 then
if pse==0 then
call Cdv("Nullpointer exception when calling Context.setSpellTargetItem","when calling error in ScmdDataTypes, line 1202")
else
call Cdv("Called Context.setSpellTargetItem on invalid object.","when calling error in ScmdDataTypes, line 1202")
endif
endif
call ppe(pse,pSe)
set EM=EM-1
endfunction
function pTe takes integer pue,unit pUe returns nothing
set HJ[pue]=pUe
endfunction
function pwe takes integer pWe,unit pye,string pYe returns nothing
set ZM[EM]=pYe
set EM=EM+1
if Rx[pWe]==0 then
if pWe==0 then
call Cdv("Nullpointer exception when calling Context.setSpellAbilityUnit","when calling error in ScmdDataTypes, line 1172")
else
call Cdv("Called Context.setSpellAbilityUnit on invalid object.","when calling error in ScmdDataTypes, line 1172")
endif
endif
call pTe(pWe,pye)
set EM=EM-1
endfunction
function pze takes integer pZe,integer p_e returns nothing
set XJ[pZe]=p_e
endfunction
function p0e takes integer p1e,integer p2e,string p3e returns nothing
set ZM[EM]=p3e
set EM=EM+1
if Rx[p1e]==0 then
if p1e==0 then
call Cdv("Nullpointer exception when calling Context.setSpellAbilityId","when calling error in ScmdDataTypes, line 1208")
else
call Cdv("Called Context.setSpellAbilityId on invalid object.","when calling error in ScmdDataTypes, line 1208")
endif
endif
call pze(p1e,p2e)
set EM=EM-1
endfunction
function p4e takes integer p5e,integer p6e returns nothing
set PJ[p5e]=p6e
endfunction
function p7e takes integer p8e,integer p9e,string Pve returns nothing
set ZM[EM]=Pve
set EM=EM+1
if Rx[p8e]==0 then
if p8e==0 then
call Cdv("Nullpointer exception when calling Context.setPlayerId","when calling error in ScmdDataTypes, line 1154")
else
call Cdv("Called Context.setPlayerId on invalid object.","when calling error in ScmdDataTypes, line 1154")
endif
endif
call p4e(p8e,p9e)
set EM=EM-1
endfunction
function Pee takes integer Pxe,real Poe returns nothing
set LJ[Pxe]=Poe
endfunction
function Pre takes integer Pie,real Pae,string Pne returns nothing
set ZM[EM]=Pne
set EM=EM+1
if Rx[Pie]==0 then
if Pie==0 then
call Cdv("Nullpointer exception when calling Context.setSpellTargetY","when calling error in ScmdDataTypes, line 1190")
else
call Cdv("Called Context.setSpellTargetY on invalid object.","when calling error in ScmdDataTypes, line 1190")
endif
endif
call Pee(Pie,Pae)
set EM=EM-1
endfunction
function PVe takes integer PEe returns destructable
return CJ[PEe]
endfunction
function PXe takes integer POe,string PRe returns destructable
local destructable PIe
set ZM[EM]=PRe
set EM=EM+1
if Rx[POe]==0 then
if POe==0 then
call Cdv("Nullpointer exception when calling Context.getSpellTargetDestructable","when calling error in ScmdDataTypes, line 1199")
else
call Cdv("Called Context.getSpellTargetDestructable on invalid object.","when calling error in ScmdDataTypes, line 1199")
endif
endif
set PIe=PVe(POe)
set EM=EM-1
set Ihv=PIe
set PIe=null
return Ihv
endfunction
function PAe takes integer PNe returns item
return BJ[PNe]
endfunction
function Pbe takes integer PBe,string Pce returns item
local item PCe
set ZM[EM]=Pce
set EM=EM+1
if Rx[PBe]==0 then
if PBe==0 then
call Cdv("Nullpointer exception when calling Context.getManipulatedItem","when calling error in ScmdDataTypes, line 1217")
else
call Cdv("Called Context.getManipulatedItem on invalid object.","when calling error in ScmdDataTypes, line 1217")
endif
endif
set PCe=PAe(PBe)
set EM=EM-1
set Ijv=PCe
set PCe=null
return Ijv
endfunction
function Pde takes integer PDe,item Pfe returns nothing
set BJ[PDe]=Pfe
endfunction
function PFe takes integer Pge,item PGe,string Phe returns nothing
set ZM[EM]=Phe
set EM=EM+1
if Rx[Pge]==0 then
if Pge==0 then
call Cdv("Nullpointer exception when calling Context.setManipulatedItem","when calling error in ScmdDataTypes, line 1214")
else
call Cdv("Called Context.setManipulatedItem on invalid object.","when calling error in ScmdDataTypes, line 1214")
endif
endif
call Pde(Pge,PGe)
set EM=EM-1
endfunction
function PHe takes integer Pje,real PJe returns nothing
set KJ[Pje]=PJe
endfunction
function Pke takes integer PKe,real Ple,string PLe returns nothing
set ZM[EM]=PLe
set EM=EM+1
if Rx[PKe]==0 then
if PKe==0 then
call Cdv("Nullpointer exception when calling Context.setSpellTargetX","when calling error in ScmdDataTypes, line 1184")
else
call Cdv("Called Context.setSpellTargetX on invalid object.","when calling error in ScmdDataTypes, line 1184")
endif
endif
call PHe(PKe,Ple)
set EM=EM-1
endfunction
function Pme takes string PMe returns integer
local integer Ppe
set ZM[EM]=PMe
set EM=EM+1
if bh==0 then
if yh<$8000 then
set yh=yh+1
set Ppe=yh
set ph[Ppe]=4899
else
call Cdv("Out of memory: Could not create IterableMap.","when calling error in HashMap, line 46")
set Ppe=0
endif
else
set bh=bh-1
set Ppe=lh[bh]
set ph[Ppe]=4899
endif
set EM=EM-1
return Ppe
endfunction
function PPe takes integer Pqe,string PQe returns nothing
set ZM[EM]=PQe
set EM=EM+1
set bU[Pqe]=TEv("when calling new_HashList in HashMap, line 47")
set yU[Pqe]=false
set EM=EM-1
endfunction
function Pse takes integer PSe,string Pte returns nothing
set ZM[EM]=Pte
set EM=EM+1
call Csv(PSe)
call PPe(PSe,"when calling IterableMap_init in HashMap, line 50")
set EM=EM-1
endfunction
function PTe takes string Pue returns integer
local integer PUe
set ZM[EM]=Pue
set EM=EM+1
set PUe=Pme("when calling alloc_IterableMap in HashMap, line 50")
call Pse(PUe,"when calling construct_IterableMap in HashMap, line 50")
set EM=EM-1
return PUe
endfunction
function Pwe takes integer PWe,string Pye returns nothing
set ZM[EM]=Pye
set EM=EM+1
set NJ[PWe]=PTe("when calling new_IterableMap in ScmdDataTypes, line 1130")
set EM=EM-1
endfunction
function PYe takes integer Pze,string PZe returns nothing
set ZM[EM]=PZe
set EM=EM+1
call Pwe(Pze,"when calling Context_init in ScmdDataTypes, line 1117")
set EM=EM-1
endfunction
function P_e takes string P0e returns integer
local integer P1e
set ZM[EM]=P0e
set EM=EM+1
if dx==0 then
if fx<$8000 then
set fx=fx+1
set P1e=fx
set Rx[P1e]=$65D
else
call Cdv("Out of memory: Could not create Context.","when calling error in ScmdDataTypes, line 1117")
set P1e=0
endif
else
set dx=dx-1
set P1e=nx[dx]
set Rx[P1e]=$65D
endif
set EM=EM-1
return P1e
endfunction
function P2e takes string P3e returns integer
local integer P4e
set ZM[EM]=P3e
set EM=EM+1
set P4e=P_e("when calling alloc_Context in ScmdDataTypes, line 1117")
call PYe(P4e,"when calling construct_Context in ScmdDataTypes, line 1117")
set EM=EM-1
return P4e
endfunction
function P5e takes integer P6e returns unit
return DJ[P6e]
endfunction
function P7e takes integer P8e,string P9e returns unit
local unit qve
set ZM[EM]=P9e
set EM=EM+1
if Rx[P8e]==0 then
if P8e==0 then
call Cdv("Nullpointer exception when calling Context.getTriggerUnit","when calling error in ScmdDataTypes, line 1169")
else
call Cdv("Called Context.getTriggerUnit on invalid object.","when calling error in ScmdDataTypes, line 1169")
endif
endif
set qve=P5e(P8e)
set EM=EM-1
set IFv=qve
set qve=null
return IFv
endfunction
function qee takes integer qxe returns integer
return XJ[qxe]
endfunction
function qoe takes integer qre,string qie returns integer
local integer qae
set ZM[EM]=qie
set EM=EM+1
if Rx[qre]==0 then
if qre==0 then
call Cdv("Nullpointer exception when calling Context.getSpellAbilityId","when calling error in ScmdDataTypes, line 1211")
else
call Cdv("Called Context.getSpellAbilityId on invalid object.","when calling error in ScmdDataTypes, line 1211")
endif
endif
set qae=qee(qre)
set EM=EM-1
return qae
endfunction
function qne takes integer qVe,unit qEe returns nothing
set JJ[qVe]=qEe
endfunction
function qXe takes integer qOe,unit qRe,string qIe returns nothing
set ZM[EM]=qIe
set EM=EM+1
if Rx[qOe]==0 then
if qOe==0 then
call Cdv("Nullpointer exception when calling Context.setSpellTargetUnit","when calling error in ScmdDataTypes, line 1178")
else
call Cdv("Called Context.setSpellTargetUnit on invalid object.","when calling error in ScmdDataTypes, line 1178")
endif
endif
call qne(qOe,qRe)
set EM=EM-1
endfunction
function qAe takes integer qNe returns unit
return HJ[qNe]
endfunction
function qbe takes integer qBe,string qce returns unit
local unit qCe
set ZM[EM]=qce
set EM=EM+1
if Rx[qBe]==0 then
if qBe==0 then
call Cdv("Nullpointer exception when calling Context.getSpellAbilityUnit","when calling error in ScmdDataTypes, line 1175")
else
call Cdv("Called Context.getSpellAbilityUnit on invalid object.","when calling error in ScmdDataTypes, line 1175")
endif
endif
set qCe=qAe(qBe)
set EM=EM-1
set Igv=qCe
set qCe=null
return Igv
endfunction
function qde takes integer qDe returns item
return VJ[qDe]
endfunction
function qfe takes integer qFe,string qge returns item
local item qGe
set ZM[EM]=qge
set EM=EM+1
if Rx[qFe]==0 then
if qFe==0 then
call Cdv("Nullpointer exception when calling Context.getSpellTargetItem","when calling error in ScmdDataTypes, line 1205")
else
call Cdv("Called Context.getSpellTargetItem on invalid object.","when calling error in ScmdDataTypes, line 1205")
endif
endif
set qGe=qde(qFe)
set EM=EM-1
set IHv=qGe
set qGe=null
return IHv
endfunction
function qhe takes integer qHe,unit qje returns nothing
set DJ[qHe]=qje
endfunction
function qJe takes integer qke,unit qKe,string qle returns nothing
set ZM[EM]=qle
set EM=EM+1
if Rx[qke]==0 then
if qke==0 then
call Cdv("Nullpointer exception when calling Context.setTriggerUnit","when calling error in ScmdDataTypes, line 1166")
else
call Cdv("Called Context.setTriggerUnit on invalid object.","when calling error in ScmdDataTypes, line 1166")
endif
endif
call qhe(qke,qKe)
set EM=EM-1
endfunction
function qLe takes integer qme returns real
return KJ[qme]
endfunction
function qMe takes integer qpe,string qPe returns real
local real qqe
set ZM[EM]=qPe
set EM=EM+1
if Rx[qpe]==0 then
if qpe==0 then
call Cdv("Nullpointer exception when calling Context.getSpellTargetX","when calling error in ScmdDataTypes, line 1187")
else
call Cdv("Called Context.getSpellTargetX on invalid object.","when calling error in ScmdDataTypes, line 1187")
endif
endif
set qqe=qLe(qpe)
set EM=EM-1
return qqe
endfunction
function qQe takes integer qse,string qSe returns integer
local integer qte
local integer qTe
local string que
set ZM[EM]=qSe
set EM=EM+1
set qte=P2e("when calling new_Context in ScmdDataTypes, line 1138")
call p7e(qte,QGv(qse,"when calling getPlayerId in ScmdDataTypes, line 1139"),"when calling setPlayerId in ScmdDataTypes, line 1139")
call m7v(qte,Mov(qse,"when calling getEnumUnit in ScmdDataTypes, line 1140"),"when calling setEnumUnit in ScmdDataTypes, line 1140")
call qJe(qte,P7e(qse,"when calling getTriggerUnit in ScmdDataTypes, line 1141"),"when calling setTriggerUnit in ScmdDataTypes, line 1141")
call pwe(qte,qbe(qse,"when calling getSpellAbilityUnit in ScmdDataTypes, line 1142"),"when calling setSpellAbilityUnit in ScmdDataTypes, line 1142")
call qXe(qte,pEv(qse,"when calling getSpellTargetUnit in ScmdDataTypes, line 1143"),"when calling setSpellTargetUnit in ScmdDataTypes, line 1143")
call Pke(qte,qMe(qse,"when calling getSpellTargetX in ScmdDataTypes, line 1144"),"when calling setSpellTargetX in ScmdDataTypes, line 1144")
call Pre(qte,ple(qse,"when calling getSpellTargetY in ScmdDataTypes, line 1145"),"when calling setSpellTargetY in ScmdDataTypes, line 1145")
call phe(qte,PXe(qse,"when calling getSpellTargetDestructable in ScmdDataTypes, line 1146"),"when calling setSpellTargetDestructable in ScmdDataTypes, line 1146")
call pQe(qte,qfe(qse,"when calling getSpellTargetItem in ScmdDataTypes, line 1147"),"when calling setSpellTargetItem in ScmdDataTypes, line 1147")
call p0e(qte,qoe(qse,"when calling getSpellAbilityId in ScmdDataTypes, line 1148"),"when calling setSpellAbilityId in ScmdDataTypes, line 1148")
call PFe(qte,Pbe(qse,"when calling getManipulatedItem in ScmdDataTypes, line 1149"),"when calling setManipulatedItem in ScmdDataTypes, line 1149")
set qTe=jjv(NJ[qse],"when calling iterator in ScmdDataTypes, line 1150")
loop
exitwhen not Jgv(qTe,"when calling hasNext in ScmdDataTypes, line 1150")
set que=hxv(jTv(qTe,"when calling next in ScmdDataTypes, line 1150"),"when calling stringFromIndex in ScmdDataTypes, line 1150")
call WTv(NJ[qte],KCv(que,"when calling stringToIndex in ScmdDataTypes, line 1151"),P_v(f3v(NJ[qse],KCv(que,"when calling stringToIndex in ScmdDataTypes, line 1151"),"when calling get in ScmdDataTypes, line 1151"),"when calling clone in ScmdDataTypes, line 1151"),"when calling put in ScmdDataTypes, line 1151")
endloop
call Jqv(qTe,"when calling close in ScmdDataTypes, line 1150")
set EM=EM-1
return qte
endfunction
function qUe takes integer qwe,string qWe returns integer
local integer qye
set ZM[EM]=qWe
set EM=EM+1
if Rx[qwe]==0 then
if qwe==0 then
call Cdv("Nullpointer exception when calling Context.clone","when calling error in ScmdDataTypes, line 1137")
else
call Cdv("Called Context.clone on invalid object.","when calling error in ScmdDataTypes, line 1137")
endif
endif
set qye=qQe(qwe,"when calling clone in ScmdDataTypes, line 1137")
set EM=EM-1
return qye
endfunction
function qYe takes integer gQt,integer hQt,integer qze,string qZe returns integer
local integer q_e
local integer q0e
local integer q1e
local integer q2e
set ZM[EM]=qZe
set EM=EM+1
set q_e=j5e("when calling new_Vector in ScmdCoreBuiltins, line 308")
set q0e=MRe(qze,"when calling iterator in ScmdCoreBuiltins, line 309")
loop
exitwhen not Jgv(q0e,"when calling hasNext in ScmdCoreBuiltins, line 309")
set q1e=jTv(q0e,"when calling next in ScmdCoreBuiltins, line 309")
call JRe(q_e,P_v(q1e,"when calling clone in ScmdCoreBuiltins, line 310"),"when calling push in ScmdCoreBuiltins, line 310")
endloop
call Jqv(q0e,"when calling close in ScmdCoreBuiltins, line 309")
set q2e=p0v(q_e,"when calling new_SharedPointer in ScmdCoreBuiltins, line 311")
set EM=EM-1
return q2e
endfunction
function q3e takes integer kSi,integer jSi,integer q4e,string q5e returns integer
local integer q6e
set ZM[EM]=q5e
set EM=EM+1
call w6v(PCv(M7v(q4e,0,"when calling get in ScmdUnitBuiltins, line 114"),"when calling getInner in ScmdUnitBuiltins, line 114"),QNv(M7v(q4e,1,"when calling get in ScmdUnitBuiltins, line 114"),"when calling intValue in ScmdUnitBuiltins, line 114"),QNv(M7v(q4e,2,"when calling get in ScmdUnitBuiltins, line 114"),"when calling intValue in ScmdUnitBuiltins, line 114"),QNv(M7v(q4e,3,"when calling get in ScmdUnitBuiltins, line 114"),"when calling intValue in ScmdUnitBuiltins, line 114"),QNv(M7v(q4e,4,"when calling get in ScmdUnitBuiltins, line 114"),"when calling intValue in ScmdUnitBuiltins, line 114"))
set q6e=MLv("when calling nullptr in ScmdUnitBuiltins, line 115")
set EM=EM-1
return q6e
endfunction
function q7e takes integer kTi,integer q8e,integer q9e,string Qve returns integer
local integer Qee
set ZM[EM]=Qve
set EM=EM+1
call Rue(Mov(q8e,"when calling getEnumUnit in ScmdUnitBuiltins, line 663"),dve(PEv(M7v(q9e,0,"when calling get in ScmdUnitBuiltins, line 663"),"when calling realValue in ScmdUnitBuiltins, line 663"),VT,CT))
set Qee=MLv("when calling nullptr in ScmdUnitBuiltins, line 664")
set EM=EM-1
return Qee
endfunction
function Qxe takes integer kfi,integer jfi,integer Qoe,string Qre returns integer
local integer Qie
set ZM[EM]=Qre
set EM=EM+1
set Qie=p0v(SSv(WAv(PCv(M7v(Qoe,0,"when calling get in ScmdUnitBuiltins, line 594"),"when calling getInner in ScmdUnitBuiltins, line 594"),WCv(M7v(Qoe,1,"when calling get in ScmdUnitBuiltins, line 594"),"when calling booleanValue in ScmdUnitBuiltins, line 594")),"when calling new_Integer in ScmdUnitBuiltins, line 594"),"when calling new_SharedPointer in ScmdUnitBuiltins, line 594")
set EM=EM-1
return Qie
endfunction
function Qae takes string Qne returns integer
local integer QVe
set ZM[EM]=Qne
set EM=EM+1
if CY==0 then
if VY<$8000 then
set VY=VY+1
set QVe=VY
set BY[QVe]=$86C
else
call Cdv("Out of memory: Could not create ForForceCallback_execute_setArgumentsTypes_setProvidingEnumUnit_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 210")
set QVe=0
endif
else
set CY=CY-1
set QVe=XY[CY]
set BY[QVe]=$86C
endif
set EM=EM-1
return QVe
endfunction
function QEe takes group QXe returns group
set ae=CreateGroup()
call ForGroup(QXe,OUv)
return ae
endfunction
function QOe takes group QRe returns nothing
call J5e(QRe)
call kcv(QRe)
endfunction
function QIe takes integer oOi,integer QAe,integer QNe,string Qbe returns integer
local integer QBe
local group Qce
local unit QCe
local group Qde
local unit QDe
local integer Qfe
local integer QFe
local integer Qge
set ZM[EM]=Qbe
set EM=EM+1
set QBe=MLv("when calling nullptr in ScmdUnitBuiltins, line 206")
set Qce=jDe(sa[QGv(QAe,"when calling getPlayerId in ScmdUnitBuiltins, line 207")],Filter(Rfv))
set QCe=Mov(QAe,"when calling getEnumUnit in ScmdUnitBuiltins, line 208")
set Qde=QEe(Qce)
loop
exitwhen not F9e(Qde)
set QDe=F6e(Qde)
set Qfe=Qae("when calling alloc_ForForceCallback_execute_setArgumentsTypes_setProvidingEnumUnit_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 210")
set VK[Qfe]=QAe
set BK[Qfe]=QDe
set NK[Qfe]=QNe
set MK[Qfe]=QBe
call Fte(Qfe,"when calling execute in ScmdUnitBuiltins, line 210")
set QFe=ox[m0v(QBe,"when calling get in ScmdUnitBuiltins, line 216")]
if QFe>=$EF1 and QFe<=$EF2 then
exitwhen true
endif
endloop
call QOe(Qde)
call m7v(QAe,QCe,"when calling setEnumUnit in ScmdUnitBuiltins, line 218")
call kcv(Qce)
set Qge=QBe
set EM=EM-1
set Qce=null
set QCe=null
set Qde=null
set QDe=null
return Qge
endfunction
function QGe takes integer pSi,integer eSi,integer Qhe,string QHe returns integer
local unit Qje
local integer QJe
local integer Qke
set ZM[EM]=QHe
set EM=EM+1
set Qje=PCv(M7v(Qhe,0,"when calling get in ScmdUnitBuiltins, line 107"),"when calling getInner in ScmdUnitBuiltins, line 107")
if v1e(Qje)then
set QJe=q2v(ere(Qje),"when calling new_Real in ScmdUnitBuiltins, line 108")
else
set QJe=cBe("when calling new_Undefined in ScmdUnitBuiltins, line 108")
endif
set Qke=pIe(QJe,"when calling new_GenericSharedPointer in ScmdUnitBuiltins, line 108")
set EM=EM-1
set Qje=null
return Qke
endfunction
function QKe takes integer qTi,integer Qle,integer nTi,string QLe returns integer
local integer Qme
set ZM[EM]=QLe
set EM=EM+1
set Qme=p0v(q2v(QJv(Mov(Qle,"when calling getEnumUnit in ScmdUnitBuiltins, line 658")),"when calling new_Real in ScmdUnitBuiltins, line 658"),"when calling new_SharedPointer in ScmdUnitBuiltins, line 658")
set EM=EM-1
return Qme
endfunction
function QMe takes unit Qpe,integer QPe returns nothing
call SetHeroAgi(Qpe,QPe,true)
endfunction
function Qqe takes integer qfi,integer afi,integer QQe,string Qse returns integer
local integer QSe
set ZM[EM]=Qse
set EM=EM+1
call QMe(PCv(M7v(QQe,0,"when calling get in ScmdUnitBuiltins, line 588"),"when calling getInner in ScmdUnitBuiltins, line 588"),QNv(M7v(QQe,1,"when calling get in ScmdUnitBuiltins, line 588"),"when calling intValue in ScmdUnitBuiltins, line 588"))
set QSe=MLv("when calling nullptr in ScmdUnitBuiltins, line 589")
set EM=EM-1
return QSe
endfunction
function Qte takes effect QTe,real Que returns nothing
call BlzSetSpecialEffectY(QTe,Que)
endfunction
function QUe takes integer qft,integer aft,integer Qwe,string QWe returns integer
local integer Qye
set ZM[EM]=QWe
set EM=EM+1
call Qte(Pov(M7v(Qwe,0,"when calling get in SLangSpecialEffectFunctions, line 23"),"when calling getInner in SLangSpecialEffectFunctions, line 23"),PEv(M7v(Qwe,1,"when calling get in SLangSpecialEffectFunctions, line 23"),"when calling realValue in SLangSpecialEffectFunctions, line 23"))
set Qye=MLv("when calling nullptr in SLangSpecialEffectFunctions, line 24")
set EM=EM-1
return Qye
endfunction
function QYe takes integer pvi,integer Qze,integer QZe,string Q_e returns integer
local unit Q0e
local unit Q1e
local integer Q2e
set ZM[EM]=Q_e
set EM=EM+1
set Q0e=Mov(Qze,"when calling getEnumUnit in SotFRP_AbilitySystem, line 49")
call wAv(Q0e,Mqv(M7v(QZe,0,"when calling get in SotFRP_AbilitySystem, line 49"),"when calling getInner in SotFRP_AbilitySystem, line 49"),"when calling addAbility in SotFRP_AbilitySystem, line 49")
set Q1e=Q0e
call U2v(Q1e,Mqv(M7v(QZe,0,"when calling get in SotFRP_AbilitySystem, line 49"),"when calling getInner in SotFRP_AbilitySystem, line 49"),QNv(M7v(QZe,1,"when calling get in SotFRP_AbilitySystem, line 49"),"when calling intValue in SotFRP_AbilitySystem, line 49"),"when calling setAbilityLevel in SotFRP_AbilitySystem, line 49")
set Q2e=MLv("when calling nullptr in SotFRP_AbilitySystem, line 50")
set EM=EM-1
set Q0e=null
set Q1e=null
return Q2e
endfunction
function Q3e takes integer uFt,integer rFt,integer Q4e,string Q5e returns integer
local integer Q6e
set ZM[EM]=Q5e
set EM=EM+1
call fge(1,M7v(Q4e,0,"when calling get in ScmdCoreBuiltins, line 110"),"when calling toString in ScmdCoreBuiltins, line 110")
set Q6e=p0v(tJv(RHv,"when calling new_Exception in ScmdCoreBuiltins, line 110"),"when calling new_SharedPointer in ScmdCoreBuiltins, line 110")
set EM=EM-1
return Q6e
endfunction
function Q7e takes integer uQt,integer rQt,integer sQt,string Q8e returns integer
local integer Q9e
set ZM[EM]=Q8e
set EM=EM+1
set Q9e=p0v(q2v(GetRandomReal(.0,1.),"when calling new_Real in ScmdCoreBuiltins, line 297"),"when calling new_SharedPointer in ScmdCoreBuiltins, line 297")
set EM=EM-1
return Q9e
endfunction
function sve takes effect see,real sxe returns nothing
call BlzSetSpecialEffectYaw(see,sxe)
endfunction
function soe takes integer uRt,integer rRt,integer sre,string sie returns integer
local integer sae
set ZM[EM]=sie
set EM=EM+1
call sve(Pov(M7v(sre,0,"when calling get in SLangSpecialEffectFunctions, line 48"),"when calling getInner in SLangSpecialEffectFunctions, line 48"),PEv(M7v(sre,1,"when calling get in SLangSpecialEffectFunctions, line 48"),"when calling realValue in SLangSpecialEffectFunctions, line 48"))
set sae=MLv("when calling nullptr in SLangSpecialEffectFunctions, line 49")
set EM=EM-1
return sae
endfunction
function sne takes trigger sVe,unit sEe,unitevent sXe returns event
return TriggerRegisterUnitEvent(sVe,sEe,sXe)
endfunction
function sOe takes integer NRt,integer MRt,integer sRe,string sIe returns integer
local unitevent sAe
local string sNe
local integer sbe
local integer sBe
set ZM[EM]=sIe
set EM=EM+1
set sAe=null
set sNe=tYv(Mqv(M7v(sRe,2,"when calling get in SLangTriggerFunctions, line 50"),"when calling getInner in SLangTriggerFunctions, line 50"))
if sNe=="spellcast" then
set sAe=EVENT_UNIT_SPELL_CAST
elseif sNe=="spellchannel" then
set sAe=EVENT_UNIT_SPELL_CHANNEL
elseif sNe=="spelleffect" then
set sAe=EVENT_UNIT_SPELL_EFFECT
elseif sNe=="spellendcast" then
set sAe=EVENT_UNIT_SPELL_ENDCAST
elseif sNe=="spellfinish" then
set sAe=EVENT_UNIT_SPELL_FINISH
elseif sNe=="damaged" then
set sAe=EVENT_UNIT_DAMAGED
elseif sNe=="death" then
set sAe=EVENT_UNIT_DEATH
elseif sNe=="decay" then
set sAe=EVENT_UNIT_DECAY
elseif sNe=="pickupitem" then
set sAe=EVENT_UNIT_PICKUP_ITEM
elseif sNe=="useitem" then
set sAe=EVENT_UNIT_USE_ITEM
endif
if sAe!=null then
call sne(qGv(M7v(sRe,0,"when calling get in SLangTriggerFunctions, line 72"),"when calling getInner in SLangTriggerFunctions, line 72"),PCv(M7v(sRe,1,"when calling get in SLangTriggerFunctions, line 72"),"when calling getInner in SLangTriggerFunctions, line 72"),sAe)
endif
if sAe!=null then
set sbe=p0v(dpe("when calling new_Null in SLangTriggerFunctions, line 73"),"when calling new_SharedPointer in SLangTriggerFunctions, line 73")
else
set sbe=p0v(tJv("Wrong event name","when calling new_Exception in SLangTriggerFunctions, line 73"),"when calling new_SharedPointer in SLangTriggerFunctions, line 73")
endif
set sBe=sbe
set EM=EM-1
set sAe=null
return sBe
endfunction
function sce takes integer UJt returns nothing
endfunction
function sCe takes integer sde,destructable sDe returns nothing
call pfv(sde,sDe)
call sce(sde)
set MJ[sde]=sDe
endfunction
function sfe takes string sFe returns integer
local integer sge
set ZM[EM]=sFe
set EM=EM+1
if Sx==0 then
if cx<$8000 then
set cx=cx+1
set sge=cx
set ox[sge]=$EF8
else
call Cdv("Out of memory: Could not create Destructable.","when calling error in ScmdDataTypes, line 832")
set sge=0
endif
else
set Sx=Sx-1
set sge=ix[Sx]
set ox[sge]=$EF8
endif
set EM=EM-1
return sge
endfunction
function sGe takes destructable she,string sHe returns integer
local integer sje
set ZM[EM]=sHe
set EM=EM+1
set sje=sfe("when calling alloc_Destructable in ScmdDataTypes, line 838")
call sCe(sje,she)
set EM=EM-1
return sje
endfunction
function sJe takes integer uYt,integer ske,integer sYt,string sKe returns integer
local integer sle
set ZM[EM]=sKe
set EM=EM+1
set sle=p0v(sGe(PXe(ske,"when calling getSpellTargetDestructable in SLangTriggerFunctions, line 109"),"when calling new_Destructable in SLangTriggerFunctions, line 109"),"when calling new_SharedPointer in SLangTriggerFunctions, line 109")
set EM=EM-1
return sle
endfunction
function sLe takes string sme returns integer
local integer sMe
set ZM[EM]=sme
set EM=EM+1
set sMe=p0v(tJv("Unknown destructable","when calling new_Exception in SotfrpGuiDestructables, line 130"),"when calling new_SharedPointer in SotfrpGuiDestructables, line 130")
set EM=EM-1
return sMe
endfunction
function spe takes string sPe,string sqe,string sQe,string sse,string sSe,string ste,string sTe returns string
local string sue=sPe
local integer sUe=0
set sue=HXe(sue,"{"+SMv(sUe)+"}",sqe)
set sUe=sUe+1
set sue=HXe(sue,"{"+SMv(sUe)+"}",sQe)
set sUe=sUe+1
set sue=HXe(sue,"{"+SMv(sUe)+"}",sse)
set sUe=sUe+1
set sue=HXe(sue,"{"+SMv(sUe)+"}",sSe)
set sUe=sUe+1
set sue=HXe(sue,"{"+SMv(sUe)+"}",ste)
set sUe=sUe+1
set sue=HXe(sue,"{"+SMv(sUe)+"}",sTe)
set sUe=sUe+1
return sue
endfunction
function swe takes integer sWe,string sye,string sYe,string sze,string sZe,string s_e,string s0e returns nothing
local string s1e=spe(If,sye,sYe,sze,sZe,s_e,s0e)
if ta==sa[sWe]then
call BlzSetAbilityExtendedTooltip(Uf,Zf+s1e,1)
endif
endfunction
function s2e takes integer s3e,string s4e returns string
local string s5e
set ZM[EM]=s4e
set EM=EM+1
set s5e=hxv(f3v(Qf,s3e,"when calling get in SotfrpGuiDestructables, line 29"),"when calling stringFromIndex in SotfrpGuiDestructables, line 29")
set EM=EM-1
return s5e
endfunction
function s6e takes integer s7e,string s8e returns nothing
local string s9e
local string Sve
local integer See
local string Sxe
local string Soe
local string Sre
local string Sie
local string Sae
set ZM[EM]=s8e
set EM=EM+1
set See=s7e
set Sxe=s2e(Pf[s7e],"when calling getRegisteredDestructableName in SotfrpGuiDestructables, line 148")
set Soe=d0v(Pf[s7e])
set Sre=qwv(Af[s7e])
if Df[s7e]then
set s9e="Случ."
else
set s9e=qwv(Hf[s7e])
endif
set Sie=s9e
set Sae=qwv(Jf[s7e])
if Kf[s7e]then
set Sve="Случ."
else
set Sve=SMv(Lf[s7e])
endif
call swe(See,Sxe,Soe,Sre,Sie,Sae,Sve)
set EM=EM-1
endfunction
function Sne takes integer SVe,integer SEe,string SXe returns nothing
set ZM[EM]=SXe
set EM=EM+1
set Pf[SVe]=SEe
call s6e(SVe,"when calling updateInfo in SotfrpGuiDestructables, line 152")
set EM=EM-1
endfunction
function SOe takes string SRe,string SIe returns integer
local integer SAe
set ZM[EM]=SIe
set EM=EM+1
set SAe=hIv(mf,SRe,"when calling get in SotfrpGuiDestructables, line 26")
set EM=EM-1
return SAe
endfunction
function SNe takes integer MEi,integer Sbe,integer SBe,string Sce returns integer
local integer SCe
local integer Sde
local integer SDe
set ZM[EM]=Sce
set EM=EM+1
set SCe=SOe(Mqv(M7v(SBe,0,"when calling get in SotfrpGuiDestructables, line 227"),"when calling getInner in SotfrpGuiDestructables, line 227"),"when calling getRegisteredDestructableId in SotfrpGuiDestructables, line 227")
if SCe!=0 then
call Sne(QGv(Sbe,"when calling getPlayerId in SotfrpGuiDestructables, line 229"),SCe,"when calling setId in SotfrpGuiDestructables, line 229")
endif
if SCe==0 then
set Sde=sLe("when calling makeUnknownDestructableException in SotfrpGuiDestructables, line 230")
else
set Sde=MLv("when calling nullptr in SotfrpGuiDestructables, line 230")
endif
set SDe=Sde
set EM=EM-1
return SDe
endfunction
function Sfe takes unit SFe returns nothing
call KillUnit(SFe)
endfunction
function Sge takes unit SGe,boolean She returns nothing
call SetUnitExploded(SGe,She)
endfunction
function SHe takes unit Sje returns nothing
call Sge(Sje,true)
call Sfe(Sje)
endfunction
function SJe takes integer uhi,integer Ske,integer shi,string SKe returns integer
local integer Sle
set ZM[EM]=SKe
set EM=EM+1
call SHe(Mov(Ske,"when calling getEnumUnit in ScmdUnitBuiltins, line 764"))
set Sle=MLv("when calling nullptr in ScmdUnitBuiltins, line 765")
set EM=EM-1
return Sle
endfunction
function SLe takes integer uki,integer rki,integer Sme,string SMe returns integer
local integer Spe
set ZM[EM]=SMe
set EM=EM+1
call Mwv(PCv(M7v(Sme,0,"when calling get in ScmdUnitBuiltins, line 817"),"when calling getInner in ScmdUnitBuiltins, line 817"),Mqv(M7v(Sme,1,"when calling get in ScmdUnitBuiltins, line 817"),"when calling getInner in ScmdUnitBuiltins, line 817"),false)
set Spe=MLv("when calling nullptr in ScmdUnitBuiltins, line 818")
set EM=EM-1
return Spe
endfunction
function SPe takes unit Sqe,player SQe,boolean Sse returns nothing
call SetUnitOwner(Sqe,SQe,Sse)
endfunction
function SSe takes playercolor Ste returns player
local integer STe=0
local integer Sue=bj_MAX_PLAYER_SLOTS-1
loop
exitwhen STe>Sue
if g_e(sa[STe])==Ste then
return sa[STe]
endif
set STe=STe+1
endloop
return null
endfunction
function SUe takes integer Bsi,integer Swe,integer SWe,string Sye returns integer
local string SYe
local player Sze
local string SZe
local integer S_e
local integer S0e
set ZM[EM]=Sye
set EM=EM+1
set SYe=tYv(Mqv(M7v(SWe,1,"when calling get in ScmdUnitBuiltins, line 35"),"when calling getInner in ScmdUnitBuiltins, line 35"))
set SZe=SYe
if SZe=="hostile" then
set Sze=sa[PLAYER_NEUTRAL_AGGRESSIVE]
elseif SZe=="neutral" then
set Sze=sa[PLAYER_NEUTRAL_PASSIVE]
elseif SZe=="me" then
set Sze=sa[QGv(Swe,"when calling getPlayerId in ScmdUnitBuiltins, line 43")]
else
set Sze=SSe(tZv(SYe))
endif
if Sze!=null then
call SPe(PCv(M7v(SWe,0,"when calling get in ScmdUnitBuiltins, line 47"),"when calling getInner in ScmdUnitBuiltins, line 47"),Sze,false)
endif
if Sze!=null then
set S_e=MLv("when calling nullptr in ScmdUnitBuiltins, line 48")
else
set S_e=tLv("when calling newWCNException in ScmdUnitBuiltins, line 48")
endif
set S0e=S_e
set EM=EM-1
set Sze=null
return S0e
endfunction
function S1e takes unit S2e,string S3e returns nothing
call SetUnitAnimation(S2e,S3e)
endfunction
function S4e takes integer aFi,integer nFi,integer S5e,string S6e returns integer
local integer S7e
set ZM[EM]=S6e
set EM=EM+1
call S1e(PCv(M7v(S5e,0,"when calling get in ScmdUnitBuiltins, line 796"),"when calling getInner in ScmdUnitBuiltins, line 796"),Mqv(M7v(S5e,1,"when calling get in ScmdUnitBuiltins, line 796"),"when calling getInner in ScmdUnitBuiltins, line 796"))
set S7e=MLv("when calling nullptr in ScmdUnitBuiltins, line 797")
set EM=EM-1
return S7e
endfunction
function S8e takes integer S9e,integer tve returns nothing
local integer tee=tve
if tee==1 then
set AW[S9e]=true
elseif tee==2 then
set VW[S9e]=true
endif
endfunction
function txe takes integer toe,integer tre,string tie returns nothing
set ZM[EM]=tie
set EM=EM+1
if Gg[toe]==0 then
if toe==0 then
call Cdv("Nullpointer exception when calling CustomUnitType.resetDiceSides","when calling error in CustomUnitTypes, line 159")
else
call Cdv("Called CustomUnitType.resetDiceSides on invalid object.","when calling error in CustomUnitTypes, line 159")
endif
endif
call S8e(toe,tre)
set EM=EM-1
endfunction
function tae takes integer tne,integer tVe returns nothing
local integer tEe=tVe
if tEe==1 then
set IW[tne]=true
elseif tEe==2 then
set XW[tne]=true
endif
endfunction
function tXe takes integer tOe,integer tRe,string tIe returns nothing
set ZM[EM]=tIe
set EM=EM+1
if Gg[tOe]==0 then
if tOe==0 then
call Cdv("Nullpointer exception when calling CustomUnitType.resetAttackCooldown","when calling error in CustomUnitTypes, line 143")
else
call Cdv("Called CustomUnitType.resetAttackCooldown on invalid object.","when calling error in CustomUnitTypes, line 143")
endif
endif
call tae(tOe,tRe)
set EM=EM-1
endfunction
function tAe takes integer tNe,integer tbe returns nothing
local integer tBe=tbe
if tBe==1 then
set HW[tNe]=true
elseif tBe==2 then
set NW[tNe]=true
endif
endfunction
function tce takes integer tCe,integer tde,string tDe returns nothing
set ZM[EM]=tDe
set EM=EM+1
if Gg[tCe]==0 then
if tCe==0 then
call Cdv("Nullpointer exception when calling CustomUnitType.resetDiceNumber","when calling error in CustomUnitTypes, line 175")
else
call Cdv("Called CustomUnitType.resetDiceNumber on invalid object.","when calling error in CustomUnitTypes, line 175")
endif
endif
call tAe(tCe,tde)
set EM=EM-1
endfunction
function tfe takes integer tFe,integer tge returns nothing
local integer tGe=tge
if tGe==1 then
set ZW[tFe]=true
elseif tGe==2 then
set KW[tFe]=true
endif
endfunction
function the takes integer tHe,integer tje,string tJe returns nothing
set ZM[EM]=tJe
set EM=EM+1
if Gg[tHe]==0 then
if tHe==0 then
call Cdv("Nullpointer exception when calling CustomUnitType.resetBaseDamage","when calling error in CustomUnitTypes, line 127")
else
call Cdv("Called CustomUnitType.resetBaseDamage on invalid object.","when calling error in CustomUnitTypes, line 127")
endif
endif
call tfe(tHe,tje)
set EM=EM-1
endfunction
function tke takes integer tKe,string tle returns nothing
set ZM[EM]=tle
set EM=EM+1
set EW[tKe]=0
call the(tKe,1,"when calling resetBaseDamage in CustomUnitTypes, line 95")
call tXe(tKe,1,"when calling resetAttackCooldown in CustomUnitTypes, line 96")
call txe(tKe,1,"when calling resetDiceSides in CustomUnitTypes, line 97")
call tce(tKe,1,"when calling resetDiceNumber in CustomUnitTypes, line 98")
call the(tKe,2,"when calling resetBaseDamage in CustomUnitTypes, line 99")
call tXe(tKe,2,"when calling resetAttackCooldown in CustomUnitTypes, line 100")
call txe(tKe,2,"when calling resetDiceSides in CustomUnitTypes, line 101")
call tce(tKe,2,"when calling resetDiceNumber in CustomUnitTypes, line 102")
set EM=EM-1
endfunction
function tLe takes integer tme,string tMe returns nothing
set ZM[EM]=tMe
set EM=EM+1
if Gg[tme]==0 then
if tme==0 then
call Cdv("Nullpointer exception when calling CustomUnitType.reset","when calling error in CustomUnitTypes, line 93")
else
call Cdv("Called CustomUnitType.reset on invalid object.","when calling error in CustomUnitTypes, line 93")
endif
endif
call tke(tme,"when calling reset in CustomUnitTypes, line 93")
set EM=EM-1
endfunction
function tpe takes integer tPe,integer tqe returns integer
return wa[yH[tPe]+tqe]
endfunction
function tQe takes integer tse,integer tSe,string tte returns integer
local integer tTe
set ZM[EM]=tte
set EM=EM+1
if Gg[tse]==0 then
if tse==0 then
call Cdv("Nullpointer exception when calling PlayerDefinedUnitTypes.getSlot","when calling error in PlayerDefinedUnitTypes, line 26")
else
call Cdv("Called PlayerDefinedUnitTypes.getSlot on invalid object.","when calling error in PlayerDefinedUnitTypes, line 26")
endif
endif
set tTe=tpe(tse,tSe)
set EM=EM-1
return tTe
endfunction
function tue takes integer Zit returns string
return"SotFRP\\Data\\utypes.pld"
endfunction
function tUe takes integer twe returns string
return"SotFRP\\Save\\"+VU[twe]+".pld"
endfunction
function tWe takes integer tye returns string
return"SotFRP\\Save\\"+WH[tye]+".pld"
endfunction
function tYe takes integer tze,string tZe returns string
local string t_e
set ZM[EM]=tZe
set EM=EM+1
if Gg[tze]==0 then
if tze==0 then
call Cdv("Nullpointer exception when calling Persistable.getPath","when calling error in PersistableData, line 65")
else
call Cdv("Called Persistable.getPath on invalid object.","when calling error in PersistableData, line 65")
endif
endif
if Gg[tze]<=$6D5 then
if Gg[tze]<=$6D4 then
set t_e=tUe(tze)
else
set t_e=tue(tze)
endif
else
set t_e=tWe(tze)
endif
set EM=EM-1
return t_e
endfunction
function t0e takes integer DKc,integer HKc returns integer
return 0
endfunction
function t1e takes integer t2e,integer t3e,integer t4e,integer t5e returns integer
return t2e+t3e*256+t4e*65536+t5e*$1000000
endfunction
function t6e takes integer t7e,string t8e returns nothing
local integer t9e
local integer Tve
local integer Tee
local integer Txe
set ZM[EM]=t8e
set EM=EM+1
set yW[t7e]=yW[t7e]+1
call Dyv(uW[t7e],yW[t7e],t1e(rW[t7e],sW[t7e],tW[t7e],iW[t7e]),"when calling saveInt in ByteBuffer, line 34")
set t9e=0
set Tve=0
set Tee=0
set Txe=0
set rW[t7e]=t9e
set sW[t7e]=Tve
set tW[t7e]=Tee
set iW[t7e]=Txe
set eW[t7e]=eW[t7e]+SW[t7e]
set SW[t7e]=0
set EM=EM-1
endfunction
function Toe takes integer Tre,string Tie returns nothing
set ZM[EM]=Tie
set EM=EM+1
if EG[Tre]==0 then
if Tre==0 then
call Cdv("Nullpointer exception when calling ByteBuffer.commitInt","when calling error in ByteBuffer, line 32")
else
call Cdv("Called ByteBuffer.commitInt on invalid object.","when calling error in ByteBuffer, line 32")
endif
endif
call t6e(Tre,"when calling commitInt in ByteBuffer, line 32")
set EM=EM-1
endfunction
function Tae takes integer Tne,integer TVe,integer TEe,integer TXe,integer TOe,integer TRe returns integer
local integer TIe
local integer TAe
local integer TNe
local integer Tbe
local integer TBe
local integer Tce
local integer TCe
local integer Tde
local integer TDe
local integer Tfe
local integer TFe
local integer Tge
local integer TGe
local integer The
local integer THe
local integer Tje
local integer TJe
local integer Tke
local integer TKe
local integer Tle
if TOe>1 then
if TOe==3 then
set TBe=Tne
set Tce=TVe
set TCe=TEe
set Tde=TRe
set TIe=TBe
set TAe=Tce
set TNe=TCe
set Tbe=Tde
else
set TDe=Tne
set Tfe=TVe
set TFe=TRe
set Tge=TXe
set TIe=TDe
set TAe=Tfe
set TNe=TFe
set Tbe=Tge
endif
elseif TOe==1 then
set TGe=Tne
set The=TRe
set THe=TEe
set Tje=TXe
set TIe=TGe
set TAe=The
set TNe=THe
set Tbe=Tje
else
set TJe=TRe
set Tke=TVe
set TKe=TEe
set Tle=TXe
set TIe=TJe
set TAe=Tke
set TNe=TKe
set Tbe=Tle
endif
set KM=TIe
set LM=TAe
set XM=TNe
set CM=Tbe
return KM
endfunction
function TLe takes integer Tme,integer TMe,string Tpe returns nothing
local integer TPe
local integer Tqe
local integer TQe
local integer Tse
set ZM[EM]=Tpe
set EM=EM+1
if SW[Tme]>3 then
call Toe(Tme,"when calling commitInt in ByteBuffer, line 46")
endif
set TPe=Tae(rW[Tme],sW[Tme],tW[Tme],iW[Tme],SW[Tme],TMe)
set Tqe=LM
set TQe=XM
set Tse=CM
set rW[Tme]=TPe
set sW[Tme]=Tqe
set tW[Tme]=TQe
set iW[Tme]=Tse
set SW[Tme]=SW[Tme]+1
set EM=EM-1
endfunction
function TSe takes integer Tte,integer TTe,string Tue returns nothing
set ZM[EM]=Tue
set EM=EM+1
if EG[Tte]==0 then
if Tte==0 then
call Cdv("Nullpointer exception when calling ByteBuffer.writeByteInternal","when calling error in ByteBuffer, line 44")
else
call Cdv("Called ByteBuffer.writeByteInternal on invalid object.","when calling error in ByteBuffer, line 44")
endif
endif
call TLe(Tte,TTe,"when calling writeByteInternal in ByteBuffer, line 44")
set EM=EM-1
endfunction
function TUe takes integer Twe,integer TWe,string Tye returns nothing
set ZM[EM]=Tye
set EM=EM+1
call TSe(Twe,TWe,"when calling writeByteInternal in ByteBuffer, line 59")
set EM=EM-1
endfunction
function TYe takes integer Tze,integer TZe,string T_e returns nothing
set ZM[EM]=T_e
set EM=EM+1
if EG[Tze]==0 then
if Tze==0 then
call Cdv("Nullpointer exception when calling ByteBuffer.writeByte","when calling error in ByteBuffer, line 58")
else
call Cdv("Called ByteBuffer.writeByte on invalid object.","when calling error in ByteBuffer, line 58")
endif
endif
call TUe(Tze,TZe,"when calling writeByte in ByteBuffer, line 58")
set EM=EM-1
endfunction
function T0e takes integer T1e,integer T2e,string T3e returns nothing
set ZM[EM]=T3e
set EM=EM+1
call TYe(GQ[T1e],T2e,"when calling writeByte in Base64, line 161")
set EM=EM-1
endfunction
function T4e takes integer T5e,integer T6e,string T7e returns nothing
set ZM[EM]=T7e
set EM=EM+1
if LY[T5e]==0 then
if T5e==0 then
call Cdv("Nullpointer exception when calling Base64Encoder.pushByte","when calling error in Base64, line 160")
else
call Cdv("Called Base64Encoder.pushByte on invalid object.","when calling error in Base64, line 160")
endif
endif
call T0e(T5e,T6e,"when calling pushByte in Base64, line 160")
set EM=EM-1
endfunction
function T8e takes integer T9e,integer uve,string uee returns nothing
set ZM[EM]=uee
set EM=EM+1
call T4e(nQ[T9e],uve,"when calling pushByte in Base64Data, line 20")
set EM=EM-1
endfunction
function uxe takes integer uoe,integer ure,string uie returns nothing
set ZM[EM]=uie
set EM=EM+1
call Dyv(rU[uoe],sU[uoe],ure,"when calling saveInt in HashData, line 27")
set sU[uoe]=sU[uoe]+1
set EM=EM-1
endfunction
function uae takes integer une,integer uVe,string uEe returns nothing
set ZM[EM]=uEe
set EM=EM+1
if jY[une]==0 then
if une==0 then
call Cdv("Nullpointer exception when calling HashWriter.writeInt","when calling error in HashData, line 26")
else
call Cdv("Called HashWriter.writeInt on invalid object.","when calling error in HashData, line 26")
endif
endif
call uxe(une,uVe,"when calling writeInt in HashData, line 26")
set EM=EM-1
endfunction
function uXe takes integer uOe,integer uRe,string uIe returns nothing
set ZM[EM]=uIe
set EM=EM+1
call uae(uOe,uRe,"when calling writeInt in HashData, line 21")
set EM=EM-1
endfunction
function uAe takes integer uNe,integer ube,string uBe returns nothing
set ZM[EM]=uBe
set EM=EM+1
if jY[uNe]==0 then
if uNe==0 then
call Cdv("Nullpointer exception when calling DataWriter.writeByte","when calling error in DataInterfaces, line 36")
else
call Cdv("Called DataWriter.writeByte on invalid object.","when calling error in DataInterfaces, line 36")
endif
endif
if jY[uNe]<=$6E1 then
call T8e(uNe,ube,"when calling writeByte in DataInterfaces, line 36")
else
call uXe(uNe,ube,"when calling writeByte in DataInterfaces, line 36")
endif
set EM=EM-1
endfunction
function uce takes string uCe returns integer
local integer ude
set ZM[EM]=uCe
set EM=EM+1
if CY==0 then
if VY<$8000 then
set VY=VY+1
set ude=VY
set BY[ude]=$862
else
call Cdv("Out of memory: Could not create ForForceCallback_execute_StringTable_StringTable.","when calling error in StringTable, line 66")
set ude=0
endif
else
set CY=CY-1
set ude=XY[CY]
set BY[ude]=$862
endif
set EM=EM-1
return ude
endfunction
function uDe takes integer ufe returns integer
return ModuloInteger(ufe,256)
endfunction
function uFe takes integer uge returns integer
return(uge-uge/65536*65536)/256
endfunction
function uGe takes integer uhe,integer uHe,string uje returns nothing
set ZM[EM]=uje
set EM=EM+1
call TSe(uhe,uDe(uHe),"when calling writeByteInternal in ByteBuffer, line 63")
call TSe(uhe,uFe(uHe),"when calling writeByteInternal in ByteBuffer, line 64")
set EM=EM-1
endfunction
function uJe takes integer uke,integer uKe,string ule returns nothing
set ZM[EM]=ule
set EM=EM+1
if EG[uke]==0 then
if uke==0 then
call Cdv("Nullpointer exception when calling ByteBuffer.writeShort","when calling error in ByteBuffer, line 62")
else
call Cdv("Called ByteBuffer.writeShort on invalid object.","when calling error in ByteBuffer, line 62")
endif
endif
call uGe(uke,uKe,"when calling writeShort in ByteBuffer, line 62")
set EM=EM-1
endfunction
function uLe takes integer ume,integer uMe,string upe returns nothing
set ZM[EM]=upe
set EM=EM+1
call uJe(GQ[ume],uMe,"when calling writeShort in Base64, line 165")
set EM=EM-1
endfunction
function uPe takes integer uqe,integer uQe,string use returns nothing
set ZM[EM]=use
set EM=EM+1
if LY[uqe]==0 then
if uqe==0 then
call Cdv("Nullpointer exception when calling Base64Encoder.pushShort","when calling error in Base64, line 164")
else
call Cdv("Called Base64Encoder.pushShort on invalid object.","when calling error in Base64, line 164")
endif
endif
call uLe(uqe,uQe,"when calling pushShort in Base64, line 164")
set EM=EM-1
endfunction
function uSe takes integer ute,integer uTe,string uue returns nothing
set ZM[EM]=uue
set EM=EM+1
call uPe(nQ[ute],uTe,"when calling pushShort in Base64Data, line 23")
set EM=EM-1
endfunction
function uUe takes integer uwe,integer uWe,string uye returns nothing
set ZM[EM]=uye
set EM=EM+1
call uae(uwe,uWe,"when calling writeInt in HashData, line 24")
set EM=EM-1
endfunction
function uYe takes integer uze,integer uZe,string u_e returns nothing
set ZM[EM]=u_e
set EM=EM+1
if jY[uze]==0 then
if uze==0 then
call Cdv("Nullpointer exception when calling DataWriter.writeShort","when calling error in DataInterfaces, line 39")
else
call Cdv("Called DataWriter.writeShort on invalid object.","when calling error in DataInterfaces, line 39")
endif
endif
if jY[uze]<=$6E1 then
call uSe(uze,uZe,"when calling writeShort in DataInterfaces, line 39")
else
call uUe(uze,uZe,"when calling writeShort in DataInterfaces, line 39")
endif
set EM=EM-1
endfunction
function u0e takes integer nBi,integer u1e,string u2e,string u3e returns nothing
local integer u4e
local integer u5e
set ZM[EM]=u3e
set EM=EM+1
set u4e=GZv(u2e)
call uYe(u1e,GZv(u2e),"when calling writeShort in StringTable, line 65")
set u5e=uce("when calling alloc_ForForceCallback_execute_StringTable_StringTable in StringTable, line 66")
set wC[u5e]=u4e
set uC[u5e]=u1e
set rC[u5e]=u2e
call Fte(u5e,"when calling execute in StringTable, line 66")
set EM=EM-1
endfunction
function u6e takes integer u7e,integer u8e,string u9e,string Uve returns nothing
set ZM[EM]=Uve
set EM=EM+1
if Gg[u7e]==0 then
if u7e==0 then
call Cdv("Nullpointer exception when calling StringTable.serializeString","when calling error in StringTable, line 63")
else
call Cdv("Called StringTable.serializeString on invalid object.","when calling error in StringTable, line 63")
endif
endif
call u0e(u7e,u8e,u9e,"when calling serializeString in StringTable, line 63")
set EM=EM-1
endfunction
function Uee takes integer Uxe returns integer
local integer Uoe=Uxe
local integer Ure=0
local integer Uie
local integer Uae
local integer Une
local integer UVe
if Uoe<0 then
set Uoe=--$80000000+Uoe
set Ure=1
endif
set Uie=ModuloInteger(Uoe,256)
set Uae=(Uoe-Uoe/65536*65536)/256
set Une=(Uoe-Uoe/$1000000*$1000000)/65536
set UVe=Ure*$80+Uoe/$1000000
set VM=Uie
set BM=Uae
set NM=Une
set MM=UVe
return VM
endfunction
function UEe takes integer UXe,integer UOe,string URe returns nothing
local integer UIe
local integer UAe
local integer UNe
local integer Ube
local integer UBe
local integer Uce
local integer UCe
local integer Ude
set ZM[EM]=URe
set EM=EM+1
set UBe=Uee(UOe)
set Uce=BM
set UCe=NM
set Ude=MM
set UIe=UBe
set UAe=Uce
set UNe=UCe
set Ube=Ude
call TSe(UXe,UIe,"when calling writeByteInternal in ByteBuffer, line 69")
call TSe(UXe,UAe,"when calling writeByteInternal in ByteBuffer, line 70")
call TSe(UXe,UNe,"when calling writeByteInternal in ByteBuffer, line 71")
call TSe(UXe,Ube,"when calling writeByteInternal in ByteBuffer, line 72")
set EM=EM-1
endfunction
function UDe takes integer Ufe,integer UFe,string Uge returns nothing
set ZM[EM]=Uge
set EM=EM+1
if EG[Ufe]==0 then
if Ufe==0 then
call Cdv("Nullpointer exception when calling ByteBuffer.writeInt","when calling error in ByteBuffer, line 67")
else
call Cdv("Called ByteBuffer.writeInt on invalid object.","when calling error in ByteBuffer, line 67")
endif
endif
call UEe(Ufe,UFe,"when calling writeInt in ByteBuffer, line 67")
set EM=EM-1
endfunction
function UGe takes integer Uhe,integer UHe,string Uje returns nothing
set ZM[EM]=Uje
set EM=EM+1
call UDe(GQ[Uhe],UHe,"when calling writeInt in Base64, line 169")
set EM=EM-1
endfunction
function UJe takes integer Uke,integer UKe,string Ule returns nothing
set ZM[EM]=Ule
set EM=EM+1
if LY[Uke]==0 then
if Uke==0 then
call Cdv("Nullpointer exception when calling Base64Encoder.pushInt","when calling error in Base64, line 168")
else
call Cdv("Called Base64Encoder.pushInt on invalid object.","when calling error in Base64, line 168")
endif
endif
call UGe(Uke,UKe,"when calling pushInt in Base64, line 168")
set EM=EM-1
endfunction
function ULe takes integer Ume,integer UMe,string Upe returns nothing
set ZM[EM]=Upe
set EM=EM+1
call UJe(nQ[Ume],UMe,"when calling pushInt in Base64Data, line 26")
set EM=EM-1
endfunction
function UPe takes integer Uqe,integer UQe,string Use returns nothing
set ZM[EM]=Use
set EM=EM+1
if jY[Uqe]==0 then
if Uqe==0 then
call Cdv("Nullpointer exception when calling DataWriter.writeInt","when calling error in DataInterfaces, line 42")
else
call Cdv("Called DataWriter.writeInt on invalid object.","when calling error in DataInterfaces, line 42")
endif
endif
if jY[Uqe]<=$6E1 then
call ULe(Uqe,UQe,"when calling writeInt in DataInterfaces, line 42")
else
call uxe(Uqe,UQe,"when calling writeInt in DataInterfaces, line 42")
endif
set EM=EM-1
endfunction
function USe takes integer Ute,integer UTe,integer Uue,string UUe returns nothing
set ZM[EM]=UUe
set EM=EM+1
if VX[UTe]then
if BX[UTe]then
call UPe(Ute,Uue,"when calling writeInt in StringTable, line 28")
else
call uYe(Ute,Uue,"when calling writeShort in StringTable, line 30")
endif
else
call uAe(Ute,Uue,"when calling writeByte in StringTable, line 32")
endif
set EM=EM-1
endfunction
function Uwe takes string UWe returns integer
local integer Uye
set ZM[EM]=UWe
set EM=EM+1
if am==0 then
if nm<$8000 then
set nm=nm+1
set Uye=nm
set dm[Uye]=4813
else
call Cdv("Out of memory: Could not create StringHLIterator.","when calling error in Utility, line 271")
set Uye=0
endif
else
set am=am-1
set Uye=qm[am]
set dm[Uye]=4813
endif
set EM=EM-1
return Uye
endfunction
function UYe takes integer Uze returns nothing
set aM[Uze]=0
endfunction
function UZe takes integer U_e,integer U0e returns nothing
call UYe(U_e)
set nM[U_e]=U0e
endfunction
function U1e takes integer U2e,string U3e returns integer
local integer U4e
set ZM[EM]=U3e
set EM=EM+1
set U4e=Uwe("when calling alloc_StringHLIterator in Utility, line 275")
call UZe(U4e,U2e)
set EM=EM-1
return U4e
endfunction
function U5e takes integer U6e,string U7e returns integer
local integer U8e
set ZM[EM]=U7e
set EM=EM+1
set U8e=U1e(U6e,"when calling new_StringHLIterator in Utility, line 252")
set EM=EM-1
return U8e
endfunction
function U9e takes integer wve,string wee returns string
local string wxe
set ZM[EM]=wee
set EM=EM+1
set aM[wve]=aM[wve]+1
set wxe=Rre(nM[wve],aM[wve]-1,"when calling get in Utility, line 286")
set EM=EM-1
return wxe
endfunction
function woe takes integer wre,integer wie returns integer
set w4=dpv(wre,wie)
return w4
endfunction
function wae takes integer wne,string wVe returns nothing
set ZM[EM]=wVe
set EM=EM+1
if dm[wne]==0 then
call Cdv("Double free: object of type StringHLIterator","when calling error in Utility, line 271")
else
set qm[am]=wne
set am=am+1
set dm[wne]=0
endif
set EM=EM-1
endfunction
function wEe takes integer aqS returns nothing
endfunction
function wXe takes integer wOe,string wRe returns nothing
set ZM[EM]=wRe
set EM=EM+1
call wEe(wOe)
call wae(wOe,"when calling dealloc_StringHLIterator in Utility, line 271")
set EM=EM-1
endfunction
function wIe takes integer wAe,string wNe returns nothing
set ZM[EM]=wNe
set EM=EM+1
if dm[wAe]==0 then
if wAe==0 then
call Cdv("Nullpointer exception when calling StringHLIterator.StringHLIterator","when calling error in Utility, line 271")
else
call Cdv("Called StringHLIterator.StringHLIterator on invalid object.","when calling error in Utility, line 271")
endif
endif
call wXe(wAe,"when calling destroyStringHLIterator in Utility, line 271")
set EM=EM-1
endfunction
function wbe takes integer wBe,string wce returns nothing
set ZM[EM]=wce
set EM=EM+1
call wIe(wBe,"when calling dispatch_StringHLIterator_destroyStringHLIterator in Utility, line 289")
set EM=EM-1
endfunction
function wCe takes integer wde,string wDe returns boolean
local boolean wfe
set ZM[EM]=wDe
set EM=EM+1
set wfe=aM[wde]<Z2v(nM[wde],"when calling size in Utility, line 279")
set EM=EM-1
return wfe
endfunction
function wFe takes integer wge,integer wGe,string whe returns nothing
local integer wHe
local string wje
local integer wJe
local integer wke
set ZM[EM]=whe
set EM=EM+1
if Z2v(MX[wge],"when calling size in StringTable, line 81")>$FF then
set VX[wge]=true
set wJe=woe(CX[wge],0)
set CX[wge]=wJe
if Z2v(MX[wge],"when calling size in StringTable, line 84")>$FFFF then
set BX[wge]=true
set wke=woe(CX[wge],1)
set CX[wge]=wke
endif
endif
call uAe(wGe,CX[wge],"when calling writeByte in StringTable, line 88")
call USe(wGe,wge,Z2v(MX[wge],"when calling size in StringTable, line 90"),"when calling writeStringTableIndex in StringTable, line 90")
set wHe=U5e(MX[wge],"when calling iterator in StringTable, line 91")
loop
exitwhen not wCe(wHe,"when calling hasNext in StringTable, line 91")
set wje=U9e(wHe,"when calling next in StringTable, line 91")
call u6e(wge,wGe,wje,"when calling serializeString in StringTable, line 92")
endloop
call wbe(wHe,"when calling close in StringTable, line 91")
set EM=EM-1
endfunction
function wKe takes integer gKs,integer hKs returns nothing
endfunction
function wle takes integer wLe,integer wme returns boolean
return n9e(wLe,wme)
endfunction
function wMe takes string wpe returns integer
local integer wPe
set ZM[EM]=wpe
set EM=EM+1
if EY==0 then
if ZY<$8000 then
set ZY=ZY+1
set wPe=ZY
set UY[wPe]=$D17
else
call Cdv("Out of memory: Could not create LimitedExecuteCondition_executeWhile_PositionedUnitData_UnitData.","when calling error in UnitData, line 1404")
set wPe=0
endif
else
set EY=EY-1
set wPe=WY[EY]
set UY[wPe]=$D17
endif
set EM=EM-1
return wPe
endfunction
function wqe takes string wQe returns integer
local integer wse
set ZM[EM]=wQe
set EM=EM+1
if PY==0 then
if AY<$8000 then
set AY=AY+1
set wse=AY
set DY[wse]=$CF3
else
call Cdv("Out of memory: Could not create LimitedExecuteAction_executeWhile_PositionedUnitData_UnitData.","when calling error in UnitData, line 1404")
set wse=0
endif
else
set PY=PY-1
set wse=IY[PY]
set DY[wse]=$CF3
endif
set EM=EM-1
return wse
endfunction
function wSe takes integer wte,string wTe returns nothing
set ZM[EM]=wTe
set EM=EM+1
if ih[wte]==0 then
if wte==0 then
call Cdv("Nullpointer exception when calling HLIterator.close","when calling error in HashList, line 145")
else
call Cdv("Called HLIterator.close on invalid object.","when calling error in HashList, line 145")
endif
endif
call Jqv(wte,"when calling close in HashList, line 145")
set EM=EM-1
endfunction
function wue takes integer wUe,integer wwe returns integer
set r6=dpv(wUe,wwe)
return r6
endfunction
function wWe takes integer wye,string wYe returns nothing
set ZM[EM]=wYe
set EM=EM+1
if UY[wye]==0 then
call Cdv("Double free: object of type LimitedExecuteCondition","when calling error in Execute, line 104")
else
set WY[EY]=wye
set EY=EY+1
set UY[wye]=0
endif
set EM=EM-1
endfunction
function wze takes integer wZe,string w_e returns nothing
set ZM[EM]=w_e
set EM=EM+1
call wWe(wZe,"when calling dealloc_LimitedExecuteCondition in Execute, line 104")
set EM=EM-1
endfunction
function w0e takes integer w1e,string w2e returns nothing
set ZM[EM]=w2e
set EM=EM+1
if UY[w1e]==0 then
if w1e==0 then
call Cdv("Nullpointer exception when calling LimitedExecuteCondition.LimitedExecuteCondition","when calling error in Execute, line 104")
else
call Cdv("Called LimitedExecuteCondition.LimitedExecuteCondition on invalid object.","when calling error in Execute, line 104")
endif
endif
call wze(w1e,"when calling destroyLimitedExecuteCondition in Execute, line 104")
set EM=EM-1
endfunction
function w3e takes integer w4e,string w5e returns nothing
set ZM[EM]=w5e
set EM=EM+1
if DY[w4e]==0 then
call Cdv("Double free: object of type LimitedExecuteAction","when calling error in Execute, line 107")
else
set IY[PY]=w4e
set PY=PY+1
set DY[w4e]=0
endif
set EM=EM-1
endfunction
function w6e takes integer w7e,string w8e returns nothing
set ZM[EM]=w8e
set EM=EM+1
call w3e(w7e,"when calling dealloc_LimitedExecuteAction in Execute, line 107")
set EM=EM-1
endfunction
function w9e takes integer Wve,string Wee returns nothing
set ZM[EM]=Wee
set EM=EM+1
if DY[Wve]==0 then
if Wve==0 then
call Cdv("Nullpointer exception when calling LimitedExecuteAction.LimitedExecuteAction","when calling error in Execute, line 107")
else
call Cdv("Called LimitedExecuteAction.LimitedExecuteAction on invalid object.","when calling error in Execute, line 107")
endif
endif
call w6e(Wve,"when calling destroyLimitedExecuteAction in Execute, line 107")
set EM=EM-1
endfunction
function Wxe takes string Woe returns integer
local integer Wre
set ZM[EM]=Woe
set EM=EM+1
if CY==0 then
if VY<$8000 then
set VY=VY+1
set Wre=VY
set BY[Wre]=$852
else
call Cdv("Out of memory: Could not create ForForceCallback_execute_Execute.","when calling error in Execute, line 111")
set Wre=0
endif
else
set CY=CY-1
set Wre=XY[CY]
set BY[Wre]=$852
endif
set EM=EM-1
return Wre
endfunction
function Wie takes integer Wae,integer Wne,integer WVe,string WEe returns nothing
local integer WXe
set ZM[EM]=WEe
set EM=EM+1
set WXe=Wxe("when calling alloc_ForForceCallback_execute_Execute in Execute, line 111")
set BE[WXe]=Wne
set NE[WXe]=Wae
set ME[WXe]=WVe
call Fte(WXe,"when calling execute in Execute, line 111")
set EM=EM-1
endfunction
function WOe takes integer WRe,integer WIe,integer WAe,string WNe returns nothing
set ZM[EM]=WNe
set EM=EM+1
call Wie(WRe,WIe,WAe,"when calling executeWhileInternal in Execute, line 127")
call w0e(WIe,"when calling dispatch_LimitedExecuteCondition_destroyLimitedExecuteCondition in Execute, line 128")
call w9e(WAe,"when calling dispatch_LimitedExecuteAction_destroyLimitedExecuteAction in Execute, line 129")
set EM=EM-1
endfunction
function Wbe takes integer WBe,integer Wce,string WCe returns nothing
local integer Wde
local integer WDe
local integer Wfe
local integer WFe
local integer Wge
local integer WGe
set ZM[EM]=WCe
set EM=EM+1
if dgv(XC[WBe],"when calling size in UnitData, line 1388")>$FF then
set Wge=wue(LC[WBe],0)
set LC[WBe]=Wge
if dgv(XC[WBe],"when calling size in UnitData, line 1390")>$FFFF then
set WGe=wue(LC[WBe],1)
set LC[WBe]=WGe
endif
endif
call uAe(Wce,LC[WBe],"when calling writeByte in UnitData, line 1393")
if wle(LC[WBe],0)then
if wle(LC[WBe],1)then
call UPe(Wce,dgv(XC[WBe],"when calling size in UnitData, line 1397"),"when calling writeInt in UnitData, line 1397")
else
call uYe(Wce,dgv(XC[WBe],"when calling size in UnitData, line 1399"),"when calling writeShort in UnitData, line 1399")
endif
else
call uAe(Wce,dgv(XC[WBe],"when calling size in UnitData, line 1401"),"when calling writeByte in UnitData, line 1401")
endif
set Wde=jgv(XC[WBe],"when calling iterator in UnitData, line 1403")
set WDe=wMe("when calling alloc_LimitedExecuteCondition_executeWhile_PositionedUnitData_UnitData in UnitData, line 1404")
set CC[WDe]=Wde
set WFe=WDe
set Wfe=wqe("when calling alloc_LimitedExecuteAction_executeWhile_PositionedUnitData_UnitData in UnitData, line 1404")
set VC[Wfe]=Wde
set BC[Wfe]=Wce
call WOe('d',WFe,Wfe,"when calling executeWhile in UnitData, line 1404")
call wSe(Wde,"when calling close in UnitData, line 1406")
set EM=EM-1
endfunction
function Whe takes string WHe returns integer
local integer Wje
set ZM[EM]=WHe
set EM=EM+1
if CY==0 then
if VY<$8000 then
set VY=VY+1
set Wje=VY
set BY[Wje]=$860
else
call Cdv("Out of memory: Could not create ForForceCallback_execute_StringTable_LegacyStringTable.","when calling error in LegacyStringTable, line 33")
set Wje=0
endif
else
set CY=CY-1
set Wje=XY[CY]
set BY[Wje]=$860
endif
set EM=EM-1
return Wje
endfunction
function WJe takes integer lXs,integer Wke,string WKe,string Wle returns nothing
local integer WLe
local integer Wme
set ZM[EM]=Wle
set EM=EM+1
set WLe=GZv(WKe)
call uYe(Wke,GZv(WKe),"when calling writeShort in LegacyStringTable, line 32")
set Wme=Whe("when calling alloc_ForForceCallback_execute_StringTable_LegacyStringTable in LegacyStringTable, line 33")
set SI[Wme]=WLe
set cI[Wme]=Wke
set oI[Wme]=WKe
call Fte(Wme,"when calling execute in LegacyStringTable, line 33")
set EM=EM-1
endfunction
function WMe takes integer Wpe,integer WPe,string Wqe,string WQe returns nothing
set ZM[EM]=WQe
set EM=EM+1
if Gg[Wpe]==0 then
if Wpe==0 then
call Cdv("Nullpointer exception when calling StringTable.serializeString","when calling error in LegacyStringTable, line 30")
else
call Cdv("Called StringTable.serializeString on invalid object.","when calling error in LegacyStringTable, line 30")
endif
endif
call WJe(Wpe,WPe,Wqe,"when calling serializeString in LegacyStringTable, line 30")
set EM=EM-1
endfunction
function Wse takes integer WSe,integer Wte,string WTe returns nothing
local integer Wue
local string WUe
set ZM[EM]=WTe
set EM=EM+1
call uAe(Wte,sI[WSe],"when calling writeByte in LegacyStringTable, line 48")
call uYe(Wte,Z2v(iI[WSe],"when calling size in LegacyStringTable, line 49"),"when calling writeShort in LegacyStringTable, line 49")
set Wue=U5e(iI[WSe],"when calling iterator in LegacyStringTable, line 50")
loop
exitwhen not wCe(Wue,"when calling hasNext in LegacyStringTable, line 50")
set WUe=U9e(Wue,"when calling next in LegacyStringTable, line 50")
call WMe(WSe,Wte,WUe,"when calling serializeString in LegacyStringTable, line 51")
endloop
call wbe(Wue,"when calling close in LegacyStringTable, line 50")
set EM=EM-1
endfunction
function Wwe takes integer WWe,integer Wye,integer WYe,string Wze returns nothing
set ZM[EM]=Wze
set EM=EM+1
if qH[Wye]then
if aH[Wye]then
call UPe(WWe,WYe,"when calling writeInt in RawcodeTable, line 26")
else
call uYe(WWe,WYe,"when calling writeShort in RawcodeTable, line 28")
endif
else
call uAe(WWe,WYe,"when calling writeByte in RawcodeTable, line 30")
endif
set EM=EM-1
endfunction
function WZe takes integer W_e,integer W0e returns integer
set G1=dpv(W_e,W0e)
return G1
endfunction
function W1e takes integer W2e,integer W3e,string W4e returns nothing
local integer W5e
local integer W6e
local integer W7e
local integer W8e
set ZM[EM]=W4e
set EM=EM+1
if dgv(dH[W2e],"when calling size in RawcodeTable, line 62")>$FF then
set qH[W2e]=true
set W7e=WZe(eH[W2e],0)
set eH[W2e]=W7e
if dgv(dH[W2e],"when calling size in RawcodeTable, line 65")>$FFFF then
set aH[W2e]=true
set W8e=WZe(eH[W2e],1)
set eH[W2e]=W8e
endif
endif
call uAe(W3e,eH[W2e],"when calling writeByte in RawcodeTable, line 69")
call Wwe(W3e,W2e,dgv(dH[W2e],"when calling size in RawcodeTable, line 71"),"when calling writeRawcodeTableIndex in RawcodeTable, line 71")
set W5e=jdv(dH[W2e],"when calling iterator in RawcodeTable, line 72")
loop
exitwhen not Jgv(W5e,"when calling hasNext in RawcodeTable, line 72")
set W6e=jTv(W5e,"when calling next in RawcodeTable, line 72")
call UPe(W3e,W6e,"when calling writeInt in RawcodeTable, line 73")
endloop
call Jqv(W5e,"when calling close in RawcodeTable, line 72")
set EM=EM-1
endfunction
function W9e takes integer yve,integer yee,boolean yxe returns nothing
call ctv(XR,yve,yee,yxe)
endfunction
function yoe takes integer yre,integer yie,boolean yae,string yne returns nothing
set ZM[EM]=yne
set EM=EM+1
if ph[yre]==0 then
if yre==0 then
call Cdv("Nullpointer exception when calling Table.saveBoolean","when calling error in Table, line 54")
else
call Cdv("Called Table.saveBoolean on invalid object.","when calling error in Table, line 54")
endif
endif
call W9e(yre,yie,yae)
set EM=EM-1
endfunction
function yVe takes integer yEe,boolean yXe,string yOe returns nothing
set ZM[EM]=yOe
set EM=EM+1
call yoe(rU[yEe],SU[yEe],yXe,"when calling saveBoolean in HashData, line 35")
set SU[yEe]=SU[yEe]+1
set EM=EM-1
endfunction
function yRe takes boolean yIe returns integer
local integer yAe
if yIe then
set yAe=1
else
set yAe=0
endif
return yAe
endfunction
function yNe takes integer ybe,boolean yBe,string yce returns nothing
set ZM[EM]=yce
set EM=EM+1
call T4e(nQ[ybe],yRe(yBe),"when calling pushByte in Base64Data, line 37")
set EM=EM-1
endfunction
function yCe takes integer yde,boolean yDe,string yfe returns nothing
set ZM[EM]=yfe
set EM=EM+1
if jY[yde]==0 then
if yde==0 then
call Cdv("Nullpointer exception when calling DataWriter.writeBoolean","when calling error in DataInterfaces, line 48")
else
call Cdv("Called DataWriter.writeBoolean on invalid object.","when calling error in DataInterfaces, line 48")
endif
endif
if jY[yde]<=$6E1 then
call yNe(yde,yDe,"when calling writeBoolean in DataInterfaces, line 48")
else
call yVe(yde,yDe,"when calling writeBoolean in DataInterfaces, line 48")
endif
set EM=EM-1
endfunction
function yFe takes integer yge,boolean yGe,integer yhe,string yHe returns nothing
set ZM[EM]=yHe
set EM=EM+1
call yCe(yge,yGe,"when calling writeBoolean in CustomUnitTypes, line 19")
if not yGe then
call UPe(yge,yhe,"when calling writeInt in CustomUnitTypes, line 21")
endif
set EM=EM-1
endfunction
function yje takes integer yJe,integer yke,real yKe returns nothing
call Ake(XR,yJe,yke,yKe)
endfunction
function yle takes integer yLe,integer yme,real yMe,string ype returns nothing
set ZM[EM]=ype
set EM=EM+1
if ph[yLe]==0 then
if yLe==0 then
call Cdv("Nullpointer exception when calling Table.saveReal","when calling error in Table, line 48")
else
call Cdv("Called Table.saveReal on invalid object.","when calling error in Table, line 48")
endif
endif
call yje(yLe,yme,yMe)
set EM=EM-1
endfunction
function yPe takes integer yqe,real yQe,string yse returns nothing
set ZM[EM]=yse
set EM=EM+1
call yle(rU[yqe],tU[yqe],yQe,"when calling saveReal in HashData, line 31")
set tU[yqe]=tU[yqe]+1
set EM=EM-1
endfunction
function ySe takes integer yte,integer yTe,integer yue returns integer
local integer yUe
local integer ywe
if yte<=yTe then
set ywe=yTe
else
if yte>=yue then
set yUe=yue
else
set yUe=yte
endif
set ywe=yUe
endif
return ywe
endfunction
function yWe takes real yye returns real
local real yYe
if yye<.0 then
set yYe=-yye
else
set yYe=yye
endif
return yYe
endfunction
function yze takes integer yZe,real y_e,string y0e returns nothing
local integer y1e
local integer y2e
set ZM[EM]=y0e
set EM=EM+1
set y1e=c6v(y_e)
set y2e=0
if ModuloReal(y_e,1.)>.0001 then
set y2e=ySe(c6v(1./yWe(y_e-y1e)),0,$FFFF)
endif
call UJe(nQ[yZe],y1e,"when calling pushInt in Base64Data, line 33")
call uPe(nQ[yZe],y2e,"when calling pushShort in Base64Data, line 34")
set EM=EM-1
endfunction
function y3e takes integer y4e,real y5e,string y6e returns nothing
set ZM[EM]=y6e
set EM=EM+1
if jY[y4e]==0 then
if y4e==0 then
call Cdv("Nullpointer exception when calling DataWriter.writeReal","when calling error in DataInterfaces, line 45")
else
call Cdv("Called DataWriter.writeReal on invalid object.","when calling error in DataInterfaces, line 45")
endif
endif
if jY[y4e]<=$6E1 then
call yze(y4e,y5e,"when calling writeReal in DataInterfaces, line 45")
else
call yPe(y4e,y5e,"when calling writeReal in DataInterfaces, line 45")
endif
set EM=EM-1
endfunction
function y7e takes integer y8e,boolean y9e,real Yve,string Yee returns nothing
set ZM[EM]=Yee
set EM=EM+1
call yCe(y8e,y9e,"when calling writeBoolean in CustomUnitTypes, line 34")
if not y9e then
call y3e(y8e,Yve,"when calling writeReal in CustomUnitTypes, line 36")
endif
set EM=EM-1
endfunction
function Yxe takes integer Yoe,boolean Yre,integer Yie,boolean Yae,real Yne,boolean YVe,integer YEe,boolean YXe,integer YOe,string YRe returns nothing
set ZM[EM]=YRe
set EM=EM+1
call yFe(Yoe,Yre,Yie,"when calling writeOptInt in CustomUnitTypes, line 60")
call y7e(Yoe,Yae,Yne,"when calling writeOptReal in CustomUnitTypes, line 61")
call yFe(Yoe,YVe,YEe,"when calling writeOptInt in CustomUnitTypes, line 62")
call yFe(Yoe,YXe,YOe,"when calling writeOptInt in CustomUnitTypes, line 63")
set EM=EM-1
endfunction
function YIe takes integer YAe,integer YNe,string Ybe returns nothing
set ZM[EM]=Ybe
set EM=EM+1
call UPe(YNe,EW[YAe],"when calling writeInt in CustomUnitTypes, line 190")
call Yxe(YNe,ZW[YAe],UW[YAe],IW[YAe],PW[YAe],AW[YAe],DW[YAe],HW[YAe],JW[YAe],"when calling writeAttackData in CustomUnitTypes, line 191")
call Yxe(YNe,KW[YAe],LW[YAe],XW[YAe],CW[YAe],VW[YAe],BW[YAe],NW[YAe],MW[YAe],"when calling writeAttackData in CustomUnitTypes, line 192")
set EM=EM-1
endfunction
function YBe takes integer Yce,integer YCe,string Yde returns nothing
set ZM[EM]=Yde
set EM=EM+1
if Gg[Yce]==0 then
if Yce==0 then
call Cdv("Nullpointer exception when calling PositionedUnitData.serialize","when calling error in UnitData, line 1387")
else
call Cdv("Called PositionedUnitData.serialize on invalid object.","when calling error in UnitData, line 1387")
endif
endif
call Wbe(Yce,YCe,"when calling serialize in UnitData, line 1387")
set EM=EM-1
endfunction
function YDe takes string Yfe returns integer
local integer YFe
set ZM[EM]=Yfe
set EM=EM+1
if CY==0 then
if VY<$8000 then
set VY=VY+1
set YFe=VY
set BY[YFe]=$85B
else
call Cdv("Out of memory: Could not create ForForceCallback_execute_PositionedDestructableData_DestructableData.","when calling error in DestructableData, line 248")
set YFe=0
endif
else
set CY=CY-1
set YFe=XY[CY]
set BY[YFe]=$85B
endif
set EM=EM-1
return YFe
endfunction
function Yge takes integer YGe,integer Yhe,string YHe returns nothing
set ZM[EM]=YHe
set EM=EM+1
if Gg[YGe]==0 then
if YGe==0 then
call Cdv("Nullpointer exception when calling RawcodeTable.serialize","when calling error in RawcodeTable, line 61")
else
call Cdv("Called RawcodeTable.serialize on invalid object.","when calling error in RawcodeTable, line 61")
endif
endif
call W1e(YGe,Yhe,"when calling serialize in RawcodeTable, line 61")
set EM=EM-1
endfunction
function Yje takes integer YJe,integer Yke returns boolean
return n9e(YJe,Yke)
endfunction
function YKe takes integer Yle,integer YLe returns integer
set U3=dpv(Yle,YLe)
return U3
endfunction
function Yme takes integer YMe,integer Ype,string YPe returns nothing
local integer Yqe
local integer YQe
local integer Yse
local integer YSe
local integer Yte
set ZM[EM]=YPe
set EM=EM+1
if dgv(rE[YMe],"when calling size in DestructableData, line 231")>$FF then
set YSe=YKe(wE[YMe],0)
set wE[YMe]=YSe
if dgv(rE[YMe],"when calling size in DestructableData, line 233")>$FFFF then
set Yte=YKe(wE[YMe],1)
set wE[YMe]=Yte
endif
endif
call uAe(Ype,wE[YMe],"when calling writeByte in DestructableData, line 236")
call Yge(uE[YMe],Ype,"when calling serialize in DestructableData, line 238")
if Yje(wE[YMe],0)then
if Yje(wE[YMe],1)then
call UPe(Ype,dgv(rE[YMe],"when calling size in DestructableData, line 242"),"when calling writeInt in DestructableData, line 242")
else
call uYe(Ype,dgv(rE[YMe],"when calling size in DestructableData, line 244"),"when calling writeShort in DestructableData, line 244")
endif
else
call uAe(Ype,dgv(rE[YMe],"when calling size in DestructableData, line 246"),"when calling writeByte in DestructableData, line 246")
endif
set Yqe=jdv(rE[YMe],"when calling iterator in DestructableData, line 247")
loop
exitwhen not Jgv(Yqe,"when calling hasNext in DestructableData, line 247")
set YQe=jTv(Yqe,"when calling next in DestructableData, line 247")
set Yse=YDe("when calling alloc_ForForceCallback_execute_PositionedDestructableData_DestructableData in DestructableData, line 248")
set sE[Yse]=YQe
set tE[Yse]=Ype
call Fte(Yse,"when calling execute in DestructableData, line 248")
endloop
call Jqv(Yqe,"when calling close in DestructableData, line 247")
set EM=EM-1
endfunction
function YTe takes integer Yue,integer YUe,string Ywe returns nothing
set ZM[EM]=Ywe
set EM=EM+1
if Gg[Yue]==0 then
if Yue==0 then
call Cdv("Nullpointer exception when calling PositionedDestructableData.serialize","when calling error in DestructableData, line 230")
else
call Cdv("Called PositionedDestructableData.serialize on invalid object.","when calling error in DestructableData, line 230")
endif
endif
call Yme(Yue,YUe,"when calling serialize in DestructableData, line 230")
set EM=EM-1
endfunction
function YWe takes integer Yye,integer YYe returns boolean
return n9e(Yye,YYe)
endfunction
function Yze takes integer YZe,integer Y_e,string Y0e returns nothing
set ZM[EM]=Y0e
set EM=EM+1
if Gg[YZe]==0 then
if YZe==0 then
call Cdv("Nullpointer exception when calling StringTable.serialize","when calling error in StringTable, line 80")
else
call Cdv("Called StringTable.serialize on invalid object.","when calling error in StringTable, line 80")
endif
endif
call wFe(YZe,Y_e,"when calling serialize in StringTable, line 80")
set EM=EM-1
endfunction
function Y1e takes integer Y2e,integer Y3e returns boolean
return n9e(Y2e,Y3e)
endfunction
function Y4e takes integer Y5e,integer Y6e returns boolean
return n9e(Y5e,Y6e)
endfunction
function Y7e takes integer Y8e,real Y9e,real zve,string zee returns nothing
set ZM[EM]=zee
set EM=EM+1
call uYe(Y8e,DSv(Y9e)+$7FFF,"when calling writeShort in PointData, line 17")
call uYe(Y8e,DSv(zve)+$7FFF,"when calling writeShort in PointData, line 18")
set EM=EM-1
endfunction
function zxe takes integer zoe,integer zre,string zie returns nothing
local boolean zae
local integer zne
local integer zVe
set ZM[EM]=zie
set EM=EM+1
call uAe(zre,nC[zoe],"when calling writeByte in TerrainData, line 88")
call Y7e(zre,dC[zoe],fC[zoe],"when calling writePointData in TerrainData, line 90")
call Y7e(zre,RC[zoe],TC[zoe],"when calling writePointData in TerrainData, line 91")
if Y4e(nC[zoe],0)then
if Y4e(nC[zoe],1)then
call UPe(zre,dgv(YC[zoe],"when calling size in TerrainData, line 95"),"when calling writeInt in TerrainData, line 95")
else
call uYe(zre,dgv(YC[zoe],"when calling size in TerrainData, line 97"),"when calling writeShort in TerrainData, line 97")
endif
else
call uAe(zre,dgv(YC[zoe],"when calling size in TerrainData, line 99"),"when calling writeByte in TerrainData, line 99")
endif
set zae=Y4e(nC[zoe],2)
set zne=0
set zVe=dgv(YC[zoe],"when calling size in TerrainData, line 102")-1
loop
exitwhen zne>zVe
call Wwe(zre,aC[zoe],jqv(YC[zoe],zne,"when calling get in TerrainData, line 103"),"when calling writeRawcodeTableIndex in TerrainData, line 103")
if zae then
call uAe(zre,jqv(GC[zoe],zne,"when calling get in TerrainData, line 105"),"when calling writeByte in TerrainData, line 105")
endif
set zne=zne+1
endloop
set EM=EM-1
endfunction
function zEe takes integer zXe,integer zOe,string zRe returns nothing
set ZM[EM]=zRe
set EM=EM+1
if Qv[zXe]==0 then
if zXe==0 then
call Cdv("Nullpointer exception when calling SubRectTileData.serialize","when calling error in TerrainData, line 87")
else
call Cdv("Called SubRectTileData.serialize on invalid object.","when calling error in TerrainData, line 87")
endif
endif
call zxe(zXe,zOe,"when calling serialize in TerrainData, line 87")
set EM=EM-1
endfunction
function zIe takes integer zAe,integer zNe,string zbe returns nothing
local integer zBe
local integer zce
set ZM[EM]=zbe
set EM=EM+1
call uAe(zNe,IC[zAe],"when calling writeByte in TerrainData, line 146")
call Yge(PC[zAe],zNe,"when calling serialize in TerrainData, line 148")
if Y1e(IC[zAe],0)then
if Y1e(IC[zAe],1)then
call UPe(zNe,hye(AC[zAe],"when calling size in TerrainData, line 152"),"when calling writeInt in TerrainData, line 152")
else
call uYe(zNe,hye(AC[zAe],"when calling size in TerrainData, line 154"),"when calling writeShort in TerrainData, line 154")
endif
else
call uAe(zNe,hye(AC[zAe],"when calling size in TerrainData, line 156"),"when calling writeByte in TerrainData, line 156")
endif
set zBe=Xle(AC[zAe],"when calling iterator in TerrainData, line 158")
loop
exitwhen not Xie(zBe)
set zce=E3e(zBe)
call zEe(zce,zNe,"when calling serialize in TerrainData, line 159")
endloop
call Xpe(zBe,"when calling close in TerrainData, line 158")
set EM=EM-1
endfunction
function zCe takes integer zde,integer zDe,string zfe returns nothing
set ZM[EM]=zfe
set EM=EM+1
if Gg[zde]==0 then
if zde==0 then
call Cdv("Nullpointer exception when calling TileData.serialize","when calling error in TerrainData, line 145")
else
call Cdv("Called TileData.serialize on invalid object.","when calling error in TerrainData, line 145")
endif
endif
call zIe(zde,zDe,"when calling serialize in TerrainData, line 145")
set EM=EM-1
endfunction
function zFe takes integer zge,integer zGe returns boolean
return n9e(zge,zGe)
endfunction
function zhe takes integer zHe,integer zje,string zJe returns nothing
set ZM[EM]=zJe
set EM=EM+1
call uAe(zje,EC[zHe],"when calling writeByte in TerrainData, line 213")
if zFe(EC[zHe],0)then
call zCe(ZC[zHe],zje,"when calling serialize in TerrainData, line 216")
endif
set EM=EM-1
endfunction
function zke takes integer zKe,integer zle,string zLe returns nothing
set ZM[EM]=zLe
set EM=EM+1
if Gg[zKe]==0 then
if zKe==0 then
call Cdv("Nullpointer exception when calling TerrainData.serialize","when calling error in TerrainData, line 212")
else
call Cdv("Called TerrainData.serialize on invalid object.","when calling error in TerrainData, line 212")
endif
endif
call zhe(zKe,zle,"when calling serialize in TerrainData, line 212")
set EM=EM-1
endfunction
function zme takes integer zMe,integer zpe,string zPe returns nothing
set ZM[EM]=zPe
set EM=EM+1
call uAe(zpe,EH[zMe],"when calling writeByte in RegionData, line 54")
call y3e(zpe,AH[zMe],"when calling writeReal in RegionData, line 56")
call y3e(zpe,DH[zMe],"when calling writeReal in RegionData, line 57")
call y3e(zpe,HH[zMe],"when calling writeReal in RegionData, line 59")
call y3e(zpe,JH[zMe],"when calling writeReal in RegionData, line 60")
call Yze(KH[zMe],zpe,"when calling serialize in RegionData, line 62")
if YWe(EH[zMe],0)then
call zke(LH[zMe],zpe,"when calling serialize in RegionData, line 65")
endif
if YWe(EH[zMe],1)then
call YTe(XH[zMe],zpe,"when calling serialize in RegionData, line 67")
endif
if YWe(EH[zMe],2)then
call YBe(CH[zMe],zpe,"when calling serialize in RegionData, line 69")
endif
set EM=EM-1
endfunction
function zqe takes integer zQe,integer zse returns integer
set e9=dpv(zQe,zse)
return e9
endfunction
function zSe takes string zte returns integer
local integer zTe
set ZM[EM]=zte
set EM=EM+1
if CY==0 then
if VY<$8000 then
set VY=VY+1
set zTe=VY
set BY[zTe]=$864
else
call Cdv("Out of memory: Could not create ForForceCallback_execute_UnitData_UnitTypeData.","when calling error in UnitTypeData, line 1384")
set zTe=0
endif
else
set CY=CY-1
set zTe=XY[CY]
set BY[zTe]=$864
endif
set EM=EM-1
return zTe
endfunction
function zue takes integer geS,integer heS returns nothing
endfunction
function zUe takes integer zwe,integer zWe,string zye returns nothing
set ZM[EM]=zye
set EM=EM+1
if bm[zwe]==0 then
if zwe==0 then
call Cdv("Nullpointer exception when calling UnitTypeTable.serialize","when calling error in UnitTypeData, line 1283")
else
call Cdv("Called UnitTypeTable.serialize on invalid object.","when calling error in UnitTypeData, line 1283")
endif
endif
call zue(zwe,zWe)
set EM=EM-1
endfunction
function zYe takes integer zze,integer zZe returns boolean
return n9e(zze,zZe)
endfunction
function z_e takes integer z0e,integer z1e,string z2e returns nothing
local integer z3e
local integer z4e
local integer z5e
local integer z6e
local integer z7e
set ZM[EM]=z2e
set EM=EM+1
if dgv(MB[z0e],"when calling size in UnitTypeData, line 1367")>$FF then
set z6e=zqe(BB[z0e],0)
set BB[z0e]=z6e
if dgv(MB[z0e],"when calling size in UnitTypeData, line 1369")>$FFFF then
set z7e=zqe(BB[z0e],1)
set BB[z0e]=z7e
endif
endif
call uAe(z1e,BB[z0e],"when calling writeByte in UnitTypeData, line 1372")
call zUe(NB[z0e],z1e,"when calling serialize in UnitTypeData, line 1374")
if zYe(BB[z0e],0)then
if zYe(BB[z0e],1)then
call UPe(z1e,dgv(MB[z0e],"when calling size in UnitTypeData, line 1378"),"when calling writeInt in UnitTypeData, line 1378")
else
call uYe(z1e,dgv(MB[z0e],"when calling size in UnitTypeData, line 1380"),"when calling writeShort in UnitTypeData, line 1380")
endif
else
call uAe(z1e,dgv(MB[z0e],"when calling size in UnitTypeData, line 1382"),"when calling writeByte in UnitTypeData, line 1382")
endif
set z3e=jdv(MB[z0e],"when calling iterator in UnitTypeData, line 1383")
loop
exitwhen not Jgv(z3e,"when calling hasNext in UnitTypeData, line 1383")
set z4e=jTv(z3e,"when calling next in UnitTypeData, line 1383")
set z5e=zSe("when calling alloc_ForForceCallback_execute_UnitData_UnitTypeData in UnitTypeData, line 1384")
set wN[z5e]=z4e
set uN[z5e]=z1e
call Fte(z5e,"when calling execute in UnitTypeData, line 1384")
endloop
call Jqv(z3e,"when calling close in UnitTypeData, line 1383")
set EM=EM-1
endfunction
function z8e takes integer z9e,integer Zve,string Zee returns nothing
set ZM[EM]=Zee
set EM=EM+1
if Gg[z9e]==0 then
if z9e==0 then
call Cdv("Nullpointer exception when calling CustomUnitType.serialize","when calling error in CustomUnitTypes, line 189")
else
call Cdv("Called CustomUnitType.serialize on invalid object.","when calling error in CustomUnitTypes, line 189")
endif
endif
call YIe(z9e,Zve,"when calling serialize in CustomUnitTypes, line 189")
set EM=EM-1
endfunction
function Zxe takes integer Zoe,integer Zre,string Zie returns nothing
local integer Zae
local integer Zne
set ZM[EM]=Zie
set EM=EM+1
call UPe(Zre,Mq,"when calling writeInt in PlayerDefinedUnitTypes, line 30")
set Zae=0
set Zne=Mq-1
loop
exitwhen Zae>Zne
call z8e(tQe(Zoe,Zae,"when calling getSlot in PlayerDefinedUnitTypes, line 32"),Zre,"when calling serialize in PlayerDefinedUnitTypes, line 32")
set Zae=Zae+1
endloop
set EM=EM-1
endfunction
function ZVe takes integer ZEe,integer ZXe returns integer
set c6=dpv(ZEe,ZXe)
return c6
endfunction
function ZOe takes integer ZRe,integer ZIe returns boolean
return n9e(ZRe,ZIe)
endfunction
function ZAe takes integer ZNe,integer Zbe,real ZBe,real Zce,real ZCe,real Zde,real ZDe,string Zfe returns nothing
set ZM[EM]=Zfe
set EM=EM+1
call uAe(ZNe,Zbe,"when calling writeByte in UnitTypeData, line 230")
if ZOe(Zbe,0)then
if ZOe(Zbe,1)then
call uYe(ZNe,c6v(ZBe*10.),"when calling writeShort in UnitTypeData, line 234")
else
call y3e(ZNe,ZBe,"when calling writeReal in UnitTypeData, line 236")
endif
endif
if ZOe(Zbe,2)then
call uYe(ZNe,c6v(Zce*10000.),"when calling writeShort in UnitTypeData, line 238")
endif
if ZOe(Zbe,3)then
if ZOe(Zbe,4)then
call uAe(ZNe,c6v(ZCe*100.),"when calling writeByte in UnitTypeData, line 241")
elseif ZOe(Zbe,5)then
call uYe(ZNe,c6v(ZCe*1000.),"when calling writeShort in UnitTypeData, line 243")
else
call y3e(ZNe,ZCe,"when calling writeReal in UnitTypeData, line 245")
endif
endif
if ZOe(Zbe,6)then
call y3e(ZNe,Zde,"when calling writeReal in UnitTypeData, line 247")
endif
if ZOe(Zbe,7)then
call uYe(ZNe,c6v(ZDe*10000.),"when calling writeShort in UnitTypeData, line 249")
endif
set EM=EM-1
endfunction
function ZFe takes integer Zge,integer ZGe returns boolean
return n9e(Zge,ZGe)
endfunction
function Zhe takes integer ZHe,integer Zje returns boolean
return n9e(ZHe,Zje)
endfunction
function ZJe takes integer Zke,integer ZKe returns boolean
return n9e(Zke,ZKe)
endfunction
function Zle takes integer ZLe,integer Zme returns boolean
return n9e(ZLe,Zme)
endfunction
function ZMe takes integer Zpe,integer ZPe,integer Zqe,integer ZQe,integer Zse,integer ZSe,integer Zte,string ZTe returns nothing
set ZM[EM]=ZTe
set EM=EM+1
call uAe(Zpe,ZPe,"when calling writeByte in UnitTypeData, line 373")
if Zle(ZPe,7)then
call uAe(Zpe,Zqe,"when calling writeByte in UnitTypeData, line 375")
endif
call UPe(Zpe,ZQe,"when calling writeInt in UnitTypeData, line 377")
if Zle(ZPe,1)then
if Zle(ZPe,2)then
if ZJe(Zqe,0)then
call UPe(Zpe,Zse,"when calling writeInt in UnitTypeData, line 382")
else
call uYe(Zpe,Zse,"when calling writeShort in UnitTypeData, line 384")
endif
else
call uAe(Zpe,Zse,"when calling writeByte in UnitTypeData, line 386")
endif
endif
if Zle(ZPe,3)then
if Zle(ZPe,4)then
if ZJe(Zqe,1)then
call UPe(Zpe,ZSe,"when calling writeInt in UnitTypeData, line 390")
else
call uYe(Zpe,ZSe,"when calling writeShort in UnitTypeData, line 392")
endif
else
call uAe(Zpe,ZSe,"when calling writeByte in UnitTypeData, line 394")
endif
endif
if Zle(ZPe,5)then
if Zle(ZPe,6)then
if ZJe(Zqe,2)then
call UPe(Zpe,Zte,"when calling writeInt in UnitTypeData, line 398")
else
call uYe(Zpe,Zte,"when calling writeShort in UnitTypeData, line 400")
endif
else
call uAe(Zpe,Zte,"when calling writeByte in UnitTypeData, line 402")
endif
endif
set EM=EM-1
endfunction
function Zue takes integer ZUe,integer Zwe,integer ZWe,integer Zye,integer ZYe,integer Zze,integer ZZe,integer Z_e,integer Z0e,string Z1e returns nothing
set ZM[EM]=Z1e
set EM=EM+1
call uYe(ZUe,Zwe,"when calling writeShort in UnitTypeData, line 520")
if Zhe(Zwe,0)then
call ZMe(ZUe,ZWe,Zye,ZYe,Zze,ZZe,Z_e,"when calling writeHeroParameters in UnitTypeData, line 523")
endif
if Zhe(Zwe,1)then
call uAe(ZUe,Z0e,"when calling writeByte in UnitTypeData, line 526")
endif
set EM=EM-1
endfunction
function Z2e takes integer Z3e,integer Z4e returns boolean
return n9e(Z3e,Z4e)
endfunction
function Z5e takes integer Z6e,integer Z7e returns boolean
return n9e(Z6e,Z7e)
endfunction
function Z8e takes integer Z9e,integer vvx returns boolean
return n9e(Z9e,vvx)
endfunction
function vex takes integer vxx,integer vox,integer vrx,real vix,integer vax,integer vnx,string vVx returns nothing
set ZM[EM]=vVx
set EM=EM+1
call uAe(vxx,vox,"when calling writeByte in UnitTypeData, line 614")
if Z8e(vox,0)then
if Z8e(vox,1)then
call UPe(vxx,vrx,"when calling writeInt in UnitTypeData, line 618")
else
call uAe(vxx,vrx,"when calling writeByte in UnitTypeData, line 620")
endif
endif
if Z8e(vox,2)then
if Z8e(vox,3)then
call uAe(vxx,c6v(vix*100.),"when calling writeByte in UnitTypeData, line 623")
else
call y3e(vxx,vix,"when calling writeReal in UnitTypeData, line 625")
endif
endif
if Z8e(vox,4)then
if Z8e(vox,5)then
call UPe(vxx,vax,"when calling writeInt in UnitTypeData, line 628")
else
call uAe(vxx,vax,"when calling writeByte in UnitTypeData, line 630")
endif
endif
if Z8e(vox,6)then
if Z8e(vox,7)then
call UPe(vxx,vnx,"when calling writeInt in UnitTypeData, line 633")
else
call uAe(vxx,vnx,"when calling writeByte in UnitTypeData, line 635")
endif
endif
set EM=EM-1
endfunction
function vEx takes integer vXx,integer vOx,integer vRx,integer vIx,real vAx,integer vNx,integer vbx,integer vBx,integer vcx,real vCx,integer vdx,integer vDx,integer vfx,integer vFx,integer vgx,string vGx returns nothing
set ZM[EM]=vGx
set EM=EM+1
call uYe(vXx,vOx,"when calling writeShort in UnitTypeData, line 745")
if Z5e(vOx,0)then
call vex(vXx,vRx,vIx,vAx,vNx,vbx,"when calling writeAttackParameters in UnitTypeData, line 748")
endif
if Z5e(vOx,1)then
call vex(vXx,vBx,vcx,vCx,vdx,vDx,"when calling writeAttackParameters in UnitTypeData, line 750")
endif
if Z5e(vOx,2)then
if Z5e(vOx,3)then
call uAe(vXx,vfx,"when calling writeByte in UnitTypeData, line 753")
else
call UPe(vXx,vfx,"when calling writeInt in UnitTypeData, line 755")
endif
endif
if Z5e(vOx,4)then
if Z5e(vOx,5)then
call uYe(vXx,vFx,"when calling writeShort in UnitTypeData, line 758")
else
call UPe(vXx,vFx,"when calling writeInt in UnitTypeData, line 760")
endif
endif
if Z5e(vOx,6)then
if Z5e(vOx,7)then
call uYe(vXx,vgx,"when calling writeShort in UnitTypeData, line 763")
else
call UPe(vXx,vgx,"when calling writeInt in UnitTypeData, line 765")
endif
endif
set EM=EM-1
endfunction
function vhx takes integer vHx,integer vjx returns boolean
return n9e(vHx,vjx)
endfunction
function vJx takes integer vkx,integer vKx,string vlx returns nothing
set ZM[EM]=vlx
set EM=EM+1
call uAe(vKx,EB[vkx],"when calling writeByte in UnitTypeData, line 864")
call UPe(vKx,ZB[vkx],"when calling writeInt in UnitTypeData, line 865")
if not(vhx(EB[vkx],0)or vhx(EB[vkx],1)or vhx(EB[vkx],2)or vhx(EB[vkx],3))then
call uYe(vKx,UB[vkx],"when calling writeShort in UnitTypeData, line 868")
endif
if vhx(EB[vkx],4)then
if vhx(EB[vkx],6)then
call uAe(vKx,IB[vkx],"when calling writeByte in UnitTypeData, line 871")
else
call UPe(vKx,IB[vkx],"when calling writeInt in UnitTypeData, line 873")
endif
endif
if vhx(EB[vkx],5)then
if vhx(EB[vkx],6)then
call uAe(vKx,c6v(PB[vkx]*2.),"when calling writeByte in UnitTypeData, line 876")
else
call y3e(vKx,PB[vkx],"when calling writeReal in UnitTypeData, line 878")
endif
endif
set EM=EM-1
endfunction
function vLx takes integer vmx,integer vMx,string vpx returns nothing
set ZM[EM]=vpx
set EM=EM+1
if wm[vmx]==0 then
if vmx==0 then
call Cdv("Nullpointer exception when calling SingleAbilityData.serialize","when calling error in UnitTypeData, line 863")
else
call Cdv("Called SingleAbilityData.serialize on invalid object.","when calling error in UnitTypeData, line 863")
endif
endif
call vJx(vmx,vMx,"when calling serialize in UnitTypeData, line 863")
set EM=EM-1
endfunction
function vPx takes integer vqx,integer vQx returns boolean
return n9e(vqx,vQx)
endfunction
function vsx takes integer vSx,integer vtx,real vTx,integer vux,integer vUx,integer vwx,integer vWx,integer vyx,real vYx,string vzx returns nothing
set ZM[EM]=vzx
set EM=EM+1
call uAe(vSx,vtx,"when calling writeByte in UnitTypeData, line 98")
if vPx(vtx,0)then
if vPx(vtx,1)then
call uAe(vSx,c6v(vTx),"when calling writeByte in UnitTypeData, line 102")
elseif vPx(vtx,2)then
call uYe(vSx,c6v(vTx*10.),"when calling writeShort in UnitTypeData, line 104")
else
call y3e(vSx,vTx,"when calling writeReal in UnitTypeData, line 106")
endif
endif
if vPx(vtx,3)then
call uAe(vSx,vux,"when calling writeByte in UnitTypeData, line 108")
endif
if vPx(vtx,4)then
call uAe(vSx,vUx,"when calling writeByte in UnitTypeData, line 110")
call uAe(vSx,vwx,"when calling writeByte in UnitTypeData, line 111")
call uAe(vSx,vWx,"when calling writeByte in UnitTypeData, line 112")
call uAe(vSx,vyx,"when calling writeByte in UnitTypeData, line 113")
endif
if vPx(vtx,5)then
if vPx(vtx,6)then
call uAe(vSx,c6v(vYx*100.),"when calling writeByte in UnitTypeData, line 116")
elseif vPx(vtx,7)then
call uYe(vSx,c6v(vYx*1000.)+$7FFF,"when calling writeShort in UnitTypeData, line 118")
else
call y3e(vSx,vYx,"when calling writeReal in UnitTypeData, line 120")
endif
endif
set EM=EM-1
endfunction
function vZx takes integer v_x,integer v0x,string v1x returns nothing
local integer v2x
local integer v3x
local integer v4x
local integer v5x
set ZM[EM]=v1x
set EM=EM+1
call uAe(v0x,dN[v_x],"when calling writeByte in UnitTypeData, line 1169")
if Z2e(dN[v_x],7)then
call uAe(v0x,fN[v_x],"when calling writeByte in UnitTypeData, line 1171")
endif
call UPe(v0x,RN[v_x],"when calling writeInt in UnitTypeData, line 1172")
if Z2e(dN[v_x],2)then
call USe(v0x,nN[v_x],TN[v_x],"when calling writeStringTableIndex in UnitTypeData, line 1175")
endif
if Z2e(dN[v_x],3)then
call vsx(v0x,YN[v_x],GN[v_x],gN[v_x],hN[v_x],FN[v_x],kN[v_x],jN[v_x],xN[v_x],"when calling writeArtParameters in UnitTypeData, line 1178")
endif
if Z2e(dN[v_x],4)then
call ZAe(v0x,vN[v_x],mN[v_x],QN[v_x],WN[v_x],EN[v_x],ZN[v_x],"when calling writeAnimationParameters in UnitTypeData, line 1180")
endif
if Z2e(dN[v_x],5)then
call Zue(v0x,UN[v_x],IN[v_x],PN[v_x],AN[v_x],DN[v_x],HN[v_x],JN[v_x],KN[v_x],"when calling writeGeneralStats in UnitTypeData, line 1183")
endif
if Z2e(dN[v_x],6)then
call vEx(v0x,LN[v_x],XN[v_x],CN[v_x],VN[v_x],BN[v_x],NN[v_x],MN[v_x],wM[v_x],uM[v_x],rM[v_x],sM[v_x],tM[v_x],iM[v_x],SM[v_x],"when calling writeStats in UnitTypeData, line 1185")
endif
if Zhe(UN[v_x],5)then
call uAe(v0x,hye(cM[v_x],"when calling size in UnitTypeData, line 1188"),"when calling writeByte in UnitTypeData, line 1188")
set v2x=Xle(cM[v_x],"when calling iterator in UnitTypeData, line 1189")
loop
exitwhen not Xie(v2x)
set v3x=E3e(v2x)
call UPe(v0x,v3x,"when calling writeInt in UnitTypeData, line 1190")
endloop
call Xpe(v2x,"when calling close in UnitTypeData, line 1189")
endif
if Zhe(UN[v_x],6)then
call uAe(v0x,hye(oM[v_x],"when calling size in UnitTypeData, line 1192"),"when calling writeByte in UnitTypeData, line 1192")
set v4x=Xle(oM[v_x],"when calling iterator in UnitTypeData, line 1193")
loop
exitwhen not Xie(v4x)
set v5x=E3e(v4x)
call vLx(v5x,v0x,"when calling serialize in UnitTypeData, line 1194")
endloop
call Xpe(v4x,"when calling close in UnitTypeData, line 1193")
endif
if ZFe(fN[v_x],1)then
call uAe(v0x,OM[v_x],"when calling writeByte in UnitTypeData, line 1197")
endif
if ZFe(fN[v_x],2)then
call uAe(v0x,lM[v_x],"when calling writeByte in UnitTypeData, line 1199")
endif
if ZFe(fN[v_x],3)then
endif
set EM=EM-1
endfunction
function v6x takes integer v7x,integer v8x,string v9x returns nothing
set ZM[EM]=v9x
set EM=EM+1
if lm[v7x]==0 then
if v7x==0 then
call Cdv("Nullpointer exception when calling UnitTypeData.serialize","when calling error in UnitTypeData, line 1168")
else
call Cdv("Called UnitTypeData.serialize on invalid object.","when calling error in UnitTypeData, line 1168")
endif
endif
call vZx(v7x,v8x,"when calling serialize in UnitTypeData, line 1168")
set EM=EM-1
endfunction
function evx takes integer eex,integer exx,integer eox,string erx returns nothing
set ZM[EM]=erx
set EM=EM+1
if vB[exx]then
if mB[exx]then
call UPe(eex,eox,"when calling writeInt in UnitTypeDataTable, line 30")
else
call uYe(eex,eox,"when calling writeShort in UnitTypeDataTable, line 32")
endif
else
call uAe(eex,eox,"when calling writeByte in UnitTypeDataTable, line 34")
endif
set EM=EM-1
endfunction
function eix takes integer eax,integer enx,string eVx returns nothing
local integer eEx
local integer eXx
local integer eOx
local integer eRx
set ZM[EM]=eVx
set EM=EM+1
if dgv(kB[eax],"when calling size in UnitTypeDataTable, line 96")>$FF then
set vB[eax]=true
set eOx=ZVe(xB[eax],0)
set xB[eax]=eOx
if dgv(kB[eax],"when calling size in UnitTypeDataTable, line 99")>$FFFF then
set mB[eax]=true
set eRx=ZVe(xB[eax],1)
set xB[eax]=eRx
endif
endif
call uAe(enx,xB[eax],"when calling writeByte in UnitTypeDataTable, line 103")
call evx(enx,eax,dgv(kB[eax],"when calling size in UnitTypeDataTable, line 105"),"when calling writeUnitTypeDataTableIndex in UnitTypeDataTable, line 105")
set eEx=jdv(kB[eax],"when calling iterator in UnitTypeDataTable, line 106")
loop
exitwhen not Jgv(eEx,"when calling hasNext in UnitTypeDataTable, line 106")
set eXx=jTv(eEx,"when calling next in UnitTypeDataTable, line 106")
call v6x(eXx,enx,"when calling serialize in UnitTypeDataTable, line 107")
endloop
call Jqv(eEx,"when calling close in UnitTypeDataTable, line 106")
set EM=EM-1
endfunction
function eIx takes integer eAx,integer eNx,string ebx returns nothing
set ZM[EM]=ebx
set EM=EM+1
if Gg[eAx]==0 then
if eAx==0 then
call Cdv("Nullpointer exception when calling DataSerializable.serialize","when calling error in DataInterfaces, line 25")
else
call Cdv("Called DataSerializable.serialize on invalid object.","when calling error in DataInterfaces, line 25")
endif
endif
if Gg[eAx]<=$6D9 then
if Gg[eAx]<=$6D6 then
if Gg[eAx]<=$6D4 then
if Gg[eAx]<=$6D2 then
call YIe(eAx,eNx,"when calling serialize in DataInterfaces, line 25")
else
call wKe(eAx,eNx)
endif
elseif Gg[eAx]<=$6D5 then
call Zxe(eAx,eNx,"when calling serialize in DataInterfaces, line 25")
else
call zme(eAx,eNx,"when calling serialize in DataInterfaces, line 25")
endif
elseif Gg[eAx]<=$6D8 then
if Gg[eAx]<=$6D7 then
call Yme(eAx,eNx,"when calling serialize in DataInterfaces, line 25")
else
call Wbe(eAx,eNx,"when calling serialize in DataInterfaces, line 25")
endif
else
call W1e(eAx,eNx,"when calling serialize in DataInterfaces, line 25")
endif
elseif Gg[eAx]<=$6DC then
if Gg[eAx]<=$6DB then
if Gg[eAx]<=$6DA then
call Wse(eAx,eNx,"when calling serialize in DataInterfaces, line 25")
else
call wFe(eAx,eNx,"when calling serialize in DataInterfaces, line 25")
endif
else
call zhe(eAx,eNx,"when calling serialize in DataInterfaces, line 25")
endif
elseif Gg[eAx]<=$6DE then
if Gg[eAx]<=$6DD then
call zIe(eAx,eNx,"when calling serialize in DataInterfaces, line 25")
else
call z_e(eAx,eNx,"when calling serialize in DataInterfaces, line 25")
endif
else
call eix(eAx,eNx,"when calling serialize in DataInterfaces, line 25")
endif
set EM=EM-1
endfunction
function eBx takes integer ecx,integer eCx,string edx returns nothing
set ZM[EM]=edx
set EM=EM+1
call eIx(eCx,ecx,"when calling serialize in Base64Data, line 46")
set EM=EM-1
endfunction
function eDx takes integer efx,integer eFx,string egx returns nothing
set ZM[EM]=egx
set EM=EM+1
call eIx(eFx,efx,"when calling serialize in HashData, line 43")
set EM=EM-1
endfunction
function eGx takes integer ehx,integer eHx,string ejx returns nothing
set ZM[EM]=ejx
set EM=EM+1
if jY[ehx]==0 then
if ehx==0 then
call Cdv("Nullpointer exception when calling DataWriter.writeSerializable","when calling error in DataInterfaces, line 54")
else
call Cdv("Called DataWriter.writeSerializable on invalid object.","when calling error in DataInterfaces, line 54")
endif
endif
if jY[ehx]<=$6E1 then
call eBx(ehx,eHx,"when calling writeSerializable in DataInterfaces, line 54")
else
call eDx(ehx,eHx,"when calling writeSerializable in DataInterfaces, line 54")
endif
set EM=EM-1
endfunction
function eJx takes integer ekx,string eKx returns integer
local integer elx
local integer eLx
local integer emx
set ZM[EM]=eKx
set EM=EM+1
set elx=0
if jQ[ekx]!="" then
set elx=elx+Ccv(jQ[ekx])
endif
set eLx=Xle(FQ[ekx],"when calling iterator in BigString, line 216")
loop
exitwhen not Xie(eLx)
set emx=E3e(eLx)
set elx=elx+Ccv(mQ[emx])
endloop
call Xpe(eLx,"when calling close in BigString, line 216")
if kQ[ekx]!="" then
set elx=elx+Ccv(kQ[ekx])
endif
set EM=EM-1
return elx
endfunction
function eMx takes integer epx,string ePx returns integer
local integer eqx
set ZM[EM]=ePx
set EM=EM+1
if uG[epx]==0 then
if epx==0 then
call Cdv("Nullpointer exception when calling BigString.checksum","when calling error in BigString, line 210")
else
call Cdv("Called BigString.checksum on invalid object.","when calling error in BigString, line 210")
endif
endif
set eqx=eJx(epx,"when calling checksum in BigString, line 210")
set EM=EM-1
return eqx
endfunction
function eQx takes string esx returns nothing
call Preload(Jq)
call PreloadGenEnd(esx)
endfunction
function eSx takes integer etx,integer eTx returns string
local integer eux=etx
local string eUx=""
local integer ewx=1
local integer eWx=eTx
loop
exitwhen ewx>eWx
set eUx=Qp[ModuloInteger(eux,16)]+eUx
set eux=eux/16
set ewx=ewx+1
endloop
return eUx
endfunction
function eyx takes string eYx,string ezx returns nothing
local string eZx
set ZM[EM]=ezx
set EM=EM+1
if GZv(eYx)>Kq then
call Cdv("exceeded max packet length","when calling error in PacketIO, line 94")
endif
if Xq>Cq then
call Cdv("exceeded max packets per file","when calling error in PacketIO, line 97")
endif
set eZx=eSx(Xq,4)
call Preload(Aq+eYx+Dq+eZx+Hq)
set Xq=Xq+1
set EM=EM-1
endfunction
function e_x takes integer e0x,string e1x returns nothing
set ZM[EM]=e1x
set EM=EM+1
if xk[e0x]==0 then
call Cdv("Double free: object of type PersistableSaveCallback","when calling error in PersistableData, line 47")
else
set Fk[kk]=e0x
set kk=kk+1
set xk[e0x]=0
endif
set EM=EM-1
endfunction
function e2x takes integer e3x,string e4x returns nothing
set ZM[EM]=e4x
set EM=EM+1
call e_x(e3x,"when calling dealloc_PersistableSaveCallback in PersistableData, line 47")
set EM=EM-1
endfunction
function e5x takes integer e6x,string e7x returns nothing
set ZM[EM]=e7x
set EM=EM+1
if xk[e6x]==0 then
if e6x==0 then
call Cdv("Nullpointer exception when calling PersistableSaveCallback.PersistableSaveCallback","when calling error in PersistableData, line 47")
else
call Cdv("Called PersistableSaveCallback.PersistableSaveCallback on invalid object.","when calling error in PersistableData, line 47")
endif
endif
call e2x(e6x,"when calling destroyPersistableSaveCallback in PersistableData, line 47")
set EM=EM-1
endfunction
function e8x takes integer Grt returns nothing
endfunction
function e9x takes integer xvx,string xex returns nothing
set ZM[EM]=xex
set EM=EM+1
if Gg[xvx]==0 then
if xvx==0 then
call Cdv("Nullpointer exception when calling Persistable.onSaved","when calling error in PersistableData, line 67")
else
call Cdv("Called Persistable.onSaved on invalid object.","when calling error in PersistableData, line 67")
endif
endif
call e8x(xvx)
set EM=EM-1
endfunction
function xxx takes integer xox,string xrx returns nothing
set ZM[EM]=xrx
set EM=EM+1
if Gg[xox]==0 then
call Cdv("Double free: object of type RegionData","when calling error in RegionData, line 27")
else
set Rg[Tg]=xox
set Tg=Tg+1
set Gg[xox]=0
endif
set EM=EM-1
endfunction
function xix takes integer xax,string xnx returns nothing
set ZM[EM]=xnx
set EM=EM+1
if Dv[xax]==0 then
call Cdv("Double free: object of type SinglePositionedUnitData","when calling error in UnitData, line 1334")
else
set Iv[Pv]=xax
set Pv=Pv+1
set Dv[xax]=0
endif
set EM=EM-1
endfunction
function xVx takes integer xEx,string xXx returns nothing
set ZM[EM]=xXx
set EM=EM+1
call XQe(xEx,"when calling SingleUnitData_onDestroy in UnitData, line 1334")
set EM=EM-1
endfunction
function xOx takes integer xRx,string xIx returns nothing
set ZM[EM]=xIx
set EM=EM+1
call xVx(xRx,"when calling SinglePositionedUnitData_onDestroy in UnitData, line 1334")
call xix(xRx,"when calling dealloc_SinglePositionedUnitData in UnitData, line 1334")
set EM=EM-1
endfunction
function xAx takes integer xNx,string xbx returns nothing
set ZM[EM]=xbx
set EM=EM+1
if Dv[xNx]==0 then
if xNx==0 then
call Cdv("Nullpointer exception when calling SinglePositionedUnitData.SinglePositionedUnitData","when calling error in UnitData, line 1334")
else
call Cdv("Called SinglePositionedUnitData.SinglePositionedUnitData on invalid object.","when calling error in UnitData, line 1334")
endif
endif
call xOx(xNx,"when calling destroySinglePositionedUnitData in UnitData, line 1334")
set EM=EM-1
endfunction
function xBx takes integer xcx,string xCx returns nothing
local integer xdx
local integer xDx
set ZM[EM]=xCx
set EM=EM+1
set xdx=jdv(XC[xcx],"when calling iterator in UnitData, line 1447")
loop
exitwhen not Jgv(xdx,"when calling hasNext in UnitData, line 1447")
set xDx=jTv(xdx,"when calling next in UnitData, line 1447")
call xAx(xDx,"when calling dispatch_SinglePositionedUnitData_destroySinglePositionedUnitData in UnitData, line 1448")
endloop
call Jqv(xdx,"when calling close in UnitData, line 1447")
call JEv(XC[xcx],"when calling dispatch_HashList_destroyHashList in UnitData, line 1449")
set EM=EM-1
endfunction
function xfx takes integer xFx,string xgx returns nothing
set ZM[EM]=xgx
set EM=EM+1
if Gg[xFx]==0 then
call Cdv("Double free: object of type PositionedUnitData","when calling error in UnitData, line 1376")
else
set Rg[Tg]=xFx
set Tg=Tg+1
set Gg[xFx]=0
endif
set EM=EM-1
endfunction
function xGx takes integer xhx,string xHx returns nothing
set ZM[EM]=xHx
set EM=EM+1
call xBx(xhx,"when calling PositionedUnitData_onDestroy in UnitData, line 1446")
call xfx(xhx,"when calling dealloc_PositionedUnitData in UnitData, line 1446")
set EM=EM-1
endfunction
function xjx takes integer xJx,string xkx returns nothing
set ZM[EM]=xkx
set EM=EM+1
if Gg[xJx]==0 then
if xJx==0 then
call Cdv("Nullpointer exception when calling PositionedUnitData.PositionedUnitData","when calling error in UnitData, line 1376")
else
call Cdv("Called PositionedUnitData.PositionedUnitData on invalid object.","when calling error in UnitData, line 1376")
endif
endif
call xGx(xJx,"when calling destroyPositionedUnitData in UnitData, line 1376")
set EM=EM-1
endfunction
function xKx takes integer xlx,string xLx returns nothing
set ZM[EM]=xLx
set EM=EM+1
if ph[xlx]==0 then
call Cdv("Double free: object of type HashMap","when calling error in HashMap, line 8")
else
set lh[bh]=xlx
set bh=bh+1
set ph[xlx]=0
endif
set EM=EM-1
endfunction
function xmx takes integer xMx,string xpx returns nothing
set ZM[EM]=xpx
set EM=EM+1
call lkv(xMx,"when calling HashMap_onDestroy in HashMap, line 7")
call xKx(xMx,"when calling dealloc_HashMap in HashMap, line 7")
set EM=EM-1
endfunction
function xPx takes integer xqx,string xQx returns nothing
set ZM[EM]=xQx
set EM=EM+1
if ph[xqx]==0 then
if xqx==0 then
call Cdv("Nullpointer exception when calling HashMap.HashMap","when calling error in HashMap, line 8")
else
call Cdv("Called HashMap.HashMap on invalid object.","when calling error in HashMap, line 8")
endif
endif
if ph[xqx]<=4898 then
call xmx(xqx,"when calling destroyHashMap in HashMap, line 8")
else
call lpv(xqx,"when calling destroyIterableMap in HashMap, line 8")
endif
set EM=EM-1
endfunction
function xsx takes integer xSx,string xtx returns nothing
set ZM[EM]=xtx
set EM=EM+1
call xPx(nH[xSx],"when calling dispatch_HashMap_destroyHashMap in RawcodeTable, line 86")
call JEv(dH[xSx],"when calling dispatch_HashList_destroyHashList in RawcodeTable, line 87")
set EM=EM-1
endfunction
function xTx takes integer xux,string xUx returns nothing
set ZM[EM]=xUx
set EM=EM+1
if Gg[xux]==0 then
call Cdv("Double free: object of type RawcodeTable","when calling error in RawcodeTable, line 41")
else
set Rg[Tg]=xux
set Tg=Tg+1
set Gg[xux]=0
endif
set EM=EM-1
endfunction
function xwx takes integer xWx,string xyx returns nothing
set ZM[EM]=xyx
set EM=EM+1
call xsx(xWx,"when calling RawcodeTable_onDestroy in RawcodeTable, line 85")
call xTx(xWx,"when calling dealloc_RawcodeTable in RawcodeTable, line 85")
set EM=EM-1
endfunction
function xYx takes integer xzx,string xZx returns nothing
set ZM[EM]=xZx
set EM=EM+1
if Gg[xzx]==0 then
if xzx==0 then
call Cdv("Nullpointer exception when calling RawcodeTable.RawcodeTable","when calling error in RawcodeTable, line 41")
else
call Cdv("Called RawcodeTable.RawcodeTable on invalid object.","when calling error in RawcodeTable, line 41")
endif
endif
call xwx(xzx,"when calling destroyRawcodeTable in RawcodeTable, line 41")
set EM=EM-1
endfunction
function x_x takes integer x0x,string x1x returns nothing
set ZM[EM]=x1x
set EM=EM+1
if mg[x0x]==0 then
call Cdv("Double free: object of type SingleDestructableData","when calling error in DestructableData, line 54")
else
set jg[xg]=x0x
set xg=xg+1
set mg[x0x]=0
endif
set EM=EM-1
endfunction
function x2x takes integer Whs returns nothing
endfunction
function x3x takes integer x4x,string x5x returns nothing
set ZM[EM]=x5x
set EM=EM+1
call x2x(x4x)
call x_x(x4x,"when calling dealloc_SingleDestructableData in DestructableData, line 54")
set EM=EM-1
endfunction
function x6x takes integer x7x,string x8x returns nothing
set ZM[EM]=x8x
set EM=EM+1
if mg[x7x]==0 then
if x7x==0 then
call Cdv("Nullpointer exception when calling SingleDestructableData.SingleDestructableData","when calling error in DestructableData, line 54")
else
call Cdv("Called SingleDestructableData.SingleDestructableData on invalid object.","when calling error in DestructableData, line 54")
endif
endif
call x3x(x7x,"when calling destroySingleDestructableData in DestructableData, line 54")
set EM=EM-1
endfunction
function x9x takes integer ovx,string oex returns nothing
local integer oxx
local integer oox
set ZM[EM]=oex
set EM=EM+1
set oxx=jdv(rE[ovx],"when calling iterator in DestructableData, line 290")
loop
exitwhen not Jgv(oxx,"when calling hasNext in DestructableData, line 290")
set oox=jTv(oxx,"when calling next in DestructableData, line 290")
call x6x(oox,"when calling dispatch_SingleDestructableData_destroySingleDestructableData in DestructableData, line 291")
endloop
call Jqv(oxx,"when calling close in DestructableData, line 290")
call JEv(rE[ovx],"when calling dispatch_HashList_destroyHashList in DestructableData, line 292")
call xYx(uE[ovx],"when calling dispatch_RawcodeTable_destroyRawcodeTable in DestructableData, line 293")
set EM=EM-1
endfunction
function orx takes integer oix,string oax returns nothing
set ZM[EM]=oax
set EM=EM+1
if Gg[oix]==0 then
call Cdv("Double free: object of type PositionedDestructableData","when calling error in DestructableData, line 223")
else
set Rg[Tg]=oix
set Tg=Tg+1
set Gg[oix]=0
endif
set EM=EM-1
endfunction
function onx takes integer oVx,string oEx returns nothing
set ZM[EM]=oEx
set EM=EM+1
call x9x(oVx,"when calling PositionedDestructableData_onDestroy in DestructableData, line 289")
call orx(oVx,"when calling dealloc_PositionedDestructableData in DestructableData, line 289")
set EM=EM-1
endfunction
function oXx takes integer oOx,string oRx returns nothing
set ZM[EM]=oRx
set EM=EM+1
if Gg[oOx]==0 then
if oOx==0 then
call Cdv("Nullpointer exception when calling PositionedDestructableData.PositionedDestructableData","when calling error in DestructableData, line 223")
else
call Cdv("Called PositionedDestructableData.PositionedDestructableData on invalid object.","when calling error in DestructableData, line 223")
endif
endif
call onx(oOx,"when calling destroyPositionedDestructableData in DestructableData, line 223")
set EM=EM-1
endfunction
function oIx takes integer oAx,string oNx returns nothing
set ZM[EM]=oNx
set EM=EM+1
if Gg[oAx]==0 then
call Cdv("Double free: object of type TileData","when calling error in TerrainData, line 138")
else
set Rg[Tg]=oAx
set Tg=Tg+1
set Gg[oAx]=0
endif
set EM=EM-1
endfunction
function obx takes integer oBx,string ocx returns nothing
set ZM[EM]=ocx
set EM=EM+1
call JEv(GC[oBx],"when calling dispatch_HashList_destroyHashList in TerrainData, line 41")
call JEv(YC[oBx],"when calling dispatch_HashList_destroyHashList in TerrainData, line 42")
set EM=EM-1
endfunction
function oCx takes integer odx,string oDx returns nothing
set ZM[EM]=oDx
set EM=EM+1
if Qv[odx]==0 then
call Cdv("Double free: object of type SubRectTileData","when calling error in TerrainData, line 28")
else
set xv[vv]=odx
set vv=vv+1
set Qv[odx]=0
endif
set EM=EM-1
endfunction
function ofx takes integer oFx,string ogx returns nothing
set ZM[EM]=ogx
set EM=EM+1
call obx(oFx,"when calling SubRectTileData_onDestroy in TerrainData, line 40")
call oCx(oFx,"when calling dealloc_SubRectTileData in TerrainData, line 40")
set EM=EM-1
endfunction
function oGx takes integer ohx,string oHx returns nothing
set ZM[EM]=oHx
set EM=EM+1
if Qv[ohx]==0 then
if ohx==0 then
call Cdv("Nullpointer exception when calling SubRectTileData.SubRectTileData","when calling error in TerrainData, line 28")
else
call Cdv("Called SubRectTileData.SubRectTileData on invalid object.","when calling error in TerrainData, line 28")
endif
endif
call ofx(ohx,"when calling destroySubRectTileData in TerrainData, line 28")
set EM=EM-1
endfunction
function ojx takes integer oJx,string okx returns nothing
local integer oKx
local integer olx
set ZM[EM]=okx
set EM=EM+1
set oKx=Xle(AC[oJx],"when calling iterator in TerrainData, line 192")
loop
exitwhen not Xie(oKx)
set olx=E3e(oKx)
call oGx(olx,"when calling dispatch_SubRectTileData_destroySubRectTileData in TerrainData, line 193")
endloop
call Xpe(oKx,"when calling close in TerrainData, line 192")
call Hcv(AC[oJx],"when calling dispatch_LinkedList_destroyLinkedList in TerrainData, line 194")
call xYx(PC[oJx],"when calling dispatch_RawcodeTable_destroyRawcodeTable in TerrainData, line 195")
set EM=EM-1
endfunction
function oLx takes integer omx,string oMx returns nothing
set ZM[EM]=oMx
set EM=EM+1
call ojx(omx,"when calling TileData_onDestroy in TerrainData, line 191")
call oIx(omx,"when calling dealloc_TileData in TerrainData, line 191")
set EM=EM-1
endfunction
function opx takes integer oPx,string oqx returns nothing
set ZM[EM]=oqx
set EM=EM+1
if Gg[oPx]==0 then
if oPx==0 then
call Cdv("Nullpointer exception when calling TileData.TileData","when calling error in TerrainData, line 138")
else
call Cdv("Called TileData.TileData on invalid object.","when calling error in TerrainData, line 138")
endif
endif
call oLx(oPx,"when calling destroyTileData in TerrainData, line 138")
set EM=EM-1
endfunction
function oQx takes integer osx,string oSx returns nothing
set ZM[EM]=oSx
set EM=EM+1
call opx(ZC[osx],"when calling dispatch_TileData_destroyTileData in TerrainData, line 237")
set EM=EM-1
endfunction
function otx takes integer oTx,string oux returns nothing
set ZM[EM]=oux
set EM=EM+1
if Gg[oTx]==0 then
call Cdv("Double free: object of type TerrainData","when calling error in TerrainData, line 206")
else
set Rg[Tg]=oTx
set Tg=Tg+1
set Gg[oTx]=0
endif
set EM=EM-1
endfunction
function oUx takes integer owx,string oWx returns nothing
set ZM[EM]=oWx
set EM=EM+1
call oQx(owx,"when calling TerrainData_onDestroy in TerrainData, line 236")
call otx(owx,"when calling dealloc_TerrainData in TerrainData, line 236")
set EM=EM-1
endfunction
function oyx takes integer oYx,string ozx returns nothing
set ZM[EM]=ozx
set EM=EM+1
if Gg[oYx]==0 then
if oYx==0 then
call Cdv("Nullpointer exception when calling TerrainData.TerrainData","when calling error in TerrainData, line 206")
else
call Cdv("Called TerrainData.TerrainData on invalid object.","when calling error in TerrainData, line 206")
endif
endif
call oUx(oYx,"when calling destroyTerrainData in TerrainData, line 206")
set EM=EM-1
endfunction
function oZx takes integer o_x,string o0x returns nothing
set ZM[EM]=o0x
set EM=EM+1
if hk[o_x]==0 then
call Cdv("Double free: object of type PersistableMiddleware","when calling error in PersistableData, line 17")
else
set gk=gk+1
set hk[o_x]=0
endif
set EM=EM-1
endfunction
function o1x takes integer o2x,string o3x returns nothing
set ZM[EM]=o3x
set EM=EM+1
call oZx(o2x,"when calling dealloc_PersistableMiddleware in PersistableData, line 17")
set EM=EM-1
endfunction
function o4x takes integer o5x,string o6x returns nothing
set ZM[EM]=o6x
set EM=EM+1
if hk[o5x]==0 then
if o5x==0 then
call Cdv("Nullpointer exception when calling PersistableMiddleware.PersistableMiddleware","when calling error in PersistableData, line 17")
else
call Cdv("Called PersistableMiddleware.PersistableMiddleware on invalid object.","when calling error in PersistableData, line 17")
endif
endif
call o1x(o5x,"when calling destroyPersistableMiddleware in PersistableData, line 17")
set EM=EM-1
endfunction
function o7x takes integer o8x,string o9x returns nothing
set ZM[EM]=o9x
set EM=EM+1
if vD[o8x]!=0 then
call o4x(vD[o8x],"when calling dispatch_PersistableMiddleware_destroyPersistableMiddleware in PersistableData, line 63")
endif
set EM=EM-1
endfunction
function rvx takes integer rex,string rxx returns nothing
set ZM[EM]=rxx
set EM=EM+1
call xjx(CH[rex],"when calling dispatch_PositionedUnitData_destroyPositionedUnitData in RegionData, line 126")
call oXx(XH[rex],"when calling dispatch_PositionedDestructableData_destroyPositionedDestructableData in RegionData, line 127")
call oyx(LH[rex],"when calling dispatch_TerrainData_destroyTerrainData in RegionData, line 128")
call OJe(KH[rex],"when calling dispatch_StringTable_destroyStringTable in RegionData, line 129")
call o7x(rex,"when calling Persistable_onDestroy in RegionData, line 27")
set EM=EM-1
endfunction
function rox takes integer rrx,string rix returns nothing
set ZM[EM]=rix
set EM=EM+1
call rvx(rrx,"when calling RegionData_onDestroy in RegionData, line 125")
call xxx(rrx,"when calling dealloc_RegionData in RegionData, line 125")
set EM=EM-1
endfunction
function rax takes integer rnx,string rVx returns nothing
set ZM[EM]=rVx
set EM=EM+1
if Gg[rnx]==0 then
if rnx==0 then
call Cdv("Nullpointer exception when calling RegionData.RegionData","when calling error in RegionData, line 27")
else
call Cdv("Called RegionData.RegionData on invalid object.","when calling error in RegionData, line 27")
endif
endif
call rox(rnx,"when calling destroyRegionData in RegionData, line 27")
set EM=EM-1
endfunction
function rEx takes integer rXx,string rOx returns nothing
set ZM[EM]=rOx
set EM=EM+1
call GDe("Сохранение завершено!",30.,sa[JL[rXx]])
call rax(KL[rXx],"when calling dispatch_RegionData_destroyRegionData in SotfrpGuiRegions, line 131")
set EM=EM-1
endfunction
function rRx takes integer rIx,string rAx returns nothing
set ZM[EM]=rAx
set EM=EM+1
if xk[rIx]==0 then
if rIx==0 then
call Cdv("Nullpointer exception when calling PersistableSaveCallback.onSaved","when calling error in PersistableData, line 48")
else
call Cdv("Called PersistableSaveCallback.onSaved on invalid object.","when calling error in PersistableData, line 48")
endif
endif
call rEx(rIx,"when calling onSaved_save_setArgumentsTypes_registerProtectedBuiltin_SotfrpGuiRegions in PersistableData, line 48")
set EM=EM-1
endfunction
function rNx takes integer rbx,integer rBx,string rcx returns nothing
set ZM[EM]=rcx
set EM=EM+1
call e9x(rbx,"when calling onSaved in PersistableData, line 128")
if rBx!=0 then
call rRx(rBx,"when calling onSaved in PersistableData, line 130")
call e5x(rBx,"when calling dispatch_PersistableSaveCallback_destroyPersistableSaveCallback in PersistableData, line 131")
endif
set EM=EM-1
endfunction
function rCx takes integer rdx,integer rDx,string rfx returns nothing
set ZM[EM]=rfx
set EM=EM+1
if Gg[rdx]==0 then
if rdx==0 then
call Cdv("Nullpointer exception when calling Persistable.finishSave","when calling error in PersistableData, line 127")
else
call Cdv("Called Persistable.finishSave on invalid object.","when calling error in PersistableData, line 127")
endif
endif
call rNx(rdx,rDx,"when calling finishSave in PersistableData, line 127")
set EM=EM-1
endfunction
function rFx takes integer rgx,string rGx returns boolean
local boolean rhx
set ZM[EM]=rGx
set EM=EM+1
set rhx=GZv(jQ[rgx])>0 or(not YYv(FQ[rgx],"when calling isEmpty in BigString, line 202"))or GZv(kQ[rgx])>0
set EM=EM-1
return rhx
endfunction
function rHx takes integer rjx,string rJx returns boolean
local boolean rkx
set ZM[EM]=rJx
set EM=EM+1
if uG[rjx]==0 then
if rjx==0 then
call Cdv("Nullpointer exception when calling BigString.hasData","when calling error in BigString, line 201")
else
call Cdv("Called BigString.hasData on invalid object.","when calling error in BigString, line 201")
endif
endif
set rkx=rFx(rjx,"when calling hasData in BigString, line 201")
set EM=EM-1
return rkx
endfunction
function rKx takes integer Qys returns nothing
endfunction
function rlx takes integer rLx,string rmx returns nothing
set ZM[EM]=rmx
set EM=EM+1
if iG[rLx]==0 then
call Cdv("Double free: object of type BigStringElement","when calling error in BigString, line 15")
else
set rG[sG]=rLx
set sG=sG+1
set iG[rLx]=0
endif
set EM=EM-1
endfunction
function rMx takes integer rpx,string rPx returns nothing
set ZM[EM]=rPx
set EM=EM+1
call rKx(rpx)
call rlx(rpx,"when calling dealloc_BigStringElement in BigString, line 14")
set EM=EM-1
endfunction
function rqx takes integer rQx,string rsx returns nothing
set ZM[EM]=rsx
set EM=EM+1
if iG[rQx]==0 then
if rQx==0 then
call Cdv("Nullpointer exception when calling BigStringElement.BigStringElement","when calling error in BigString, line 15")
else
call Cdv("Called BigStringElement.BigStringElement on invalid object.","when calling error in BigString, line 15")
endif
endif
call rMx(rQx,"when calling destroyBigStringElement in BigString, line 15")
set EM=EM-1
endfunction
function rSx takes integer rtx,string rTx returns string
local string rux
local string rUx
local integer rwx
set ZM[EM]=rTx
set EM=EM+1
if GZv(jQ[rtx])>0 then
set rUx=jQ[rtx]
set jQ[rtx]=""
set rux=rUx
elseif not YYv(FQ[rtx],"when calling isEmpty in BigString, line 124")then
set rwx=Gqe(FQ[rtx],"when calling dequeue in BigString, line 125")
set rux=mQ[rwx]
call rqx(rwx,"when calling dispatch_BigStringElement_destroyBigStringElement in BigString, line 127")
elseif GZv(kQ[rtx])>0 then
set rux=kQ[rtx]
set kQ[rtx]=""
else
set rux=null
endif
set EM=EM-1
return rux
endfunction
function rWx takes integer ryx,string rYx returns string
local string rzx
set ZM[EM]=rYx
set EM=EM+1
if uG[ryx]==0 then
if ryx==0 then
call Cdv("Nullpointer exception when calling BigString.read","when calling error in BigString, line 117")
else
call Cdv("Called BigString.read on invalid object.","when calling error in BigString, line 117")
endif
endif
set rzx=rSx(ryx,"when calling read in BigString, line 117")
set EM=EM-1
return rzx
endfunction
function rZx takes integer r_x returns integer
return xQ[r_x]
endfunction
function r0x takes integer r1x,string r2x returns integer
local integer r3x
set ZM[EM]=r2x
set EM=EM+1
if uG[r1x]==0 then
if r1x==0 then
call Cdv("Nullpointer exception when calling BigString.maxLength","when calling error in BigString, line 207")
else
call Cdv("Called BigString.maxLength on invalid object.","when calling error in BigString, line 207")
endif
endif
set r3x=rZx(r1x)
set EM=EM-1
return r3x
endfunction
function r4x takes integer r5x,string r6x returns nothing
local integer r7x
local integer r8x
set ZM[EM]=r6x
set EM=EM+1
set r7x=Xle(FQ[r5x],"when calling iterator in BigString, line 67")
loop
exitwhen not Xie(r7x)
set r8x=E3e(r7x)
call rqx(r8x,"when calling dispatch_BigStringElement_destroyBigStringElement in BigString, line 68")
endloop
call Xpe(r7x,"when calling close in BigString, line 67")
call Hcv(FQ[r5x],"when calling dispatch_LinkedList_destroyLinkedList in BigString, line 70")
set EM=EM-1
endfunction
function r9x takes integer ivx,string iex returns nothing
set ZM[EM]=iex
set EM=EM+1
if uG[ivx]==0 then
call Cdv("Double free: object of type BigString","when calling error in BigString, line 39")
else
set NY[MY]=ivx
set MY=MY+1
set uG[ivx]=0
endif
set EM=EM-1
endfunction
function ixx takes integer iox,string irx returns nothing
set ZM[EM]=irx
set EM=EM+1
call r4x(iox,"when calling BigString_onDestroy in BigString, line 66")
call r9x(iox,"when calling dealloc_BigString in BigString, line 66")
set EM=EM-1
endfunction
function iix takes integer iax,string inx returns nothing
set ZM[EM]=inx
set EM=EM+1
if uG[iax]==0 then
if iax==0 then
call Cdv("Nullpointer exception when calling BigString.BigString","when calling error in BigString, line 39")
else
call Cdv("Called BigString.BigString on invalid object.","when calling error in BigString, line 39")
endif
endif
call ixx(iax,"when calling destroyBigString in BigString, line 39")
set EM=EM-1
endfunction
function iVx takes integer iEx,string iXx returns nothing
set ZM[EM]=iXx
set EM=EM+1
if r0x(iEx,"when calling maxLength in PacketIO, line 112")>Kq then
call Cdv("PacketWriter: trying to write a BigString with maxLength > MAX_PACKET_LENGTH","when calling error in PacketIO, line 113")
endif
loop
exitwhen not rHx(iEx,"when calling hasData in PacketIO, line 115")
call eyx(rWx(iEx,"when calling read in PacketIO, line 116"),"when calling write in PacketIO, line 116")
endloop
call iix(iEx,"when calling dispatch_BigString_destroyBigString in PacketIO, line 118")
set EM=EM-1
endfunction
function iOx takes integer iRx,string iIx returns nothing
set ZM[EM]=iIx
set EM=EM+1
if EG[iRx]==0 then
call Cdv("Double free: object of type ByteBuffer","when calling error in ByteBuffer, line 15")
else
set mG[QG]=iRx
set QG=QG+1
set EG[iRx]=0
endif
set EM=EM-1
endfunction
function iAx takes integer iNx,string ibx returns nothing
set ZM[EM]=ibx
set EM=EM+1
if ph[iNx]==0 then
call Cdv("Double free: object of type Table","when calling error in Table, line 6")
else
set lh[bh]=iNx
set bh=bh+1
set ph[iNx]=0
endif
set EM=EM-1
endfunction
function iBx takes integer icx,string iCx returns nothing
set ZM[EM]=iCx
set EM=EM+1
call lHv(icx,"when calling Table_onDestroy in Table, line 253")
call iAx(icx,"when calling dealloc_Table in Table, line 253")
set EM=EM-1
endfunction
function idx takes integer iDx,string ifx returns nothing
set ZM[EM]=ifx
set EM=EM+1
if ph[iDx]==0 then
if iDx==0 then
call Cdv("Nullpointer exception when calling Table.Table","when calling error in Table, line 6")
else
call Cdv("Called Table.Table on invalid object.","when calling error in Table, line 6")
endif
endif
if ph[iDx]<=4898 then
call iBx(iDx,"when calling destroyTable in Table, line 6")
else
call lpv(iDx,"when calling destroyIterableMap in Table, line 6")
endif
set EM=EM-1
endfunction
function iFx takes integer igx,string iGx returns nothing
set ZM[EM]=iGx
set EM=EM+1
call idx(uW[igx],"when calling dispatch_Table_destroyTable in ByteBuffer, line 30")
set EM=EM-1
endfunction
function ihx takes integer iHx,string ijx returns nothing
set ZM[EM]=ijx
set EM=EM+1
call iFx(iHx,"when calling ByteBuffer_onDestroy in ByteBuffer, line 29")
call iOx(iHx,"when calling dealloc_ByteBuffer in ByteBuffer, line 29")
set EM=EM-1
endfunction
function iJx takes integer ikx,string iKx returns nothing
set ZM[EM]=iKx
set EM=EM+1
if EG[ikx]==0 then
if ikx==0 then
call Cdv("Nullpointer exception when calling ByteBuffer.ByteBuffer","when calling error in ByteBuffer, line 15")
else
call Cdv("Called ByteBuffer.ByteBuffer on invalid object.","when calling error in ByteBuffer, line 15")
endif
endif
call ihx(ikx,"when calling destroyByteBuffer in ByteBuffer, line 15")
set EM=EM-1
endfunction
function ilx takes integer iLx,string imx returns nothing
set ZM[EM]=imx
set EM=EM+1
if YQ[iLx]!=0 then
call iix(YQ[iLx],"when calling dispatch_BigString_destroyBigString in Base64, line 99")
endif
call iJx(GQ[iLx],"when calling dispatch_ByteBuffer_destroyByteBuffer in Base64, line 100")
set EM=EM-1
endfunction
function iMx takes integer ipx,string iPx returns nothing
set ZM[EM]=iPx
set EM=EM+1
if LY[ipx]==0 then
call Cdv("Double free: object of type Base64Encoder","when calling error in Base64, line 90")
else
set HY[JY]=ipx
set JY=JY+1
set LY[ipx]=0
endif
set EM=EM-1
endfunction
function iqx takes integer iQx,string isx returns nothing
set ZM[EM]=isx
set EM=EM+1
call ilx(iQx,"when calling Base64Encoder_onDestroy in Base64, line 97")
call iMx(iQx,"when calling dealloc_Base64Encoder in Base64, line 97")
set EM=EM-1
endfunction
function iSx takes integer itx,string iTx returns nothing
set ZM[EM]=iTx
set EM=EM+1
if LY[itx]==0 then
if itx==0 then
call Cdv("Nullpointer exception when calling Base64Encoder.Base64Encoder","when calling error in Base64, line 90")
else
call Cdv("Called Base64Encoder.Base64Encoder on invalid object.","when calling error in Base64, line 90")
endif
endif
call iqx(itx,"when calling destroyBase64Encoder in Base64, line 90")
set EM=EM-1
endfunction
function iux takes integer iUx,string iwx returns nothing
set ZM[EM]=iwx
set EM=EM+1
if qQ[iUx]!=0 then
call iSx(qQ[iUx],"when calling dispatch_Base64Encoder_destroyBase64Encoder in Base64Data, line 68")
endif
set EM=EM-1
endfunction
function iWx takes integer iyx,string iYx returns nothing
set ZM[EM]=iYx
set EM=EM+1
if RY[iyx]==0 then
call Cdv("Double free: object of type Base64DataEncoder","when calling error in Base64Data, line 60")
else
set nY[dY]=iyx
set dY=dY+1
set RY[iyx]=0
endif
set EM=EM-1
endfunction
function izx takes integer iZx,string i_x returns nothing
set ZM[EM]=i_x
set EM=EM+1
call iux(iZx,"when calling Base64DataEncoder_onDestroy in Base64Data, line 66")
call iWx(iZx,"when calling dealloc_Base64DataEncoder in Base64Data, line 66")
set EM=EM-1
endfunction
function i0x takes integer i1x,string i2x returns nothing
set ZM[EM]=i2x
set EM=EM+1
if RY[i1x]==0 then
if i1x==0 then
call Cdv("Nullpointer exception when calling Base64DataEncoder.Base64DataEncoder","when calling error in Base64Data, line 60")
else
call Cdv("Called Base64DataEncoder.Base64DataEncoder on invalid object.","when calling error in Base64Data, line 60")
endif
endif
call izx(i1x,"when calling destroyBase64DataEncoder in Base64Data, line 60")
set EM=EM-1
endfunction
function i3x takes string i4x returns integer
local integer i5x
set ZM[EM]=i4x
set EM=EM+1
if CY==0 then
if VY<$8000 then
set VY=VY+1
set i5x=VY
set BY[i5x]=$851
else
call Cdv("Out of memory: Could not create ForForceCallback_execute_Base64Encoder_Base64.","when calling error in Base64, line 138")
set i5x=0
endif
else
set CY=CY-1
set i5x=XY[CY]
set BY[i5x]=$851
endif
set EM=EM-1
return i5x
endfunction
function i6x takes integer i7x,string i8x returns nothing
local integer i9x
set ZM[EM]=i8x
set EM=EM+1
set i9x=i3x("when calling alloc_ForForceCallback_execute_Base64Encoder_Base64 in Base64, line 138")
set gQ[i9x]=i7x
call Fte(i9x,"when calling execute in Base64, line 138")
set EM=EM-1
endfunction
function avx takes integer aex,string axx returns nothing
set ZM[EM]=axx
set EM=EM+1
if LY[aex]==0 then
if aex==0 then
call Cdv("Nullpointer exception when calling Base64Encoder.encode","when calling error in Base64, line 137")
else
call Cdv("Called Base64Encoder.encode on invalid object.","when calling error in Base64, line 137")
endif
endif
call i6x(aex,"when calling encode in Base64, line 137")
set EM=EM-1
endfunction
function aox takes integer arx,string aix returns integer
local integer aax
set ZM[EM]=aix
set EM=EM+1
set aax=YQ[arx]
set YQ[arx]=0
call iSx(arx,"when calling dispatch_Base64Encoder_destroyBase64Encoder in Base64, line 183")
set EM=EM-1
return aax
endfunction
function anx takes integer aVx,string aEx returns integer
local integer aXx
set ZM[EM]=aEx
set EM=EM+1
if LY[aVx]==0 then
if aVx==0 then
call Cdv("Nullpointer exception when calling Base64Encoder.intoData","when calling error in Base64, line 180")
else
call Cdv("Called Base64Encoder.intoData on invalid object.","when calling error in Base64, line 180")
endif
endif
set aXx=aox(aVx,"when calling intoData in Base64, line 180")
set EM=EM-1
return aXx
endfunction
function aOx takes integer aRx,string aIx returns integer
local integer aAx
local integer aNx
set ZM[EM]=aIx
set EM=EM+1
set aAx=qQ[aRx]
set qQ[aRx]=0
call i0x(aRx,"when calling dispatch_Base64DataEncoder_destroyBase64DataEncoder in Base64Data, line 73")
call avx(aAx,"when calling encode in Base64Data, line 74")
set aNx=anx(aAx,"when calling intoData in Base64Data, line 75")
set EM=EM-1
return aNx
endfunction
function abx takes integer aBx,string acx returns integer
local integer aCx
set ZM[EM]=acx
set EM=EM+1
if RY[aBx]==0 then
if aBx==0 then
call Cdv("Nullpointer exception when calling DataEncoder.encode","when calling error in DataInterfaces, line 111")
else
call Cdv("Called DataEncoder.encode on invalid object.","when calling error in DataInterfaces, line 111")
endif
endif
set aCx=aOx(aBx,"when calling encode in DataInterfaces, line 111")
set EM=EM-1
return aCx
endfunction
function adx takes integer EZs returns integer
return 0
endfunction
function aDx takes integer KSs returns nothing
endfunction
function afx takes integer aFx,integer agx returns nothing
call aDx(aFx)
set qQ[aFx]=agx
endfunction
function aGx takes string ahx returns integer
local integer aHx
set ZM[EM]=ahx
set EM=EM+1
if dY==0 then
if fY<$8000 then
set fY=fY+1
set aHx=fY
set RY[aHx]=$6CC
else
call Cdv("Out of memory: Could not create Base64DataEncoder.","when calling error in Base64Data, line 60")
set aHx=0
endif
else
set dY=dY-1
set aHx=nY[dY]
set RY[aHx]=$6CC
endif
set EM=EM-1
return aHx
endfunction
function ajx takes integer aJx,string akx returns integer
local integer aKx
set ZM[EM]=akx
set EM=EM+1
set aKx=aGx("when calling alloc_Base64DataEncoder in Base64Data, line 63")
call afx(aKx,aJx)
set EM=EM-1
return aKx
endfunction
function alx takes integer aLx,string amx returns nothing
set ZM[EM]=amx
set EM=EM+1
if jY[aLx]==0 then
call Cdv("Double free: object of type Base64DataWriter","when calling error in Base64Data, line 9")
else
set hY[FY]=aLx
set FY=FY+1
set jY[aLx]=0
endif
set EM=EM-1
endfunction
function aMx takes integer apx,string aPx returns nothing
set ZM[EM]=aPx
set EM=EM+1
if nQ[apx]!=0 then
call iSx(nQ[apx],"when calling dispatch_Base64Encoder_destroyBase64Encoder in Base64Data, line 17")
endif
set EM=EM-1
endfunction
function aqx takes integer aQx,string asx returns nothing
set ZM[EM]=asx
set EM=EM+1
call aMx(aQx,"when calling Base64DataWriter_onDestroy in Base64Data, line 15")
call alx(aQx,"when calling dealloc_Base64DataWriter in Base64Data, line 15")
set EM=EM-1
endfunction
function aSx takes integer atx,string aTx returns nothing
set ZM[EM]=aTx
set EM=EM+1
if jY[atx]==0 then
if atx==0 then
call Cdv("Nullpointer exception when calling Base64DataWriter.Base64DataWriter","when calling error in Base64Data, line 9")
else
call Cdv("Called Base64DataWriter.Base64DataWriter on invalid object.","when calling error in Base64Data, line 9")
endif
endif
call aqx(atx,"when calling destroyBase64DataWriter in Base64Data, line 9")
set EM=EM-1
endfunction
function aux takes integer aUx,string awx returns integer
local integer aWx
local integer ayx
set ZM[EM]=awx
set EM=EM+1
set aWx=nQ[aUx]
set nQ[aUx]=0
call aSx(aUx,"when calling dispatch_Base64DataWriter_destroyBase64DataWriter in Base64Data, line 57")
set ayx=ajx(aWx,"when calling new_Base64DataEncoder in Base64Data, line 58")
set EM=EM-1
return ayx
endfunction
function aYx takes integer azx,string aZx returns integer
local integer a_x
set ZM[EM]=aZx
set EM=EM+1
if jY[azx]==0 then
if azx==0 then
call Cdv("Nullpointer exception when calling DataWriter.intoEncoder","when calling error in DataInterfaces, line 74")
else
call Cdv("Called DataWriter.intoEncoder on invalid object.","when calling error in DataInterfaces, line 74")
endif
endif
if jY[azx]<=$6E1 then
set a_x=aux(azx,"when calling intoEncoder in DataInterfaces, line 74")
else
set a_x=adx(azx)
endif
set EM=EM-1
return a_x
endfunction
function a0x takes string a1x returns integer
local integer a2x
set ZM[EM]=a1x
set EM=EM+1
if FY==0 then
if kY<$8000 then
set kY=kY+1
set a2x=kY
set jY[a2x]=$6E1
else
call Cdv("Out of memory: Could not create Base64DataWriter.","when calling error in Base64Data, line 9")
set a2x=0
endif
else
set FY=FY-1
set a2x=hY[FY]
set jY[a2x]=$6E1
endif
set EM=EM-1
return a2x
endfunction
function a3x takes string a4x returns integer
local integer a5x
set ZM[EM]=a4x
set EM=EM+1
if bh==0 then
if yh<$8000 then
set yh=yh+1
set a5x=yh
set ph[a5x]=4897
else
call Cdv("Out of memory: Could not create Table.","when calling error in Table, line 6")
set a5x=0
endif
else
set bh=bh-1
set a5x=lh[bh]
set ph[a5x]=4897
endif
set EM=EM-1
return a5x
endfunction
function a6x takes string a7x returns integer
local integer a8x
set ZM[EM]=a7x
set EM=EM+1
set a8x=a3x("when calling alloc_Table in Table, line 5")
call Cqv(a8x)
set EM=EM-1
return a8x
endfunction
function a9x takes integer nvx,string nex returns nothing
local integer nxx
local integer nox
local integer nrx
local integer nix
local integer nax
local integer nnx
local integer nVx
local integer nEx
set ZM[EM]=nex
set EM=EM+1
set uW[nvx]=a6x("when calling new_Table in ByteBuffer, line 16")
set nxx=0
set nox=0
set nrx=0
set nix=0
set rW[nvx]=nxx
set sW[nvx]=nox
set tW[nvx]=nrx
set iW[nvx]=nix
set SW[nvx]=0
set nax=0
set nnx=0
set nVx=0
set nEx=0
set cW[nvx]=nax
set oW[nvx]=nnx
set OW[nvx]=nVx
set lW[nvx]=nEx
set bW[nvx]=0
set yW[nvx]=-1
set pW[nvx]=-1
set eW[nvx]=0
set EM=EM-1
endfunction
function nXx takes integer nOx,string nRx returns nothing
set ZM[EM]=nRx
set EM=EM+1
call a9x(nOx,"when calling ByteBuffer_init in ByteBuffer, line 14")
set EM=EM-1
endfunction
function nIx takes string nAx returns integer
local integer nNx
set ZM[EM]=nAx
set EM=EM+1
if QG==0 then
if WG<$8000 then
set WG=WG+1
set nNx=WG
set EG[nNx]=$450
else
call Cdv("Out of memory: Could not create ByteBuffer.","when calling error in ByteBuffer, line 15")
set nNx=0
endif
else
set QG=QG-1
set nNx=mG[QG]
set EG[nNx]=$450
endif
set EM=EM-1
return nNx
endfunction
function nbx takes string nBx returns integer
local integer ncx
set ZM[EM]=nBx
set EM=EM+1
set ncx=nIx("when calling alloc_ByteBuffer in ByteBuffer, line 14")
call nXx(ncx,"when calling construct_ByteBuffer in ByteBuffer, line 14")
set EM=EM-1
return ncx
endfunction
function nCx takes integer ndx,string nDx returns nothing
set ZM[EM]=nDx
set EM=EM+1
set GQ[ndx]=nbx("when calling new_ByteBuffer in Base64, line 92")
set EM=EM-1
endfunction
function nfx takes string nFx returns integer
local integer ngx
set ZM[EM]=nFx
set EM=EM+1
if MY==0 then
if wG<$8000 then
set wG=wG+1
set ngx=wG
set uG[ngx]=989
else
call Cdv("Out of memory: Could not create BigString.","when calling error in BigString, line 39")
set ngx=0
endif
else
set MY=MY-1
set ngx=NY[MY]
set uG[ngx]=989
endif
set EM=EM-1
return ngx
endfunction
function nGx takes integer nhx returns nothing
set kQ[nhx]=""
set jQ[nhx]=""
set vQ[nhx]=0
endfunction
function nHx takes integer njx,integer nJx,string nkx returns nothing
set ZM[EM]=nkx
set EM=EM+1
call nGx(njx)
if nJx>Yy then
call Cdv("BigString: maxLength needs to be under BIGSTRING_MAX_CHUNK_LENGTH.","when calling error in BigString, line 48")
endif
set xQ[njx]=nJx
set FQ[njx]=yTv("when calling new_LinkedList in BigString, line 51")
set EM=EM-1
endfunction
function nKx takes integer nlx,string nLx returns integer
local integer nmx
set ZM[EM]=nLx
set EM=EM+1
set nmx=nfx("when calling alloc_BigString in BigString, line 46")
call nHx(nmx,nlx,"when calling construct_BigString in BigString, line 46")
set EM=EM-1
return nmx
endfunction
function nMx takes integer npx,integer nPx,string nqx returns nothing
set ZM[EM]=nqx
set EM=EM+1
call nCx(npx,"when calling Base64Encoder_init in Base64, line 94")
set YQ[npx]=nKx(nPx,"when calling new_BigString in Base64, line 95")
set EM=EM-1
endfunction
function nQx takes string nsx returns integer
local integer nSx
set ZM[EM]=nsx
set EM=EM+1
if JY==0 then
if KY<$8000 then
set KY=KY+1
set nSx=KY
set LY[nSx]=956
else
call Cdv("Out of memory: Could not create Base64Encoder.","when calling error in Base64, line 90")
set nSx=0
endif
else
set JY=JY-1
set nSx=HY[JY]
set LY[nSx]=956
endif
set EM=EM-1
return nSx
endfunction
function ntx takes integer nTx,string nux returns integer
local integer nUx
set ZM[EM]=nux
set EM=EM+1
set nUx=nQx("when calling alloc_Base64Encoder in Base64, line 94")
call nMx(nUx,nTx,"when calling construct_Base64Encoder in Base64, line 94")
set EM=EM-1
return nUx
endfunction
function nwx takes integer Ros returns nothing
endfunction
function nWx takes integer nyx,integer nYx,string nzx returns nothing
set ZM[EM]=nzx
set EM=EM+1
call nwx(nyx)
set nQ[nyx]=ntx(nYx,"when calling new_Base64Encoder in Base64Data, line 13")
set EM=EM-1
endfunction
function nZx takes integer n_x,string n0x returns integer
local integer n1x
set ZM[EM]=n0x
set EM=EM+1
set n1x=a0x("when calling alloc_Base64DataWriter in Base64Data, line 12")
call nWx(n1x,n_x,"when calling construct_Base64DataWriter in Base64Data, line 12")
set EM=EM-1
return n1x
endfunction
function n2x takes integer hrt,string n3x returns integer
local integer n4x
set ZM[EM]=n3x
set EM=EM+1
set n4x=nZx(Kq,"when calling new_Base64DataWriter in PersistableData, line 70")
set EM=EM-1
return n4x
endfunction
function n5x takes integer n6x,string n7x returns integer
local integer n8x
set ZM[EM]=n7x
set EM=EM+1
if Gg[n6x]==0 then
if n6x==0 then
call Cdv("Nullpointer exception when calling Persistable.getWriter","when calling error in PersistableData, line 69")
else
call Cdv("Called Persistable.getWriter on invalid object.","when calling error in PersistableData, line 69")
endif
endif
set n8x=n2x(n6x,"when calling getWriter in PersistableData, line 69")
set EM=EM-1
return n8x
endfunction
function n9x takes nothing returns nothing
set Xq=1
call PreloadGenClear()
call PreloadGenStart()
endfunction
function Vvx takes integer Vex,integer Vxx,string Vox returns nothing
local integer Vrx
local integer Vix
set ZM[EM]=Vox
set EM=EM+1
if ta==xD[Vex]then
set Vrx=n5x(Vex,"when calling getWriter in PersistableData, line 157")
call eGx(Vrx,Vex,"when calling writeSerializable in PersistableData, line 158")
set Vix=abx(aYx(Vrx,"when calling intoEncoder in PersistableData, line 159"),"when calling encode in PersistableData, line 159")
if vD[Vex]!=0 then
set Vix=t0e(vD[Vex],Vix)
endif
call n9x()
call eyx(SMv(eMx(Vix,"when calling checksum in PersistableData, line 163")),"when calling write in PersistableData, line 163")
call iVx(Vix,"when calling write in PersistableData, line 164")
call eQx(tYe(Vex,"when calling getPath in PersistableData, line 165"))
endif
call rCx(Vex,Vxx,"when calling finishSave in PersistableData, line 166")
set EM=EM-1
endfunction
function Vax takes integer Vnx,integer VVx,string VEx returns nothing
set ZM[EM]=VEx
set EM=EM+1
if Gg[Vnx]==0 then
if Vnx==0 then
call Cdv("Nullpointer exception when calling Persistable.save","when calling error in PersistableData, line 155")
else
call Cdv("Called Persistable.save on invalid object.","when calling error in PersistableData, line 155")
endif
endif
call Vvx(Vnx,VVx,"when calling save in PersistableData, line 155")
set EM=EM-1
endfunction
function VXx takes integer VOx,string VRx returns nothing
set ZM[EM]=VRx
set EM=EM+1
call Vax(VOx,0,"when calling save in PersistableData, line 169")
set EM=EM-1
endfunction
function VIx takes integer VAx,string VNx returns nothing
set ZM[EM]=VNx
set EM=EM+1
if Gg[VAx]==0 then
if VAx==0 then
call Cdv("Nullpointer exception when calling Persistable.save","when calling error in PersistableData, line 168")
else
call Cdv("Called Persistable.save on invalid object.","when calling error in PersistableData, line 168")
endif
endif
call VXx(VAx,"when calling save in PersistableData, line 168")
set EM=EM-1
endfunction
function Vbx takes integer VBx,integer Vcx,string VCx returns nothing
set ZM[EM]=VCx
set EM=EM+1
call tLe(tQe(VBx,Vcx,"when calling getSlot in PlayerDefinedUnitTypes, line 65"),"when calling reset in PlayerDefinedUnitTypes, line 65")
call VIx(VBx,"when calling save in PlayerDefinedUnitTypes, line 66")
set EM=EM-1
endfunction
function Vdx takes integer VDx,integer Vfx,string VFx returns nothing
set ZM[EM]=VFx
set EM=EM+1
if Gg[VDx]==0 then
if VDx==0 then
call Cdv("Nullpointer exception when calling PlayerDefinedUnitTypes.flushSlot","when calling error in PlayerDefinedUnitTypes, line 64")
else
call Cdv("Called PlayerDefinedUnitTypes.flushSlot on invalid object.","when calling error in PlayerDefinedUnitTypes, line 64")
endif
endif
call Vbx(VDx,Vfx,"when calling flushSlot in PlayerDefinedUnitTypes, line 64")
set EM=EM-1
endfunction
function Vgx takes string VGx,string Vhx returns string
return VGx+" (|cFFFFCC00"+Vhx+"|r)"
endfunction
function VHx takes integer Vjx returns integer
return EW[Vjx]
endfunction
function VJx takes integer Vkx,string VKx returns integer
local integer Vlx
set ZM[EM]=VKx
set EM=EM+1
if Gg[Vkx]==0 then
if Vkx==0 then
call Cdv("Nullpointer exception when calling CustomUnitType.getBaseTypeId","when calling error in CustomUnitTypes, line 115")
else
call Cdv("Called CustomUnitType.getBaseTypeId on invalid object.","when calling error in CustomUnitTypes, line 115")
endif
endif
set Vlx=VHx(Vkx)
set EM=EM-1
return Vlx
endfunction
function VLx takes integer Vmx,integer VMx,string Vpx returns integer
local integer VPx
set ZM[EM]=Vpx
set EM=EM+1
set VPx=VJx(tQe(Vmx,VMx,"when calling getSlot in PlayerDefinedUnitTypes, line 46"),"when calling getBaseTypeId in PlayerDefinedUnitTypes, line 46")
set EM=EM-1
return VPx
endfunction
function Vqx takes integer VQx,integer Vsx,string VSx returns integer
local integer Vtx
set ZM[EM]=VSx
set EM=EM+1
if Gg[VQx]==0 then
if VQx==0 then
call Cdv("Nullpointer exception when calling PlayerDefinedUnitTypes.getBaseTypeId","when calling error in PlayerDefinedUnitTypes, line 45")
else
call Cdv("Called PlayerDefinedUnitTypes.getBaseTypeId on invalid object.","when calling error in PlayerDefinedUnitTypes, line 45")
endif
endif
set Vtx=VLx(VQx,Vsx,"when calling getBaseTypeId in PlayerDefinedUnitTypes, line 45")
set EM=EM-1
return Vtx
endfunction
function VTx takes integer Vux,integer VUx returns string
return kT[VUx*4+Vux]
endfunction
function Vwx takes integer VWx,integer Vyx,boolean VYx,string Vzx returns nothing
local string VZx
local string V_x
local integer V0x
local integer V1x
local integer V2x
local player V3x
local integer V4x
set ZM[EM]=Vzx
set EM=EM+1
if ta==sa[VWx]then
set V1x=IT[Vyx]
if VYx then
set VZx=ke
else
set VZx=WT
endif
call BlzSetAbilityIcon(V1x,VZx)
set V2x=IT[Vyx]
if VYx then
set V_x=GetObjectName(Vqx(Vq[VWx],Vyx,"when calling getBaseTypeId in UnitShops, line 139"))
else
set V_x=ET
endif
call BlzSetAbilityTooltip(V2x,Vgx(V_x,VTx(PT[Vyx],AT[Vyx])),1)
endif
set V3x=sa[VWx]
set V4x=DT[Vyx]
if VYx then
set V0x=1
else
set V0x=0
endif
call SetPlayerTechResearched(V3x,V4x,V0x)
set EM=EM-1
set V3x=null
endfunction
function V5x takes integer V6x,integer V7x,string V8x returns nothing
set ZM[EM]=V8x
set EM=EM+1
call Vdx(Vq[V6x],V7x,"when calling flushSlot in UnitShops, line 147")
call Vwx(V6x,V7x,false,"when calling makeSlotAvailable in UnitShops, line 148")
set EM=EM-1
endfunction
function V9x takes integer aSS,integer Evx,integer Eex,string Exx returns integer
local integer Eox
set ZM[EM]=Exx
set EM=EM+1
call V5x(QGv(Evx,"when calling getPlayerId in UnitShopsBuiltins, line 13"),QNv(M7v(Eex,0,"when calling get in UnitShopsBuiltins, line 13"),"when calling intValue in UnitShopsBuiltins, line 13"),"when calling flushCustomUnitTypeSlot in UnitShopsBuiltins, line 13")
set Eox=MLv("when calling nullptr in UnitShopsBuiltins, line 14")
set EM=EM-1
return Eox
endfunction
function Erx takes integer aTt,integer Eix,integer dTt,string Eax returns integer
local integer Enx
set ZM[EM]=Eax
set EM=EM+1
set Enx=p0v(pjv(P7e(Eix,"when calling getTriggerUnit in SLangTriggerFunctions, line 91"),"when calling new_Unit in SLangTriggerFunctions, line 91"),"when calling new_SharedPointer in SLangTriggerFunctions, line 91")
set EM=EM-1
return Enx
endfunction
function EVx takes timer EEx returns integer
return GetHandleId(EEx)
endfunction
function EXx takes timer EOx,integer ERx,string EIx returns nothing
set ZM[EM]=EIx
set EM=EM+1
call Dyv(tT,EVx(EOx),ERx,"when calling saveInt in TimerUtils, line 18")
set EM=EM-1
endfunction
function EAx takes timer ENx,real Ebx,code EBx returns nothing
call TimerStart(ENx,Ebx,false,EBx)
endfunction
function Ecx takes integer ECx,timer Edx,real EDx,string Efx returns nothing
local timer EFx
local timer Egx
set ZM[EM]=Efx
set EM=EM+1
set EFx=Edx
call EXx(EFx,ECx,"when calling setData in ClosureTimers, line 113")
set Egx=EFx
call EAx(Egx,EDx,Rbv)
set WW[ECx]=Egx
set EM=EM-1
set EFx=null
set Egx=null
endfunction
function EGx takes integer Ehx,timer EHx,real Ejx,string EJx returns nothing
set ZM[EM]=EJx
set EM=EM+1
if vG[Ehx]==0 then
if Ehx==0 then
call Cdv("Nullpointer exception when calling CallbackSingle.start","when calling error in ClosureTimers, line 111")
else
call Cdv("Called CallbackSingle.start on invalid object.","when calling error in ClosureTimers, line 111")
endif
endif
call Ecx(Ehx,EHx,Ejx,"when calling start in ClosureTimers, line 111")
set EM=EM-1
endfunction
function Ekx takes timer EKx,real Elx,integer ELx,string Emx returns integer
set ZM[EM]=Emx
set EM=EM+1
call EGx(ELx,EKx,Elx,"when calling start in ClosureTimers, line 16")
set EM=EM-1
return ELx
endfunction
function EMx takes string Epx returns timer
local timer EPx
local timer Eqx
set ZM[EM]=Epx
set EM=EM+1
if sT>0 then
set sT=sT-1
call EXx(rT[sT],0,"when calling setData in TimerUtils, line 30")
set EM=EM-1
set EPx=null
set Eqx=null
return rT[sT]
else
set EPx=CreateTimer()
call EXx(EPx,0,"when calling setData in TimerUtils, line 33")
set Eqx=EPx
set EM=EM-1
set RZv=Eqx
set EPx=null
set Eqx=null
return RZv
endif
endfunction
function EQx takes real Esx,integer ESx,string Etx returns integer
local integer ETx
set ZM[EM]=Etx
set EM=EM+1
set ETx=Ekx(EMx("when calling getTimer in ClosureTimers, line 27"),Esx,ESx,"when calling doAfter in ClosureTimers, line 27")
set EM=EM-1
return ETx
endfunction
function Eux takes integer YTs returns nothing
endfunction
function EUx takes integer Ewx returns nothing
call Eux(Ewx)
endfunction
function EWx takes string Eyx returns integer
local integer EYx
set ZM[EM]=Eyx
set EM=EM+1
if jG==0 then
if xG<$8000 then
set xG=xG+1
set EYx=xG
set vG[EYx]=$46F
else
call Cdv("Out of memory: Could not create CallbackSingle_doAfter_setArgumentsTypes_setVariadicArgumentTypes_registerProtectedBuiltin_ScmdCoreBuiltins.","when calling error in ScmdCoreBuiltins, line 335")
set EYx=0
endif
else
set jG=jG-1
set EYx=kG[jG]
set vG[EYx]=$46F
endif
set EM=EM-1
return EYx
endfunction
function Ezx takes integer OWt,integer EZx,integer E_x,string E0x returns integer
local real E1x
local integer E2x
local integer E3x
local integer E4x
local integer E5x
local integer E6x
local integer E7x
local real E8x
set ZM[EM]=E0x
set EM=EM+1
set E1x=PEv(M7v(E_x,0,"when calling get in ScmdCoreBuiltins, line 330"),"when calling realValue in ScmdCoreBuiltins, line 330")
set E2x=qUe(EZx,"when calling clone in ScmdCoreBuiltins, line 331")
set E3x=TEv("when calling new_HashList in ScmdCoreBuiltins, line 332")
set E4x=1
set E5x=SNv(E_x,"when calling size in ScmdCoreBuiltins, line 333")-1
loop
exitwhen E4x>E5x
call dlv(E3x,MJv(Joe(E_x,E4x,"when calling getPtr in ScmdCoreBuiltins, line 334"),"when calling clone in ScmdCoreBuiltins, line 334"),"when calling add in ScmdCoreBuiltins, line 334")
set E4x=E4x+1
endloop
set E8x=E1x
set E6x=EWx("when calling alloc_CallbackSingle_doAfter_setArgumentsTypes_setVariadicArgumentTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdCoreBuiltins, line 335")
call EUx(E6x)
set YJ[E6x]=E3x
set GJ[E6x]=E2x
call EQx(E8x,E6x,"when calling doAfter in ScmdCoreBuiltins, line 335")
set E7x=MLv("when calling nullptr in ScmdCoreBuiltins, line 347")
set EM=EM-1
return E7x
endfunction
function E9x takes unit Xvx returns nothing
call PauseUnit(Xvx,false)
endfunction
function Xex takes integer Xxx,integer Xox,integer dgi,string Xrx returns integer
local integer Xix
set ZM[EM]=Xrx
set EM=EM+1
call E9x(Mov(Xox,"when calling getEnumUnit in ScmdUnitBuiltins, line 743"))
set Xix=MLv("when calling nullptr in ScmdUnitBuiltins, line 744")
set EM=EM-1
return Xix
endfunction
function Xax takes string Xnx,string XVx returns boolean
local integer XEx=GZv(Xnx)
if GZv(XVx)>XEx then
return false
endif
return Psv(Xnx,0,GZv(XVx))==XVx
endfunction
function XXx takes integer ajt,integer njt,integer XOx,string XRx returns integer
local integer XIx
set ZM[EM]=XRx
set EM=EM+1
set XIx=p0v(qRv(Xax(Mqv(M7v(XOx,0,"when calling get in ScmdCoreBuiltins, line 178"),"when calling getInner in ScmdCoreBuiltins, line 178"),Mqv(M7v(XOx,1,"when calling get in ScmdCoreBuiltins, line 178"),"when calling getInner in ScmdCoreBuiltins, line 178")),"when calling new_Boolean in ScmdCoreBuiltins, line 178"),"when calling new_SharedPointer in ScmdCoreBuiltins, line 178")
set EM=EM-1
return XIx
endfunction
function XAx takes string XNx returns string
return StringCase(XNx,true)
endfunction
function Xbx takes integer ekt,integer qkt,integer XBx,string Xcx returns integer
local string XCx
local string Xdx
local integer XDx
set ZM[EM]=Xcx
set EM=EM+1
set XCx=Mqv(M7v(XBx,0,"when calling get in ScmdCoreBuiltins, line 153"),"when calling getInner in ScmdCoreBuiltins, line 153")
if XCx=="" then
set Xdx=""
else
set Xdx=XAx(duv(XCx,0))+tYv(Tgv(XCx,1))
endif
set XDx=p0v(Ppv(Xdx,"when calling new_String in ScmdCoreBuiltins, line 154"),"when calling new_SharedPointer in ScmdCoreBuiltins, line 154")
set EM=EM-1
return XDx
endfunction
function Xfx takes integer mGi,integer XFx,integer WGi,string Xgx returns integer
local integer XGx
set ZM[EM]=Xgx
set EM=EM+1
set XGx=p0v(Ppv(zAv(Mov(XFx,"when calling getEnumUnit in ScmdUnitBuiltins, line 726")),"when calling new_String in ScmdUnitBuiltins, line 726"),"when calling new_SharedPointer in ScmdUnitBuiltins, line 726")
set EM=EM-1
return XGx
endfunction
function Xhx takes integer mRt,integer QRt,integer XHx,string Xjx returns integer
local integer XJx
set ZM[EM]=Xjx
set EM=EM+1
call mdv(qGv(M7v(XHx,0,"when calling get in SLangTriggerFunctions, line 16"),"when calling getInner in SLangTriggerFunctions, line 16"))
set XJx=MLv("when calling nullptr in SLangTriggerFunctions, line 17")
set EM=EM-1
return XJx
endfunction
function Xkx takes integer XKx,integer Xlx,string XLx returns string
local string Xmx
set ZM[EM]=XLx
set EM=EM+1
set Xmx=G7v(yP[XKx],Xlx,"when calling loadString in Locale, line 35")
set EM=EM-1
return Xmx
endfunction
function XMx takes integer Xpx,integer XPx,string Xqx returns string
local string XQx
set ZM[EM]=Xqx
set EM=EM+1
if QF[Xpx]==0 then
if Xpx==0 then
call Cdv("Nullpointer exception when calling Locale.getLocalizedObjectName","when calling error in Locale, line 34")
else
call Cdv("Called Locale.getLocalizedObjectName on invalid object.","when calling error in Locale, line 34")
endif
endif
set XQx=Xkx(Xpx,XPx,"when calling getLocalizedObjectName in Locale, line 34")
set EM=EM-1
return XQx
endfunction
function Xsx takes player XSx,integer Xtx,string XTx returns nothing
local rect Xux
local group XUx
local unit Xwx
local group XWx
local string Xyx
local integer XYx
local integer Xzx
local integer XZx
local integer X_x
set ZM[EM]=XTx
set EM=EM+1
call Hme(XSx)
set Xux=GetWorldBounds()
set XUx=GetUnitsInRectAll(Xux)
call lnv(Xux)
set XWx=XUx
loop
exitwhen not F9e(XWx)
set Xwx=F6e(XWx)
if XSx==ta then
set Xyx=XMx(Xtx,umv(Xwx),"when calling getLocalizedObjectName in Locale, line 66")
if Xyx!=null then
call Nee(Xwx,Xyx)
endif
endif
endloop
set XYx=jdv(pP[Xtx],"when calling iterator in Locale, line 69")
loop
exitwhen not Jgv(XYx,"when calling hasNext in Locale, line 69")
set Xzx=jTv(XYx,"when calling next in Locale, line 69")
set XZx=1
set X_x=f3v(eP[Xtx],Xzx,"when calling get in Locale, line 70")
loop
exitwhen XZx>X_x
if XSx==ta then
if Knv(qP[Xtx],Xzx,XZx)then
call BlzSetAbilityTooltip(Xzx,G0v(qP[Xtx],Xzx,XZx),XZx)
endif
if Knv(aP[Xtx],Xzx,XZx)then
call BlzSetAbilityExtendedTooltip(Xzx,G0v(aP[Xtx],Xzx,XZx),XZx)
endif
endif
set XZx=XZx+1
endloop
endloop
call Jqv(XYx,"when calling close in Locale, line 69")
call kcv(XUx)
set EM=EM-1
set Xux=null
set XUx=null
set Xwx=null
set XWx=null
endfunction
function X0x takes integer jat,integer X1x,integer X2x,string X3x returns integer
local integer X4x
local string X5x
local integer X6x
local integer X7x
set ZM[EM]=X3x
set EM=EM+1
set X4x=0
set X5x=Mqv(M7v(X2x,0,"when calling get in SLangPlayerFunctions, line 25"),"when calling getInner in SLangPlayerFunctions, line 25")
if X5x=="en" then
call Xsx(sa[QGv(X1x,"when calling getPlayerId in SLangPlayerFunctions, line 27")],ef,"when calling setLocale in SLangPlayerFunctions, line 27")
elseif X5x=="ru" then
call Xsx(sa[QGv(X1x,"when calling getPlayerId in SLangPlayerFunctions, line 29")],qf,"when calling setLocale in SLangPlayerFunctions, line 29")
else
set X4x=p0v(tJv("Wrong locale","when calling new_Exception in SLangPlayerFunctions, line 31"),"when calling new_SharedPointer in SLangPlayerFunctions, line 31")
endif
if X4x==0 then
set X6x=p0v(dpe("when calling new_Null in SLangPlayerFunctions, line 32"),"when calling new_SharedPointer in SLangPlayerFunctions, line 32")
else
set X6x=X4x
endif
set X7x=X6x
set EM=EM-1
return X7x
endfunction
function X8x takes unit X9x,string Ovx,real Oex,real Oxx returns boolean
return IssuePointOrder(X9x,Ovx,Oex,Oxx)
endfunction
function Oox takes integer mhi,integer Qhi,integer Orx,string Oix returns integer
local integer Oax
set ZM[EM]=Oix
set EM=EM+1
set Oax=p0v(qRv(X8x(PCv(M7v(Orx,0,"when calling get in ScmdUnitBuiltins, line 778"),"when calling getInner in ScmdUnitBuiltins, line 778"),Mqv(M7v(Orx,1,"when calling get in ScmdUnitBuiltins, line 778"),"when calling getInner in ScmdUnitBuiltins, line 778"),PEv(M7v(Orx,2,"when calling get in ScmdUnitBuiltins, line 778"),"when calling realValue in ScmdUnitBuiltins, line 778"),PEv(M7v(Orx,3,"when calling get in ScmdUnitBuiltins, line 778"),"when calling realValue in ScmdUnitBuiltins, line 778")),"when calling new_Boolean in ScmdUnitBuiltins, line 778"),"when calling new_SharedPointer in ScmdUnitBuiltins, line 778")
set EM=EM-1
return Oax
endfunction
function Onx takes string OVx,string OEx returns player
local playercolor OXx
local integer OOx
local integer ORx
local player OIx
local integer OAx
local player ONx
local integer Obx
set ZM[EM]=OEx
set EM=EM+1
set OXx=tZv(OVx)
if OXx!=null or tYv(OVx)=="red" then
set OOx=0
set ORx=bj_MAX_PLAYER_SLOTS-1
loop
exitwhen OOx>ORx
if g_e(sa[OOx])==OXx then
set EM=EM-1
set x1=sa[OOx]
set v1=0
set OXx=null
set OIx=null
set ONx=null
return x1
endif
set OOx=OOx+1
endloop
endif
set ONx=null
set Obx=B6e("Invalid color name","when calling wrap in SLangPlayerFunctions, line 69")
set OIx=ONx
set OAx=Obx
set EM=EM-1
set x1=OIx
set v1=OAx
set OXx=null
set OIx=null
set ONx=null
return x1
endfunction
function OBx takes player Ocx,playercolor OCx returns nothing
call SetPlayerColor(Ocx,OCx)
endfunction
function Odx takes player ODx returns playerslotstate
return GetPlayerSlotState(ODx)
endfunction
function Ofx takes player OFx returns mapcontrol
return GetPlayerController(OFx)
endfunction
function Ogx takes integer gnt,integer OGx,integer Ohx,string OHx returns integer
local player Ojx
local integer OJx
local playercolor Okx
local playercolor OKx
local integer Olx
local integer OLx
local player Omx
local integer OMx
set ZM[EM]=OHx
set EM=EM+1
set Omx=Onx(Mqv(M7v(Ohx,0,"when calling get in SLangPlayerFunctions, line 73"),"when calling getInner in SLangPlayerFunctions, line 73"),"when calling resolvePlayer in SLangPlayerFunctions, line 73")
set OMx=v1
set Ojx=Omx
set OJx=OMx
if OJx==0 then
if Ofx(Ojx)==MAP_CONTROL_USER and Odx(Ojx)==PLAYER_SLOT_STATE_PLAYING then
set OJx=B6e("Color is occupied","when calling wrap in SLangPlayerFunctions, line 76")
else
set Okx=g_e(sa[QGv(OGx,"when calling getPlayerId in SLangPlayerFunctions, line 78")])
set OKx=g_e(Ojx)
call OBx(Ojx,Okx)
call tSv(QKv(Hme(Ojx)),Okx)
call OBx(sa[QGv(OGx,"when calling getPlayerId in SLangPlayerFunctions, line 82")],OKx)
call tSv(QKv(QGv(OGx,"when calling getPlayerId in SLangPlayerFunctions, line 83")),OKx)
endif
endif
if OJx!=0 then
set Olx=OJx
else
set Olx=MLv("when calling nullptr in SLangPlayerFunctions, line 84")
endif
set OLx=Olx
set EM=EM-1
set Ojx=null
set Okx=null
set OKx=null
set Omx=null
return OLx
endfunction
function Opx takes integer J0i,integer K0i,integer OPx,string Oqx returns integer
local integer OQx
set ZM[EM]=Oqx
set EM=EM+1
call IBe(Wlv(M7v(OPx,0,"when calling get in ScmdItemBuiltins, line 46"),"when calling getInner in ScmdItemBuiltins, line 46"),PEv(M7v(OPx,1,"when calling get in ScmdItemBuiltins, line 46"),"when calling realValue in ScmdItemBuiltins, line 46"))
set OQx=MLv("when calling nullptr in ScmdItemBuiltins, line 47")
set EM=EM-1
return OQx
endfunction
function Osx takes integer JRi,integer OSx,integer LRi,string Otx returns integer
local integer OTx
set ZM[EM]=Otx
set EM=EM+1
set OTx=p0v(q2v(GetUnitFacing(Mov(OSx,"when calling getEnumUnit in ScmdUnitBuiltins, line 645")),"when calling new_Real in ScmdUnitBuiltins, line 645"),"when calling new_SharedPointer in ScmdUnitBuiltins, line 645")
set EM=EM-1
return OTx
endfunction
function Oux takes integer JYi,integer OUx,integer LYi,string Owx returns integer
local integer OWx
set ZM[EM]=Owx
set EM=EM+1
set OWx=p0v(qRv(IsUnitType(Mov(OUx,"when calling getEnumUnit in ScmdUnitBuiltins, line 699"),UNIT_TYPE_STRUCTURE),"when calling new_Boolean in ScmdUnitBuiltins, line 699"),"when calling new_SharedPointer in ScmdUnitBuiltins, line 699")
set EM=EM-1
return OWx
endfunction
function Oyx takes integer Jdi,integer Kdi,integer OYx,string Ozx returns integer
local integer OZx
set ZM[EM]=Ozx
set EM=EM+1
call O8e(PCv(M7v(OYx,0,"when calling get in ScmdUnitBuiltins, line 576"),"when calling getInner in ScmdUnitBuiltins, line 576"),QNv(M7v(OYx,1,"when calling get in ScmdUnitBuiltins, line 576"),"when calling intValue in ScmdUnitBuiltins, line 576"))
set OZx=MLv("when calling nullptr in ScmdUnitBuiltins, line 577")
set EM=EM-1
return OZx
endfunction
function O_x takes integer O0x,string O1x,widget O2x,string O3x returns nothing
call fwe(O0x)
set TK[O0x]=AddSpecialEffectTarget(O1x,O2x,O3x)
set YK[O0x]=O1x
endfunction
function O4x takes string O5x,widget O6x,string O7x,string O8x returns integer
local integer O9x
set ZM[EM]=O8x
set EM=EM+1
set O9x=f_e("when calling alloc_SpecialEffect in ScmdDataTypes, line 606")
call O_x(O9x,O5x,O6x,O7x)
set EM=EM-1
return O9x
endfunction
function Rvx takes integer Jdt,integer Rex,integer Rxx,string Rox returns integer
local integer Rrx
set ZM[EM]=Rox
set EM=EM+1
set Rrx=p0v(O4x(Mqv(M7v(Rxx,0,"when calling get in SLangSpecialEffectFunctions, line 10"),"when calling getInner in SLangSpecialEffectFunctions, line 10"),Mov(Rex,"when calling getEnumUnit in SLangSpecialEffectFunctions, line 10"),Mqv(M7v(Rxx,1,"when calling get in SLangSpecialEffectFunctions, line 10"),"when calling getInner in SLangSpecialEffectFunctions, line 10"),"when calling new_SpecialEffect in SLangSpecialEffectFunctions, line 10"),"when calling new_SharedPointer in SLangSpecialEffectFunctions, line 10")
set EM=EM-1
return Rrx
endfunction
function Rix takes integer Joi,integer Rax,integer Loi,string Rnx returns integer
local integer RVx
set ZM[EM]=Rnx
set EM=EM+1
set RVx=p0v(SSv(rde(Mov(Rax,"when calling getEnumUnit in ScmdUnitBuiltins, line 176")),"when calling new_Integer in ScmdUnitBuiltins, line 176"),"when calling new_SharedPointer in ScmdUnitBuiltins, line 176")
set EM=EM-1
return RVx
endfunction
function REx takes integer Ppt,integer RXx,integer ROx,string RRx returns integer
local integer RIx
local unit RAx
local string RNx
local string Rbx
local integer RBx
set ZM[EM]=RRx
set EM=EM+1
set RIx=QGv(RXx,"when calling getPlayerId in SLangChatSystem, line 207")
set RAx=Mov(RXx,"when calling getEnumUnit in SLangChatSystem, line 208")
if IsHeroUnitId(umv(RAx))then
set Rbx=Zev(RAx)
else
set Rbx=zAv(RAx)
endif
set RNx=Rbx
call HFe(Ha,RIx,gye(g5e(g_e(sa[RIx])),b3,y3)+RNx+"|r: "+Mqv(M7v(ROx,0,"when calling get in SLangChatSystem, line 210"),"when calling getInner in SLangChatSystem, line 210"),ta,"when calling send in SLangChatSystem, line 210")
set RBx=MLv("when calling nullptr in SLangChatSystem, line 211")
set EM=EM-1
set RAx=null
return RBx
endfunction
function Rcx takes integer Psi,integer RCx,integer Rdx,string RDx returns integer
local string Rfx
local player RFx
local string Rgx
local integer RGx
local integer Rhx
set ZM[EM]=RDx
set EM=EM+1
set Rfx=tYv(Mqv(M7v(Rdx,0,"when calling get in ScmdUnitBuiltins, line 20"),"when calling getInner in ScmdUnitBuiltins, line 20"))
set Rgx=Rfx
if Rgx=="hostile" then
set RFx=sa[PLAYER_NEUTRAL_AGGRESSIVE]
elseif Rgx=="neutral" then
set RFx=sa[PLAYER_NEUTRAL_PASSIVE]
elseif Rgx=="me" then
set RFx=sa[QGv(RCx,"when calling getPlayerId in ScmdUnitBuiltins, line 28")]
else
set RFx=SSe(tZv(Rfx))
endif
if RFx!=null then
call SPe(Mov(RCx,"when calling getEnumUnit in ScmdUnitBuiltins, line 32"),RFx,false)
endif
if RFx!=null then
set RGx=MLv("when calling nullptr in ScmdUnitBuiltins, line 33")
else
set RGx=tLv("when calling newWCNException in ScmdUnitBuiltins, line 33")
endif
set Rhx=RGx
set EM=EM-1
set RFx=null
return Rhx
endfunction
function RHx takes string Rjx returns integer
local integer RJx
set ZM[EM]=Rjx
set EM=EM+1
if Sx==0 then
if cx<$8000 then
set cx=cx+1
set RJx=cx
set ox[RJx]=$F0E
else
call Cdv("Out of memory: Could not create WeatherEffect.","when calling error in ScmdDataTypes, line 625")
set RJx=0
endif
else
set Sx=Sx-1
set RJx=ix[Sx]
set ox[RJx]=$F0E
endif
set EM=EM-1
return RJx
endfunction
function Rkx takes integer M7i returns nothing
endfunction
function RKx takes integer Rlx,rect RLx,integer Rmx returns nothing
call Rkx(Rlx)
set IK[Rlx]=AddWeatherEffect(RLx,Rmx)
endfunction
function RMx takes rect Rpx,integer RPx,string Rqx returns integer
local integer RQx
set ZM[EM]=Rqx
set EM=EM+1
set RQx=RHx("when calling alloc_WeatherEffect in ScmdDataTypes, line 631")
call RKx(RQx,Rpx,RPx)
set EM=EM-1
return RQx
endfunction
function Rsx takes integer Jxi,integer Kxi,integer RSx,string Rtx returns integer
local integer RTx
set ZM[EM]=Rtx
set EM=EM+1
set RTx=p0v(RMx(gOe(M7v(RSx,0,"when calling get in ScmdWeatherEffectFunctions, line 7"),"when calling getInner in ScmdWeatherEffectFunctions, line 7"),QNv(M7v(RSx,1,"when calling get in ScmdWeatherEffectFunctions, line 7"),"when calling intValue in ScmdWeatherEffectFunctions, line 7"),"when calling new_WeatherEffect in ScmdWeatherEffectFunctions, line 7"),"when calling new_SharedPointer in ScmdWeatherEffectFunctions, line 7")
set EM=EM-1
return RTx
endfunction
function Rux takes unit RUx,integer Rwx returns nothing
call SetUnitAnimationByIndex(RUx,Rwx)
endfunction
function RWx takes integer jFi,integer xFi,integer Ryx,string RYx returns integer
local integer Rzx
set ZM[EM]=RYx
set EM=EM+1
call Rux(PCv(M7v(Ryx,0,"when calling get in ScmdUnitBuiltins, line 803"),"when calling getInner in ScmdUnitBuiltins, line 803"),QNv(M7v(Ryx,1,"when calling get in ScmdUnitBuiltins, line 803"),"when calling intValue in ScmdUnitBuiltins, line 803"))
set Rzx=MLv("when calling nullptr in ScmdUnitBuiltins, line 804")
set EM=EM-1
return Rzx
endfunction
function RZx takes integer jTt,integer R_x,integer vTt,string R0x returns integer
local integer R1x
set ZM[EM]=R0x
set EM=EM+1
set R1x=p0v(pjv(qbe(R_x,"when calling getSpellAbilityUnit in SLangTriggerFunctions, line 97"),"when calling new_Unit in SLangTriggerFunctions, line 97"),"when calling new_SharedPointer in SLangTriggerFunctions, line 97")
set EM=EM-1
return R1x
endfunction
function R2x takes effect R3x,real R4x returns nothing
call BlzSetSpecialEffectScale(R3x,R4x)
endfunction
function R5x takes integer jft,integer xft,integer R6x,string R7x returns integer
local integer R8x
set ZM[EM]=R7x
set EM=EM+1
call R2x(Pov(M7v(R6x,0,"when calling get in SLangSpecialEffectFunctions, line 32"),"when calling getInner in SLangSpecialEffectFunctions, line 32"),PEv(M7v(R6x,1,"when calling get in SLangSpecialEffectFunctions, line 32"),"when calling realValue in SLangSpecialEffectFunctions, line 32"))
set R8x=MLv("when calling nullptr in SLangSpecialEffectFunctions, line 33")
set EM=EM-1
return R8x
endfunction
function R9x takes integer jgi,integer Ivx,integer vgi,string Iex returns integer
local integer Ixx
set ZM[EM]=Iex
set EM=EM+1
call PFv(Mov(Ivx,"when calling getEnumUnit in ScmdUnitBuiltins, line 750"))
set Ixx=MLv("when calling nullptr in ScmdUnitBuiltins, line 751")
set EM=EM-1
return Ixx
endfunction
function Iox takes integer ngt,integer dgt,integer Irx,string Iix returns integer
local boolean Iax
local integer Inx
local integer IVx
local integer IEx
local real IXx
local integer IOx
local integer IRx
local integer IIx
local integer IAx
local integer INx
local integer Ibx
local integer IBx
set ZM[EM]=Iix
set EM=EM+1
set Iax=false
set Inx=0
set IVx=SNv(Irx,"when calling size in ScmdCoreBuiltins, line 12")-1
loop
exitwhen Inx>IVx
set Ibx=ox[M7v(Irx,Inx,"when calling get in ScmdCoreBuiltins, line 13")]
if not(Ibx==$EFD or Ibx==$F03)then
set Iax=true
endif
set Inx=Inx+1
endloop
set IEx=0
set IXx=.0
if Iax then
set IOx=0
set IRx=SNv(Irx,"when calling size in ScmdCoreBuiltins, line 18")-1
loop
exitwhen IOx>IRx
set IXx=IXx+kge(M7v(Irx,IOx,"when calling get in ScmdCoreBuiltins, line 19"),"when calling realValue in ScmdCoreBuiltins, line 19")
set IOx=IOx+1
endloop
else
set IIx=0
set IAx=SNv(Irx,"when calling size in ScmdCoreBuiltins, line 21")-1
loop
exitwhen IIx>IAx
set IEx=IEx+kZe(M7v(Irx,IIx,"when calling get in ScmdCoreBuiltins, line 22"),"when calling intValue in ScmdCoreBuiltins, line 22")
set IIx=IIx+1
endloop
endif
if Iax then
set INx=q2v(IXx,"when calling new_Real in ScmdCoreBuiltins, line 23")
else
set INx=SSv(IEx,"when calling new_Integer in ScmdCoreBuiltins, line 23")
endif
set IBx=p0v(INx,"when calling new_SharedPointer in ScmdCoreBuiltins, line 23")
set EM=EM-1
return IBx
endfunction
function Icx takes string ICx,string Idx returns boolean
return h9e(ICx,Idx)!=-1
endfunction
function IDx takes integer jjt,integer xjt,integer Ifx,string IFx returns integer
local integer Igx
set ZM[EM]=IFx
set EM=EM+1
set Igx=p0v(qRv(Icx(Mqv(M7v(Ifx,0,"when calling get in ScmdCoreBuiltins, line 184"),"when calling getInner in ScmdCoreBuiltins, line 184"),Mqv(M7v(Ifx,1,"when calling get in ScmdCoreBuiltins, line 184"),"when calling getInner in ScmdCoreBuiltins, line 184")),"when calling new_Boolean in ScmdCoreBuiltins, line 184"),"when calling new_SharedPointer in ScmdCoreBuiltins, line 184")
set EM=EM-1
return Igx
endfunction
function IGx takes integer jkt,integer xkt,integer Ihx,string IHx returns integer
local integer Ijx
set ZM[EM]=IHx
set EM=EM+1
set Ijx=p0v(Ppv(XAx(Mqv(M7v(Ihx,0,"when calling get in ScmdCoreBuiltins, line 160"),"when calling getInner in ScmdCoreBuiltins, line 160")),"when calling new_String in ScmdCoreBuiltins, line 160"),"when calling new_SharedPointer in ScmdCoreBuiltins, line 160")
set EM=EM-1
return Ijx
endfunction
function IJx takes integer DFi,integer HFi,integer Ikx,string IKx returns integer
local integer Ilx
set ZM[EM]=IKx
set EM=EM+1
call Mwv(PCv(M7v(Ikx,0,"when calling get in ScmdUnitBuiltins, line 810"),"when calling getInner in ScmdUnitBuiltins, line 810"),Mqv(M7v(Ikx,1,"when calling get in ScmdUnitBuiltins, line 810"),"when calling getInner in ScmdUnitBuiltins, line 810"),true)
set Ilx=MLv("when calling nullptr in ScmdUnitBuiltins, line 811")
set EM=EM-1
return Ilx
endfunction
function ILx takes integer DTt,integer Imx,integer JTt,string IMx returns integer
local integer Ipx
set ZM[EM]=IMx
set EM=EM+1
set Ipx=p0v(q2v(qMe(Imx,"when calling getSpellTargetX in SLangTriggerFunctions, line 103"),"when calling new_Real in SLangTriggerFunctions, line 103"),"when calling new_SharedPointer in SLangTriggerFunctions, line 103")
set EM=EM-1
return Ipx
endfunction
function IPx takes effect Iqx,real IQx returns nothing
call BlzSetSpecialEffectTimeScale(Iqx,IQx)
endfunction
function Isx takes integer Dft,integer Hft,integer ISx,string Itx returns integer
local integer ITx
set ZM[EM]=Itx
set EM=EM+1
call IPx(Pov(M7v(ISx,0,"when calling get in SLangSpecialEffectFunctions, line 40"),"when calling getInner in SLangSpecialEffectFunctions, line 40"),PEv(M7v(ISx,1,"when calling get in SLangSpecialEffectFunctions, line 40"),"when calling realValue in SLangSpecialEffectFunctions, line 40"))
set ITx=MLv("when calling nullptr in SLangSpecialEffectFunctions, line 41")
set EM=EM-1
return ITx
endfunction
function Iux takes integer Dgi,integer IUx,integer Jgi,string Iwx returns integer
local integer IWx
set ZM[EM]=Iwx
set EM=EM+1
call Sfe(Mov(IUx,"when calling getEnumUnit in ScmdUnitBuiltins, line 757"))
set IWx=MLv("when calling nullptr in ScmdUnitBuiltins, line 758")
set EM=EM-1
return IWx
endfunction
function Iyx takes integer Lyt,integer IYx,string Izx,string IZx returns nothing
set ZM[EM]=IZx
set EM=EM+1
call HFe(Ka[IYx],IYx,Izx,sa[IYx],"when calling send in SLangChatSystem, line 176")
set EM=EM-1
endfunction
function I_x takes integer I0x,integer I1x,string I2x,string I3x returns nothing
set ZM[EM]=I3x
set EM=EM+1
if qj[I0x]==0 then
if I0x==0 then
call Cdv("Nullpointer exception when calling ISystemMessagesReceiver.call","when calling error in ScmdSystemMessaging, line 6")
else
call Cdv("Called ISystemMessagesReceiver.call on invalid object.","when calling error in ScmdSystemMessaging, line 6")
endif
endif
call Iyx(I0x,I1x,I2x,"when calling call_registerSystemMessagesReceiver_SLangChatSystem in ScmdSystemMessaging, line 6")
set EM=EM-1
endfunction
function I4x takes integer I5x,string I6x,string I7x returns nothing
local integer I8x
local integer I9x
set ZM[EM]=I7x
set EM=EM+1
set I8x=0
set I9x=Qd-1
loop
exitwhen I8x>I9x
call I_x(md[I8x],I5x,I6x,"when calling call in ScmdSystemMessaging, line 17")
set I8x=I8x+1
endloop
set EM=EM-1
endfunction
function Avx takes integer Uht,integer Aex,integer Axx,string Aox returns integer
local string Arx
local integer Aix
local integer Aax
local string Anx
local string AVx
set ZM[EM]=Aox
set EM=EM+1
set Arx=""
if SNv(Axx,"when calling size in ScmdCoreBuiltins, line 89")>0 then
set Anx=Arx
call fge(1,M7v(Axx,0,"when calling get in ScmdCoreBuiltins, line 90"),"when calling toString in ScmdCoreBuiltins, line 90")
set Arx=Anx+RHv
set Aix=1
loop
exitwhen not(Aix<SNv(Axx,"when calling size in ScmdCoreBuiltins, line 92"))
set AVx=Arx
call fge(1,M7v(Axx,Aix,"when calling get in ScmdCoreBuiltins, line 93"),"when calling toString in ScmdCoreBuiltins, line 93")
set Arx=AVx+" "+RHv
set Aix=Aix+1
endloop
endif
call I4x(QGv(Aex,"when calling getPlayerId in ScmdCoreBuiltins, line 95"),Arx,"when calling sendSystemMessage in ScmdCoreBuiltins, line 95")
set Aax=MLv("when calling nullptr in ScmdCoreBuiltins, line 96")
set EM=EM-1
return Aax
endfunction
function AEx takes string AXx returns string
local integer AOx=0
local integer ARx=GZv(AXx)
loop
exitwhen not(AOx<ARx and duv(AXx,AOx)==" ")
set AOx=AOx+1
endloop
return Psv(AXx,AOx,GZv(AXx))
endfunction
function AIx takes integer Dkt,integer Hkt,integer AAx,string ANx returns integer
local integer Abx
set ZM[EM]=ANx
set EM=EM+1
set Abx=p0v(Ppv(AEx(Mqv(M7v(AAx,0,"when calling get in ScmdCoreBuiltins, line 166"),"when calling getInner in ScmdCoreBuiltins, line 166")),"when calling new_String in ScmdCoreBuiltins, line 166"),"when calling new_SharedPointer in ScmdCoreBuiltins, line 166")
set EM=EM-1
return Abx
endfunction
function ABx takes string Acx returns integer
local integer ACx
set ZM[EM]=Acx
set EM=EM+1
if Tk==0 then
if Yk<$8000 then
set Yk=Yk+1
set ACx=Yk
set Gk[ACx]=$FE2
else
call Cdv("Out of memory: Could not create PersistableLoadCallback_load_setArgumentsTypes_registerProtectedBuiltin_SotfrpGuiRegions.","when calling error in SotfrpGuiRegions, line 163")
set ACx=0
endif
else
set Tk=Tk-1
set ACx=Rk[Tk]
set Gk[ACx]=$FE2
endif
set EM=EM-1
return ACx
endfunction
function Adx takes integer ADx,string Afx returns nothing
local integer AFx
set ZM[EM]=Afx
set EM=EM+1
set AFx=0
set eH[ADx]=AFx
set qH[ADx]=false
set aH[ADx]=false
set nH[ADx]=Ctv("when calling new_HashMap in RawcodeTable, line 48")
set dH[ADx]=TEv("when calling new_HashList in RawcodeTable, line 49")
set EM=EM-1
endfunction
function Agx takes integer AGx,string Ahx returns nothing
set ZM[EM]=Ahx
set EM=EM+1
call Adx(AGx,"when calling RawcodeTable_init in RawcodeTable, line 41")
set EM=EM-1
endfunction
function AHx takes string Ajx returns integer
local integer AJx
set ZM[EM]=Ajx
set EM=EM+1
if Tg==0 then
if Yg<$8000 then
set Yg=Yg+1
set AJx=Yg
set Gg[AJx]=$6D9
else
call Cdv("Out of memory: Could not create RawcodeTable.","when calling error in RawcodeTable, line 41")
set AJx=0
endif
else
set Tg=Tg-1
set AJx=Rg[Tg]
set Gg[AJx]=$6D9
endif
set EM=EM-1
return AJx
endfunction
function Akx takes string AKx returns integer
local integer Alx
set ZM[EM]=AKx
set EM=EM+1
set Alx=AHx("when calling alloc_RawcodeTable in RawcodeTable, line 41")
call Agx(Alx,"when calling construct_RawcodeTable in RawcodeTable, line 41")
set EM=EM-1
return Alx
endfunction
function ALx takes integer Amx,string AMx returns nothing
local integer Apx
set ZM[EM]=AMx
set EM=EM+1
set Apx=0
set wE[Amx]=Apx
set uE[Amx]=Akx("when calling new_RawcodeTable in DestructableData, line 227")
set rE[Amx]=TEv("when calling new_HashList in DestructableData, line 228")
set EM=EM-1
endfunction
function APx takes integer Aqx,string AQx returns nothing
set ZM[EM]=AQx
set EM=EM+1
call ALx(Aqx,"when calling PositionedDestructableData_init in DestructableData, line 223")
set EM=EM-1
endfunction
function Asx takes string ASx returns integer
local integer Atx
set ZM[EM]=ASx
set EM=EM+1
if Tg==0 then
if Yg<$8000 then
set Yg=Yg+1
set Atx=Yg
set Gg[Atx]=$6D7
else
call Cdv("Out of memory: Could not create PositionedDestructableData.","when calling error in DestructableData, line 223")
set Atx=0
endif
else
set Tg=Tg-1
set Atx=Rg[Tg]
set Gg[Atx]=$6D7
endif
set EM=EM-1
return Atx
endfunction
function ATx takes string Aux returns integer
local integer AUx
set ZM[EM]=Aux
set EM=EM+1
set AUx=Asx("when calling alloc_PositionedDestructableData in DestructableData, line 223")
call APx(AUx,"when calling construct_PositionedDestructableData in DestructableData, line 223")
set EM=EM-1
return AUx
endfunction
function Awx takes integer AWx,string Ayx returns nothing
local integer AYx
set ZM[EM]=Ayx
set EM=EM+1
set AYx=0
set LC[AWx]=AYx
set XC[AWx]=TEv("when calling new_HashList in UnitData, line 1382")
set EM=EM-1
endfunction
function Azx takes integer AZx,integer A_x,string A0x returns nothing
set ZM[EM]=A0x
set EM=EM+1
call Awx(AZx,"when calling PositionedUnitData_init in UnitData, line 1384")
set KC[AZx]=A_x
set EM=EM-1
endfunction
function A1x takes string A2x returns integer
local integer A3x
set ZM[EM]=A2x
set EM=EM+1
if Tg==0 then
if Yg<$8000 then
set Yg=Yg+1
set A3x=Yg
set Gg[A3x]=$6D8
else
call Cdv("Out of memory: Could not create PositionedUnitData.","when calling error in UnitData, line 1376")
set A3x=0
endif
else
set Tg=Tg-1
set A3x=Rg[Tg]
set Gg[A3x]=$6D8
endif
set EM=EM-1
return A3x
endfunction
function A4x takes integer A5x,string A6x returns integer
local integer A7x
set ZM[EM]=A6x
set EM=EM+1
set A7x=A1x("when calling alloc_PositionedUnitData in UnitData, line 1384")
call Azx(A7x,A5x,"when calling construct_PositionedUnitData in UnitData, line 1384")
set EM=EM-1
return A7x
endfunction
function A8x takes integer A9x,integer Nvx returns integer
set j1=dpv(A9x,Nvx)
return j1
endfunction
function Nex takes integer Nxx,string Nox returns nothing
local integer Nrx
set ZM[EM]=Nox
set EM=EM+1
set Nrx=0
set IC[Nxx]=Nrx
set PC[Nxx]=Akx("when calling new_RawcodeTable in TerrainData, line 142")
set AC[Nxx]=yTv("when calling new_LinkedList in TerrainData, line 143")
set EM=EM-1
endfunction
function Nix takes integer Nax,string Nnx returns nothing
set ZM[EM]=Nnx
set EM=EM+1
call Nex(Nax,"when calling TileData_init in TerrainData, line 138")
set EM=EM-1
endfunction
function NVx takes string NEx returns integer
local integer NXx
set ZM[EM]=NEx
set EM=EM+1
if Tg==0 then
if Yg<$8000 then
set Yg=Yg+1
set NXx=Yg
set Gg[NXx]=$6DD
else
call Cdv("Out of memory: Could not create TileData.","when calling error in TerrainData, line 138")
set NXx=0
endif
else
set Tg=Tg-1
set NXx=Rg[Tg]
set Gg[NXx]=$6DD
endif
set EM=EM-1
return NXx
endfunction
function NOx takes string NRx returns integer
local integer NIx
set ZM[EM]=NRx
set EM=EM+1
set NIx=NVx("when calling alloc_TileData in TerrainData, line 138")
call Nix(NIx,"when calling construct_TileData in TerrainData, line 138")
set EM=EM-1
return NIx
endfunction
function NAx takes integer NNx,integer Nbx returns integer
set i4=dpv(NNx,Nbx)
return i4
endfunction
function NBx takes integer Ncx,string NCx returns nothing
local integer Ndx
set ZM[EM]=NCx
set EM=EM+1
set Ndx=NAx(0,0)
set EC[Ncx]=Ndx
set ZC[Ncx]=NOx("when calling new_TileData in TerrainData, line 210")
set EM=EM-1
endfunction
function NDx takes integer Nfx,string NFx returns nothing
set ZM[EM]=NFx
set EM=EM+1
call NBx(Nfx,"when calling TerrainData_init in TerrainData, line 206")
set EM=EM-1
endfunction
function Ngx takes string NGx returns integer
local integer Nhx
set ZM[EM]=NGx
set EM=EM+1
if Tg==0 then
if Yg<$8000 then
set Yg=Yg+1
set Nhx=Yg
set Gg[Nhx]=$6DC
else
call Cdv("Out of memory: Could not create TerrainData.","when calling error in TerrainData, line 206")
set Nhx=0
endif
else
set Tg=Tg-1
set Nhx=Rg[Tg]
set Gg[Nhx]=$6DC
endif
set EM=EM-1
return Nhx
endfunction
function NHx takes string Njx returns integer
local integer NJx
set ZM[EM]=Njx
set EM=EM+1
set NJx=Ngx("when calling alloc_TerrainData in TerrainData, line 206")
call NDx(NJx,"when calling construct_TerrainData in TerrainData, line 206")
set EM=EM-1
return NJx
endfunction
function Nkx takes integer NKx,string Nlx returns nothing
local integer NLx
local real Nmx
local real NMx
local real Npx
local real NPx
set ZM[EM]=Nlx
set EM=EM+1
set NLx=A8x(A8x(0,1),2)
set EH[NKx]=NLx
set ZH[NKx]=Fa
set UH[NKx]=ka
set IH[NKx]=Fa
set PH[NKx]=ka
set Nmx=.0
set NMx=.0
set AH[NKx]=Nmx
set DH[NKx]=NMx
set Npx=.0
set NPx=.0
set HH[NKx]=Npx
set JH[NKx]=NPx
set KH[NKx]=ybv("when calling new_StringTable in RegionData, line 41")
set LH[NKx]=NHx("when calling new_TerrainData in RegionData, line 42")
set XH[NKx]=ATx("when calling new_PositionedDestructableData in RegionData, line 43")
set CH[NKx]=A4x(KH[NKx],"when calling new_PositionedUnitData in RegionData, line 44")
set EM=EM-1
endfunction
function Nqx takes integer Gst returns nothing
endfunction
function NQx takes integer Nsx,player NSx returns nothing
call Nqx(Nsx)
set xD[Nsx]=NSx
endfunction
function Ntx takes integer NTx,player Nux,string NUx,string Nwx returns nothing
set ZM[EM]=Nwx
set EM=EM+1
call NQx(NTx,Nux)
call Nkx(NTx,"when calling RegionData_init in RegionData, line 46")
set WH[NTx]=NUx
set EM=EM-1
endfunction
function NWx takes string Nyx returns integer
local integer NYx
set ZM[EM]=Nyx
set EM=EM+1
if Tg==0 then
if Yg<$8000 then
set Yg=Yg+1
set NYx=Yg
set Gg[NYx]=$6D6
else
call Cdv("Out of memory: Could not create RegionData.","when calling error in RegionData, line 27")
set NYx=0
endif
else
set Tg=Tg-1
set NYx=Rg[Tg]
set Gg[NYx]=$6D6
endif
set EM=EM-1
return NYx
endfunction
function Nzx takes player NZx,string N_x,string N0x returns integer
local integer N1x
set ZM[EM]=N0x
set EM=EM+1
set N1x=NWx("when calling alloc_RegionData in RegionData, line 46")
call Ntx(N1x,NZx,N_x,"when calling construct_RegionData in RegionData, line 46")
set EM=EM-1
return N1x
endfunction
function N2x takes string N3x returns integer
local integer N4x
set ZM[EM]=N3x
set EM=EM+1
if CF==0 then
if VF<$8000 then
set VF=VF+1
set N4x=VF
set BF[N4x]=$E58
else
call Cdv("Out of memory: Could not create NetworkFinishedCallback_start_Persistable_PersistableData.","when calling error in PersistableData, line 139")
set N4x=0
endif
else
set CF=CF-1
set N4x=XF[CF]
set BF[N4x]=$E58
endif
set EM=EM-1
return N4x
endfunction
function N5x takes string N6x returns integer
local integer N7x
set ZM[EM]=N6x
set EM=EM+1
if Jm==0 then
if Km<$8000 then
set Km=Km+1
set N7x=Km
set Lm[N7x]=$41C
else
call Cdv("Out of memory: Could not create Box⟪integer⟫.","when calling error in Box, line 14")
set N7x=0
endif
else
set Jm=Jm-1
set N7x=Hm[Jm]
set Lm[N7x]=$41C
endif
set EM=EM-1
return N7x
endfunction
function N8x takes integer xdS returns nothing
endfunction
function N9x takes integer bvx,integer bex returns nothing
call N8x(bvx)
set vM[bvx]=bex
endfunction
function bxx takes integer box,string brx returns integer
local integer bix
set ZM[EM]=brx
set EM=EM+1
set bix=N5x("when calling alloc_Box⟪integer⟫ in Box, line 17")
call N9x(bix,box)
set EM=EM-1
return bix
endfunction
function bax takes string bnx returns integer
local integer bVx
set ZM[EM]=bnx
set EM=EM+1
if CY==0 then
if VY<$8000 then
set VY=VY+1
set bVx=VY
set BY[bVx]=$857
else
call Cdv("Out of memory: Could not create ForForceCallback_execute_Network_NetworkData.","when calling error in NetworkData, line 273")
set bVx=0
endif
else
set CY=CY-1
set bVx=XY[CY]
set BY[bVx]=$857
endif
set EM=EM-1
return bVx
endfunction
function bEx takes integer bXx,integer bOx,string bRx returns nothing
local integer bIx
set ZM[EM]=bRx
set EM=EM+1
set bIx=bax("when calling alloc_ForForceCallback_execute_Network_NetworkData in NetworkData, line 273")
set rA[bIx]=bXx
set sA[bIx]=bOx
call Fte(bIx,"when calling execute in NetworkData, line 273")
set EM=EM-1
endfunction
function bAx takes integer bNx,integer bbx,string bBx returns nothing
set ZM[EM]=bBx
set EM=EM+1
if LF[bNx]==0 then
if bNx==0 then
call Cdv("Nullpointer exception when calling Network.write","when calling error in NetworkData, line 271")
else
call Cdv("Called Network.write on invalid object.","when calling error in NetworkData, line 271")
endif
endif
call bEx(bNx,bbx,"when calling write in NetworkData, line 271")
set EM=EM-1
endfunction
function bcx takes string bCx returns integer
local integer bdx
set ZM[EM]=bCx
set EM=EM+1
if CY==0 then
if VY<$8000 then
set VY=VY+1
set bdx=VY
set BY[bdx]=$86E
else
call Cdv("Out of memory: Could not create ForForceCallback_try_Persistable_PersistableData.","when calling error in PersistableData, line 79")
set bdx=0
endif
else
set CY=CY-1
set bdx=XY[CY]
set BY[bdx]=$86E
endif
set EM=EM-1
return bdx
endfunction
function bDx takes string bfx returns integer
local integer bFx
set ZM[EM]=bfx
set EM=EM+1
if MF==0 then
if wk<$8000 then
set wk=wk+1
set bFx=wk
set uk[bFx]=$E5A
else
call Cdv("Out of memory: Could not create NetworkWriteCallback_write_Persistable_PersistableData.","when calling error in PersistableData, line 95")
set bFx=0
endif
else
set MF=MF-1
set bFx=NF[MF]
set uk[bFx]=$E5A
endif
set EM=EM-1
return bFx
endfunction
function bgx takes integer bGx,string bhx returns nothing
set ZM[EM]=bhx
set EM=EM+1
if gY[bGx]==0 then
call Cdv("Double free: object of type DataReader","when calling error in DataInterfaces, line 82")
else
set TY[YY]=bGx
set YY=YY+1
set gY[bGx]=0
endif
set EM=EM-1
endfunction
function bHx takes integer bjx,string bJx returns nothing
set ZM[EM]=bJx
set EM=EM+1
call bgx(bjx,"when calling dealloc_DataReader in DataInterfaces, line 82")
set EM=EM-1
endfunction
function bkx takes integer XQs returns nothing
endfunction
function bKx takes integer blx,string bLx returns nothing
set ZM[EM]=bLx
set EM=EM+1
if gY[blx]==0 then
call Cdv("Double free: object of type HashDataProxyReader","when calling error in HashData, line 228")
else
set TY[YY]=blx
set YY=YY+1
set gY[blx]=0
endif
set EM=EM-1
endfunction
function bmx takes integer bMx,string bpx returns nothing
set ZM[EM]=bpx
set EM=EM+1
call bkx(bMx)
call bKx(bMx,"when calling dealloc_HashDataProxyReader in HashData, line 228")
set EM=EM-1
endfunction
function bPx takes integer bqx,string bQx returns nothing
set ZM[EM]=bQx
set EM=EM+1
if gY[bqx]==0 then
call Cdv("Double free: object of type HashReader","when calling error in HashData, line 77")
else
set TY[YY]=bqx
set YY=YY+1
set gY[bqx]=0
endif
set EM=EM-1
endfunction
function bsx takes integer bSx,string btx returns nothing
set ZM[EM]=btx
set EM=EM+1
call idx(LZ[bSx],"when calling dispatch_Table_destroyTable in HashData, line 99")
set EM=EM-1
endfunction
function bTx takes integer bux,string bUx returns nothing
set ZM[EM]=bUx
set EM=EM+1
call bsx(bux,"when calling HashReader_onDestroy in HashData, line 98")
call bPx(bux,"when calling dealloc_HashReader in HashData, line 98")
set EM=EM-1
endfunction
function bwx takes integer bWx,string byx returns nothing
set ZM[EM]=byx
set EM=EM+1
if gY[bWx]==0 then
call Cdv("Double free: object of type Base64DataReader","when calling error in Base64Data, line 77")
else
set TY[YY]=bWx
set YY=YY+1
set gY[bWx]=0
endif
set EM=EM-1
endfunction
function bYx takes integer bzx,string bZx returns nothing
set ZM[EM]=bZx
set EM=EM+1
if aQ[bzx]!=0 then
call iJx(aQ[bzx],"when calling dispatch_ByteBuffer_destroyByteBuffer in Base64Data, line 85")
endif
set EM=EM-1
endfunction
function b_x takes integer b0x,string b1x returns nothing
set ZM[EM]=b1x
set EM=EM+1
call bYx(b0x,"when calling Base64DataReader_onDestroy in Base64Data, line 83")
call bwx(b0x,"when calling dealloc_Base64DataReader in Base64Data, line 83")
set EM=EM-1
endfunction
function b2x takes integer b3x,string b4x returns nothing
set ZM[EM]=b4x
set EM=EM+1
if gY[b3x]==0 then
if b3x==0 then
call Cdv("Nullpointer exception when calling DataReader.DataReader","when calling error in DataInterfaces, line 82")
else
call Cdv("Called DataReader.DataReader on invalid object.","when calling error in DataInterfaces, line 82")
endif
endif
if gY[b3x]<=$6CE then
if gY[b3x]<=$6CD then
call bHx(b3x,"when calling destroyDataReader in DataInterfaces, line 82")
else
call b_x(b3x,"when calling destroyBase64DataReader in DataInterfaces, line 82")
endif
elseif gY[b3x]<=$6CF then
call bmx(b3x,"when calling destroyHashDataProxyReader in DataInterfaces, line 82")
else
call bTx(b3x,"when calling destroyHashReader in DataInterfaces, line 82")
endif
set EM=EM-1
endfunction
function b5x takes string b6x returns integer
local integer b7x
set ZM[EM]=b6x
set EM=EM+1
if CY==0 then
if VY<$8000 then
set VY=VY+1
set b7x=VY
set BY[b7x]=$86F
else
call Cdv("Out of memory: Could not create ForForceCallback_try_Persistable_PersistableData.","when calling error in PersistableData, line 98")
set b7x=0
endif
else
set CY=CY-1
set b7x=XY[CY]
set BY[b7x]=$86F
endif
set EM=EM-1
return b7x
endfunction
function b8x takes string b9x returns integer
local integer Bvx
set ZM[EM]=b9x
set EM=EM+1
if MF==0 then
if wk<$8000 then
set wk=wk+1
set Bvx=wk
set uk[Bvx]=$E5B
else
call Cdv("Out of memory: Could not create NetworkWriteCallback_write_Persistable_PersistableData.","when calling error in PersistableData, line 113")
set Bvx=0
endif
else
set MF=MF-1
set Bvx=NF[MF]
set uk[Bvx]=$E5B
endif
set EM=EM-1
return Bvx
endfunction
function Bex takes integer Bxx returns nothing
endfunction
function Box takes integer Brx,string Bix returns nothing
set ZM[EM]=Bix
set EM=EM+1
if Bm[Brx]==0 then
call Cdv("Double free: object of type Box⟪DataReader208⟫","when calling error in Box, line 14")
else
set Xm[Cm]=Brx
set Cm=Cm+1
set Bm[Brx]=0
endif
set EM=EM-1
endfunction
function Bax takes integer Bnx,string BVx returns nothing
set ZM[EM]=BVx
set EM=EM+1
call Bex(Bnx)
call Box(Bnx,"when calling dealloc_Box⟪DataReader208⟫ in Box, line 13")
set EM=EM-1
endfunction
function BEx takes integer BXx,string BOx returns nothing
set ZM[EM]=BOx
set EM=EM+1
if Bm[BXx]==0 then
if BXx==0 then
call Cdv("Nullpointer exception when calling Box⟪DataReader208⟫.Box","when calling error in Box, line 14")
else
call Cdv("Called Box⟪DataReader208⟫.Box on invalid object.","when calling error in Box, line 14")
endif
endif
call Bax(BXx,"when calling destroyBox⟪DataReader208⟫ in Box, line 14")
set EM=EM-1
endfunction
function BRx takes integer BIx,string BAx returns nothing
set ZM[EM]=BAx
set EM=EM+1
if Lm[BIx]==0 then
call Cdv("Double free: object of type Box⟪integer⟫","when calling error in Box, line 14")
else
set Hm[Jm]=BIx
set Jm=Jm+1
set Lm[BIx]=0
endif
set EM=EM-1
endfunction
function BNx takes integer Bbx,string BBx returns nothing
set ZM[EM]=BBx
set EM=EM+1
call Bex(Bbx)
call BRx(Bbx,"when calling dealloc_Box⟪integer⟫ in Box, line 13")
set EM=EM-1
endfunction
function Bcx takes integer BCx,string Bdx returns nothing
set ZM[EM]=Bdx
set EM=EM+1
if Lm[BCx]==0 then
if BCx==0 then
call Cdv("Nullpointer exception when calling Box⟪integer⟫.Box","when calling error in Box, line 14")
else
call Cdv("Called Box⟪integer⟫.Box on invalid object.","when calling error in Box, line 14")
endif
endif
call BNx(BCx,"when calling destroyBox⟪integer⟫ in Box, line 14")
set EM=EM-1
endfunction
function BDx takes string Bfx returns integer
local integer BFx
set ZM[EM]=Bfx
set EM=EM+1
if Cm==0 then
if Vm<$8000 then
set Vm=Vm+1
set BFx=Vm
set Bm[BFx]=$41A
else
call Cdv("Out of memory: Could not create Box⟪DataReader208⟫.","when calling error in Box, line 14")
set BFx=0
endif
else
set Cm=Cm-1
set BFx=Xm[Cm]
set Bm[BFx]=$41A
endif
set EM=EM-1
return BFx
endfunction
function Bgx takes integer mdS returns nothing
endfunction
function BGx takes integer Bhx,integer BHx returns nothing
call Bgx(Bhx)
set mM[Bhx]=BHx
endfunction
function Bjx takes integer BJx,string Bkx returns integer
local integer BKx
set ZM[EM]=Bkx
set EM=EM+1
set BKx=BDx("when calling alloc_Box⟪DataReader208⟫ in Box, line 17")
call BGx(BKx,BJx)
set EM=EM-1
return BKx
endfunction
function Blx takes integer BLx,integer Bmx,string BMx returns nothing
local integer Bpx
local integer BPx
local boolean Bqx
local integer BQx
local integer Bsx
local integer BSx
local boolean Btx
local integer BTx
local integer Bux
local integer BUx
local integer Bwx
set ZM[EM]=BMx
set EM=EM+1
set Bpx=bxx(0,"when calling new_Box⟪integer⟫ in PersistableData, line 76")
set BPx=Bjx(0,"when calling new_Box⟪DataReader208⟫ in PersistableData, line 77")
set BQx=bcx("when calling alloc_ForForceCallback_try_Persistable_PersistableData in PersistableData, line 79")
set mD[BQx]=BLx
set QD[BQx]=BPx
set Bqx=FPe(BQx,"when calling try in PersistableData, line 79")
set Bsx=mM[BPx]
call BEx(BPx,"when calling dispatch_Box⟪DataReader208⟫_destroyBox⟪DataReader208⟫ in PersistableData, line 92")
if Bqx and Bsx!=0 then
set BUx=Bmx
set BSx=bDx("when calling alloc_NetworkWriteCallback_write_Persistable_PersistableData in PersistableData, line 95")
call bAx(BUx,BSx,"when calling write in PersistableData, line 95")
set BTx=b5x("when calling alloc_ForForceCallback_try_Persistable_PersistableData in PersistableData, line 98")
set WD[BTx]=Bmx
set ED[BTx]=Bsx
set ZD[BTx]=BLx
set Btx=FPe(BTx,"when calling try in PersistableData, line 98")
if Btx then
call Bcx(Bpx,"when calling dispatch_Box⟪integer⟫_destroyBox⟪integer⟫ in PersistableData, line 104")
if Bsx!=0 then
call b2x(Bsx,"when calling dispatch_DataReader_destroyDataReader in PersistableData, line 106")
endif
set EM=EM-1
return
else
set vM[Bpx]=2
endif
else
set vM[Bpx]=1
endif
set Bwx=Bmx
set Bux=b8x("when calling alloc_NetworkWriteCallback_write_Persistable_PersistableData in PersistableData, line 113")
set UD[Bux]=Bpx
call bAx(Bwx,Bux,"when calling write in PersistableData, line 113")
call Bcx(Bpx,"when calling dispatch_Box⟪integer⟫_destroyBox⟪integer⟫ in PersistableData, line 117")
if Bsx!=0 then
call b2x(Bsx,"when calling dispatch_DataReader_destroyDataReader in PersistableData, line 119")
endif
set EM=EM-1
endfunction
function BWx takes integer Byx,integer BYx,string Bzx returns nothing
set ZM[EM]=Bzx
set EM=EM+1
if Gg[Byx]==0 then
if Byx==0 then
call Cdv("Nullpointer exception when calling Persistable.readIntoNetwork","when calling error in PersistableData, line 75")
else
call Cdv("Called Persistable.readIntoNetwork on invalid object.","when calling error in PersistableData, line 75")
endif
endif
call Blx(Byx,BYx,"when calling readIntoNetwork in PersistableData, line 75")
set EM=EM-1
endfunction
function BZx takes integer L7t,integer X7t,integer C7t,string B_x returns nothing
set ZM[EM]=B_x
set EM=EM+1
call Cdv("Network: did not specify any callback function","when calling error in NetworkData, line 244")
set EM=EM-1
endfunction
function B0x takes integer B1x,integer B2x returns integer
local integer B3x=B2x
local integer B4x
if B3x==0 then
set B4x=NZ[B1x]
elseif B3x==1 then
set B4x=MZ[B1x]
elseif B3x==2 then
set B4x=wU[B1x]
else
set B4x=uU[B1x]
endif
return B4x
endfunction
function B5x takes integer B6x,integer B7x,string B8x returns integer
local integer B9x
set ZM[EM]=B8x
set EM=EM+1
if gY[B6x]==0 then
if B6x==0 then
call Cdv("Nullpointer exception when calling HashReader.getCount","when calling error in HashData, line 130")
else
call Cdv("Called HashReader.getCount on invalid object.","when calling error in HashData, line 130")
endif
endif
set B9x=B0x(B6x,B7x)
set EM=EM-1
return B9x
endfunction
function cvx takes integer cex,integer cxx returns integer
local integer cox=cxx
local integer crx
if cox==0 then
set crx=XZ[cex]
elseif cox==1 then
set crx=CZ[cex]
elseif cox==2 then
set crx=VZ[cex]
else
set crx=BZ[cex]
endif
return crx
endfunction
function cix takes integer cax,integer cnx,string cVx returns integer
local integer cEx
set ZM[EM]=cVx
set EM=EM+1
if gY[cax]==0 then
if cax==0 then
call Cdv("Nullpointer exception when calling HashReader.getReadIndex","when calling error in HashData, line 116")
else
call Cdv("Called HashReader.getReadIndex on invalid object.","when calling error in HashData, line 116")
endif
endif
set cEx=cvx(cax,cnx)
set EM=EM-1
return cEx
endfunction
function cXx takes integer cOx returns string
local integer cRx=cOx
local string cIx
if cRx==0 then
set cIx="integer"
elseif cRx==1 then
set cIx="real"
elseif cRx==2 then
set cIx="string"
else
set cIx="boolean"
endif
return cIx
endfunction
function cAx takes integer cNx,integer cbx returns boolean
local integer cBx=cbx
local boolean ccx
if cBx==0 then
set ccx=NZ[cNx]>XZ[cNx]
elseif cBx==1 then
set ccx=MZ[cNx]>CZ[cNx]
elseif cBx==2 then
set ccx=wU[cNx]>VZ[cNx]
else
set ccx=uU[cNx]>BZ[cNx]
endif
return ccx
endfunction
function cCx takes integer cdx,integer cDx,string cfx returns boolean
local boolean cFx
set ZM[EM]=cfx
set EM=EM+1
if gY[cdx]==0 then
if cdx==0 then
call Cdv("Nullpointer exception when calling HashReader.hasRemainingData","when calling error in HashData, line 102")
else
call Cdv("Called HashReader.hasRemainingData on invalid object.","when calling error in HashData, line 102")
endif
endif
set cFx=cAx(cdx,cDx)
set EM=EM-1
return cFx
endfunction
function cgx takes integer cGx,integer chx,string cHx returns nothing
set ZM[EM]=cHx
set EM=EM+1
if Ca and(not cCx(cGx,chx,"when calling hasRemainingData in HashData, line 146"))then
call Cdv("trying to read "+cXx(chx)+" at position "+SMv(cix(cGx,chx,"when calling getReadIndex in HashData, line 147"))+" out of "+SMv(B5x(cGx,chx,"when calling getCount in HashData, line 147")),"when calling error in HashData, line 147")
endif
set EM=EM-1
endfunction
function cjx takes integer cJx,integer ckx,string cKx returns nothing
set ZM[EM]=cKx
set EM=EM+1
if gY[cJx]==0 then
if cJx==0 then
call Cdv("Nullpointer exception when calling HashReader.validateType","when calling error in HashData, line 145")
else
call Cdv("Called HashReader.validateType on invalid object.","when calling error in HashData, line 145")
endif
endif
call cgx(cJx,ckx,"when calling validateType in HashData, line 145")
set EM=EM-1
endfunction
function clx takes integer cLx,string cmx returns integer
local integer cMx
set ZM[EM]=cmx
set EM=EM+1
set cMx=fwv(LZ[cLx],XZ[cLx],"when calling loadInt in HashData, line 161")
set XZ[cLx]=XZ[cLx]+1
set EM=EM-1
return cMx
endfunction
function cpx takes integer cPx,string cqx returns integer
local integer cQx
set ZM[EM]=cqx
set EM=EM+1
if gY[cPx]==0 then
if cPx==0 then
call Cdv("Nullpointer exception when calling HashReader.readIntUnchecked","when calling error in HashData, line 160")
else
call Cdv("Called HashReader.readIntUnchecked on invalid object.","when calling error in HashData, line 160")
endif
endif
set cQx=clx(cPx,"when calling readIntUnchecked in HashData, line 160")
set EM=EM-1
return cQx
endfunction
function csx takes integer cSx,string ctx returns integer
local integer cTx
set ZM[EM]=ctx
set EM=EM+1
call cjx(cSx,0,"when calling validateType in HashData, line 156")
set cTx=cpx(cSx,"when calling readIntUnchecked in HashData, line 157")
set EM=EM-1
return cTx
endfunction
function cux takes integer cUx,string cwx returns integer
local integer cWx
set ZM[EM]=cwx
set EM=EM+1
if gY[cUx]==0 then
if cUx==0 then
call Cdv("Nullpointer exception when calling HashReader.readInt","when calling error in HashData, line 155")
else
call Cdv("Called HashReader.readInt on invalid object.","when calling error in HashData, line 155")
endif
endif
set cWx=csx(cUx,"when calling readInt in HashData, line 155")
set EM=EM-1
return cWx
endfunction
function cyx takes integer cYx returns boolean
return cYx!=0
endfunction
function czx takes integer cZx,string c_x returns nothing
local integer c0x
local integer c1x
local integer c2x
local integer c3x
set ZM[EM]=c_x
set EM=EM+1
set pW[cZx]=pW[cZx]+1
set c0x=Uee(fwv(uW[cZx],pW[cZx],"when calling loadInt in ByteBuffer, line 41"))
set c1x=BM
set c2x=NM
set c3x=MM
set cW[cZx]=c0x
set oW[cZx]=c1x
set OW[cZx]=c2x
set lW[cZx]=c3x
set bW[cZx]=0
set EM=EM-1
endfunction
function c4x takes integer c5x,string c6x returns nothing
set ZM[EM]=c6x
set EM=EM+1
if EG[c5x]==0 then
if c5x==0 then
call Cdv("Nullpointer exception when calling ByteBuffer.loadInt","when calling error in ByteBuffer, line 39")
else
call Cdv("Called ByteBuffer.loadInt on invalid object.","when calling error in ByteBuffer, line 39")
endif
endif
call czx(c5x,"when calling loadInt in ByteBuffer, line 39")
set EM=EM-1
endfunction
function c7x takes integer c8x,integer c9x,integer Cvx,integer Cex,integer Cxx returns integer
local integer Cox
if Cxx>1 then
if Cxx==3 then
set Cox=Cex
else
set Cox=Cvx
endif
elseif Cxx==1 then
set Cox=c9x
else
set Cox=c8x
endif
return Cox
endfunction
function Crx takes integer Cix,string Cax returns integer
local integer Cnx
set ZM[EM]=Cax
set EM=EM+1
if bW[Cix]>3 then
call c4x(Cix,"when calling loadInt in ByteBuffer, line 52")
endif
set Cnx=c7x(cW[Cix],oW[Cix],OW[Cix],lW[Cix],bW[Cix])
set bW[Cix]=bW[Cix]+1
set EM=EM-1
return Cnx
endfunction
function CVx takes integer CEx,string CXx returns integer
local integer COx
set ZM[EM]=CXx
set EM=EM+1
if EG[CEx]==0 then
if CEx==0 then
call Cdv("Nullpointer exception when calling ByteBuffer.readByteInternal","when calling error in ByteBuffer, line 50")
else
call Cdv("Called ByteBuffer.readByteInternal on invalid object.","when calling error in ByteBuffer, line 50")
endif
endif
set COx=Crx(CEx,"when calling readByteInternal in ByteBuffer, line 50")
set EM=EM-1
return COx
endfunction
function CRx takes integer CIx,string CAx returns integer
local integer CNx
set ZM[EM]=CAx
set EM=EM+1
set CNx=CVx(CIx,"when calling readByteInternal in ByteBuffer, line 76")
set EM=EM-1
return CNx
endfunction
function Cbx takes integer CBx,string Ccx returns integer
local integer CCx
set ZM[EM]=Ccx
set EM=EM+1
if EG[CBx]==0 then
if CBx==0 then
call Cdv("Nullpointer exception when calling ByteBuffer.readByte","when calling error in ByteBuffer, line 75")
else
call Cdv("Called ByteBuffer.readByte on invalid object.","when calling error in ByteBuffer, line 75")
endif
endif
set CCx=CRx(CBx,"when calling readByte in ByteBuffer, line 75")
set EM=EM-1
return CCx
endfunction
function Cdx takes integer CDx,string Cfx returns boolean
local boolean CFx
set ZM[EM]=Cfx
set EM=EM+1
set CFx=cyx(Cbx(aQ[CDx],"when calling readByte in Base64Data, line 105"))
set EM=EM-1
return CFx
endfunction
function Cgx takes integer CGx,boolean Chx,string CHx returns nothing
set ZM[EM]=CHx
set EM=EM+1
if jY[CGx]==0 then
if CGx==0 then
call Cdv("Nullpointer exception when calling HashWriter.writeBoolean","when calling error in HashData, line 34")
else
call Cdv("Called HashWriter.writeBoolean on invalid object.","when calling error in HashData, line 34")
endif
endif
call yVe(CGx,Chx,"when calling writeBoolean in HashData, line 34")
set EM=EM-1
endfunction
function Cjx takes integer CJx,integer Ckx returns boolean
return cZv(XR,CJx,Ckx)
endfunction
function CKx takes integer Clx,integer CLx,string Cmx returns boolean
local boolean CMx
set ZM[EM]=Cmx
set EM=EM+1
if ph[Clx]==0 then
if Clx==0 then
call Cdv("Nullpointer exception when calling Table.loadBoolean","when calling error in Table, line 51")
else
call Cdv("Called Table.loadBoolean on invalid object.","when calling error in Table, line 51")
endif
endif
set CMx=Cjx(Clx,CLx)
set EM=EM-1
return CMx
endfunction
function Cpx takes integer CPx,string Cqx returns boolean
local boolean CQx
set ZM[EM]=Cqx
set EM=EM+1
set CQx=CKx(LZ[CPx],BZ[CPx],"when calling loadBoolean in HashData, line 181")
set BZ[CPx]=BZ[CPx]+1
set EM=EM-1
return CQx
endfunction
function Csx takes integer CSx,string Ctx returns boolean
local boolean CTx
set ZM[EM]=Ctx
set EM=EM+1
if gY[CSx]==0 then
if CSx==0 then
call Cdv("Nullpointer exception when calling HashReader.readBooleanUnchecked","when calling error in HashData, line 180")
else
call Cdv("Called HashReader.readBooleanUnchecked on invalid object.","when calling error in HashData, line 180")
endif
endif
set CTx=Cpx(CSx,"when calling readBooleanUnchecked in HashData, line 180")
set EM=EM-1
return CTx
endfunction
function Cux takes integer CUx,string Cwx returns boolean
local boolean CWx
set ZM[EM]=Cwx
set EM=EM+1
call cjx(CUx,3,"when calling validateType in HashData, line 176")
set CWx=Csx(CUx,"when calling readBooleanUnchecked in HashData, line 177")
set EM=EM-1
return CWx
endfunction
function Cyx takes integer CYx,integer Czx,string CZx returns nothing
local boolean C_x
local boolean C0x
if CYx==0 then
set ZM[EM]=CZx
set EM=EM+1
if gY[Czx]==0 then
if Czx==0 then
call Cdv("Nullpointer exception when calling DataReader.readBoolean","when calling error in DataInterfaces, line 96")
else
call Cdv("Called DataReader.readBoolean on invalid object.","when calling error in DataInterfaces, line 96")
endif
endif
if gY[Czx]<=$6CF then
if gY[Czx]<=$6CE then
set C_x=Cdx(Czx,"when calling readBoolean in DataInterfaces, line 96")
else
call Cyx(1,Czx,"when calling readBoolean in DataInterfaces, line 96")
set C_x=Rjv
endif
else
set C_x=Cux(Czx,"when calling readBoolean in DataInterfaces, line 96")
endif
set EM=EM-1
set Rjv=C_x
return
elseif CYx==1 then
set ZM[EM]=CZx
set EM=EM+1
call Cyx(0,KZ[Czx],"when calling readBoolean in HashData, line 262")
set C0x=Rjv
call Cgx(JZ[Czx],C0x,"when calling writeBoolean in HashData, line 263")
set EM=EM-1
set Rjv=C0x
return
endif
endfunction
function C1x takes integer C2x,integer C3x returns integer
return C2x*xy[C3x]
endfunction
function C4x takes integer C5x,integer C6x returns integer
return C1x(C5x,C6x)
endfunction
function C7x takes integer C8x,string C9x returns integer
local integer dvx
set ZM[EM]=C9x
set EM=EM+1
set dvx=CVx(C8x,"when calling readByteInternal in ByteBuffer, line 84")+C4x(CVx(C8x,"when calling readByteInternal in ByteBuffer, line 84"),8)+C4x(CVx(C8x,"when calling readByteInternal in ByteBuffer, line 84"),16)+C4x(CVx(C8x,"when calling readByteInternal in ByteBuffer, line 84"),24)
set EM=EM-1
return dvx
endfunction
function dex takes integer dxx,string dox returns integer
local integer drx
set ZM[EM]=dox
set EM=EM+1
if EG[dxx]==0 then
if dxx==0 then
call Cdv("Nullpointer exception when calling ByteBuffer.readInt","when calling error in ByteBuffer, line 83")
else
call Cdv("Called ByteBuffer.readInt on invalid object.","when calling error in ByteBuffer, line 83")
endif
endif
set drx=C7x(dxx,"when calling readInt in ByteBuffer, line 83")
set EM=EM-1
return drx
endfunction
function dix takes integer dax,string dnx returns integer
local integer dVx
set ZM[EM]=dnx
set EM=EM+1
set dVx=dex(aQ[dax],"when calling readInt in Base64Data, line 94")
set EM=EM-1
return dVx
endfunction
function dEx takes integer dXx,integer dOx,string dRx returns nothing
local integer dIx
local integer dAx
if dXx==0 then
set ZM[EM]=dRx
set EM=EM+1
if gY[dOx]==0 then
if dOx==0 then
call Cdv("Nullpointer exception when calling DataReader.readInt","when calling error in DataInterfaces, line 90")
else
call Cdv("Called DataReader.readInt on invalid object.","when calling error in DataInterfaces, line 90")
endif
endif
if gY[dOx]<=$6CF then
if gY[dOx]<=$6CE then
set dIx=dix(dOx,"when calling readInt in DataInterfaces, line 90")
else
call dEx(1,dOx,"when calling readInt in DataInterfaces, line 90")
set dIx=RJv
endif
else
set dIx=csx(dOx,"when calling readInt in DataInterfaces, line 90")
endif
set EM=EM-1
set RJv=dIx
return
elseif dXx==1 then
set ZM[EM]=dRx
set EM=EM+1
call dEx(0,KZ[dOx],"when calling readInt in HashData, line 250")
set dAx=RJv
call uae(JZ[dOx],dAx,"when calling writeInt in HashData, line 251")
set EM=EM-1
set RJv=dAx
return
endif
endfunction
function dNx takes integer dbx,string dBx returns boolean
local boolean dcx
local integer dCx
local boolean ddx
local integer dDx
set ZM[EM]=dBx
set EM=EM+1
call Cyx(0,dbx,"when calling readBoolean in CustomUnitTypes, line 25")
set ddx=Rjv
set dDx=0
set dcx=ddx
set dCx=dDx
if not dcx then
call dEx(0,dbx,"when calling readInt in CustomUnitTypes, line 27")
set dCx=RJv
endif
set EM=EM-1
set Y3=dcx
set G3=dCx
return Y3
endfunction
function dfx takes integer dFx,integer dgx returns real
return DFv(XR,dFx,dgx)
endfunction
function dGx takes integer dhx,integer dHx,string djx returns real
local real dJx
set ZM[EM]=djx
set EM=EM+1
if ph[dhx]==0 then
if dhx==0 then
call Cdv("Nullpointer exception when calling Table.loadReal","when calling error in Table, line 45")
else
call Cdv("Called Table.loadReal on invalid object.","when calling error in Table, line 45")
endif
endif
set dJx=dfx(dhx,dHx)
set EM=EM-1
return dJx
endfunction
function dkx takes integer dKx,string dlx returns real
local real dLx
set ZM[EM]=dlx
set EM=EM+1
set dLx=dGx(LZ[dKx],CZ[dKx],"when calling loadReal in HashData, line 171")
set CZ[dKx]=CZ[dKx]+1
set EM=EM-1
return dLx
endfunction
function dmx takes integer dMx,string dpx returns real
local real dPx
set ZM[EM]=dpx
set EM=EM+1
if gY[dMx]==0 then
if dMx==0 then
call Cdv("Nullpointer exception when calling HashReader.readRealUnchecked","when calling error in HashData, line 170")
else
call Cdv("Called HashReader.readRealUnchecked on invalid object.","when calling error in HashData, line 170")
endif
endif
set dPx=dkx(dMx,"when calling readRealUnchecked in HashData, line 170")
set EM=EM-1
return dPx
endfunction
function dqx takes integer dQx,string dsx returns real
local real dSx
set ZM[EM]=dsx
set EM=EM+1
call cjx(dQx,1,"when calling validateType in HashData, line 166")
set dSx=dmx(dQx,"when calling readRealUnchecked in HashData, line 167")
set EM=EM-1
return dSx
endfunction
function dtx takes integer dTx,string dux returns integer
local integer dUx
set ZM[EM]=dux
set EM=EM+1
set dUx=CVx(dTx,"when calling readByteInternal in ByteBuffer, line 80")+C4x(CVx(dTx,"when calling readByteInternal in ByteBuffer, line 80"),8)
set EM=EM-1
return dUx
endfunction
function dwx takes integer dWx,string dyx returns integer
local integer dYx
set ZM[EM]=dyx
set EM=EM+1
if EG[dWx]==0 then
if dWx==0 then
call Cdv("Nullpointer exception when calling ByteBuffer.readShort","when calling error in ByteBuffer, line 79")
else
call Cdv("Called ByteBuffer.readShort on invalid object.","when calling error in ByteBuffer, line 79")
endif
endif
set dYx=dtx(dWx,"when calling readShort in ByteBuffer, line 79")
set EM=EM-1
return dYx
endfunction
function dzx takes integer dZx,string d_x returns real
local integer d0x
local integer d1x
local real d2x
set ZM[EM]=d_x
set EM=EM+1
set d0x=dex(aQ[dZx],"when calling readInt in Base64Data, line 97")
set d1x=dwx(aQ[dZx],"when calling readShort in Base64Data, line 98")
set d2x=.0
if d1x>0 then
set d2x=1./DQv(d1x)
endif
set EM=EM-1
return d0x+d2x
endfunction
function d3x takes integer d4x,real d5x,string d6x returns nothing
set ZM[EM]=d6x
set EM=EM+1
if jY[d4x]==0 then
if d4x==0 then
call Cdv("Nullpointer exception when calling HashWriter.writeReal","when calling error in HashData, line 30")
else
call Cdv("Called HashWriter.writeReal on invalid object.","when calling error in HashData, line 30")
endif
endif
call yPe(d4x,d5x,"when calling writeReal in HashData, line 30")
set EM=EM-1
endfunction
function d7x takes integer d8x,integer d9x,string Dvx returns nothing
local real Dex
local real Dxx
if d8x==0 then
set ZM[EM]=Dvx
set EM=EM+1
if gY[d9x]==0 then
if d9x==0 then
call Cdv("Nullpointer exception when calling DataReader.readReal","when calling error in DataInterfaces, line 93")
else
call Cdv("Called DataReader.readReal on invalid object.","when calling error in DataInterfaces, line 93")
endif
endif
if gY[d9x]<=$6CF then
if gY[d9x]<=$6CE then
set Dex=dzx(d9x,"when calling readReal in DataInterfaces, line 93")
else
call d7x(1,d9x,"when calling readReal in DataInterfaces, line 93")
set Dex=Rkv
endif
else
set Dex=dqx(d9x,"when calling readReal in DataInterfaces, line 93")
endif
set EM=EM-1
set Rkv=Dex
return
elseif d8x==1 then
set ZM[EM]=Dvx
set EM=EM+1
call d7x(0,KZ[d9x],"when calling readReal in HashData, line 256")
set Dxx=Rkv
call d3x(JZ[d9x],Dxx,"when calling writeReal in HashData, line 257")
set EM=EM-1
set Rkv=Dxx
return
endif
endfunction
function Dox takes integer Drx,string Dix returns boolean
local boolean Dax
local real Dnx
local boolean DVx
local real DEx
set ZM[EM]=Dix
set EM=EM+1
call Cyx(0,Drx,"when calling readBoolean in CustomUnitTypes, line 40")
set DVx=Rjv
set DEx=.0
set Dax=DVx
set Dnx=DEx
if not Dax then
call d7x(0,Drx,"when calling readReal in CustomUnitTypes, line 42")
set Dnx=Rkv
endif
set EM=EM-1
set g3=Dax
set h3=Dnx
return g3
endfunction
function DXx takes integer DOx,string DRx returns boolean
local boolean DIx
local integer DAx
local boolean DNx
local real Dbx
local boolean DBx
local integer Dcx
local boolean DCx
local integer Ddx
local boolean DDx
local integer Dfx
local boolean DFx
local real Dgx
local boolean DGx
local integer Dhx
local boolean DHx
local integer Djx
set ZM[EM]=DRx
set EM=EM+1
set DDx=dNx(DOx,"when calling readOptInt in CustomUnitTypes, line 67")
set Dfx=G3
set DFx=Dox(DOx,"when calling readOptReal in CustomUnitTypes, line 67")
set Dgx=h3
set DGx=dNx(DOx,"when calling readOptInt in CustomUnitTypes, line 67")
set Dhx=G3
set DHx=dNx(DOx,"when calling readOptInt in CustomUnitTypes, line 67")
set Djx=G3
set DIx=DDx
set DAx=Dfx
set DNx=DFx
set Dbx=Dgx
set DBx=DGx
set Dcx=Dhx
set DCx=DHx
set Ddx=Djx
set EM=EM-1
set F3=DIx
set k3=DAx
set j3=DNx
set x3=Dbx
set v3=DBx
set m3=Dcx
set Q3=DCx
set W3=Ddx
return F3
endfunction
function DJx takes integer Dkx,integer DKx,string Dlx returns nothing
local boolean DLx
local integer Dmx
local boolean DMx
local real Dpx
local boolean DPx
local integer Dqx
local boolean DQx
local integer Dsx
local boolean DSx
local integer Dtx
local boolean DTx
local real Dux
local boolean DUx
local integer Dwx
local boolean DWx
local integer Dyx
set ZM[EM]=Dlx
set EM=EM+1
call dEx(0,DKx,"when calling readInt in CustomUnitTypes, line 198")
set EW[Dkx]=RJv
set DLx=DXx(DKx,"when calling readAttackData in CustomUnitTypes, line 199")
set Dmx=k3
set DMx=j3
set Dpx=x3
set DPx=v3
set Dqx=m3
set DQx=Q3
set Dsx=W3
set ZW[Dkx]=DLx
set UW[Dkx]=Dmx
set IW[Dkx]=DMx
set PW[Dkx]=Dpx
set AW[Dkx]=DPx
set DW[Dkx]=Dqx
set HW[Dkx]=DQx
set JW[Dkx]=Dsx
set DSx=DXx(DKx,"when calling readAttackData in CustomUnitTypes, line 200")
set Dtx=k3
set DTx=j3
set Dux=x3
set DUx=v3
set Dwx=m3
set DWx=Q3
set Dyx=W3
set KW[Dkx]=DSx
set LW[Dkx]=Dtx
set XW[Dkx]=DTx
set CW[Dkx]=Dux
set VW[Dkx]=DUx
set BW[Dkx]=Dwx
set NW[Dkx]=DWx
set MW[Dkx]=Dyx
set EM=EM-1
endfunction
function DYx takes integer Dzx,integer DZx,string D_x returns nothing
set ZM[EM]=D_x
set EM=EM+1
if Gg[Dzx]==0 then
if Dzx==0 then
call Cdv("Nullpointer exception when calling CustomUnitType.deserialize","when calling error in CustomUnitTypes, line 197")
else
call Cdv("Called CustomUnitType.deserialize on invalid object.","when calling error in CustomUnitTypes, line 197")
endif
endif
call DJx(Dzx,DZx,"when calling deserialize in CustomUnitTypes, line 197")
set EM=EM-1
endfunction
function D0x takes integer D1x,integer D2x,string D3x returns nothing
local integer D4x
local integer D5x
set ZM[EM]=D3x
set EM=EM+1
set D4x=0
call dEx(0,D2x,"when calling readInt in PlayerDefinedUnitTypes, line 35")
set D5x=bUe(RJv,Mq)-1
loop
exitwhen D4x>D5x
call DYx(tQe(D1x,D4x,"when calling getSlot in PlayerDefinedUnitTypes, line 36"),D2x,"when calling deserialize in PlayerDefinedUnitTypes, line 36")
set D4x=D4x+1
endloop
set EM=EM-1
endfunction
function D6x takes integer D7x,string D8x returns integer
local integer D9x
set ZM[EM]=D8x
set EM=EM+1
set D9x=cux(D7x,"when calling readInt in HashData, line 150")
set EM=EM-1
return D9x
endfunction
function fvx takes integer fex,string fxx returns integer
local integer fox
set ZM[EM]=fxx
set EM=EM+1
set fox=Cbx(aQ[fex],"when calling readByte in Base64Data, line 88")
set EM=EM-1
return fox
endfunction
function frx takes integer fix,integer fax,string fnx returns nothing
set ZM[EM]=fnx
set EM=EM+1
if jY[fix]==0 then
if fix==0 then
call Cdv("Nullpointer exception when calling HashWriter.writeByte","when calling error in HashData, line 20")
else
call Cdv("Called HashWriter.writeByte on invalid object.","when calling error in HashData, line 20")
endif
endif
call uXe(fix,fax,"when calling writeByte in HashData, line 20")
set EM=EM-1
endfunction
function fVx takes integer fEx,integer fXx,string fOx returns nothing
local integer fRx
local integer fIx
if fEx==0 then
set ZM[EM]=fOx
set EM=EM+1
if gY[fXx]==0 then
if fXx==0 then
call Cdv("Nullpointer exception when calling DataReader.readByte","when calling error in DataInterfaces, line 84")
else
call Cdv("Called DataReader.readByte on invalid object.","when calling error in DataInterfaces, line 84")
endif
endif
if gY[fXx]<=$6CF then
if gY[fXx]<=$6CE then
set fRx=fvx(fXx,"when calling readByte in DataInterfaces, line 84")
else
call fVx(1,fXx,"when calling readByte in DataInterfaces, line 84")
set fRx=RJv
endif
else
set fRx=D6x(fXx,"when calling readByte in DataInterfaces, line 84")
endif
set EM=EM-1
set RJv=fRx
return
elseif fEx==1 then
set ZM[EM]=fOx
set EM=EM+1
call fVx(0,KZ[fXx],"when calling readByte in HashData, line 238")
set fIx=RJv
call frx(JZ[fXx],fIx,"when calling writeByte in HashData, line 239")
set EM=EM-1
set RJv=fIx
return
endif
endfunction
function fAx takes integer fNx,string fbx returns integer
local integer fBx
set ZM[EM]=fbx
set EM=EM+1
set fBx=dwx(aQ[fNx],"when calling readShort in Base64Data, line 91")
set EM=EM-1
return fBx
endfunction
function fcx takes integer fCx,integer fdx,string fDx returns nothing
set ZM[EM]=fDx
set EM=EM+1
if jY[fCx]==0 then
if fCx==0 then
call Cdv("Nullpointer exception when calling HashWriter.writeShort","when calling error in HashData, line 23")
else
call Cdv("Called HashWriter.writeShort on invalid object.","when calling error in HashData, line 23")
endif
endif
call uUe(fCx,fdx,"when calling writeShort in HashData, line 23")
set EM=EM-1
endfunction
function ffx takes integer fFx,string fgx returns integer
local integer fGx
set ZM[EM]=fgx
set EM=EM+1
set fGx=cux(fFx,"when calling readInt in HashData, line 153")
set EM=EM-1
return fGx
endfunction
function fhx takes integer fHx,integer fjx,string fJx returns nothing
local integer fkx
local integer fKx
if fHx==0 then
set ZM[EM]=fJx
set EM=EM+1
call fhx(1,KZ[fjx],"when calling readShort in HashData, line 244")
set fkx=RJv
call fcx(JZ[fjx],fkx,"when calling writeShort in HashData, line 245")
set EM=EM-1
set RJv=fkx
return
elseif fHx==1 then
set ZM[EM]=fJx
set EM=EM+1
if gY[fjx]==0 then
if fjx==0 then
call Cdv("Nullpointer exception when calling DataReader.readShort","when calling error in DataInterfaces, line 87")
else
call Cdv("Called DataReader.readShort on invalid object.","when calling error in DataInterfaces, line 87")
endif
endif
if gY[fjx]<=$6CF then
if gY[fjx]<=$6CE then
set fKx=fAx(fjx,"when calling readShort in DataInterfaces, line 87")
else
call fhx(0,fjx,"when calling readShort in DataInterfaces, line 87")
set fKx=RJv
endif
else
set fKx=ffx(fjx,"when calling readShort in DataInterfaces, line 87")
endif
set EM=EM-1
set RJv=fKx
return
endif
endfunction
function flx takes integer fLx,integer fmx,string fMx returns integer
local integer fpx
local integer fPx
local integer fqx
local integer fQx
local integer fsx
local integer fSx
set ZM[EM]=fMx
set EM=EM+1
if qH[fmx]then
if aH[fmx]then
call dEx(0,fLx,"when calling readInt in RawcodeTable, line 35")
set fQx=RJv
set fpx=fQx
set EM=EM-1
set h1=fpx
return h1
else
call fhx(1,fLx,"when calling readShort in RawcodeTable, line 37")
set fsx=RJv
set fqx=fsx
set EM=EM-1
set h1=fqx
return h1
endif
else
call fVx(0,fLx,"when calling readByte in RawcodeTable, line 39")
set fSx=RJv
set fPx=fSx
set EM=EM-1
set h1=fPx
return h1
endif
endfunction
function ftx takes integer fTx,integer fux returns boolean
return n9e(fTx,fux)
endfunction
function fUx takes integer fwx,integer fWx,string fyx returns nothing
local integer fYx
local integer fzx
local integer fZx
local integer f_x
local integer f0x
local integer f1x
local integer f2x
set ZM[EM]=fyx
set EM=EM+1
call fVx(0,fWx,"when calling readByte in RawcodeTable, line 76")
set f0x=RJv
set eH[fwx]=f0x
set qH[fwx]=ftx(eH[fwx],0)
set aH[fwx]=ftx(eH[fwx],1)
set f1x=flx(fWx,fwx,"when calling readRawcodeTableIndex in RawcodeTable, line 81")
set fzx=f1x
set fYx=fzx
set fZx=0
set f_x=fYx-1
loop
exitwhen fZx>f_x
set f2x=fwx
call dEx(0,fWx,"when calling readInt in RawcodeTable, line 83")
call Fav(f2x,RJv,"when calling addRawcode in RawcodeTable, line 83")
set fZx=fZx+1
endloop
set EM=EM-1
endfunction
function f3x takes integer f4x,integer f5x returns boolean
return n9e(f4x,f5x)
endfunction
function f6x takes integer KdS returns nothing
endfunction
function f7x takes integer f8x,string f9x returns nothing
call f6x(f8x)
set QM[f8x]=f9x
endfunction
function Fvx takes string Fex returns integer
local integer Fxx
set ZM[EM]=Fex
set EM=EM+1
if Mm==0 then
if wQ<$8000 then
set wQ=wQ+1
set Fxx=wQ
set uQ[Fxx]=$41D
else
call Cdv("Out of memory: Could not create Box⟪string⟫.","when calling error in Box, line 14")
set Fxx=0
endif
else
set Mm=Mm-1
set Fxx=Nm[Mm]
set uQ[Fxx]=$41D
endif
set EM=EM-1
return Fxx
endfunction
function Fox takes string Frx,string Fix returns integer
local integer Fax
set ZM[EM]=Fix
set EM=EM+1
set Fax=Fvx("when calling alloc_Box⟪string⟫ in Box, line 17")
call f7x(Fax,Frx)
set EM=EM-1
return Fax
endfunction
function Fnx takes string FVx returns integer
local integer FEx
set ZM[EM]=FVx
set EM=EM+1
if CY==0 then
if VY<$8000 then
set VY=VY+1
set FEx=VY
set BY[FEx]=$863
else
call Cdv("Out of memory: Could not create ForForceCallback_execute_StringTable_StringTable.","when calling error in StringTable, line 73")
set FEx=0
endif
else
set CY=CY-1
set FEx=XY[CY]
set BY[FEx]=$863
endif
set EM=EM-1
return FEx
endfunction
function FXx takes integer FOx,string FRx returns nothing
set ZM[EM]=FRx
set EM=EM+1
if uQ[FOx]==0 then
call Cdv("Double free: object of type Box⟪string⟫","when calling error in Box, line 14")
else
set Nm[Mm]=FOx
set Mm=Mm+1
set uQ[FOx]=0
endif
set EM=EM-1
endfunction
function FIx takes integer FAx,string FNx returns nothing
set ZM[EM]=FNx
set EM=EM+1
call Bex(FAx)
call FXx(FAx,"when calling dealloc_Box⟪string⟫ in Box, line 13")
set EM=EM-1
endfunction
function Fbx takes integer FBx,string Fcx returns nothing
set ZM[EM]=Fcx
set EM=EM+1
if uQ[FBx]==0 then
if FBx==0 then
call Cdv("Nullpointer exception when calling Box⟪string⟫.Box","when calling error in Box, line 14")
else
call Cdv("Called Box⟪string⟫.Box on invalid object.","when calling error in Box, line 14")
endif
endif
call FIx(FBx,"when calling destroyBox⟪string⟫ in Box, line 14")
set EM=EM-1
endfunction
function FCx takes integer gBi,integer Fdx,string FDx returns string
local integer Ffx
local integer FFx
local integer Fgx
local string FGx
set ZM[EM]=FDx
set EM=EM+1
call fhx(1,Fdx,"when calling readShort in StringTable, line 71")
set Ffx=RJv
set FFx=Fox("","when calling new_Box⟪string⟫ in StringTable, line 72")
set Fgx=Fnx("when calling alloc_ForForceCallback_execute_StringTable_StringTable in StringTable, line 73")
set sC[Fgx]=Ffx
set tC[Fgx]=FFx
set iC[Fgx]=Fdx
call Fte(Fgx,"when calling execute in StringTable, line 73")
set FGx=QM[FFx]
call Fbx(FFx,"when calling dispatch_Box⟪string⟫_destroyBox⟪string⟫ in StringTable, line 77")
set EM=EM-1
return FGx
endfunction
function Fhx takes integer FHx,integer Fjx,string FJx returns string
local string Fkx
set ZM[EM]=FJx
set EM=EM+1
if Gg[FHx]==0 then
if FHx==0 then
call Cdv("Nullpointer exception when calling StringTable.deserializeString","when calling error in StringTable, line 70")
else
call Cdv("Called StringTable.deserializeString on invalid object.","when calling error in StringTable, line 70")
endif
endif
set Fkx=FCx(FHx,Fjx,"when calling deserializeString in StringTable, line 70")
set EM=EM-1
return Fkx
endfunction
function FKx takes integer Flx,integer FLx,string Fmx returns integer
local integer FMx
local integer Fpx
local integer FPx
local integer Fqx
local integer FQx
local integer Fsx
set ZM[EM]=Fmx
set EM=EM+1
if VX[FLx]then
if BX[FLx]then
call dEx(0,Flx,"when calling readInt in StringTable, line 37")
set Fqx=RJv
set Fpx=Fqx
set EM=EM-1
set r4=Fpx
return r4
else
call fhx(1,Flx,"when calling readShort in StringTable, line 39")
set FQx=RJv
set FPx=FQx
set EM=EM-1
set r4=FPx
return r4
endif
else
call fVx(0,Flx,"when calling readByte in StringTable, line 41")
set Fsx=RJv
set FMx=Fsx
set EM=EM-1
set r4=FMx
return r4
endif
endfunction
function FSx takes integer Ftx,integer FTx,string Fux returns nothing
local integer FUx
local integer Fwx
local integer FWx
local integer Fyx
local string FYx
local integer Fzx
local integer FZx
set ZM[EM]=Fux
set EM=EM+1
call fVx(0,FTx,"when calling readByte in StringTable, line 95")
set Fzx=RJv
set CX[Ftx]=Fzx
set VX[Ftx]=f3x(CX[Ftx],0)
set BX[Ftx]=f3x(CX[Ftx],1)
set FZx=FKx(FTx,Ftx,"when calling readStringTableIndex in StringTable, line 100")
set Fwx=FZx
set FUx=Fwx
set FWx=0
set Fyx=FUx-1
loop
exitwhen FWx>Fyx
set FYx=Fhx(Ftx,FTx,"when calling deserializeString in StringTable, line 102")
call vre(Ftx,FYx,"when calling addString in StringTable, line 103")
set FWx=FWx+1
endloop
set EM=EM-1
endfunction
function F_x takes integer F0x,integer F1x,string F2x returns nothing
set ZM[EM]=F2x
set EM=EM+1
if Gg[F0x]==0 then
if F0x==0 then
call Cdv("Nullpointer exception when calling StringTable.deserialize","when calling error in StringTable, line 94")
else
call Cdv("Called StringTable.deserialize on invalid object.","when calling error in StringTable, line 94")
endif
endif
call FSx(F0x,F1x,"when calling deserialize in StringTable, line 94")
set EM=EM-1
endfunction
function F3x takes integer F4x,string F5x returns nothing
local integer F6x
local real F7x
local real F8x
local real F9x
local real gvx
set ZM[EM]=F5x
set EM=EM+1
set F6x=0
set nC[F4x]=F6x
set F7x=F7v()
set F8x=a1
set dC[F4x]=F7x
set fC[F4x]=F8x
set F9x=F7v()
set gvx=a1
set RC[F4x]=F9x
set TC[F4x]=gvx
set YC[F4x]=TEv("when calling new_HashList in TerrainData, line 37")
set GC[F4x]=TEv("when calling new_HashList in TerrainData, line 38")
set EM=EM-1
endfunction
function gex takes integer gxx,integer gox,string grx returns nothing
set ZM[EM]=grx
set EM=EM+1
call F3x(gxx,"when calling SubRectTileData_init in TerrainData, line 44")
set aC[gxx]=gox
set EM=EM-1
endfunction
function gix takes string gax returns integer
local integer gnx
set ZM[EM]=gax
set EM=EM+1
if vv==0 then
if mv<$8000 then
set mv=mv+1
set gnx=mv
set Qv[gnx]=4867
else
call Cdv("Out of memory: Could not create SubRectTileData.","when calling error in TerrainData, line 28")
set gnx=0
endif
else
set vv=vv-1
set gnx=xv[vv]
set Qv[gnx]=4867
endif
set EM=EM-1
return gnx
endfunction
function gVx takes integer gEx,string gXx returns integer
local integer gOx
set ZM[EM]=gXx
set EM=EM+1
set gOx=gix("when calling alloc_SubRectTileData in TerrainData, line 44")
call gex(gOx,gEx,"when calling construct_SubRectTileData in TerrainData, line 44")
set EM=EM-1
return gOx
endfunction
function gRx takes integer gIx,integer gAx,string gNx returns nothing
set ZM[EM]=gNx
set EM=EM+1
if Gg[gIx]==0 then
if gIx==0 then
call Cdv("Nullpointer exception when calling RawcodeTable.deserialize","when calling error in RawcodeTable, line 75")
else
call Cdv("Called RawcodeTable.deserialize on invalid object.","when calling error in RawcodeTable, line 75")
endif
endif
call fUx(gIx,gAx,"when calling deserialize in RawcodeTable, line 75")
set EM=EM-1
endfunction
function gbx takes integer gBx,string gcx returns real
local integer gCx
local integer gdx
local real gDx
local real gfx
local real gFx
local real ggx
set ZM[EM]=gcx
set EM=EM+1
call fhx(1,gBx,"when calling readShort in PointData, line 21")
set gCx=RJv-$7FFF
call fhx(1,gBx,"when calling readShort in PointData, line 22")
set gdx=RJv-$7FFF
set gFx=DQv(gCx)
set ggx=DQv(gdx)
set gDx=gFx
set gfx=ggx
set EM=EM-1
set T1=gDx
set Y1=gfx
return T1
endfunction
function gGx takes integer ghx,integer gHx,string gjx returns nothing
local integer gJx
local boolean gkx
local integer gKx
local integer glx
local integer gLx
local integer gmx
local integer gMx
local real gpx
local real gPx
local real gqx
local real gQx
local integer gsx
local integer gSx
set ZM[EM]=gjx
set EM=EM+1
call fVx(0,gHx,"when calling readByte in TerrainData, line 108")
set gMx=RJv
set nC[ghx]=gMx
set gpx=gbx(gHx,"when calling readPointData in TerrainData, line 110")
set gPx=Y1
set dC[ghx]=gpx
set fC[ghx]=gPx
set gqx=gbx(gHx,"when calling readPointData in TerrainData, line 111")
set gQx=Y1
set RC[ghx]=gqx
set TC[ghx]=gQx
if Y4e(nC[ghx],0)then
if Y4e(nC[ghx],1)then
call dEx(0,gHx,"when calling readInt in TerrainData, line 116")
set gJx=RJv
else
call fhx(1,gHx,"when calling readShort in TerrainData, line 118")
set gJx=RJv
endif
else
call fVx(0,gHx,"when calling readByte in TerrainData, line 120")
set gJx=RJv
endif
set gkx=Y4e(nC[ghx],2)
set gKx=0
set glx=gJx-1
loop
exitwhen gKx>glx
set gmx=YC[ghx]
set gsx=flx(gHx,aC[ghx],"when calling readRawcodeTableIndex in TerrainData, line 124")
set gLx=gsx
call dlv(gmx,gLx,"when calling add in TerrainData, line 124")
if gkx then
set gSx=GC[ghx]
call fVx(0,gHx,"when calling readByte in TerrainData, line 126")
call dlv(gSx,RJv,"when calling add in TerrainData, line 126")
endif
set gKx=gKx+1
endloop
set EM=EM-1
endfunction
function gtx takes integer gTx,integer gux,string gUx returns nothing
set ZM[EM]=gUx
set EM=EM+1
if Qv[gTx]==0 then
if gTx==0 then
call Cdv("Nullpointer exception when calling SubRectTileData.deserialize","when calling error in TerrainData, line 107")
else
call Cdv("Called SubRectTileData.deserialize on invalid object.","when calling error in TerrainData, line 107")
endif
endif
call gGx(gTx,gux,"when calling deserialize in TerrainData, line 107")
set EM=EM-1
endfunction
function gwx takes integer gWx,integer gyx,string gYx returns nothing
local integer gzx
local integer gZx
local integer g_x
local integer g0x
local integer g1x
local integer g2x
set ZM[EM]=gYx
set EM=EM+1
call fVx(0,gyx,"when calling readByte in TerrainData, line 162")
set g2x=RJv
set IC[gWx]=g2x
call gRx(PC[gWx],gyx,"when calling deserialize in TerrainData, line 164")
if Y1e(IC[gWx],0)then
if Y1e(IC[gWx],1)then
call dEx(0,gyx,"when calling readInt in TerrainData, line 169")
set gzx=RJv
else
call fhx(1,gyx,"when calling readShort in TerrainData, line 171")
set gzx=RJv
endif
else
call fVx(0,gyx,"when calling readByte in TerrainData, line 173")
set gzx=RJv
endif
set gZx=0
set g_x=gzx-1
loop
exitwhen gZx>g_x
set g1x=AC[gWx]
set g0x=gVx(PC[gWx],"when calling new_SubRectTileData in TerrainData, line 176")
call gtx(g0x,gyx,"when calling deserialize in TerrainData, line 176")
call zGv(g1x,g0x,"when calling add in TerrainData, line 176")
set gZx=gZx+1
endloop
set EM=EM-1
endfunction
function g3x takes integer g4x,integer g5x,string g6x returns nothing
set ZM[EM]=g6x
set EM=EM+1
if Gg[g4x]==0 then
if g4x==0 then
call Cdv("Nullpointer exception when calling TileData.deserialize","when calling error in TerrainData, line 161")
else
call Cdv("Called TileData.deserialize on invalid object.","when calling error in TerrainData, line 161")
endif
endif
call gwx(g4x,g5x,"when calling deserialize in TerrainData, line 161")
set EM=EM-1
endfunction
function g7x takes integer g8x,integer g9x,string Gvx returns nothing
local integer Gex
set ZM[EM]=Gvx
set EM=EM+1
call fVx(0,g9x,"when calling readByte in TerrainData, line 219")
set Gex=RJv
set EC[g8x]=Gex
if zFe(EC[g8x],0)then
call g3x(ZC[g8x],g9x,"when calling deserialize in TerrainData, line 222")
endif
set EM=EM-1
endfunction
function Gxx takes integer Gox,integer Grx,string Gix returns nothing
set ZM[EM]=Gix
set EM=EM+1
if Gg[Gox]==0 then
if Gox==0 then
call Cdv("Nullpointer exception when calling TerrainData.deserialize","when calling error in TerrainData, line 218")
else
call Cdv("Called TerrainData.deserialize on invalid object.","when calling error in TerrainData, line 218")
endif
endif
call g7x(Gox,Grx,"when calling deserialize in TerrainData, line 218")
set EM=EM-1
endfunction
function Gax takes string Gnx returns integer
local integer GVx
set ZM[EM]=Gnx
set EM=EM+1
if CY==0 then
if VY<$8000 then
set VY=VY+1
set GVx=VY
set BY[GVx]=$85C
else
call Cdv("Out of memory: Could not create ForForceCallback_execute_PositionedDestructableData_DestructableData.","when calling error in DestructableData, line 256")
set GVx=0
endif
else
set CY=CY-1
set GVx=XY[CY]
set BY[GVx]=$85C
endif
set EM=EM-1
return GVx
endfunction
function GEx takes integer GXx,integer GOx,string GRx returns nothing
local integer GIx
local integer GAx
set ZM[EM]=GRx
set EM=EM+1
call fVx(0,GOx,"when calling readByte in DestructableData, line 252")
set GAx=RJv
set wE[GXx]=GAx
call gRx(uE[GXx],GOx,"when calling deserialize in DestructableData, line 254")
set GIx=Gax("when calling alloc_ForForceCallback_execute_PositionedDestructableData_DestructableData in DestructableData, line 256")
set iE[GIx]=GXx
set SE[GIx]=GOx
call Fte(GIx,"when calling execute in DestructableData, line 256")
set EM=EM-1
endfunction
function GNx takes integer Gbx,integer GBx,string Gcx returns nothing
set ZM[EM]=Gcx
set EM=EM+1
if Gg[Gbx]==0 then
if Gbx==0 then
call Cdv("Nullpointer exception when calling PositionedDestructableData.deserialize","when calling error in DestructableData, line 251")
else
call Cdv("Called PositionedDestructableData.deserialize on invalid object.","when calling error in DestructableData, line 251")
endif
endif
call GEx(Gbx,GBx,"when calling deserialize in DestructableData, line 251")
set EM=EM-1
endfunction
function GCx takes string Gdx returns integer
local integer GDx
set ZM[EM]=Gdx
set EM=EM+1
if EY==0 then
if ZY<$8000 then
set ZY=ZY+1
set GDx=ZY
set UY[GDx]=$D18
else
call Cdv("Out of memory: Could not create LimitedExecuteCondition_executeWhile_PositionedUnitData_UnitData.","when calling error in UnitData, line 1421")
set GDx=0
endif
else
set EY=EY-1
set GDx=WY[EY]
set UY[GDx]=$D18
endif
set EM=EM-1
return GDx
endfunction
function Gfx takes string GFx returns integer
local integer Ggx
set ZM[EM]=GFx
set EM=EM+1
if PY==0 then
if AY<$8000 then
set AY=AY+1
set Ggx=AY
set DY[Ggx]=$CF4
else
call Cdv("Out of memory: Could not create LimitedExecuteAction_executeWhile_PositionedUnitData_UnitData.","when calling error in UnitData, line 1421")
set Ggx=0
endif
else
set PY=PY-1
set Ggx=IY[PY]
set DY[Ggx]=$CF4
endif
set EM=EM-1
return Ggx
endfunction
function GGx takes integer Ghx,integer GHx,string Gjx returns nothing
local integer GJx
local integer Gkx
local integer GKx
local integer Glx
local integer GLx
local integer Gmx
set ZM[EM]=Gjx
set EM=EM+1
call fVx(0,GHx,"when calling readByte in UnitData, line 1409")
set Gmx=RJv
set LC[Ghx]=Gmx
if wle(LC[Ghx],0)then
if wle(LC[Ghx],1)then
call dEx(0,GHx,"when calling readInt in UnitData, line 1414")
set GJx=RJv
else
call fhx(1,GHx,"when calling readShort in UnitData, line 1416")
set GJx=RJv
endif
else
call fVx(0,GHx,"when calling readByte in UnitData, line 1418")
set GJx=RJv
endif
set Gkx=bxx(0,"when calling new_Box⟪integer⟫ in UnitData, line 1420")
set GKx=GCx("when calling alloc_LimitedExecuteCondition_executeWhile_PositionedUnitData_UnitData in UnitData, line 1421")
set NC[GKx]=Gkx
set MC[GKx]=GJx
set GLx=GKx
set Glx=Gfx("when calling alloc_LimitedExecuteAction_executeWhile_PositionedUnitData_UnitData in UnitData, line 1421")
set wV[Glx]=Ghx
set uV[Glx]=GHx
set rV[Glx]=Gkx
call WOe('d',GLx,Glx,"when calling executeWhile in UnitData, line 1421")
call Bcx(Gkx,"when calling dispatch_Box⟪integer⟫_destroyBox⟪integer⟫ in UnitData, line 1424")
set EM=EM-1
endfunction
function GMx takes integer Gpx,integer GPx,string Gqx returns nothing
set ZM[EM]=Gqx
set EM=EM+1
if Gg[Gpx]==0 then
if Gpx==0 then
call Cdv("Nullpointer exception when calling PositionedUnitData.deserialize","when calling error in UnitData, line 1408")
else
call Cdv("Called PositionedUnitData.deserialize on invalid object.","when calling error in UnitData, line 1408")
endif
endif
call GGx(Gpx,GPx,"when calling deserialize in UnitData, line 1408")
set EM=EM-1
endfunction
function GQx takes integer Gsx,integer GSx,string Gtx returns nothing
local integer GTx
set ZM[EM]=Gtx
set EM=EM+1
call fVx(0,GSx,"when calling readByte in RegionData, line 72")
set GTx=RJv
set EH[Gsx]=GTx
call d7x(0,GSx,"when calling readReal in RegionData, line 74")
set AH[Gsx]=Rkv
call d7x(0,GSx,"when calling readReal in RegionData, line 75")
set DH[Gsx]=Rkv
call d7x(0,GSx,"when calling readReal in RegionData, line 77")
set HH[Gsx]=Rkv
call d7x(0,GSx,"when calling readReal in RegionData, line 78")
set JH[Gsx]=Rkv
call F_x(KH[Gsx],GSx,"when calling deserialize in RegionData, line 80")
if YWe(EH[Gsx],0)then
call Gxx(LH[Gsx],GSx,"when calling deserialize in RegionData, line 83")
endif
if YWe(EH[Gsx],1)then
call GNx(XH[Gsx],GSx,"when calling deserialize in RegionData, line 85")
endif
if YWe(EH[Gsx],2)then
call GMx(CH[Gsx],GSx,"when calling deserialize in RegionData, line 87")
endif
set EM=EM-1
endfunction
function Gux takes integer keS,integer jeS returns nothing
endfunction
function GUx takes integer Gwx,integer GWx,string Gyx returns nothing
set ZM[EM]=Gyx
set EM=EM+1
if bm[Gwx]==0 then
if Gwx==0 then
call Cdv("Nullpointer exception when calling UnitTypeTable.deserialize","when calling error in UnitTypeData, line 1285")
else
call Cdv("Called UnitTypeTable.deserialize on invalid object.","when calling error in UnitTypeData, line 1285")
endif
endif
call Gux(Gwx,GWx)
set EM=EM-1
endfunction
function GYx takes string Gzx returns integer
local integer GZx
set ZM[EM]=Gzx
set EM=EM+1
if CY==0 then
if VY<$8000 then
set VY=VY+1
set GZx=VY
set BY[GZx]=$865
else
call Cdv("Out of memory: Could not create ForForceCallback_execute_UnitData_UnitTypeData.","when calling error in UnitTypeData, line 1392")
set GZx=0
endif
else
set CY=CY-1
set GZx=XY[CY]
set BY[GZx]=$865
endif
set EM=EM-1
return GZx
endfunction
function G_x takes integer G0x,integer G1x,string G2x returns nothing
local integer G3x
local integer G4x
set ZM[EM]=G2x
set EM=EM+1
call fVx(0,G1x,"when calling readByte in UnitTypeData, line 1388")
set G4x=RJv
set BB[G0x]=G4x
call GUx(NB[G0x],G1x,"when calling deserialize in UnitTypeData, line 1390")
set G3x=GYx("when calling alloc_ForForceCallback_execute_UnitData_UnitTypeData in UnitTypeData, line 1392")
set rN[G3x]=G0x
set sN[G3x]=G1x
call Fte(G3x,"when calling execute in UnitTypeData, line 1392")
set EM=EM-1
endfunction
function G5x takes integer G6x,integer G7x returns boolean
return n9e(G6x,G7x)
endfunction
function G8x takes integer G9x,string hvx returns integer
local integer hex
local real hxx
local integer hox
local integer hrx
local integer hix
local integer hax
local integer hnx
local real hVx
local integer hEx
local integer hXx
local integer hOx
local integer hRx
local integer hIx
local integer hAx
local integer hNx
local integer hbx
local integer hBx
set ZM[EM]=hvx
set EM=EM+1
call fVx(0,G9x,"when calling readByte in UnitTypeData, line 123")
set hEx=RJv
set hex=hEx
set hxx=.0
if vPx(hex,0)then
if vPx(hex,1)then
call fVx(0,G9x,"when calling readByte in UnitTypeData, line 128")
set hxx=DQv(RJv)
elseif vPx(hex,2)then
call fhx(1,G9x,"when calling readShort in UnitTypeData, line 130")
set hxx=RJv*1./$A
else
call d7x(0,G9x,"when calling readReal in UnitTypeData, line 132")
set hxx=Rkv
endif
endif
set hox=0
if vPx(hex,3)then
call fVx(0,G9x,"when calling readByte in UnitTypeData, line 135")
set hox=RJv
endif
set hXx=0
set hOx=0
set hRx=0
set hIx=0
set hrx=hXx
set hix=hOx
set hax=hRx
set hnx=hIx
if vPx(hex,4)then
call fVx(0,G9x,"when calling readByte in UnitTypeData, line 138")
set hAx=RJv
call fVx(0,G9x,"when calling readByte in UnitTypeData, line 138")
set hNx=RJv
call fVx(0,G9x,"when calling readByte in UnitTypeData, line 138")
set hbx=RJv
call fVx(0,G9x,"when calling readByte in UnitTypeData, line 138")
set hBx=RJv
set hrx=hAx
set hix=hNx
set hax=hbx
set hnx=hBx
endif
set hVx=.0
if vPx(hex,5)then
if vPx(hex,6)then
call fVx(0,G9x,"when calling readByte in UnitTypeData, line 142")
set hVx=RJv*1./'d'
elseif vPx(hex,7)then
call fhx(1,G9x,"when calling readShort in UnitTypeData, line 144")
set hVx=(RJv-$7FFF)*1./$3E8
else
call d7x(0,G9x,"when calling readReal in UnitTypeData, line 146")
set hVx=Rkv
endif
endif
set EM=EM-1
set F6=hex
set k6=hxx
set j6=hox
set x6=hrx
set v6=hix
set m6=hax
set Q6=hnx
set W6=hVx
return F6
endfunction
function hcx takes nothing returns integer
set t7=0
set i7=0
set S7=0
set c7=0
set o7=0
set O7=0
return t7
endfunction
function hCx takes integer hdx,string hDx returns integer
local integer hfx
local integer hFx
local integer hgx
local integer hGx
local integer hhx
local integer hHx
local integer hjx
local integer hJx
local integer hkx
set ZM[EM]=hDx
set EM=EM+1
call fVx(0,hdx,"when calling readByte in UnitTypeData, line 405")
set hJx=RJv
set hfx=hJx
if Zle(hfx,7)then
call fVx(0,hdx,"when calling readByte in UnitTypeData, line 406")
set hgx=RJv
else
set hgx=0
endif
set hkx=hgx
set hFx=hkx
call dEx(0,hdx,"when calling readInt in UnitTypeData, line 408")
set hGx=RJv
set hhx=0
if Zle(hfx,1)then
if Zle(hfx,2)then
if ZJe(hFx,0)then
call dEx(0,hdx,"when calling readInt in UnitTypeData, line 414")
set hhx=RJv
else
call fhx(1,hdx,"when calling readShort in UnitTypeData, line 416")
set hhx=RJv
endif
else
call fVx(0,hdx,"when calling readByte in UnitTypeData, line 418")
set hhx=RJv
endif
endif
set hHx=0
if Zle(hfx,3)then
if Zle(hfx,4)then
if ZJe(hFx,1)then
call dEx(0,hdx,"when calling readInt in UnitTypeData, line 423")
set hHx=RJv
else
call fhx(1,hdx,"when calling readShort in UnitTypeData, line 425")
set hHx=RJv
endif
else
call fVx(0,hdx,"when calling readByte in UnitTypeData, line 427")
set hHx=RJv
endif
endif
set hjx=0
if Zle(hfx,5)then
if Zle(hfx,6)then
if ZJe(hFx,2)then
call dEx(0,hdx,"when calling readInt in UnitTypeData, line 432")
set hjx=RJv
else
call fhx(1,hdx,"when calling readShort in UnitTypeData, line 434")
set hjx=RJv
endif
else
call fVx(0,hdx,"when calling readByte in UnitTypeData, line 436")
set hjx=RJv
endif
endif
set EM=EM-1
set a7=hfx
set n7=hFx
set d7=hGx
set f7=hhx
set R7=hHx
set T7=hjx
return a7
endfunction
function hKx takes integer hlx,string hLx returns integer
local integer hmx
local integer hMx
local integer hpx
local integer hPx
local integer hqx
local integer hQx
local integer hsx
local integer hSx
local integer htx
local integer hTx
local integer hux
local integer hUx
local integer hwx
local integer hWx
local integer hyx
local integer hYx
local integer hzx
local integer hZx
local integer h_x
local integer h0x
local integer h1x
set ZM[EM]=hLx
set EM=EM+1
call fhx(1,hlx,"when calling readShort in UnitTypeData, line 529")
set htx=RJv
set hmx=htx
set hTx=hcx()
set hux=i7
set hUx=S7
set hwx=c7
set hWx=o7
set hyx=O7
set hMx=hTx
set hpx=hux
set hPx=hUx
set hqx=hwx
set hQx=hWx
set hsx=hyx
if Zhe(hmx,0)then
set hYx=hCx(hlx,"when calling readHeroParameters in UnitTypeData, line 533")
set hzx=n7
set hZx=d7
set h_x=f7
set h0x=R7
set h1x=T7
set hMx=hYx
set hpx=hzx
set hPx=hZx
set hqx=h_x
set hQx=h0x
set hsx=h1x
endif
set hSx=0
if Zhe(hmx,1)then
call fVx(0,hlx,"when calling readByte in UnitTypeData, line 537")
set hSx=RJv
endif
set EM=EM-1
set A7=hmx
set D7=hMx
set H7=hpx
set J7=hPx
set K7=hqx
set L7=hQx
set X7=hsx
set C7=hSx
return A7
endfunction
function h2x takes integer h3x,integer h4x,string h5x returns nothing
local integer h6x
set ZM[EM]=h5x
set EM=EM+1
call fVx(0,h4x,"when calling readByte in UnitTypeData, line 881")
set h6x=RJv
set EB[h3x]=h6x
call dEx(0,h4x,"when calling readInt in UnitTypeData, line 882")
set ZB[h3x]=RJv
if vhx(EB[h3x],0)then
set UB[h3x]=1
elseif vhx(EB[h3x],1)then
set UB[h3x]=2
elseif vhx(EB[h3x],2)then
set UB[h3x]=3
elseif vhx(EB[h3x],3)then
set UB[h3x]=4
else
call fhx(1,h4x,"when calling readShort in UnitTypeData, line 893")
set UB[h3x]=RJv
endif
if vhx(EB[h3x],4)then
if vhx(EB[h3x],6)then
call fVx(0,h4x,"when calling readByte in UnitTypeData, line 896")
set IB[h3x]=RJv
else
call dEx(0,h4x,"when calling readInt in UnitTypeData, line 898")
set IB[h3x]=RJv
endif
endif
if vhx(EB[h3x],5)then
if vhx(EB[h3x],6)then
call fVx(0,h4x,"when calling readByte in UnitTypeData, line 901")
set PB[h3x]=RJv*1./2
else
call d7x(0,h4x,"when calling readReal in UnitTypeData, line 903")
set PB[h3x]=Rkv
endif
endif
set EM=EM-1
endfunction
function h7x takes integer h8x,integer h9x,string Hvx returns nothing
set ZM[EM]=Hvx
set EM=EM+1
if wm[h8x]==0 then
if h8x==0 then
call Cdv("Nullpointer exception when calling SingleAbilityData.deserialize","when calling error in UnitTypeData, line 880")
else
call Cdv("Called SingleAbilityData.deserialize on invalid object.","when calling error in UnitTypeData, line 880")
endif
endif
call h2x(h8x,h9x,"when calling deserialize in UnitTypeData, line 880")
set EM=EM-1
endfunction
function Hex takes integer Hxx,string Hox returns integer
local integer Hrx
local real Hix
local real Hax
local real Hnx
local real HVx
local real HEx
local integer HXx
set ZM[EM]=Hox
set EM=EM+1
call fVx(0,Hxx,"when calling readByte in UnitTypeData, line 252")
set HXx=RJv
set Hrx=HXx
set Hix=.0
if ZOe(Hrx,0)then
if ZOe(Hrx,1)then
call fhx(1,Hxx,"when calling readShort in UnitTypeData, line 257")
set Hix=RJv*1./$A
else
call d7x(0,Hxx,"when calling readReal in UnitTypeData, line 259")
set Hix=Rkv
endif
endif
set Hax=.0
if ZOe(Hrx,2)then
call fhx(1,Hxx,"when calling readShort in UnitTypeData, line 262")
set Hax=RJv*1./$2710
endif
set Hnx=.0
if ZOe(Hrx,3)then
if ZOe(Hrx,4)then
call fVx(0,Hxx,"when calling readByte in UnitTypeData, line 266")
set Hnx=RJv*1./'d'
elseif ZOe(Hrx,5)then
call fhx(1,Hxx,"when calling readShort in UnitTypeData, line 268")
set Hnx=RJv*1./$3E8
endif
endif
set HVx=.0
if ZOe(Hrx,6)then
call d7x(0,Hxx,"when calling readReal in UnitTypeData, line 271")
set HVx=Rkv
endif
set HEx=.0
if ZOe(Hrx,7)then
call fhx(1,Hxx,"when calling readShort in UnitTypeData, line 274")
set HEx=RJv*1./$2710
endif
set EM=EM-1
set V6=Hrx
set B6=Hix
set N6=Hax
set M6=Hnx
set w7=HVx
set u7=HEx
return V6
endfunction
function HOx takes string HRx returns integer
local integer HIx
set ZM[EM]=HRx
set EM=EM+1
if Nv==0 then
if Mv<$8000 then
set Mv=Mv+1
set HIx=Mv
set wm[HIx]=4640
else
call Cdv("Out of memory: Could not create SingleAbilityData.","when calling error in UnitTypeData, line 813")
set HIx=0
endif
else
set Nv=Nv-1
set HIx=Bv[Nv]
set wm[HIx]=4640
endif
set EM=EM-1
return HIx
endfunction
function HAx takes integer HNx returns nothing
local integer Hbx=0
set EB[HNx]=Hbx
set ZB[HNx]=0
set UB[HNx]=0
set IB[HNx]=0
set PB[HNx]=.0
endfunction
function HBx takes integer Hcx returns nothing
call HAx(Hcx)
endfunction
function HCx takes string Hdx returns integer
local integer HDx
set ZM[EM]=Hdx
set EM=EM+1
set HDx=HOx("when calling alloc_SingleAbilityData in UnitTypeData, line 828")
call HBx(HDx)
set EM=EM-1
return HDx
endfunction
function Hfx takes nothing returns integer
set B7=0
set N7=0
set M7=.0
set w8=0
set u8=0
return B7
endfunction
function HFx takes integer Hgx,string HGx returns integer
local integer Hhx
local integer HHx
local real Hjx
local integer HJx
local integer Hkx
local integer HKx
set ZM[EM]=HGx
set EM=EM+1
call fVx(0,Hgx,"when calling readByte in UnitTypeData, line 638")
set HKx=RJv
set Hhx=HKx
set HHx=0
set Hjx=.0
set HJx=0
set Hkx=0
if Z8e(Hhx,0)then
if Z8e(Hhx,1)then
call dEx(0,Hgx,"when calling readInt in UnitTypeData, line 647")
set HHx=RJv
else
call fVx(0,Hgx,"when calling readByte in UnitTypeData, line 649")
set HHx=RJv
endif
endif
if Z8e(Hhx,2)then
if Z8e(Hhx,3)then
call fVx(0,Hgx,"when calling readByte in UnitTypeData, line 652")
set Hjx=RJv*1./'d'
else
call d7x(0,Hgx,"when calling readReal in UnitTypeData, line 654")
set Hjx=Rkv
endif
endif
if Z8e(Hhx,4)then
if Z8e(Hhx,5)then
call dEx(0,Hgx,"when calling readInt in UnitTypeData, line 657")
set HJx=RJv
else
call fVx(0,Hgx,"when calling readByte in UnitTypeData, line 659")
set HJx=RJv
endif
endif
if Z8e(Hhx,6)then
if Z8e(Hhx,7)then
call dEx(0,Hgx,"when calling readInt in UnitTypeData, line 662")
set Hkx=RJv
else
call fVx(0,Hgx,"when calling readByte in UnitTypeData, line 664")
set Hkx=RJv
endif
endif
set EM=EM-1
set c8=Hhx
set o8=HHx
set O8=Hjx
set l8=HJx
set b8=Hkx
return c8
endfunction
function Hlx takes integer HLx,string Hmx returns integer
local integer HMx
local integer Hpx
local integer HPx
local real Hqx
local integer HQx
local integer Hsx
local integer HSx
local integer Htx
local real HTx
local integer Hux
local integer HUx
local integer Hwx
local integer HWx
local integer Hyx
local integer HYx
local integer Hzx
local integer HZx
local real H_x
local integer H0x
local integer H1x
local integer H2x
local integer H3x
local real H4x
local integer H5x
local integer H6x
local integer H7x
local integer H8x
local real H9x
local integer jvx
local integer jex
local integer jxx
local integer jox
local real jrx
local integer jix
local integer jax
set ZM[EM]=Hmx
set EM=EM+1
call fhx(1,HLx,"when calling readShort in UnitTypeData, line 768")
set HYx=RJv
set HMx=HYx
set Hzx=Hfx()
set HZx=N7
set H_x=M7
set H0x=w8
set H1x=u8
set Hpx=Hzx
set HPx=HZx
set Hqx=H_x
set HQx=H0x
set Hsx=H1x
if Z5e(HMx,0)then
set H2x=HFx(HLx,"when calling readAttackParameters in UnitTypeData, line 772")
set H3x=o8
set H4x=O8
set H5x=l8
set H6x=b8
set Hpx=H2x
set HPx=H3x
set Hqx=H4x
set HQx=H5x
set Hsx=H6x
endif
set H7x=Hfx()
set H8x=N7
set H9x=M7
set jvx=w8
set jex=u8
set HSx=H7x
set Htx=H8x
set HTx=H9x
set Hux=jvx
set HUx=jex
if Z5e(HMx,1)then
set jxx=HFx(HLx,"when calling readAttackParameters in UnitTypeData, line 775")
set jox=o8
set jrx=O8
set jix=l8
set jax=b8
set HSx=jxx
set Htx=jox
set HTx=jrx
set Hux=jix
set HUx=jax
endif
set Hwx=0
if Z5e(HMx,2)then
if Z5e(HMx,3)then
call fVx(0,HLx,"when calling readByte in UnitTypeData, line 779")
set Hwx=RJv
else
call dEx(0,HLx,"when calling readInt in UnitTypeData, line 781")
set Hwx=RJv
endif
endif
set HWx=0
if Z5e(HMx,4)then
if Z5e(HMx,5)then
call fhx(1,HLx,"when calling readShort in UnitTypeData, line 785")
set HWx=RJv
else
call dEx(0,HLx,"when calling readInt in UnitTypeData, line 787")
set HWx=RJv
endif
endif
set Hyx=0
if Z5e(HMx,6)then
if Z5e(HMx,7)then
call fhx(1,HLx,"when calling readShort in UnitTypeData, line 791")
set Hyx=RJv
else
call dEx(0,HLx,"when calling readInt in UnitTypeData, line 793")
set Hyx=RJv
endif
endif
set EM=EM-1
set H8=HMx
set J8=Hpx
set K8=HPx
set L8=Hqx
set X8=HQx
set C8=Hsx
set V8=HSx
set B8=Htx
set N8=HTx
set M8=Hux
set w9=HUx
set u9=Hwx
set r9=HWx
set s9=Hyx
return H8
endfunction
function jnx takes integer jVx,integer jEx,string jXx returns nothing
local integer jOx
local integer jRx
local integer jIx
local integer jAx
local integer jNx
local integer jbx
local integer jBx
local integer jcx
local integer jCx
local integer jdx
local integer jDx
local integer jfx
local real jFx
local integer jgx
local integer jGx
local integer jhx
local integer jHx
local integer jjx
local real jJx
local integer jkx
local real jKx
local real jlx
local real jLx
local real jmx
local real jMx
local integer jpx
local integer jPx
local integer jqx
local integer jQx
local integer jsx
local integer jSx
local integer jtx
local integer jTx
local integer jux
local integer jUx
local integer jwx
local real jWx
local integer jyx
local integer jYx
local integer jzx
local integer jZx
local real j_x
local integer j0x
local integer j1x
local integer j2x
local integer j3x
local integer j4x
local integer j5x
local integer j6x
local integer j7x
set ZM[EM]=jXx
set EM=EM+1
call fVx(0,jEx,"when calling readByte in UnitTypeData, line 1204")
set jCx=RJv
set dN[jVx]=jCx
if Z2e(dN[jVx],7)then
call fVx(0,jEx,"when calling readByte in UnitTypeData, line 1206")
set jdx=RJv
set fN[jVx]=jdx
endif
call dEx(0,jEx,"when calling readInt in UnitTypeData, line 1207")
set RN[jVx]=RJv
if Z2e(dN[jVx],2)then
set jDx=FKx(jEx,nN[jVx],"when calling readStringTableIndex in UnitTypeData, line 1210")
set TN[jVx]=jDx
endif
if Z2e(dN[jVx],3)then
set jfx=G8x(jEx,"when calling readArtParameters in UnitTypeData, line 1213")
set jFx=k6
set jgx=j6
set jGx=x6
set jhx=v6
set jHx=m6
set jjx=Q6
set jJx=W6
set YN[jVx]=jfx
set GN[jVx]=jFx
set gN[jVx]=jgx
set hN[jVx]=jGx
set FN[jVx]=jhx
set kN[jVx]=jHx
set jN[jVx]=jjx
set xN[jVx]=jJx
endif
if Z2e(dN[jVx],4)then
set jkx=Hex(jEx,"when calling readAnimationParameters in UnitTypeData, line 1215")
set jKx=B6
set jlx=N6
set jLx=M6
set jmx=w7
set jMx=u7
set vN[jVx]=jkx
set mN[jVx]=jKx
set QN[jVx]=jlx
set WN[jVx]=jLx
set EN[jVx]=jmx
set ZN[jVx]=jMx
endif
if Z2e(dN[jVx],5)then
set jpx=hKx(jEx,"when calling readGeneralStats in UnitTypeData, line 1218")
set jPx=D7
set jqx=H7
set jQx=J7
set jsx=K7
set jSx=L7
set jtx=X7
set jTx=C7
set UN[jVx]=jpx
set IN[jVx]=jPx
set PN[jVx]=jqx
set AN[jVx]=jQx
set DN[jVx]=jsx
set HN[jVx]=jSx
set JN[jVx]=jtx
set KN[jVx]=jTx
endif
if Z2e(dN[jVx],6)then
set jux=Hlx(jEx,"when calling readStats in UnitTypeData, line 1220")
set jUx=J8
set jwx=K8
set jWx=L8
set jyx=X8
set jYx=C8
set jzx=V8
set jZx=B8
set j_x=N8
set j0x=M8
set j1x=w9
set j2x=u9
set j3x=r9
set j4x=s9
set LN[jVx]=jux
set XN[jVx]=jUx
set CN[jVx]=jwx
set VN[jVx]=jWx
set BN[jVx]=jyx
set NN[jVx]=jYx
set MN[jVx]=jzx
set wM[jVx]=jZx
set uM[jVx]=j_x
set rM[jVx]=j0x
set sM[jVx]=j1x
set tM[jVx]=j2x
set iM[jVx]=j3x
set SM[jVx]=j4x
endif
if Zhe(UN[jVx],5)then
call fVx(0,jEx,"when calling readByte in UnitTypeData, line 1223")
set jOx=RJv
set jRx=0
set jIx=jOx-1
loop
exitwhen jRx>jIx
set j7x=cM[jVx]
call dEx(0,jEx,"when calling readInt in UnitTypeData, line 1225")
call zGv(j7x,RJv,"when calling add in UnitTypeData, line 1225")
set jRx=jRx+1
endloop
endif
if Zhe(UN[jVx],6)then
call fVx(0,jEx,"when calling readByte in UnitTypeData, line 1227")
set jAx=RJv
set jNx=0
set jbx=jAx-1
loop
exitwhen jNx>jbx
set jcx=oM[jVx]
set jBx=HCx("when calling new_SingleAbilityData in UnitTypeData, line 1229")
call h7x(jBx,jEx,"when calling deserialize in UnitTypeData, line 1229")
call zGv(jcx,jBx,"when calling add in UnitTypeData, line 1229")
set jNx=jNx+1
endloop
endif
if ZFe(fN[jVx],1)then
call fVx(0,jEx,"when calling readByte in UnitTypeData, line 1232")
set j5x=RJv
set OM[jVx]=j5x
endif
if ZFe(fN[jVx],2)then
call fVx(0,jEx,"when calling readByte in UnitTypeData, line 1234")
set j6x=RJv
set lM[jVx]=j6x
endif
if ZFe(fN[jVx],3)then
endif
set EM=EM-1
endfunction
function j8x takes integer j9x,integer Jvx,string Jex returns nothing
set ZM[EM]=Jex
set EM=EM+1
if lm[j9x]==0 then
if j9x==0 then
call Cdv("Nullpointer exception when calling UnitTypeData.deserialize","when calling error in UnitTypeData, line 1203")
else
call Cdv("Called UnitTypeData.deserialize on invalid object.","when calling error in UnitTypeData, line 1203")
endif
endif
call jnx(j9x,Jvx,"when calling deserialize in UnitTypeData, line 1203")
set EM=EM-1
endfunction
function Jxx takes string Jox returns integer
local integer Jrx
set ZM[EM]=Jox
set EM=EM+1
if om==0 then
if Om<$8000 then
set Om=Om+1
set Jrx=Om
set lm[Jrx]=5111
else
call Cdv("Out of memory: Could not create UnitTypeData.","when calling error in UnitTypeData, line 1041")
set Jrx=0
endif
else
set om=om-1
set Jrx=cm[om]
set lm[Jrx]=5111
endif
set EM=EM-1
return Jrx
endfunction
function Jix takes nothing returns integer
set G7=0
set g7=hcx()
set h7=i7
set F7=S7
set k7=c7
set j7=o7
set x7=O7
set v7=0
return G7
endfunction
function Jax takes nothing returns integer
set l6=0
set b6=.0
set y6=0
set p6=0
set e6=0
set q6=0
set a6=0
set n6=.0
return l6
endfunction
function Jnx takes nothing returns integer
set p8=0
set e8=Hfx()
set q8=N7
set a8=M7
set n8=w8
set d8=u8
set f8=Hfx()
set R8=N7
set T8=M7
set Y8=w8
set G8=u8
set g8=0
set h8=0
set F8=0
return p8
endfunction
function JVx takes nothing returns integer
set Z6=0
set U6=.0
set I6=.0
set P6=.0
set A6=.0
set D6=.0
return Z6
endfunction
function JEx takes integer JXx,string JOx returns nothing
local integer JRx
local integer JIx
local integer JAx
local integer JNx
local real Jbx
local integer JBx
local integer Jcx
local integer JCx
local integer Jdx
local integer JDx
local real Jfx
local integer JFx
local real Jgx
local real JGx
local real Jhx
local real JHx
local real Jjx
local integer JJx
local integer Jkx
local integer JKx
local integer Jlx
local integer JLx
local integer Jmx
local integer JMx
local integer Jpx
local integer JPx
local integer Jqx
local integer JQx
local real Jsx
local integer JSx
local integer Jtx
local integer JTx
local integer Jux
local real JUx
local integer Jwx
local integer JWx
local integer Jyx
local integer JYx
local integer Jzx
local integer JZx
local integer J_x
set ZM[EM]=JOx
set EM=EM+1
set JRx=0
set dN[JXx]=JRx
set JIx=0
set fN[JXx]=JIx
set RN[JXx]=0
set JAx=yWv()
set TN[JXx]=JAx
set JNx=Jax()
set Jbx=b6
set JBx=y6
set Jcx=p6
set JCx=e6
set Jdx=q6
set JDx=a6
set Jfx=n6
set YN[JXx]=JNx
set GN[JXx]=Jbx
set gN[JXx]=JBx
set hN[JXx]=Jcx
set FN[JXx]=JCx
set kN[JXx]=Jdx
set jN[JXx]=JDx
set xN[JXx]=Jfx
set JFx=JVx()
set Jgx=U6
set JGx=I6
set Jhx=P6
set JHx=A6
set Jjx=D6
set vN[JXx]=JFx
set mN[JXx]=Jgx
set QN[JXx]=JGx
set WN[JXx]=Jhx
set EN[JXx]=JHx
set ZN[JXx]=Jjx
set JJx=Jix()
set Jkx=g7
set JKx=h7
set Jlx=F7
set JLx=k7
set Jmx=j7
set JMx=x7
set Jpx=v7
set UN[JXx]=JJx
set IN[JXx]=Jkx
set PN[JXx]=JKx
set AN[JXx]=Jlx
set DN[JXx]=JLx
set HN[JXx]=Jmx
set JN[JXx]=JMx
set KN[JXx]=Jpx
set JPx=Jnx()
set Jqx=e8
set JQx=q8
set Jsx=a8
set JSx=n8
set Jtx=d8
set JTx=f8
set Jux=R8
set JUx=T8
set Jwx=Y8
set JWx=G8
set Jyx=g8
set JYx=h8
set Jzx=F8
set LN[JXx]=JPx
set XN[JXx]=Jqx
set CN[JXx]=JQx
set VN[JXx]=Jsx
set BN[JXx]=JSx
set NN[JXx]=Jtx
set MN[JXx]=JTx
set wM[JXx]=Jux
set uM[JXx]=JUx
set rM[JXx]=Jwx
set sM[JXx]=JWx
set tM[JXx]=Jyx
set iM[JXx]=JYx
set SM[JXx]=Jzx
set cM[JXx]=yTv("when calling new_LinkedList in UnitTypeData, line 1057")
set oM[JXx]=yTv("when calling new_LinkedList in UnitTypeData, line 1058")
set JZx=0
set OM[JXx]=JZx
set J_x=0
set lM[JXx]=J_x
set EM=EM-1
endfunction
function J0x takes integer J1x,integer J2x,string J3x returns nothing
set ZM[EM]=J3x
set EM=EM+1
call JEx(J1x,"when calling UnitTypeData_init in UnitTypeData, line 1069")
set nN[J1x]=J2x
set EM=EM-1
endfunction
function J4x takes integer J5x,string J6x returns integer
local integer J7x
set ZM[EM]=J6x
set EM=EM+1
set J7x=Jxx("when calling alloc_UnitTypeData in UnitTypeData, line 1069")
call J0x(J7x,J5x,"when calling construct_UnitTypeData in UnitTypeData, line 1069")
set EM=EM-1
return J7x
endfunction
function J8x takes integer J9x,string kvx returns nothing
set ZM[EM]=kvx
set EM=EM+1
if wm[J9x]==0 then
call Cdv("Double free: object of type SingleAbilityData","when calling error in UnitTypeData, line 813")
else
set Bv[Nv]=J9x
set Nv=Nv+1
set wm[J9x]=0
endif
set EM=EM-1
endfunction
function kex takes integer aoS returns nothing
endfunction
function kxx takes integer kox,string krx returns nothing
set ZM[EM]=krx
set EM=EM+1
call kex(kox)
call J8x(kox,"when calling dealloc_SingleAbilityData in UnitTypeData, line 813")
set EM=EM-1
endfunction
function kix takes integer kax,string knx returns nothing
set ZM[EM]=knx
set EM=EM+1
if wm[kax]==0 then
if kax==0 then
call Cdv("Nullpointer exception when calling SingleAbilityData.SingleAbilityData","when calling error in UnitTypeData, line 813")
else
call Cdv("Called SingleAbilityData.SingleAbilityData on invalid object.","when calling error in UnitTypeData, line 813")
endif
endif
call kxx(kax,"when calling destroySingleAbilityData in UnitTypeData, line 813")
set EM=EM-1
endfunction
function kVx takes integer kEx,string kXx returns nothing
local integer kOx
local integer kRx
set ZM[EM]=kXx
set EM=EM+1
set kOx=Xle(oM[kEx],"when calling iterator in UnitTypeData, line 1064")
loop
exitwhen not Xie(kOx)
set kRx=E3e(kOx)
call kix(kRx,"when calling dispatch_SingleAbilityData_destroySingleAbilityData in UnitTypeData, line 1065")
endloop
call Xpe(kOx,"when calling close in UnitTypeData, line 1064")
call Hcv(oM[kEx],"when calling dispatch_LinkedList_destroyLinkedList in UnitTypeData, line 1066")
call Hcv(cM[kEx],"when calling dispatch_LinkedList_destroyLinkedList in UnitTypeData, line 1067")
set EM=EM-1
endfunction
function kIx takes integer kAx,string kNx returns nothing
set ZM[EM]=kNx
set EM=EM+1
if lm[kAx]==0 then
call Cdv("Double free: object of type UnitTypeData","when calling error in UnitTypeData, line 1041")
else
set cm[om]=kAx
set om=om+1
set lm[kAx]=0
endif
set EM=EM-1
endfunction
function kbx takes integer kBx,string kcx returns nothing
set ZM[EM]=kcx
set EM=EM+1
call kVx(kBx,"when calling UnitTypeData_onDestroy in UnitTypeData, line 1063")
call kIx(kBx,"when calling dealloc_UnitTypeData in UnitTypeData, line 1063")
set EM=EM-1
endfunction
function kCx takes integer kdx,string kDx returns nothing
set ZM[EM]=kDx
set EM=EM+1
if lm[kdx]==0 then
if kdx==0 then
call Cdv("Nullpointer exception when calling UnitTypeData.UnitTypeData","when calling error in UnitTypeData, line 1041")
else
call Cdv("Called UnitTypeData.UnitTypeData on invalid object.","when calling error in UnitTypeData, line 1041")
endif
endif
call kbx(kdx,"when calling destroyUnitTypeData in UnitTypeData, line 1041")
set EM=EM-1
endfunction
function kfx takes integer kFx,integer kgx,real kGx,integer khx,integer kHx returns integer
return kFx+kgx+c6v(kGx)+khx+kHx
endfunction
function kjx takes integer kJx,integer kkx,integer kKx,real klx,integer kLx,integer kmx,integer kMx,integer kpx,real kPx,integer kqx,integer kQx,integer ksx,integer kSx,integer ktx returns integer
return kJx+kfx(kkx,kKx,klx,kLx,kmx)+kfx(kMx,kpx,kPx,kqx,kQx)+ksx+kSx+ktx
endfunction
function kTx takes integer kux,real kUx,integer kwx,integer kWx,integer kyx,integer kYx,integer kzx,real kZx returns integer
return kux+c6v(kUx)+kwx+kWx+kyx+kYx+kzx+c6v(kZx)
endfunction
function k_x takes integer k0x,real k1x,real k2x,real k3x,real k4x,real k5x returns integer
return k0x+c6v(k1x)+c6v(k2x)+c6v(k3x)+c6v(k4x)+c6v(k5x)
endfunction
function k6x takes integer k7x returns integer
local integer k8x=nN[k7x]+fN[k7x]+RN[k7x]+TN[k7x]+kTx(YN[k7x],GN[k7x],gN[k7x],hN[k7x],FN[k7x],kN[k7x],jN[k7x],xN[k7x])+k_x(vN[k7x],mN[k7x],QN[k7x],WN[k7x],EN[k7x],ZN[k7x])+kjx(LN[k7x],XN[k7x],CN[k7x],VN[k7x],BN[k7x],NN[k7x],MN[k7x],wM[k7x],uM[k7x],rM[k7x],sM[k7x],tM[k7x],iM[k7x],SM[k7x])
return k8x
endfunction
function k9x takes integer Kvx,string Kex returns integer
local integer Kxx
set ZM[EM]=Kex
set EM=EM+1
if lm[Kvx]==0 then
if Kvx==0 then
call Cdv("Nullpointer exception when calling UnitTypeData.hashCode","when calling error in UnitTypeData, line 1072")
else
call Cdv("Called UnitTypeData.hashCode on invalid object.","when calling error in UnitTypeData, line 1072")
endif
endif
set Kxx=k6x(Kvx)
set EM=EM-1
return Kxx
endfunction
function Kox takes string Krx returns integer
local integer Kix
set ZM[EM]=Krx
set EM=EM+1
if Cv==0 then
if Vv<$8000 then
set Vv=Vv+1
set Kix=Vv
else
call Cdv("Out of memory: Could not create KeyValueWrapper.","when calling error in UnitTypeDataTable, line 47")
set Kix=0
endif
else
set Cv=Cv-1
set Kix=Xv[Cv]
endif
set EM=EM-1
return Kix
endfunction
function Kax takes integer xcS returns nothing
endfunction
function Knx takes integer KVx,integer KEx,integer KXx returns nothing
call Kax(KVx)
set QB[KVx]=KEx
set WB[KVx]=KXx
endfunction
function KOx takes integer KRx,integer KIx,string KAx returns integer
local integer KNx
set ZM[EM]=KAx
set EM=EM+1
set KNx=Kox("when calling alloc_KeyValueWrapper in UnitTypeDataTable, line 51")
call Knx(KNx,KRx,KIx)
set EM=EM-1
return KNx
endfunction
function Kbx takes integer llS,integer blS returns boolean
return false
endfunction
function KBx takes integer Kcx,integer KCx,string Kdx returns boolean
local boolean KDx
set ZM[EM]=Kdx
set EM=EM+1
if lm[Kcx]==0 then
if Kcx==0 then
call Cdv("Nullpointer exception when calling UnitTypeData.equals","when calling error in UnitTypeData, line 1077")
else
call Cdv("Called UnitTypeData.equals on invalid object.","when calling error in UnitTypeData, line 1077")
endif
endif
set KDx=Kbx(Kcx,KCx)
set EM=EM-1
return KDx
endfunction
function Kfx takes integer KFx,integer Kgx,string KGx returns integer
local integer Khx
local integer KHx
local integer Kjx
local integer KJx
local integer Kkx
local integer KKx
set ZM[EM]=KGx
set EM=EM+1
set Khx=k9x(Kgx,"when calling hashCode in UnitTypeDataTable, line 79")
set KHx=f3v(FB[KFx],Khx,"when calling get in UnitTypeDataTable, line 80")
if KHx==0 then
set KHx=yTv("when calling new_LinkedList in UnitTypeDataTable, line 82")
call WTv(FB[KFx],Khx,KHx,"when calling put in UnitTypeDataTable, line 83")
endif
set Kjx=Xle(KHx,"when calling iterator in UnitTypeDataTable, line 84")
loop
exitwhen not Xie(Kjx)
set KJx=E3e(Kjx)
if KBx(QB[KJx],Kgx,"when calling equals in UnitTypeDataTable, line 85")then
call kCx(Kgx,"when calling dispatch_UnitTypeData_destroyUnitTypeData in UnitTypeDataTable, line 86")
call Xpe(Kjx,"when calling close in UnitTypeDataTable, line 84")
set EM=EM-1
set zd=WB[KJx]
return zd
endif
endloop
call Xpe(Kjx,"when calling close in UnitTypeDataTable, line 84")
call zGv(KHx,KOx(Kgx,dgv(kB[KFx],"when calling size in UnitTypeDataTable, line 88"),"when calling new_KeyValueWrapper in UnitTypeDataTable, line 88"),"when calling add in UnitTypeDataTable, line 88")
call dlv(kB[KFx],Kgx,"when calling add in UnitTypeDataTable, line 89")
set KKx=dgv(kB[KFx],"when calling size in UnitTypeDataTable, line 90")-1
set Kkx=KKx
set EM=EM-1
set zd=Kkx
return zd
endfunction
function Klx takes integer KLx,integer Kmx,string KMx returns integer
local integer Kpx
local integer KPx
set ZM[EM]=KMx
set EM=EM+1
if Gg[KLx]==0 then
if KLx==0 then
call Cdv("Nullpointer exception when calling UnitTypeDataTable.addUnitType","when calling error in UnitTypeDataTable, line 78")
else
call Cdv("Called UnitTypeDataTable.addUnitType on invalid object.","when calling error in UnitTypeDataTable, line 78")
endif
endif
set KPx=Kfx(KLx,Kmx,"when calling addUnitType in UnitTypeDataTable, line 78")
set Kpx=KPx
set EM=EM-1
set zC=Kpx
return zC
endfunction
function Kqx takes integer KQx,integer Ksx,string KSx returns integer
local integer Ktx
local integer KTx
local integer Kux
local integer KUx
local integer Kwx
local integer KWx
set ZM[EM]=KSx
set EM=EM+1
if vB[Ksx]then
if mB[Ksx]then
call dEx(0,KQx,"when calling readInt in UnitTypeDataTable, line 39")
set KUx=RJv
set Ktx=KUx
set EM=EM-1
set o6=Ktx
return o6
else
call fhx(1,KQx,"when calling readShort in UnitTypeDataTable, line 41")
set Kwx=RJv
set Kux=Kwx
set EM=EM-1
set o6=Kux
return o6
endif
else
call fVx(0,KQx,"when calling readByte in UnitTypeDataTable, line 43")
set KWx=RJv
set KTx=KWx
set EM=EM-1
set o6=KTx
return o6
endif
endfunction
function Kyx takes integer KYx,integer Kzx,string KZx returns nothing
local integer K_x
local integer K0x
local integer K1x
local integer K2x
local integer K3x
local integer K4x
local integer K5x
local integer K6x
set ZM[EM]=KZx
set EM=EM+1
call fVx(0,Kzx,"when calling readByte in UnitTypeDataTable, line 110")
set K5x=RJv
set xB[KYx]=K5x
set vB[KYx]=G5x(xB[KYx],0)
set mB[KYx]=G5x(xB[KYx],1)
set K6x=Kqx(Kzx,KYx,"when calling readUnitTypeDataTableIndex in UnitTypeDataTable, line 115")
set K0x=K6x
set K_x=K0x
set K1x=0
set K2x=K_x-1
loop
exitwhen K1x>K2x
set K4x=J4x(jB[KYx],"when calling new_UnitTypeData in UnitTypeDataTable, line 117")
call j8x(K4x,Kzx,"when calling deserialize in UnitTypeDataTable, line 117")
set K3x=K4x
call Klx(KYx,K3x,"when calling addUnitType in UnitTypeDataTable, line 118")
set K1x=K1x+1
endloop
set EM=EM-1
endfunction
function K7x takes string K8x returns integer
local integer K9x
set ZM[EM]=K8x
set EM=EM+1
if CY==0 then
if VY<$8000 then
set VY=VY+1
set K9x=VY
set BY[K9x]=$861
else
call Cdv("Out of memory: Could not create ForForceCallback_execute_StringTable_LegacyStringTable.","when calling error in LegacyStringTable, line 40")
set K9x=0
endif
else
set CY=CY-1
set K9x=XY[CY]
set BY[K9x]=$861
endif
set EM=EM-1
return K9x
endfunction
function lvx takes integer WLs returns nothing
endfunction
function lex takes integer lxx,string lox returns nothing
set ZM[EM]=lox
set EM=EM+1
if Ch[lxx]==0 then
call Cdv("Double free: object of type BoxedString","when calling error in LegacyStringTable, line 9")
else
set Kh[Lh]=lxx
set Lh=Lh+1
set Ch[lxx]=0
endif
set EM=EM-1
endfunction
function lrx takes integer lix,string lax returns nothing
set ZM[EM]=lax
set EM=EM+1
call lvx(lix)
call lex(lix,"when calling dealloc_BoxedString in LegacyStringTable, line 9")
set EM=EM-1
endfunction
function lnx takes integer lVx,string lEx returns nothing
set ZM[EM]=lEx
set EM=EM+1
if Ch[lVx]==0 then
if lVx==0 then
call Cdv("Nullpointer exception when calling BoxedString.BoxedString","when calling error in LegacyStringTable, line 9")
else
call Cdv("Called BoxedString.BoxedString on invalid object.","when calling error in LegacyStringTable, line 9")
endif
endif
call lrx(lVx,"when calling destroyBoxedString in LegacyStringTable, line 9")
set EM=EM-1
endfunction
function lXx takes integer lOx returns nothing
set rI[lOx]=""
endfunction
function lRx takes integer lIx returns nothing
call lXx(lIx)
endfunction
function lAx takes string lNx returns integer
local integer lbx
set ZM[EM]=lNx
set EM=EM+1
if Lh==0 then
if Xh<$8000 then
set Xh=Xh+1
set lbx=Xh
set Ch[lbx]=$419
else
call Cdv("Out of memory: Could not create BoxedString.","when calling error in LegacyStringTable, line 9")
set lbx=0
endif
else
set Lh=Lh-1
set lbx=Kh[Lh]
set Ch[lbx]=$419
endif
set EM=EM-1
return lbx
endfunction
function lBx takes string lcx returns integer
local integer lCx
set ZM[EM]=lcx
set EM=EM+1
set lCx=lAx("when calling alloc_BoxedString in LegacyStringTable, line 9")
call lRx(lCx)
set EM=EM-1
return lCx
endfunction
function ldx takes integer nXs,integer lDx,string lfx returns string
local integer lFx
local integer lgx
local integer lGx
local string lhx
set ZM[EM]=lfx
set EM=EM+1
call fhx(1,lDx,"when calling readShort in LegacyStringTable, line 38")
set lFx=RJv
set lgx=lBx("when calling new_BoxedString in LegacyStringTable, line 39")
set lGx=K7x("when calling alloc_ForForceCallback_execute_StringTable_LegacyStringTable in LegacyStringTable, line 40")
set OI[lGx]=lFx
set lI[lGx]=lgx
set bI[lGx]=lDx
call Fte(lGx,"when calling execute in LegacyStringTable, line 40")
set lhx=rI[lgx]
call lnx(lgx,"when calling dispatch_BoxedString_destroyBoxedString in LegacyStringTable, line 44")
set EM=EM-1
return lhx
endfunction
function lHx takes integer ljx,integer lJx,string lkx returns string
local string lKx
set ZM[EM]=lkx
set EM=EM+1
if Gg[ljx]==0 then
if ljx==0 then
call Cdv("Nullpointer exception when calling StringTable.deserializeString","when calling error in LegacyStringTable, line 37")
else
call Cdv("Called StringTable.deserializeString on invalid object.","when calling error in LegacyStringTable, line 37")
endif
endif
set lKx=ldx(ljx,lJx,"when calling deserializeString in LegacyStringTable, line 37")
set EM=EM-1
return lKx
endfunction
function llx takes integer lLx,integer lmx,string lMx returns nothing
local integer lpx
local integer lPx
local integer lqx
local string lQx
local integer lsx
set ZM[EM]=lMx
set EM=EM+1
call fVx(0,lmx,"when calling readByte in LegacyStringTable, line 54")
set lsx=RJv
set sI[lLx]=lsx
call fhx(1,lmx,"when calling readShort in LegacyStringTable, line 55")
set lpx=RJv
set lPx=0
set lqx=lpx-1
loop
exitwhen lPx>lqx
set lQx=lHx(lLx,lmx,"when calling deserializeString in LegacyStringTable, line 57")
call ZWv(tI[lLx],lQx,Z2v(iI[lLx],"when calling size in LegacyStringTable, line 58"),"when calling put in LegacyStringTable, line 58")
call Zfv(iI[lLx],lQx,"when calling add in LegacyStringTable, line 59")
set lPx=lPx+1
endloop
set EM=EM-1
endfunction
function lSx takes integer ltx,integer lTx,string lux returns nothing
set ZM[EM]=lux
set EM=EM+1
if Gg[ltx]==0 then
if ltx==0 then
call Cdv("Nullpointer exception when calling StringTable.deserialize","when calling error in LegacyStringTable, line 53")
else
call Cdv("Called StringTable.deserialize on invalid object.","when calling error in LegacyStringTable, line 53")
endif
endif
call llx(ltx,lTx,"when calling deserialize in LegacyStringTable, line 53")
set EM=EM-1
endfunction
function lUx takes string lwx returns nothing
call DisplayTimedTextToPlayer(ta,.0,.0,ha,lwx)
endfunction
function lWx takes string lyx returns integer
local integer lYx
set ZM[EM]=lyx
set EM=EM+1
if CY==0 then
if VY<$8000 then
set VY=VY+1
set lYx=VY
set BY[lYx]=$855
else
call Cdv("Out of memory: Could not create ForForceCallback_execute_LegacyPositionedUnitData_LegacyUnitData.","when calling error in LegacyUnitData, line 400")
set lYx=0
endif
else
set CY=CY-1
set lYx=XY[CY]
set BY[lYx]=$855
endif
set EM=EM-1
return lYx
endfunction
function lzx takes integer lZx,integer l_x,string l0x returns nothing
local integer l1x
set ZM[EM]=l0x
set EM=EM+1
set l1x=lWx("when calling alloc_ForForceCallback_execute_LegacyPositionedUnitData_LegacyUnitData in LegacyUnitData, line 400")
set eI[l1x]=l_x
set qI[l1x]=lZx
call Fte(l1x,"when calling execute in LegacyUnitData, line 400")
set EM=EM-1
endfunction
function l2x takes integer l3x,integer l4x,string l5x returns nothing
set ZM[EM]=l5x
set EM=EM+1
if Mh[l3x]==0 then
if l3x==0 then
call Cdv("Nullpointer exception when calling LegacyPositionedUnitData.deserialize","when calling error in LegacyUnitData, line 399")
else
call Cdv("Called LegacyPositionedUnitData.deserialize on invalid object.","when calling error in LegacyUnitData, line 399")
endif
endif
call lzx(l3x,l4x,"when calling deserialize in LegacyUnitData, line 399")
set EM=EM-1
endfunction
function l6x takes integer l7x,integer l8x,string l9x returns nothing
set ZM[EM]=l9x
set EM=EM+1
call fVx(0,l8x,"when calling readByte in LegacySaveData, line 44")
call d7x(0,l8x,"when calling readReal in LegacySaveData, line 46")
set BU[l7x]=Rkv
call d7x(0,l8x,"when calling readReal in LegacySaveData, line 47")
set NU[l7x]=Rkv
call d7x(0,l8x,"when calling readReal in LegacySaveData, line 49")
call d7x(0,l8x,"when calling readReal in LegacySaveData, line 50")
call lUx("des ST")
call lSx(MU[l7x],l8x,"when calling deserialize in LegacySaveData, line 53")
call lUx("des UD")
call l2x(wI[l7x],l8x,"when calling deserialize in LegacySaveData, line 55")
call lUx("des finish")
set EM=EM-1
endfunction
function Lvx takes integer Lex,integer Lxx,string Lox returns nothing
set ZM[EM]=Lox
set EM=EM+1
if Gg[Lex]==0 then
if Lex==0 then
call Cdv("Nullpointer exception when calling DataSerializable.deserialize","when calling error in DataInterfaces, line 26")
else
call Cdv("Called DataSerializable.deserialize on invalid object.","when calling error in DataInterfaces, line 26")
endif
endif
if Gg[Lex]<=$6D9 then
if Gg[Lex]<=$6D6 then
if Gg[Lex]<=$6D4 then
if Gg[Lex]<=$6D2 then
call DJx(Lex,Lxx,"when calling deserialize in DataInterfaces, line 26")
else
call l6x(Lex,Lxx,"when calling deserialize in DataInterfaces, line 26")
endif
elseif Gg[Lex]<=$6D5 then
call D0x(Lex,Lxx,"when calling deserialize in DataInterfaces, line 26")
else
call GQx(Lex,Lxx,"when calling deserialize in DataInterfaces, line 26")
endif
elseif Gg[Lex]<=$6D8 then
if Gg[Lex]<=$6D7 then
call GEx(Lex,Lxx,"when calling deserialize in DataInterfaces, line 26")
else
call GGx(Lex,Lxx,"when calling deserialize in DataInterfaces, line 26")
endif
else
call fUx(Lex,Lxx,"when calling deserialize in DataInterfaces, line 26")
endif
elseif Gg[Lex]<=$6DC then
if Gg[Lex]<=$6DB then
if Gg[Lex]<=$6DA then
call llx(Lex,Lxx,"when calling deserialize in DataInterfaces, line 26")
else
call FSx(Lex,Lxx,"when calling deserialize in DataInterfaces, line 26")
endif
else
call g7x(Lex,Lxx,"when calling deserialize in DataInterfaces, line 26")
endif
elseif Gg[Lex]<=$6DE then
if Gg[Lex]<=$6DD then
call gwx(Lex,Lxx,"when calling deserialize in DataInterfaces, line 26")
else
call G_x(Lex,Lxx,"when calling deserialize in DataInterfaces, line 26")
endif
else
call Kyx(Lex,Lxx,"when calling deserialize in DataInterfaces, line 26")
endif
set EM=EM-1
endfunction
function Lrx takes integer Rrt,integer Trt returns nothing
endfunction
function Lix takes integer Lax,integer Lnx,string LVx returns nothing
set ZM[EM]=LVx
set EM=EM+1
if Gg[Lax]==0 then
if Lax==0 then
call Cdv("Nullpointer exception when calling Persistable.onLoaded","when calling error in PersistableData, line 66")
else
call Cdv("Called Persistable.onLoaded on invalid object.","when calling error in PersistableData, line 66")
endif
endif
call Lrx(Lax,Lnx)
set EM=EM-1
endfunction
function LEx takes integer LXx,string LOx returns nothing
set ZM[EM]=LOx
set EM=EM+1
if Gk[LXx]==0 then
call Cdv("Double free: object of type PersistableLoadCallback","when calling error in PersistableData, line 44")
else
set Rk[Tk]=LXx
set Tk=Tk+1
set Gk[LXx]=0
endif
set EM=EM-1
endfunction
function LRx takes integer LIx,string LAx returns nothing
set ZM[EM]=LAx
set EM=EM+1
call LEx(LIx,"when calling dealloc_PersistableLoadCallback in PersistableData, line 44")
set EM=EM-1
endfunction
function LNx takes integer Lbx,string LBx returns nothing
set ZM[EM]=LBx
set EM=EM+1
if Gk[Lbx]==0 then
if Lbx==0 then
call Cdv("Nullpointer exception when calling PersistableLoadCallback.PersistableLoadCallback","when calling error in PersistableData, line 44")
else
call Cdv("Called PersistableLoadCallback.PersistableLoadCallback on invalid object.","when calling error in PersistableData, line 44")
endif
endif
call LRx(Lbx,"when calling destroyPersistableLoadCallback in PersistableData, line 44")
set EM=EM-1
endfunction
function Lcx takes integer ISS,integer LCx,integer Ldx,string LDx returns nothing
local integer Lfx
local integer LFx
local integer Lgx
set ZM[EM]=LDx
set EM=EM+1
set Lfx=Ldx
if Lfx==0 then
set LFx=0
set Lgx=Mq-1
loop
exitwhen LFx>Lgx
if Vqx(Vq[LCx],LFx,"when calling getBaseTypeId in UnitShops, line 159")!=0 then
call Vwx(LCx,LFx,true,"when calling makeSlotAvailable in UnitShops, line 160")
endif
set LFx=LFx+1
endloop
call GDe("Пользовательские типы юнитов загружены.",30.,sa[LCx])
elseif Lfx==1 then
call GDe("FAIL_READ",30.,sa[LCx])
elseif Lfx==2 then
call GDe("FAIL_DESERIALIZE: "+Bp,30.,sa[LCx])
else
call GDe("FAIL_NO_PLAYER",30.,sa[LCx])
endif
set EM=EM-1
endfunction
function LGx takes integer Lhx,integer LHx,integer Ljx,string LJx returns nothing
set ZM[EM]=LJx
set EM=EM+1
if Ek[Lhx]==0 then
if Lhx==0 then
call Cdv("Nullpointer exception when calling PlayerDefinedUnitTypesLoadCallback.onLoaded","when calling error in PlayerDefinedUnitTypes, line 75")
else
call Cdv("Called PlayerDefinedUnitTypesLoadCallback.onLoaded on invalid object.","when calling error in PlayerDefinedUnitTypes, line 75")
endif
endif
call Lcx(Lhx,LHx,Ljx,"when calling onLoaded_registerPlayerDefinedUnitTypesLoadCallback_UnitShops in PlayerDefinedUnitTypes, line 75")
set EM=EM-1
endfunction
function Lkx takes integer LKx,integer Llx,string LLx returns nothing
local integer Lmx
local integer LMx
set ZM[EM]=LLx
set EM=EM+1
set Lmx=0
set LMx=Bq-1
loop
exitwhen Lmx>LMx
call LGx(Nq[Lmx],LKx,Llx,"when calling onLoaded in PlayerDefinedUnitTypes, line 86")
set Lmx=Lmx+1
endloop
set EM=EM-1
endfunction
function Lpx takes integer LPx,integer Lqx,string LQx returns nothing
set ZM[EM]=LQx
set EM=EM+1
call Lkx(bH[LPx],Lqx,"when calling invokeCallbacks in PlayerDefinedUnitTypes, line 91")
set EM=EM-1
endfunction
function Lsx takes integer LSx,string Ltx returns integer
local integer LTx
set ZM[EM]=Ltx
set EM=EM+1
set LTx=EQx(.0,LSx,"when calling doAfter in ClosureTimers, line 33")
set EM=EM-1
return LTx
endfunction
function Lux takes string LUx returns integer
local integer Lwx
set ZM[EM]=LUx
set EM=EM+1
if Uh==0 then
if Ih<$8000 then
set Ih=Ih+1
set Lwx=Ih
set Ph[Lwx]=$CC6
else
call Cdv("Out of memory: Could not create LegacyPositionedUnitDataPasteCallback_paste_LegacySaveData_LegacySaveData.","when calling error in LegacySaveData, line 69")
set Lwx=0
endif
else
set Uh=Uh-1
set Lwx=Zh[Uh]
set Ph[Lwx]=$CC6
endif
set EM=EM-1
return Lwx
endfunction
function LWx takes integer Lyx,integer LYx,string Lzx returns real
local real LZx
if LYx<0 or LYx>=2 then
call Cdv("Index out of Bounds",Lzx)
elseif LYx<=0 then
set LZx=zQ[Lyx]
else
set LZx=zs[Lyx]
endif
return LZx
endfunction
function L_x takes integer L0x,integer L1x,string L2x returns integer
local integer L3x
if L1x<0 or L1x>=2 then
call Cdv("Index out of Bounds",L2x)
elseif L1x<=0 then
set L3x=zt[L0x]
else
set L3x=zT[L0x]
endif
return L3x
endfunction
function L4x takes integer L5x,integer L6x,string L7x returns integer
local integer L8x
if L6x<0 or L6x>=6 then
call Cdv("Index out of Bounds",L7x)
elseif L6x<=2 then
if L6x<=1 then
if L6x<=0 then
set L8x=zJ[L5x]
else
set L8x=zk[L5x]
endif
else
set L8x=zK[L5x]
endif
elseif L6x<=4 then
if L6x<=3 then
set L8x=zl[L5x]
else
set L8x=zL[L5x]
endif
else
set L8x=zm[L5x]
endif
return L8x
endfunction
function L9x takes integer mvx,integer mex returns boolean
return n9e(mvx,mex)
endfunction
function mxx takes integer mox,integer mrx returns boolean
return n9e(mox,mrx)
endfunction
function mix takes integer max returns real
return max/TT
endfunction
function mnx takes integer mVx,integer mEx,string mXx returns string
local string mOx
set ZM[EM]=mXx
set EM=EM+1
set mOx=Rre(iI[mVx],mEx,"when calling get in LegacyStringTable, line 28")
set EM=EM-1
return mOx
endfunction
function mRx takes integer mIx,integer mAx,string mNx returns string
local string mbx
set ZM[EM]=mNx
set EM=EM+1
if Gg[mIx]==0 then
if mIx==0 then
call Cdv("Nullpointer exception when calling StringTable.getString","when calling error in LegacyStringTable, line 27")
else
call Cdv("Called StringTable.getString on invalid object.","when calling error in LegacyStringTable, line 27")
endif
endif
set mbx=mnx(mIx,mAx,"when calling getString in LegacyStringTable, line 27")
set EM=EM-1
return mbx
endfunction
function mBx takes integer mcx,integer mCx,string mdx returns integer
local integer mDx
if mCx<0 or mCx>=2 then
call Cdv("Index out of Bounds",mdx)
elseif mCx<=0 then
set mDx=zS[mcx]
else
set mDx=it[mcx]
endif
return mDx
endfunction
function mfx takes integer mFx,integer mgx returns boolean
return n9e(mFx,mgx)
endfunction
function mGx takes unit mhx,integer mHx,integer mjx,real mJx,integer mkx,integer mKx,integer mlx returns nothing
if mfx(mHx,0)then
call N6e(mhx,mjx,mlx)
endif
if mfx(mHx,2)then
call tEv(mhx,mJx,mlx)
endif
if mfx(mHx,4)then
call tev(mhx,mkx,mlx)
endif
if mfx(mHx,6)then
call N2e(mhx,mKx,mlx)
endif
endfunction
function mLx takes integer mmx,integer mMx,string mpx returns integer
local integer mPx
if mMx<0 or mMx>=2 then
call Cdv("Index out of Bounds",mpx)
elseif mMx<=0 then
set mPx=zP[mmx]
else
set mPx=zq[mmx]
endif
return mPx
endfunction
function mqx takes boolean mQx returns nothing
local string msx="False"
if mQx then
set msx="True"
endif
call lUx(msx)
endfunction
function mSx takes integer mtx,integer mTx,string mux returns integer
local integer mUx
if mTx<0 or mTx>=2 then
call Cdv("Index out of Bounds",mux)
elseif mTx<=0 then
set mUx=zM[mtx]
else
set mUx=zp[mtx]
endif
return mUx
endfunction
function mwx takes integer mWx,integer myx returns boolean
return n9e(mWx,myx)
endfunction
function mYx takes integer mzx,item mZx,string m_x returns nothing
local item m0x
local item m1x
local item m2x
local item m3x
local item m4x
set ZM[EM]=m_x
set EM=EM+1
set m0x=mZx
call Ile(m0x,mwx(PU[mzx],0))
set m1x=m0x
call R9e(m1x,mwx(PU[mzx],1))
set m2x=m1x
call Iie(m2x,mwx(PU[mzx],2))
set m3x=m2x
call IMe(m3x,mwx(PU[mzx],3))
set m4x=m3x
call IJe(m4x,DU[mzx])
if mwx(PU[mzx],6)then
call IBe(mZx,HU[mzx])
endif
if mwx(PU[mzx],7)then
call Ihe(mZx,mRx(IU[mzx],JU[mzx],"when calling getString in LegacyItemData, line 94"))
endif
if mwx(PU[mzx],8)then
call IOe(mZx,mRx(IU[mzx],KU[mzx],"when calling getString in LegacyItemData, line 96"))
endif
if mwx(PU[mzx],9)then
call Wpv(mZx,mRx(IU[mzx],LU[mzx],"when calling getString in LegacyItemData, line 98"))
endif
if mwx(PU[mzx],$A)then
call IFe(mZx,mRx(IU[mzx],XU[mzx],"when calling getString in LegacyItemData, line 100"))
endif
if mwx(PU[mzx],$B)then
call IAe(mZx,mRx(IU[mzx],CU[mzx],"when calling getString in LegacyItemData, line 102"))
endif
set EM=EM-1
set m0x=null
set m1x=null
set m2x=null
set m3x=null
set m4x=null
endfunction
function m5x takes integer m6x,item m7x,string m8x returns nothing
set ZM[EM]=m8x
set EM=EM+1
if Eh[m6x]==0 then
if m6x==0 then
call Cdv("Nullpointer exception when calling SingleItemData.initItem","when calling error in LegacyItemData, line 85")
else
call Cdv("Called SingleItemData.initItem on invalid object.","when calling error in LegacyItemData, line 85")
endif
endif
call mYx(m6x,m7x,"when calling initItem in LegacyItemData, line 85")
set EM=EM-1
endfunction
function m9x takes integer Mvx,string Mex returns item
local item Mxx
set ZM[EM]=Mex
set EM=EM+1
set Mxx=ahe(AU[Mvx],.0,.0)
call m5x(Mvx,Mxx,"when calling initItem in LegacyItemData, line 106")
set EM=EM-1
set Ixv=Mxx
set Mxx=null
return Ixv
endfunction
function Mox takes integer Mrx,string Mix returns item
local item Max
set ZM[EM]=Mix
set EM=EM+1
if Eh[Mrx]==0 then
if Mrx==0 then
call Cdv("Nullpointer exception when calling SingleItemData.create","when calling error in LegacyItemData, line 104")
else
call Cdv("Called SingleItemData.create on invalid object.","when calling error in LegacyItemData, line 104")
endif
endif
set Max=m9x(Mrx,"when calling create in LegacyItemData, line 104")
set EM=EM-1
set Icv=Max
set Max=null
return Icv
endfunction
function Mnx takes integer MVx,player MEx,real MXx,real MOx,real MRx,string MIx returns unit
local unit MAx
local unit MNx
local integer Mbx
local integer MBx
local item Mcx
local real MCx
local real Mdx
local integer MDx
local integer Mfx
local integer MFx
local integer Mgx
local integer MGx
local integer Mhx
local integer MHx
local unit Mjx
local unit MJx
local integer Mkx
set ZM[EM]=MIx
set EM=EM+1
set MNx=vAe(MEx,RI[MVx],MXx,MOx,MRx)
call RSe(MNx,L9x(fI[MVx],0))
set MAx=MNx
call mqx(L9x(fI[MVx],0))
call mqx(L9x(fI[MVx],1))
call mqx(L9x(fI[MVx],2))
call mqx(L9x(fI[MVx],3))
call lUx("_")
call mqx(L9x(fI[MVx],17))
call mqx(L9x(fI[MVx],20))
call mqx(L9x(fI[MVx],21))
call mqx(L9x(fI[MVx],22))
call mqx(L9x(fI[MVx],23))
call mqx(L9x(fI[MVx],18))
call mqx(L9x(fI[MVx],19))
if L9x(fI[MVx],4)then
call bFe(MAx,1,false)
elseif L9x(fI[MVx],5)then
call bFe(MAx,1,true)
endif
call bFe(MAx,2,L9x(fI[MVx],6))
if L9x(fI[MVx],7)then
call Nde(MAx,YI[MVx])
endif
if L9x(fI[MVx],8)then
call tuv(MAx,tWv(GI[MVx]))
endif
if L9x(fI[MVx],9)then
call Nre(MAx,gI[MVx],hI[MVx],FI[MVx],kI[MVx])
endif
if L9x(fI[MVx],$A)then
call NIe(MAx,jI[MVx])
endif
if L9x(fI[MVx],$B)then
call AMe(MAx,xI[MVx])
endif
if L9x(fI[MVx],$C)then
call ASe(MAx,vI[MVx])
endif
if L9x(fI[MVx],$D)then
call AWe(MAx,mI[MVx])
endif
if L9x(fI[MVx],$E)then
call Aqe(MAx,QI[MVx])
endif
if L9x(fI[MVx],$F)then
call Age(MAx,uiv(WI[MVx]))
endif
if L9x(fI[MVx],3)then
call ZNv(MAx,II[MVx],false)
call O8e(MAx,EI[MVx])
call QMe(MAx,ZI[MVx])
call LEe(MAx,UI[MVx])
call Rfe(MAx,mRx(dI[MVx],PI[MVx],"when calling getString in LegacyUnitData, line 217"))
endif
if L9x(fI[MVx],16)then
call bze(MAx,TI[MVx])
set Mbx=0
set MBx=TI[MVx]-1
loop
exitwhen Mbx>MBx
if L4x(MVx,Mbx,"when reading array LegacySingleUnitData_items in  in LegacyUnitData, line 221")!=0 then
set Mcx=Mox(L4x(MVx,Mbx,"when reading array LegacySingleUnitData_items in  in LegacyUnitData, line 222"),"when calling create in LegacyUnitData, line 222")
call A8e(MAx,Mcx)
call AAe(MAx,Mcx,Mbx)
endif
set Mbx=Mbx+1
endloop
endif
if L9x(fI[MVx],17)then
call bKe(MAx,AI[MVx])
endif
if L9x(fI[MVx],18)then
call mGx(MAx,mSx(MVx,0,"when reading array LegacySingleUnitData_weapons_flags_val in  in LegacyUnitData, line 229"),mLx(MVx,0,"when reading array LegacySingleUnitData_weapons_baseDamage in  in LegacyUnitData, line 229"),LWx(MVx,0,"when reading array LegacySingleUnitData_weapons_cooldown in  in LegacyUnitData, line 229"),mBx(MVx,0,"when reading array LegacySingleUnitData_weapons_diceSides in  in LegacyUnitData, line 229"),L_x(MVx,0,"when reading array LegacySingleUnitData_weapons_diceNumber in  in LegacyUnitData, line 229"),1)
endif
if L9x(fI[MVx],19)then
call mGx(MAx,mSx(MVx,1,"when reading array LegacySingleUnitData_weapons_flags_val in  in LegacyUnitData, line 231"),mLx(MVx,1,"when reading array LegacySingleUnitData_weapons_baseDamage in  in LegacyUnitData, line 231"),LWx(MVx,1,"when reading array LegacySingleUnitData_weapons_cooldown in  in LegacyUnitData, line 231"),mBx(MVx,1,"when reading array LegacySingleUnitData_weapons_diceSides in  in LegacyUnitData, line 231"),L_x(MVx,1,"when reading array LegacySingleUnitData_weapons_diceNumber in  in LegacyUnitData, line 231"),1)
endif
if L9x(fI[MVx],20)then
call bVe(MAx,DI[MVx])
endif
set Mjx=MAx
if L9x(fI[MVx],21)then
set MCx=HI[MVx]
else
set MCx=b7e(MAx)
endif
call O0e(Mjx,MCx)
if L9x(fI[MVx],22)then
call uBv(MAx,JI[MVx])
endif
set MJx=MAx
if L9x(fI[MVx],23)then
set Mdx=KI[MVx]
else
set Mdx=bOe(MAx)
endif
call Rqe(MJx,Mdx)
if L9x(fI[MVx],24)then
call Nee(MAx,mRx(dI[MVx],LI[MVx],"when calling getString in LegacyUnitData, line 239"))
endif
if L9x(fI[MVx],25)then
call lUx("Has removed")
set MDx=jdv(XI[MVx],"when calling iterator in LegacyUnitData, line 242")
loop
exitwhen not Jgv(MDx,"when calling hasNext in LegacyUnitData, line 242")
set Mfx=jTv(MDx,"when calling next in LegacyUnitData, line 242")
call TMv(MAx,Mfx)
endloop
call Jqv(MDx,"when calling close in LegacyUnitData, line 242")
endif
if L9x(fI[MVx],26)then
call lUx("has modified")
set MFx=0
set Mgx=0
loop
exitwhen not(MFx!=dgv(CI[MVx],"when calling size in LegacyUnitData, line 248"))
set MGx=jqv(CI[MVx],MFx,"when calling get in LegacyUnitData, line 249")
call wnv(MAx,MGx)
set MFx=MFx+1
set Mkx=jqv(CI[MVx],MFx,"when calling get in LegacyUnitData, line 252")
set Mhx=Mkx
set MFx=MFx+1
if mxx(Mhx,0)then
set MHx=1
elseif mxx(Mhx,1)then
set MHx=2
elseif mxx(Mhx,2)then
set MHx=3
elseif mxx(Mhx,3)then
set MHx=4
else
set MHx=jqv(CI[MVx],MFx,"when calling get in LegacyUnitData, line 264")
set MFx=MFx+1
endif
call Uuv(MAx,MGx,MHx)
if mxx(Mhx,5)then
call OPe(MAx,MGx,MHx,jqv(CI[MVx],MFx,"when calling get in LegacyUnitData, line 268"))
set MFx=MFx+1
endif
if mxx(Mhx,6)then
call Ole(MAx,MGx,MHx,mix(jqv(VI[MVx],Mgx,"when calling get in LegacyUnitData, line 271")))
set Mgx=Mgx+1
endif
endloop
endif
if L9x(fI[MVx],1)then
call O3e(MAx)
endif
call NQe(MAx,not L9x(fI[MVx],2))
call Rze(MAx,MXx,MOx)
set EM=EM-1
set Iov=MAx
set MAx=null
set MNx=null
set Mcx=null
set Mjx=null
set MJx=null
return Iov
endfunction
function MKx takes integer Mlx,player MLx,real Mmx,real MMx,string Mpx returns unit
local unit MPx
set ZM[EM]=Mpx
set EM=EM+1
set MPx=Mnx(Mlx,MLx,I_e(Mmx,MMx,BI[Mlx],NI[Mlx]),O1,MI[Mlx],"when calling create in LegacyUnitData, line 378")
set EM=EM-1
set Irv=MPx
set MPx=null
return Irv
endfunction
function Mqx takes integer MQx,player Msx,real MSx,real Mtx,string MTx returns unit
local unit Mux
set ZM[EM]=MTx
set EM=EM+1
if sF[MQx]==0 then
if MQx==0 then
call Cdv("Nullpointer exception when calling LegacySingleUnitDataPositioned.create","when calling error in LegacyUnitData, line 377")
else
call Cdv("Called LegacySingleUnitDataPositioned.create on invalid object.","when calling error in LegacyUnitData, line 377")
endif
endif
set Mux=MKx(MQx,Msx,MSx,Mtx,"when calling create in LegacyUnitData, line 377")
set EM=EM-1
set ICv=Mux
set Mux=null
return ICv
endfunction
function MUx takes string Mwx returns integer
local integer MWx
set ZM[EM]=Mwx
set EM=EM+1
if jG==0 then
if xG<$8000 then
set xG=xG+1
set MWx=xG
set vG[MWx]=$47C
else
call Cdv("Out of memory: Could not create CallbackSingle_nullTimer_paste_load_setArgumentsTypes_registerProtectedBuiltin_SotfrpGuiRegions.","when calling error in SotfrpGuiRegions, line 191")
set MWx=0
endif
else
set jG=jG-1
set MWx=kG[jG]
set vG[MWx]=$47C
endif
set EM=EM-1
return MWx
endfunction
function Myx takes integer MYx,string Mzx returns nothing
local integer MZx
set ZM[EM]=Mzx
set EM=EM+1
call GDe("Загрузка завершена!",30.,sa[OX[MYx]])
set MZx=MUx("when calling alloc_CallbackSingle_nullTimer_paste_load_setArgumentsTypes_registerProtectedBuiltin_SotfrpGuiRegions in SotfrpGuiRegions, line 191")
call EUx(MZx)
set bX[MZx]=lX[MYx]
call Lsx(MZx,"when calling nullTimer in SotfrpGuiRegions, line 191")
set EM=EM-1
endfunction
function M_x takes integer M0x,string M1x returns nothing
set ZM[EM]=M1x
set EM=EM+1
if Jh[M0x]==0 then
if M0x==0 then
call Cdv("Nullpointer exception when calling SaveDataPasteCallback.onPasted","when calling error in LegacySaveData, line 19")
else
call Cdv("Called SaveDataPasteCallback.onPasted on invalid object.","when calling error in LegacySaveData, line 19")
endif
endif
call Myx(M0x,"when calling onPasted_paste_load_setArgumentsTypes_registerProtectedBuiltin_SotfrpGuiRegions in LegacySaveData, line 19")
set EM=EM-1
endfunction
function M2x takes integer M3x,string M4x returns nothing
set ZM[EM]=M4x
set EM=EM+1
if Jh[M3x]==0 then
call Cdv("Double free: object of type SaveDataPasteCallback","when calling error in LegacySaveData, line 18")
else
set Ah[Dh]=M3x
set Dh=Dh+1
set Jh[M3x]=0
endif
set EM=EM-1
endfunction
function M5x takes integer M6x,string M7x returns nothing
set ZM[EM]=M7x
set EM=EM+1
call M2x(M6x,"when calling dealloc_SaveDataPasteCallback in LegacySaveData, line 18")
set EM=EM-1
endfunction
function M8x takes integer M9x,string pvx returns nothing
set ZM[EM]=pvx
set EM=EM+1
if Jh[M9x]==0 then
if M9x==0 then
call Cdv("Nullpointer exception when calling SaveDataPasteCallback.SaveDataPasteCallback","when calling error in LegacySaveData, line 18")
else
call Cdv("Called SaveDataPasteCallback.SaveDataPasteCallback on invalid object.","when calling error in LegacySaveData, line 18")
endif
endif
call M5x(M9x,"when calling destroySaveDataPasteCallback in LegacySaveData, line 18")
set EM=EM-1
endfunction
function pex takes integer pxx,string pox returns nothing
set ZM[EM]=pox
set EM=EM+1
if uI[pxx]!=0 then
call M_x(uI[pxx],"when calling onPasted in LegacySaveData, line 71")
call M8x(uI[pxx],"when calling dispatch_SaveDataPasteCallback_destroySaveDataPasteCallback in LegacySaveData, line 72")
endif
set EM=EM-1
endfunction
function prx takes integer pix,string pax returns nothing
set ZM[EM]=pax
set EM=EM+1
if Ph[pix]==0 then
if pix==0 then
call Cdv("Nullpointer exception when calling LegacyPositionedUnitDataPasteCallback.onPasted","when calling error in LegacyUnitData, line 388")
else
call Cdv("Called LegacyPositionedUnitDataPasteCallback.onPasted on invalid object.","when calling error in LegacyUnitData, line 388")
endif
endif
call pex(pix,"when calling onPasted_paste_LegacySaveData_LegacySaveData in LegacyUnitData, line 388")
set EM=EM-1
endfunction
function pnx takes integer pVx returns nothing
call lUx(I2S(pVx))
endfunction
function pEx takes integer pXx,string pOx returns nothing
set ZM[EM]=pOx
set EM=EM+1
if Ph[pXx]==0 then
call Cdv("Double free: object of type LegacyPositionedUnitDataPasteCallback","when calling error in LegacyUnitData, line 387")
else
set Zh[Uh]=pXx
set Uh=Uh+1
set Ph[pXx]=0
endif
set EM=EM-1
endfunction
function pRx takes integer pIx,string pAx returns nothing
set ZM[EM]=pAx
set EM=EM+1
call pEx(pIx,"when calling dealloc_LegacyPositionedUnitDataPasteCallback in LegacyUnitData, line 387")
set EM=EM-1
endfunction
function pNx takes integer pbx,string pBx returns nothing
set ZM[EM]=pBx
set EM=EM+1
if Ph[pbx]==0 then
if pbx==0 then
call Cdv("Nullpointer exception when calling LegacyPositionedUnitDataPasteCallback.LegacyPositionedUnitDataPasteCallback","when calling error in LegacyUnitData, line 387")
else
call Cdv("Called LegacyPositionedUnitDataPasteCallback.LegacyPositionedUnitDataPasteCallback on invalid object.","when calling error in LegacyUnitData, line 387")
endif
endif
call pRx(pbx,"when calling destroyLegacyPositionedUnitDataPasteCallback in LegacyUnitData, line 387")
set EM=EM-1
endfunction
function pcx takes integer pCx,player pdx,real pDx,real pfx,integer pFx,string pgx returns nothing
local integer pGx
local integer phx
set ZM[EM]=pgx
set EM=EM+1
call pnx(dgv(pI[pCx],"when calling size in LegacyUnitData, line 408"))
set pGx=jdv(pI[pCx],"when calling iterator in LegacyUnitData, line 409")
loop
exitwhen not Jgv(pGx,"when calling hasNext in LegacyUnitData, line 409")
set phx=jTv(pGx,"when calling next in LegacyUnitData, line 409")
call Mqx(phx,pdx,pDx,pfx,"when calling create in LegacyUnitData, line 410")
endloop
call Jqv(pGx,"when calling close in LegacyUnitData, line 409")
call prx(pFx,"when calling onPasted in LegacyUnitData, line 411")
call pNx(pFx,"when calling dispatch_LegacyPositionedUnitDataPasteCallback_destroyLegacyPositionedUnitDataPasteCallback in LegacyUnitData, line 412")
set EM=EM-1
endfunction
function pHx takes integer pjx,player pJx,real pkx,real pKx,integer plx,string pLx returns nothing
set ZM[EM]=pLx
set EM=EM+1
if Mh[pjx]==0 then
if pjx==0 then
call Cdv("Nullpointer exception when calling LegacyPositionedUnitData.paste","when calling error in LegacyUnitData, line 407")
else
call Cdv("Called LegacyPositionedUnitData.paste on invalid object.","when calling error in LegacyUnitData, line 407")
endif
endif
call pcx(pjx,pJx,pkx,pKx,plx,"when calling paste in LegacyUnitData, line 407")
set EM=EM-1
endfunction
function pmx takes integer pMx,integer ppx,string pPx returns nothing
local integer pqx
local integer pQx
local player psx
local real pSx
local real ptx
local real pTx
local real pux
set ZM[EM]=pPx
set EM=EM+1
call lUx("pasting unit data")
set pQx=wI[pMx]
set psx=xD[pMx]
set pTx=BU[pMx]
set pux=NU[pMx]
set pSx=pTx
set ptx=pux
set pqx=Lux("when calling alloc_LegacyPositionedUnitDataPasteCallback_paste_LegacySaveData_LegacySaveData in LegacySaveData, line 69")
set uI[pqx]=ppx
call pHx(pQx,psx,pSx,ptx,pqx,"when calling paste in LegacySaveData, line 69")
set EM=EM-1
set psx=null
endfunction
function pUx takes integer pwx,integer pWx,string pyx returns nothing
set ZM[EM]=pyx
set EM=EM+1
if Gg[pwx]==0 then
if pwx==0 then
call Cdv("Nullpointer exception when calling LegacySaveData.paste","when calling error in LegacySaveData, line 67")
else
call Cdv("Called LegacySaveData.paste on invalid object.","when calling error in LegacySaveData, line 67")
endif
endif
call pmx(pwx,pWx,"when calling paste in LegacySaveData, line 67")
set EM=EM-1
endfunction
function pYx takes string pzx returns integer
local integer pZx
set ZM[EM]=pzx
set EM=EM+1
if jG==0 then
if xG<$8000 then
set xG=xG+1
set pZx=xG
set vG[pZx]=$47A
else
call Cdv("Out of memory: Could not create CallbackSingle_nullTimer_load_setArgumentsTypes_registerProtectedBuiltin_SotfrpGuiRegions.","when calling error in SotfrpGuiRegions, line 198")
set pZx=0
endif
else
set jG=jG-1
set pZx=kG[jG]
set vG[pZx]=$47A
endif
set EM=EM-1
return pZx
endfunction
function p_x takes string p0x returns integer
local integer p1x
set ZM[EM]=p0x
set EM=EM+1
if Dh==0 then
if Hh<$8000 then
set Hh=Hh+1
set p1x=Hh
set Jh[p1x]=4513
else
call Cdv("Out of memory: Could not create SaveDataPasteCallback_paste_load_setArgumentsTypes_registerProtectedBuiltin_SotfrpGuiRegions.","when calling error in SotfrpGuiRegions, line 189")
set p1x=0
endif
else
set Dh=Dh-1
set p1x=Ah[Dh]
set Jh[p1x]=4513
endif
set EM=EM-1
return p1x
endfunction
function p2x takes integer p3x,real p4x,real p5x returns nothing
local real p6x=p4x
local real p7x=p5x
set BU[p3x]=p6x
set NU[p3x]=p7x
endfunction
function p8x takes integer p9x,real Pvx,real Pex,string Pxx returns nothing
set ZM[EM]=Pxx
set EM=EM+1
if Gg[p9x]==0 then
if p9x==0 then
call Cdv("Nullpointer exception when calling LegacySaveData.setOrigin","when calling error in LegacySaveData, line 58")
else
call Cdv("Called LegacySaveData.setOrigin on invalid object.","when calling error in LegacySaveData, line 58")
endif
endif
call p2x(p9x,Pvx,Pex)
set EM=EM-1
endfunction
function Pox takes integer Prx,integer Pix,string Pax returns nothing
local integer Pnx
local integer PVx
local integer PEx
set ZM[EM]=Pax
set EM=EM+1
if Pix==0 then
call p8x(iX[Prx],SX[Prx],cX[Prx],"when calling setOrigin in SotfrpGuiRegions, line 187")
call GDe("Чтение файла и синхронизация данных завершены! Загрузка...",30.,sa[oX[Prx]])
set PEx=iX[Prx]
set Pnx=p_x("when calling alloc_SaveDataPasteCallback_paste_load_setArgumentsTypes_registerProtectedBuiltin_SotfrpGuiRegions in SotfrpGuiRegions, line 189")
set OX[Pnx]=oX[Prx]
set lX[Pnx]=iX[Prx]
call pUx(PEx,Pnx,"when calling paste in SotfrpGuiRegions, line 189")
else
if Pix==1 then
call GDe("Не удалось прочитать файл. Возможно, файл отсутствует или поврежден, или к нему не удалось получить доступ.",30.,sa[oX[Prx]])
else
call GDe("Во время загрузки произошла внутренняя ошибка. Пожалуйста, сообщите об этом разработчикам, приложив как можно больше информации о том, в каких обстоятельствах это произошло.",30.,sa[oX[Prx]])
endif
set PVx=pYx("when calling alloc_CallbackSingle_nullTimer_load_setArgumentsTypes_registerProtectedBuiltin_SotfrpGuiRegions in SotfrpGuiRegions, line 198")
call EUx(PVx)
set yX[PVx]=iX[Prx]
call Lsx(PVx,"when calling nullTimer in SotfrpGuiRegions, line 198")
endif
set EM=EM-1
endfunction
function PXx takes string POx returns integer
local integer PRx
set ZM[EM]=POx
set EM=EM+1
if Lk==0 then
if Xk<$8000 then
set Xk=Xk+1
set PRx=Xk
set Ck[PRx]=4217
else
call Cdv("Out of memory: Could not create RegionDataPasteCallback_paste_load_setArgumentsTypes_registerProtectedBuiltin_SotfrpGuiRegions.","when calling error in SotfrpGuiRegions, line 167")
set PRx=0
endif
else
set Lk=Lk-1
set PRx=Kk[Lk]
set Ck[PRx]=4217
endif
set EM=EM-1
return PRx
endfunction
function PIx takes string PAx returns integer
local integer PNx
set ZM[EM]=PAx
set EM=EM+1
if jG==0 then
if xG<$8000 then
set xG=xG+1
set PNx=xG
set vG[PNx]=$479
else
call Cdv("Out of memory: Could not create CallbackSingle_nullTimer_load_setArgumentsTypes_registerProtectedBuiltin_SotfrpGuiRegions.","when calling error in SotfrpGuiRegions, line 176")
set PNx=0
endif
else
set jG=jG-1
set PNx=kG[jG]
set vG[PNx]=$479
endif
set EM=EM-1
return PNx
endfunction
function Pbx takes integer PBx,real Pcx,real PCx returns nothing
local real Pdx=Pcx
local real PDx=PCx
set AH[PBx]=Pdx
set DH[PBx]=PDx
endfunction
function Pfx takes integer PFx,real Pgx,real PGx,string Phx returns nothing
set ZM[EM]=Phx
set EM=EM+1
if Gg[PFx]==0 then
if PFx==0 then
call Cdv("Nullpointer exception when calling RegionData.setOrigin","when calling error in RegionData, line 89")
else
call Cdv("Called RegionData.setOrigin on invalid object.","when calling error in RegionData, line 89")
endif
endif
call Pbx(PFx,Pgx,PGx)
set EM=EM-1
endfunction
function PHx takes string Pjx returns integer
local integer PJx
set ZM[EM]=Pjx
set EM=EM+1
if Bk==0 then
if Nk<$8000 then
set Nk=Nk+1
set PJx=Nk
set Mk[PJx]=4931
else
call Cdv("Out of memory: Could not create TerrainDataPasteCallback_paste_RegionData_RegionData.","when calling error in RegionData, line 115")
set PJx=0
endif
else
set Bk=Bk-1
set PJx=Vk[Bk]
set Mk[PJx]=4931
endif
set EM=EM-1
return PJx
endfunction
function Pkx takes string PKx returns integer
local integer Plx
set ZM[EM]=PKx
set EM=EM+1
if EY==0 then
if ZY<$8000 then
set ZY=ZY+1
set Plx=ZY
set UY[Plx]=$D1E
else
call Cdv("Out of memory: Could not create LimitedExecuteCondition_executeWhile_SubRectTileData_TerrainData.","when calling error in TerrainData, line 76")
set Plx=0
endif
else
set EY=EY-1
set Plx=WY[EY]
set UY[Plx]=$D1E
endif
set EM=EM-1
return Plx
endfunction
function PLx takes string Pmx returns integer
local integer PMx
set ZM[EM]=Pmx
set EM=EM+1
if PY==0 then
if AY<$8000 then
set AY=AY+1
set PMx=AY
set DY[PMx]=$CFA
else
call Cdv("Out of memory: Could not create LimitedExecuteAction_executeWhile_SubRectTileData_TerrainData.","when calling error in TerrainData, line 76")
set PMx=0
endif
else
set PY=PY-1
set PMx=IY[PY]
set DY[PMx]=$CFA
endif
set EM=EM-1
return PMx
endfunction
function Ppx takes integer Xct returns nothing
endfunction
function PPx takes integer Pqx,string PQx returns nothing
set ZM[EM]=PQx
set EM=EM+1
if Pk[Pqx]==0 then
call Cdv("Double free: object of type RectCellIterator","when calling error in RectCellIterator, line 3")
else
set Zk[Uk]=Pqx
set Uk=Uk+1
set Pk[Pqx]=0
endif
set EM=EM-1
endfunction
function Psx takes integer PSx,string Ptx returns nothing
set ZM[EM]=Ptx
set EM=EM+1
call Ppx(PSx)
call PPx(PSx,"when calling dealloc_RectCellIterator in RectCellIterator, line 3")
set EM=EM-1
endfunction
function PTx takes integer Pux,string PUx returns nothing
set ZM[EM]=PUx
set EM=EM+1
if Pk[Pux]==0 then
if Pux==0 then
call Cdv("Nullpointer exception when calling RectCellIterator.RectCellIterator","when calling error in RectCellIterator, line 3")
else
call Cdv("Called RectCellIterator.RectCellIterator on invalid object.","when calling error in RectCellIterator, line 3")
endif
endif
call Psx(Pux,"when calling destroyRectCellIterator in RectCellIterator, line 3")
set EM=EM-1
endfunction
function Pwx takes integer PWx,string Pyx returns nothing
set ZM[EM]=Pyx
set EM=EM+1
call PTx(PWx,"when calling dispatch_RectCellIterator_destroyRectCellIterator in RectCellIterator, line 35")
set EM=EM-1
endfunction
function PYx takes integer Pzx,string PZx returns nothing
set ZM[EM]=PZx
set EM=EM+1
if Pk[Pzx]==0 then
if Pzx==0 then
call Cdv("Nullpointer exception when calling RectCellIterator.close","when calling error in RectCellIterator, line 34")
else
call Cdv("Called RectCellIterator.close on invalid object.","when calling error in RectCellIterator, line 34")
endif
endif
call Pwx(Pzx,"when calling close in RectCellIterator, line 34")
set EM=EM-1
endfunction
function P_x takes integer Uct returns nothing
endfunction
function P0x takes real P1x returns integer
local integer P2x=c6v(P1x)
if P1x<.0 and P1x-P2x!=.0 then
set P2x=P2x-1
endif
return P2x
endfunction
function P3x takes real P4x returns integer
local integer P5x=c6v(P4x)
if P4x>.0 and P4x-P5x!=.0 then
set P5x=P5x+1
endif
return P5x
endfunction
function P6x takes integer P7x,rect P8x returns nothing
call P_x(P7x)
set fH[P7x]=P0x(fee(P8x)/128.)*128.+64.
set RH[P7x]=P0x(foe(P8x)/128.)*128.+64.
set TH[P7x]=P3x(fie(P8x)/128.)*128.-64.
set YH[P7x]=P3x(D9e(P8x)/128.)*128.-64.
set GH[P7x]=fH[P7x]
set gH[P7x]=RH[P7x]
endfunction
function P9x takes string qvx returns integer
local integer qex
set ZM[EM]=qvx
set EM=EM+1
if Uk==0 then
if Ik<$8000 then
set Ik=Ik+1
set qex=Ik
set Pk[qex]=4208
else
call Cdv("Out of memory: Could not create RectCellIterator.","when calling error in RectCellIterator, line 3")
set qex=0
endif
else
set Uk=Uk-1
set qex=Zk[Uk]
set Pk[qex]=4208
endif
set EM=EM-1
return qex
endfunction
function qxx takes rect qox,string qrx returns integer
local integer qix
set ZM[EM]=qrx
set EM=EM+1
set qix=P9x("when calling alloc_RectCellIterator in RectCellIterator, line 11")
call P6x(qix,qox)
set EM=EM-1
return qix
endfunction
function qax takes rect qnx,string qVx returns integer
local integer qEx
set ZM[EM]=qVx
set EM=EM+1
set qEx=qxx(qnx,"when calling new_RectCellIterator in RectCellIterator, line 41")
set EM=EM-1
return qEx
endfunction
function qXx takes rect qOx,real qRx,real qIx returns nothing
call MoveRectTo(qOx,qRx,qIx)
endfunction
function qAx takes integer qNx,real qbx,real qBx,string qcx returns nothing
local rect qCx
local rect qdx
local boolean qDx
local integer qfx
local integer qFx
local integer qgx
local integer qGx
local integer qhx
local integer qHx
set ZM[EM]=qcx
set EM=EM+1
set qdx=Rect(.0,.0,RC[qNx],TC[qNx])
call qXx(qdx,I_e(qbx,qBx,IYe(dC[qNx],fC[qNx]),d1),O1)
set qCx=qdx
set qDx=Y4e(nC[qNx],2)
set qfx=qax(qCx,"when calling cellIterator in TerrainData, line 73")
set qFx=jgv(YC[qNx],"when calling iterator in TerrainData, line 74")
set qgx=jgv(GC[qNx],"when calling iterator in TerrainData, line 75")
set qGx=Pkx("when calling alloc_LimitedExecuteCondition_executeWhile_SubRectTileData_TerrainData in TerrainData, line 76")
set jC[qGx]=qfx
set qHx=qGx
set qhx=PLx("when calling alloc_LimitedExecuteAction_executeWhile_SubRectTileData_TerrainData in TerrainData, line 76")
set xC[qhx]=qfx
set vC[qhx]=qNx
set mC[qhx]=qFx
set QC[qhx]=qDx
set WC[qhx]=qgx
call WOe($400,qHx,qhx,"when calling executeWhile in TerrainData, line 76")
call wSe(qgx,"when calling close in TerrainData, line 81")
call wSe(qFx,"when calling close in TerrainData, line 82")
call PYx(qfx,"when calling close in TerrainData, line 83")
call lnv(qCx)
set EM=EM-1
set qCx=null
set qdx=null
endfunction
function qjx takes integer qJx,real qkx,real qKx,string qlx returns nothing
set ZM[EM]=qlx
set EM=EM+1
if Qv[qJx]==0 then
if qJx==0 then
call Cdv("Nullpointer exception when calling SubRectTileData.paste","when calling error in TerrainData, line 69")
else
call Cdv("Called SubRectTileData.paste on invalid object.","when calling error in TerrainData, line 69")
endif
endif
call qAx(qJx,qkx,qKx,"when calling paste in TerrainData, line 69")
set EM=EM-1
endfunction
function qLx takes integer qmx,string qMx returns nothing
set ZM[EM]=qMx
set EM=EM+1
if Mk[qmx]==0 then
call Cdv("Double free: object of type TerrainDataPasteCallback","when calling error in TerrainData, line 13")
else
set Vk[Bk]=qmx
set Bk=Bk+1
set Mk[qmx]=0
endif
set EM=EM-1
endfunction
function qpx takes integer qPx,string qqx returns nothing
set ZM[EM]=qqx
set EM=EM+1
call qLx(qPx,"when calling dealloc_TerrainDataPasteCallback in TerrainData, line 13")
set EM=EM-1
endfunction
function qQx takes integer qsx,string qSx returns nothing
set ZM[EM]=qSx
set EM=EM+1
if Mk[qsx]==0 then
if qsx==0 then
call Cdv("Nullpointer exception when calling TerrainDataPasteCallback.TerrainDataPasteCallback","when calling error in TerrainData, line 13")
else
call Cdv("Called TerrainDataPasteCallback.TerrainDataPasteCallback on invalid object.","when calling error in TerrainData, line 13")
endif
endif
call qpx(qsx,"when calling destroyTerrainDataPasteCallback in TerrainData, line 13")
set EM=EM-1
endfunction
function qtx takes string qTx returns integer
local integer qux
set ZM[EM]=qTx
set EM=EM+1
if hg==0 then
if Fg<$8000 then
set Fg=Fg+1
set qux=Fg
set kg[qux]=4115
else
call Cdv("Out of memory: Could not create PositionedDestructableDataPasteCallback_paste_paste_RegionData_RegionData.","when calling error in RegionData, line 116")
set qux=0
endif
else
set hg=hg-1
set qux=gg[hg]
set kg[qux]=4115
endif
set EM=EM-1
return qux
endfunction
function qUx takes integer qwx returns nothing
set mW[qwx]=0
endfunction
function qWx takes integer qyx returns nothing
call qUx(qyx)
endfunction
function qYx takes timer qzx,real qZx,code q_x returns nothing
call TimerStart(qzx,qZx,true,q_x)
endfunction
function q0x takes integer q1x,timer q2x,real q3x,integer q4x,string q5x returns nothing
local timer q6x
local timer q7x
set ZM[EM]=q5x
set EM=EM+1
set mW[q1x]=q4x
set q6x=q2x
call EXx(q6x,q1x,"when calling setData in ClosureTimers, line 153")
set q7x=q6x
call qYx(q7x,q3x,RAv)
set QW[q1x]=q7x
set EM=EM-1
set q6x=null
set q7x=null
endfunction
function q8x takes integer q9x,timer Qvx,real Qex,integer Qxx,string Qox returns nothing
set ZM[EM]=Qox
set EM=EM+1
if qg[q9x]==0 then
if q9x==0 then
call Cdv("Nullpointer exception when calling CallbackCounted.start","when calling error in ClosureTimers, line 150")
else
call Cdv("Called CallbackCounted.start on invalid object.","when calling error in ClosureTimers, line 150")
endif
endif
call q0x(q9x,Qvx,Qex,Qxx,"when calling start in ClosureTimers, line 150")
set EM=EM-1
endfunction
function Qrx takes timer Qix,real Qax,integer Qnx,integer QVx,string QEx returns integer
set ZM[EM]=QEx
set EM=EM+1
call q8x(QVx,Qix,Qax,Qnx,"when calling start in ClosureTimers, line 69")
set EM=EM-1
return QVx
endfunction
function QXx takes real QOx,integer QRx,integer QIx,string QAx returns integer
local integer QNx
set ZM[EM]=QAx
set EM=EM+1
set QNx=Qrx(EMx("when calling getTimer in ClosureTimers, line 81"),QOx,QRx,QIx,"when calling doPeriodicallyCounted in ClosureTimers, line 81")
set EM=EM-1
return QNx
endfunction
function Qbx takes string QBx returns integer
local integer Qcx
set ZM[EM]=QBx
set EM=EM+1
if pg==0 then
if eg<$8000 then
set eg=eg+1
set Qcx=eg
set qg[Qcx]=$461
else
call Cdv("Out of memory: Could not create CallbackCounted_doPeriodicallyCounted_PositionedDestructableData_DestructableData.","when calling error in DestructableData, line 276")
set Qcx=0
endif
else
set pg=pg-1
set Qcx=yg[pg]
set qg[Qcx]=$461
endif
set EM=EM-1
return Qcx
endfunction
function QCx takes integer Qdx,player QDx,real Qfx,real QFx,integer Qgx,string QGx returns nothing
local integer Qhx
local integer QHx
local integer Qjx
local real QJx
local real Qkx
set ZM[EM]=QGx
set EM=EM+1
set Qhx=bxx(0,"when calling new_Box⟪integer⟫ in DestructableData, line 275")
set Qjx=kPe(P3x(dgv(rE[Qdx],"when calling size in DestructableData, line 276")*1./25),1)
set QHx=Qbx("when calling alloc_CallbackCounted_doPeriodicallyCounted_PositionedDestructableData_DestructableData in DestructableData, line 276")
call qWx(QHx)
set pE[QHx]=Qhx
set eE[QHx]=Qdx
set qE[QHx]=QDx
set QJx=Qfx
set Qkx=QFx
set aE[QHx]=QJx
set nE[QHx]=Qkx
set dE[QHx]=Qgx
call QXx(.25,Qjx,QHx,"when calling doPeriodicallyCounted in DestructableData, line 276")
set EM=EM-1
endfunction
function QKx takes integer Qlx,player QLx,real Qmx,real QMx,integer Qpx,string QPx returns nothing
set ZM[EM]=QPx
set EM=EM+1
if Gg[Qlx]==0 then
if Qlx==0 then
call Cdv("Nullpointer exception when calling PositionedDestructableData.paste","when calling error in DestructableData, line 274")
else
call Cdv("Called PositionedDestructableData.paste on invalid object.","when calling error in DestructableData, line 274")
endif
endif
call QCx(Qlx,QLx,Qmx,QMx,Qpx,"when calling paste in DestructableData, line 274")
set EM=EM-1
endfunction
function Qqx takes integer QQx,string Qsx returns nothing
local integer QSx
local integer Qtx
local player QTx
local real Qux
local real QUx
local real Qwx
local real QWx
set ZM[EM]=Qsx
set EM=EM+1
set Qtx=XH[VH[QQx]]
set QTx=xD[VH[QQx]]
set Qwx=AH[VH[QQx]]
set QWx=DH[VH[QQx]]
set Qux=Qwx
set QUx=QWx
set QSx=qtx("when calling alloc_PositionedDestructableDataPasteCallback_paste_paste_RegionData_RegionData in RegionData, line 116")
set NH[QSx]=VH[QQx]
set MH[QSx]=BH[QQx]
call QKx(Qtx,QTx,Qux,QUx,QSx,"when calling paste in RegionData, line 116")
set EM=EM-1
set QTx=null
endfunction
function Qyx takes integer QYx,integer Qzx,string QZx returns nothing
if QYx==0 then
set ZM[EM]=QZx
set EM=EM+1
if UC[Qzx]!=0 then
call Qyx(1,UC[Qzx],"when calling onPasted in TerrainData, line 230")
call qQx(UC[Qzx],"when calling dispatch_TerrainDataPasteCallback_destroyTerrainDataPasteCallback in TerrainData, line 231")
endif
set EM=EM-1
elseif QYx==1 then
set ZM[EM]=QZx
set EM=EM+1
if Mk[Qzx]==0 then
if Qzx==0 then
call Cdv("Nullpointer exception when calling TerrainDataPasteCallback.onPasted","when calling error in TerrainData, line 14")
else
call Cdv("Called TerrainDataPasteCallback.onPasted on invalid object.","when calling error in TerrainData, line 14")
endif
endif
if Mk[Qzx]<=4931 then
call Qqx(Qzx,"when calling onPasted_paste_RegionData_RegionData in TerrainData, line 14")
else
call Qyx(0,Qzx,"when calling onPasted_paste_TerrainData_TerrainData in TerrainData, line 14")
endif
set EM=EM-1
endif
endfunction
function Q_x takes integer Q0x,real Q1x,real Q2x,integer Q3x,string Q4x returns nothing
local integer Q5x
local integer Q6x
set ZM[EM]=Q4x
set EM=EM+1
set Q5x=Xle(AC[Q0x],"when calling iterator in TerrainData, line 182")
loop
exitwhen not Xie(Q5x)
set Q6x=E3e(Q5x)
call qjx(Q6x,Q1x,Q2x,"when calling paste in TerrainData, line 183")
endloop
call Xpe(Q5x,"when calling close in TerrainData, line 182")
if Q3x!=0 then
call Qyx(1,Q3x,"when calling onPasted in TerrainData, line 185")
call qQx(Q3x,"when calling dispatch_TerrainDataPasteCallback_destroyTerrainDataPasteCallback in TerrainData, line 186")
endif
set EM=EM-1
endfunction
function Q7x takes integer Q8x,real Q9x,real svx,integer sex,string sxx returns nothing
set ZM[EM]=sxx
set EM=EM+1
if Gg[Q8x]==0 then
if Q8x==0 then
call Cdv("Nullpointer exception when calling TileData.paste","when calling error in TerrainData, line 181")
else
call Cdv("Called TileData.paste on invalid object.","when calling error in TerrainData, line 181")
endif
endif
call Q_x(Q8x,Q9x,svx,sex,"when calling paste in TerrainData, line 181")
set EM=EM-1
endfunction
function sox takes string srx returns integer
local integer six
set ZM[EM]=srx
set EM=EM+1
if Bk==0 then
if Nk<$8000 then
set Nk=Nk+1
set six=Nk
set Mk[six]=4932
else
call Cdv("Out of memory: Could not create TerrainDataPasteCallback_paste_TerrainData_TerrainData.","when calling error in TerrainData, line 228")
set six=0
endif
else
set Bk=Bk-1
set six=Vk[Bk]
set Mk[six]=4932
endif
set EM=EM-1
return six
endfunction
function sax takes integer snx,real sVx,real sEx,integer sXx,string sOx returns nothing
local integer sRx
local integer sIx
local real sAx
local real sNx
local real sbx
local real sBx
set ZM[EM]=sOx
set EM=EM+1
set sIx=ZC[snx]
set sbx=sVx
set sBx=sEx
set sAx=sbx
set sNx=sBx
set sRx=sox("when calling alloc_TerrainDataPasteCallback_paste_TerrainData_TerrainData in TerrainData, line 228")
set UC[sRx]=sXx
call Q7x(sIx,sAx,sNx,sRx,"when calling paste in TerrainData, line 228")
set EM=EM-1
endfunction
function scx takes integer sCx,real sdx,real sDx,integer sfx,string sFx returns nothing
set ZM[EM]=sFx
set EM=EM+1
if Gg[sCx]==0 then
if sCx==0 then
call Cdv("Nullpointer exception when calling TerrainData.paste","when calling error in TerrainData, line 227")
else
call Cdv("Called TerrainData.paste on invalid object.","when calling error in TerrainData, line 227")
endif
endif
call sax(sCx,sdx,sDx,sfx,"when calling paste in TerrainData, line 227")
set EM=EM-1
endfunction
function sgx takes integer sGx,integer shx,string sHx returns nothing
local integer sjx
local integer sJx
local real skx
local real sKx
local real slx
local real sLx
set ZM[EM]=sHx
set EM=EM+1
set sJx=LH[sGx]
set slx=AH[sGx]
set sLx=DH[sGx]
set skx=slx
set sKx=sLx
set sjx=PHx("when calling alloc_TerrainDataPasteCallback_paste_RegionData_RegionData in RegionData, line 115")
set VH[sjx]=sGx
set BH[sjx]=shx
call scx(sJx,skx,sKx,sjx,"when calling paste in RegionData, line 115")
set EM=EM-1
endfunction
function smx takes integer sMx,integer spx,string sPx returns nothing
set ZM[EM]=sPx
set EM=EM+1
if Gg[sMx]==0 then
if sMx==0 then
call Cdv("Nullpointer exception when calling RegionData.paste","when calling error in RegionData, line 114")
else
call Cdv("Called RegionData.paste on invalid object.","when calling error in RegionData, line 114")
endif
endif
call sgx(sMx,spx,"when calling paste in RegionData, line 114")
set EM=EM-1
endfunction
function sqx takes integer sQx,integer ssx,string sSx returns nothing
local integer stx
local integer sTx
local integer sux
set ZM[EM]=sSx
set EM=EM+1
if ssx==0 then
call Pfx(BL[sQx],NL[sQx],ML[sQx],"when calling setOrigin in SotfrpGuiRegions, line 165")
call GDe("Чтение файла и синхронизация данных завершены! Загрузка...",30.,sa[wX[sQx]])
set sux=BL[sQx]
set stx=PXx("when calling alloc_RegionDataPasteCallback_paste_load_setArgumentsTypes_registerProtectedBuiltin_SotfrpGuiRegions in SotfrpGuiRegions, line 167")
set uX[stx]=wX[sQx]
set rX[stx]=BL[sQx]
call smx(sux,stx,"when calling paste in SotfrpGuiRegions, line 167")
else
if ssx==1 then
call GDe("Не удалось прочитать файл. Возможно, файл отсутствует или поврежден, или к нему не удалось получить доступ.",30.,sa[wX[sQx]])
else
call GDe("Во время загрузки произошла внутренняя ошибка. Пожалуйста, сообщите об этом разработчикам, приложив как можно больше информации о том, в каких обстоятельствах это произошло.",30.,sa[wX[sQx]])
endif
set sTx=PIx("when calling alloc_CallbackSingle_nullTimer_load_setArgumentsTypes_registerProtectedBuiltin_SotfrpGuiRegions in SotfrpGuiRegions, line 176")
call EUx(sTx)
set tX[sTx]=BL[sQx]
call Lsx(sTx,"when calling nullTimer in SotfrpGuiRegions, line 176")
endif
set EM=EM-1
endfunction
function sUx takes integer swx,integer sWx,string syx returns nothing
set ZM[EM]=syx
set EM=EM+1
if Gk[swx]==0 then
if swx==0 then
call Cdv("Nullpointer exception when calling PersistableLoadCallback.onLoaded","when calling error in PersistableData, line 45")
else
call Cdv("Called PersistableLoadCallback.onLoaded on invalid object.","when calling error in PersistableData, line 45")
endif
endif
if Gk[swx]<=$FE2 then
if Gk[swx]<=$FE1 then
call Lpx(swx,sWx,"when calling onLoaded_load_doAfter_PlayerDefinedUnitTypes in PersistableData, line 45")
else
call sqx(swx,sWx,"when calling onLoaded_load_setArgumentsTypes_registerProtectedBuiltin_SotfrpGuiRegions in PersistableData, line 45")
endif
else
call Pox(swx,sWx,"when calling onLoaded_load_setArgumentsTypes_registerProtectedBuiltin_SotfrpGuiRegions in PersistableData, line 45")
endif
set EM=EM-1
endfunction
function sYx takes integer szx,integer sZx,integer s_x,string s0x returns nothing
set ZM[EM]=s0x
set EM=EM+1
call Lix(szx,sZx,"when calling onLoaded in PersistableData, line 122")
if s_x!=0 then
call sUx(s_x,sZx,"when calling onLoaded in PersistableData, line 124")
call LNx(s_x,"when calling dispatch_PersistableLoadCallback_destroyPersistableLoadCallback in PersistableData, line 125")
endif
set EM=EM-1
endfunction
function s1x takes integer s2x,integer s3x,integer s4x,string s5x returns nothing
set ZM[EM]=s5x
set EM=EM+1
if Gg[s2x]==0 then
if s2x==0 then
call Cdv("Nullpointer exception when calling Persistable.finishLoad","when calling error in PersistableData, line 121")
else
call Cdv("Called Persistable.finishLoad on invalid object.","when calling error in PersistableData, line 121")
endif
endif
call sYx(s2x,s3x,s4x,"when calling finishLoad in PersistableData, line 121")
set EM=EM-1
endfunction
function s6x takes integer s7x,integer s8x,integer s9x,string Svx returns nothing
local integer Sex
set ZM[EM]=Svx
set EM=EM+1
if s8x==1 then
call s1x(ID[s7x],3,PD[s7x],"when calling finishLoad in PersistableData, line 141")
else
set Sex=cux(s9x,"when calling readInt in PersistableData, line 143")
if Sex==0 then
if ta!=xD[ID[s7x]]then
call Lvx(ID[s7x],s9x,"when calling deserialize in PersistableData, line 147")
endif
call s1x(ID[s7x],0,PD[s7x],"when calling finishLoad in PersistableData, line 148")
else
call s1x(ID[s7x],Sex,PD[s7x],"when calling finishLoad in PersistableData, line 150")
endif
endif
set EM=EM-1
endfunction
function Sxx takes integer Sox,integer Srx,integer Six,string Sax returns nothing
set ZM[EM]=Sax
set EM=EM+1
if BF[Sox]==0 then
if Sox==0 then
call Cdv("Nullpointer exception when calling NetworkFinishedCallback.onFinish","when calling error in NetworkData, line 199")
else
call Cdv("Called NetworkFinishedCallback.onFinish on invalid object.","when calling error in NetworkData, line 199")
endif
endif
if BF[Sox]<=$E57 then
call BZx(Sox,Srx,Six,"when calling onFinish_Network_NetworkData in NetworkData, line 199")
else
call s6x(Sox,Srx,Six,"when calling onFinish_start_Persistable_PersistableData in NetworkData, line 199")
endif
set EM=EM-1
endfunction
function Snx takes integer SVx,string SEx returns nothing
set ZM[EM]=SEx
set EM=EM+1
if LF[SVx]==0 then
call Cdv("Double free: object of type Network","when calling error in NetworkData, line 204")
else
set HF[JF]=SVx
set JF=JF+1
set LF[SVx]=0
endif
set EM=EM-1
endfunction
function SXx takes integer SOx,string SRx returns nothing
set ZM[EM]=SRx
set EM=EM+1
if jY[SOx]==0 then
call Cdv("Double free: object of type HashWriter","when calling error in HashData, line 8")
else
set hY[FY]=SOx
set FY=FY+1
set jY[SOx]=0
endif
set EM=EM-1
endfunction
function SIx takes integer SAx,string SNx returns nothing
set ZM[EM]=SNx
set EM=EM+1
if rU[SAx]!=0 then
call idx(rU[SAx],"when calling dispatch_Table_destroyTable in HashData, line 18")
endif
set EM=EM-1
endfunction
function Sbx takes integer SBx,string Scx returns nothing
set ZM[EM]=Scx
set EM=EM+1
call SIx(SBx,"when calling HashWriter_onDestroy in HashData, line 16")
call SXx(SBx,"when calling dealloc_HashWriter in HashData, line 16")
set EM=EM-1
endfunction
function SCx takes integer Sdx,string SDx returns nothing
set ZM[EM]=SDx
set EM=EM+1
if jY[Sdx]==0 then
if Sdx==0 then
call Cdv("Nullpointer exception when calling HashWriter.HashWriter","when calling error in HashData, line 8")
else
call Cdv("Called HashWriter.HashWriter on invalid object.","when calling error in HashData, line 8")
endif
endif
call Sbx(Sdx,"when calling destroyHashWriter in HashData, line 8")
set EM=EM-1
endfunction
function Sfx takes integer SFx,string Sgx returns nothing
set ZM[EM]=Sgx
set EM=EM+1
if gY[SFx]==0 then
if SFx==0 then
call Cdv("Nullpointer exception when calling HashReader.HashReader","when calling error in HashData, line 77")
else
call Cdv("Called HashReader.HashReader on invalid object.","when calling error in HashData, line 77")
endif
endif
call bTx(SFx,"when calling destroyHashReader in HashData, line 77")
set EM=EM-1
endfunction
function SGx takes integer Lvs returns nothing
endfunction
function Shx takes integer SHx,string Sjx returns nothing
set ZM[EM]=Sjx
set EM=EM+1
if Bg[SHx]==0 then
call Cdv("Double free: object of type GamecacheBuffer","when calling error in GamecacheBuffer, line 21")
else
set Xg[Cg]=SHx
set Cg=Cg+1
set Bg[SHx]=0
endif
set EM=EM-1
endfunction
function SJx takes integer Skx,string SKx returns nothing
set ZM[EM]=SKx
set EM=EM+1
call SGx(Skx)
call Shx(Skx,"when calling dealloc_GamecacheBuffer in GamecacheBuffer, line 20")
set EM=EM-1
endfunction
function Slx takes integer SLx,string Smx returns nothing
set ZM[EM]=Smx
set EM=EM+1
if Bg[SLx]==0 then
if SLx==0 then
call Cdv("Nullpointer exception when calling GamecacheBuffer.GamecacheBuffer","when calling error in GamecacheBuffer, line 21")
else
call Cdv("Called GamecacheBuffer.GamecacheBuffer on invalid object.","when calling error in GamecacheBuffer, line 21")
endif
endif
call SJx(SLx,"when calling destroyGamecacheBuffer in GamecacheBuffer, line 21")
set EM=EM-1
endfunction
function SMx takes integer Spx,string SPx returns nothing
set ZM[EM]=SPx
set EM=EM+1
if BF[Spx]==0 then
call Cdv("Double free: object of type NetworkFinishedCallback","when calling error in NetworkData, line 198")
else
set XF[CF]=Spx
set CF=CF+1
set BF[Spx]=0
endif
set EM=EM-1
endfunction
function Sqx takes integer SQx,string Ssx returns nothing
set ZM[EM]=Ssx
set EM=EM+1
call SMx(SQx,"when calling dealloc_NetworkFinishedCallback in NetworkData, line 198")
set EM=EM-1
endfunction
function SSx takes integer Stx,string STx returns nothing
set ZM[EM]=STx
set EM=EM+1
if BF[Stx]==0 then
if Stx==0 then
call Cdv("Nullpointer exception when calling NetworkFinishedCallback.NetworkFinishedCallback","when calling error in NetworkData, line 198")
else
call Cdv("Called NetworkFinishedCallback.NetworkFinishedCallback on invalid object.","when calling error in NetworkData, line 198")
endif
endif
call Sqx(Stx,"when calling destroyNetworkFinishedCallback in NetworkData, line 198")
set EM=EM-1
endfunction
function Sux takes integer SUx,string Swx returns nothing
set ZM[EM]=Swx
set EM=EM+1
if QX[SUx]!=0 then
call Sfx(QX[SUx],"when calling dispatch_HashReader_destroyHashReader in StringEncoder, line 71")
endif
if mX[SUx]!=0 then
call SCx(mX[SUx],"when calling dispatch_HashWriter_destroyHashWriter in StringEncoder, line 74")
endif
if EX[SUx]!=0 then
call Sfx(EX[SUx],"when calling dispatch_HashReader_destroyHashReader in StringEncoder, line 77")
endif
if WX[SUx]!=0 then
call SCx(WX[SUx],"when calling dispatch_HashWriter_destroyHashWriter in StringEncoder, line 80")
endif
set EM=EM-1
endfunction
function SWx takes integer Syx,string SYx returns nothing
set ZM[EM]=SYx
set EM=EM+1
if Ov[Syx]==0 then
call Cdv("Double free: object of type StringEncoder","when calling error in StringEncoder, line 59")
else
set Sv[cv]=Syx
set cv=cv+1
set Ov[Syx]=0
endif
set EM=EM-1
endfunction
function Szx takes integer SZx,string S_x returns nothing
set ZM[EM]=S_x
set EM=EM+1
call Sux(SZx,"when calling StringEncoder_onDestroy in StringEncoder, line 69")
call SWx(SZx,"when calling dealloc_StringEncoder in StringEncoder, line 69")
set EM=EM-1
endfunction
function S0x takes integer S1x,string S2x returns nothing
set ZM[EM]=S2x
set EM=EM+1
if Ov[S1x]==0 then
if S1x==0 then
call Cdv("Nullpointer exception when calling StringEncoder.StringEncoder","when calling error in StringEncoder, line 59")
else
call Cdv("Called StringEncoder.StringEncoder on invalid object.","when calling error in StringEncoder, line 59")
endif
endif
call Szx(S1x,"when calling destroyStringEncoder in StringEncoder, line 59")
set EM=EM-1
endfunction
function S3x takes integer f1s returns nothing
endfunction
function S4x takes integer S5x,string S6x returns nothing
set ZM[EM]=S6x
set EM=EM+1
if UF[S5x]==0 then
call Cdv("Double free: object of type MetadataStore","when calling error in Metadata, line 12")
else
set WF[EF]=S5x
set EF=EF+1
set UF[S5x]=0
endif
set EM=EM-1
endfunction
function S7x takes integer S8x,string S9x returns nothing
set ZM[EM]=S9x
set EM=EM+1
call S3x(S8x)
call S4x(S8x,"when calling dealloc_MetadataStore in Metadata, line 11")
set EM=EM-1
endfunction
function tvx takes integer tex,string txx returns nothing
set ZM[EM]=txx
set EM=EM+1
if UF[tex]==0 then
if tex==0 then
call Cdv("Nullpointer exception when calling MetadataStore.MetadataStore","when calling error in Metadata, line 12")
else
call Cdv("Called MetadataStore.MetadataStore on invalid object.","when calling error in Metadata, line 12")
endif
endif
call S7x(tex,"when calling destroyMetadataStore in Metadata, line 12")
set EM=EM-1
endfunction
function tox takes integer trx,string tix returns nothing
set ZM[EM]=tix
set EM=EM+1
call Slx(ZP[trx],"when calling dispatch_GamecacheBuffer_destroyGamecacheBuffer in NetworkData, line 250")
call Slx(UP[trx],"when calling dispatch_GamecacheBuffer_destroyGamecacheBuffer in NetworkData, line 251")
call Slx(IP[trx],"when calling dispatch_GamecacheBuffer_destroyGamecacheBuffer in NetworkData, line 252")
call Slx(PP[trx],"when calling dispatch_GamecacheBuffer_destroyGamecacheBuffer in NetworkData, line 253")
call S0x(EP[trx],"when calling dispatch_StringEncoder_destroyStringEncoder in NetworkData, line 254")
call tvx(AP[trx],"when calling dispatch_MetadataStore_destroyMetadataStore in NetworkData, line 255")
call SSx(uA[trx],"when calling dispatch_NetworkFinishedCallback_destroyNetworkFinishedCallback in NetworkData, line 256")
if WP[trx]!=0 then
call Sfx(WP[trx],"when calling dispatch_HashReader_destroyHashReader in NetworkData, line 259")
endif
if QP[trx]!=0 then
call SCx(QP[trx],"when calling dispatch_HashWriter_destroyHashWriter in NetworkData, line 262")
endif
set EM=EM-1
endfunction
function tax takes integer tnx,string tVx returns nothing
set ZM[EM]=tVx
set EM=EM+1
call tox(tnx,"when calling Network_onDestroy in NetworkData, line 249")
call Snx(tnx,"when calling dealloc_Network in NetworkData, line 249")
set EM=EM-1
endfunction
function tEx takes integer tXx,string tOx returns nothing
set ZM[EM]=tOx
set EM=EM+1
if LF[tXx]==0 then
if tXx==0 then
call Cdv("Nullpointer exception when calling Network.Network","when calling error in NetworkData, line 204")
else
call Cdv("Called Network.Network on invalid object.","when calling error in NetworkData, line 204")
endif
endif
call tax(tXx,"when calling destroyNetwork in NetworkData, line 204")
set EM=EM-1
endfunction
function tRx takes integer tIx,string tAx returns nothing
set ZM[EM]=tAx
set EM=EM+1
call Sxx(uA[tIx],1,0,"when calling onFinish in NetworkData, line 281")
call tEx(tIx,"when calling dispatch_Network_destroyNetwork in NetworkData, line 282")
set EM=EM-1
endfunction
function tNx takes integer tbx,string tBx returns nothing
set ZM[EM]=tBx
set EM=EM+1
if LF[tbx]==0 then
if tbx==0 then
call Cdv("Nullpointer exception when calling Network.abort","when calling error in NetworkData, line 279")
else
call Cdv("Called Network.abort on invalid object.","when calling error in NetworkData, line 279")
endif
endif
call tRx(tbx,"when calling abort in NetworkData, line 279")
set EM=EM-1
endfunction
function tcx takes integer tCx,string tdx returns integer
local integer tDx
set ZM[EM]=tdx
set EM=EM+1
set tDx=B5x(tCx,1,"when calling getCount in HashData, line 202")
set EM=EM-1
return tDx
endfunction
function tfx takes integer tFx,string tgx returns integer
local integer tGx
set ZM[EM]=tgx
set EM=EM+1
if gY[tFx]==0 then
if tFx==0 then
call Cdv("Nullpointer exception when calling HashReader.getRealCount","when calling error in HashData, line 201")
else
call Cdv("Called HashReader.getRealCount on invalid object.","when calling error in HashData, line 201")
endif
endif
set tGx=tcx(tFx,"when calling getRealCount in HashData, line 201")
set EM=EM-1
return tGx
endfunction
function thx takes gamecache tHx,string tjx,string tJx,integer tkx returns nothing
call StoreInteger(tHx,tjx,tJx,tkx)
endfunction
function tKx takes integer tlx,string tLx,integer tmx returns nothing
call thx(wq,nP[tlx],tLx,tmx)
endfunction
function tMx takes integer tpx,string tPx,integer tqx,string tQx returns nothing
set ZM[EM]=tQx
set EM=EM+1
if UF[tpx]==0 then
if tpx==0 then
call Cdv("Nullpointer exception when calling MetadataStore.saveValue","when calling error in Metadata, line 29")
else
call Cdv("Called MetadataStore.saveValue on invalid object.","when calling error in Metadata, line 29")
endif
endif
call tKx(tpx,tPx,tqx)
set EM=EM-1
endfunction
function tsx takes integer tSx,integer ttx,integer tTx,integer tux,integer tUx,integer twx,string tWx returns nothing
set ZM[EM]=tWx
set EM=EM+1
call tMx(tSx,uq,ttx,"when calling saveValue in Metadata, line 36")
call tMx(tSx,rq,tTx,"when calling saveValue in Metadata, line 37")
call tMx(tSx,sq,tux,"when calling saveValue in Metadata, line 38")
call tMx(tSx,tq,tUx,"when calling saveValue in Metadata, line 39")
call tMx(tSx,iq,twx,"when calling saveValue in Metadata, line 40")
set EM=EM-1
endfunction
function tyx takes integer tYx,integer tzx,integer tZx,integer t_x,integer t0x,integer t1x,string t2x returns nothing
set ZM[EM]=t2x
set EM=EM+1
if UF[tYx]==0 then
if tYx==0 then
call Cdv("Nullpointer exception when calling MetadataStore.setCounts","when calling error in Metadata, line 35")
else
call Cdv("Called MetadataStore.setCounts on invalid object.","when calling error in Metadata, line 35")
endif
endif
call tsx(tYx,tzx,tZx,t_x,t0x,t1x,"when calling setCounts in Metadata, line 35")
set EM=EM-1
endfunction
function t3x takes integer t4x,integer t5x,integer t6x,integer t7x returns integer
local integer t8x=xe
local integer t9x
if t4x>t8x then
set t9x=t4x
else
set t9x=t8x
endif
set t8x=t9x
if t5x>t8x then
set t9x=t5x
else
set t9x=t8x
endif
set t8x=t9x
if t6x>t8x then
set t9x=t6x
else
set t9x=t8x
endif
set t8x=t9x
if t7x>t8x then
set t9x=t7x
else
set t9x=t8x
endif
set t8x=t9x
return t8x
endfunction
function Tvx takes integer Tex,string Txx returns integer
local integer Tox
set ZM[EM]=Txx
set EM=EM+1
set Tox=B5x(Tex,0,"when calling getCount in HashData, line 199")
set EM=EM-1
return Tox
endfunction
function Trx takes integer Tix,string Tax returns integer
local integer Tnx
set ZM[EM]=Tax
set EM=EM+1
if gY[Tix]==0 then
if Tix==0 then
call Cdv("Nullpointer exception when calling HashReader.getIntCount","when calling error in HashData, line 198")
else
call Cdv("Called HashReader.getIntCount on invalid object.","when calling error in HashData, line 198")
endif
endif
set Tnx=Tvx(Tix,"when calling getIntCount in HashData, line 198")
set EM=EM-1
return Tnx
endfunction
function TVx takes integer TEx,string TXx returns integer
local integer TOx
set ZM[EM]=TXx
set EM=EM+1
set TOx=Trx(EX[TEx],"when calling getIntCount in StringEncoder, line 129")
set EM=EM-1
return TOx
endfunction
function TRx takes integer TIx,string TAx returns integer
local integer TNx
set ZM[EM]=TAx
set EM=EM+1
if Ov[TIx]==0 then
if TIx==0 then
call Cdv("Nullpointer exception when calling StringEncoder.getIntCount","when calling error in StringEncoder, line 128")
else
call Cdv("Called StringEncoder.getIntCount on invalid object.","when calling error in StringEncoder, line 128")
endif
endif
set TNx=TVx(TIx,"when calling getIntCount in StringEncoder, line 128")
set EM=EM-1
return TNx
endfunction
function Tbx takes integer TBx,string Tcx returns string
set ZM[EM]=Tcx
set EM=EM+1
if TBx>=ee then
call Cdv("Network: trying to get invalid GC key","when calling error in GamecacheKeys, line 19")
endif
set EM=EM-1
return pe[TBx]
endfunction
function TCx takes gamecache Tdx,string TDx,string Tfx returns nothing
call SyncStoredInteger(Tdx,TDx,Tfx)
endfunction
function TFx takes integer Tgx,string TGx returns nothing
local integer Thx
local integer THx
set ZM[EM]=TGx
set EM=EM+1
set Thx=0
set THx=Sq-1
loop
exitwhen Thx>THx
call TCx(wq,nP[Tgx],Tbx(Thx,"when calling get in Metadata, line 52"))
set Thx=Thx+1
endloop
set EM=EM-1
endfunction
function Tjx takes integer TJx,string Tkx returns nothing
set ZM[EM]=Tkx
set EM=EM+1
if UF[TJx]==0 then
if TJx==0 then
call Cdv("Nullpointer exception when calling MetadataStore.sync","when calling error in Metadata, line 50")
else
call Cdv("Called MetadataStore.sync on invalid object.","when calling error in Metadata, line 50")
endif
endif
call TFx(TJx,"when calling sync in Metadata, line 50")
set EM=EM-1
endfunction
function TKx takes integer Tlx returns nothing
set XZ[Tlx]=0
set CZ[Tlx]=0
set VZ[Tlx]=0
set BZ[Tlx]=0
set NZ[Tlx]=0
set MZ[Tlx]=0
set wU[Tlx]=0
set uU[Tlx]=0
endfunction
function TLx takes integer Tmx,integer TMx,integer Tpx,integer TPx,integer Tqx,integer TQx returns nothing
call TKx(Tmx)
set LZ[Tmx]=TMx
set NZ[Tmx]=Tpx
set MZ[Tmx]=TPx
set wU[Tmx]=Tqx
set uU[Tmx]=TQx
endfunction
function Tsx takes string TSx returns integer
local integer Ttx
set ZM[EM]=TSx
set EM=EM+1
if YY==0 then
if GY<$8000 then
set GY=GY+1
set Ttx=GY
set gY[Ttx]=$6D0
else
call Cdv("Out of memory: Could not create HashReader.","when calling error in HashData, line 77")
set Ttx=0
endif
else
set YY=YY-1
set Ttx=TY[YY]
set gY[Ttx]=$6D0
endif
set EM=EM-1
return Ttx
endfunction
function TTx takes integer Tux,integer TUx,integer Twx,integer TWx,integer Tyx,string TYx returns integer
local integer Tzx
set ZM[EM]=TYx
set EM=EM+1
set Tzx=Tsx("when calling alloc_HashReader in HashData, line 90")
call TLx(Tzx,Tux,TUx,Twx,TWx,Tyx)
set EM=EM-1
return Tzx
endfunction
function TZx takes integer T_x,string T0x returns integer
local integer T1x
set ZM[EM]=T0x
set EM=EM+1
set T1x=TTx(rU[T_x],sU[T_x],tU[T_x],iU[T_x],SU[T_x],"when calling new_HashReader in HashData, line 46")
set rU[T_x]=0
call SCx(T_x,"when calling dispatch_HashWriter_destroyHashWriter in HashData, line 48")
set EM=EM-1
return T1x
endfunction
function T2x takes integer T3x,string T4x returns integer
local integer T5x
set ZM[EM]=T4x
set EM=EM+1
if jY[T3x]==0 then
if T3x==0 then
call Cdv("Nullpointer exception when calling HashWriter.intoReader","when calling error in HashData, line 45")
else
call Cdv("Called HashWriter.intoReader on invalid object.","when calling error in HashData, line 45")
endif
endif
set T5x=TZx(T3x,"when calling intoReader in HashData, line 45")
set EM=EM-1
return T5x
endfunction
function T6x takes gamecache T7x,string T8x returns nothing
call FlushStoredMission(T7x,T8x)
endfunction
function T9x takes integer uvx returns nothing
set fZ[uvx]=-1
set RZ[uvx]=-1
endfunction
function uex takes integer uxx,string uox returns nothing
set ZM[EM]=uox
set EM=EM+1
if Bg[uxx]==0 then
if uxx==0 then
call Cdv("Nullpointer exception when calling GamecacheBuffer.reset","when calling error in GamecacheBuffer, line 126")
else
call Cdv("Called GamecacheBuffer.reset on invalid object.","when calling error in GamecacheBuffer, line 126")
endif
endif
call T9x(uxx)
set EM=EM-1
endfunction
function urx takes string uix returns integer
local integer uax
set ZM[EM]=uix
set EM=EM+1
if EY==0 then
if ZY<$8000 then
set ZY=ZY+1
set uax=ZY
set UY[uax]=$D01
else
call Cdv("Out of memory: Could not create LimitedExecuteCondition_executeWhile_GamecacheBuffer_GamecacheBuffer.","when calling error in GamecacheBuffer, line 120")
set uax=0
endif
else
set EY=EY-1
set uax=WY[EY]
set UY[uax]=$D01
endif
set EM=EM-1
return uax
endfunction
function unx takes string uVx returns integer
local integer uEx
set ZM[EM]=uVx
set EM=EM+1
if PY==0 then
if AY<$8000 then
set AY=AY+1
set uEx=AY
set DY[uEx]=$CDD
else
call Cdv("Out of memory: Could not create LimitedExecuteAction_executeWhile_GamecacheBuffer_GamecacheBuffer.","when calling error in GamecacheBuffer, line 120")
set uEx=0
endif
else
set PY=PY-1
set uEx=IY[PY]
set DY[uEx]=$CDD
endif
set EM=EM-1
return uEx
endfunction
function uXx takes string uOx returns integer
local integer uRx
set ZM[EM]=uOx
set EM=EM+1
if Mg==0 then
if wh<$8000 then
set wh=wh+1
set uRx=wh
set uh[uRx]=4880
else
call Cdv("Out of memory: Could not create SynchronizerFunction_GamecacheBuffer_GamecacheBuffer.","when calling error in GamecacheBuffer, line 106")
set uRx=0
endif
else
set Mg=Mg-1
set uRx=Ng[Mg]
set uh[uRx]=4880
endif
set EM=EM-1
return uRx
endfunction
function uIx takes string uAx returns integer
local integer uNx
set ZM[EM]=uAx
set EM=EM+1
if Mg==0 then
if wh<$8000 then
set wh=wh+1
set uNx=wh
set uh[uNx]=4881
else
call Cdv("Out of memory: Could not create SynchronizerFunction_GamecacheBuffer_GamecacheBuffer.","when calling error in GamecacheBuffer, line 110")
set uNx=0
endif
else
set Mg=Mg-1
set uNx=Ng[Mg]
set uh[uNx]=4881
endif
set EM=EM-1
return uNx
endfunction
function ubx takes string uBx returns integer
local integer ucx
set ZM[EM]=uBx
set EM=EM+1
if Mg==0 then
if wh<$8000 then
set wh=wh+1
set ucx=wh
set uh[ucx]=4879
else
call Cdv("Out of memory: Could not create SynchronizerFunction_GamecacheBuffer_GamecacheBuffer.","when calling error in GamecacheBuffer, line 102")
set ucx=0
endif
else
set Mg=Mg-1
set ucx=Ng[Mg]
set uh[ucx]=4879
endif
set EM=EM-1
return ucx
endfunction
function uCx takes integer udx,string uDx returns integer
local integer ufx
local integer uFx
local integer ugx
local integer uGx
local integer uhx
set ZM[EM]=uDx
set EM=EM+1
set ufx=0
set uFx=TZ[udx]
if uFx==0 then
set ugx=ubx("when calling alloc_SynchronizerFunction_GamecacheBuffer_GamecacheBuffer in GamecacheBuffer, line 102")
set GZ[ugx]=udx
set ufx=ugx
elseif uFx==1 then
set uGx=uXx("when calling alloc_SynchronizerFunction_GamecacheBuffer_GamecacheBuffer in GamecacheBuffer, line 106")
set gZ[uGx]=udx
set ufx=uGx
else
set uhx=uIx("when calling alloc_SynchronizerFunction_GamecacheBuffer_GamecacheBuffer in GamecacheBuffer, line 110")
set hZ[uhx]=udx
set ufx=uhx
endif
set EM=EM-1
return ufx
endfunction
function uHx takes integer ujx,string uJx returns integer
local integer ukx
set ZM[EM]=uJx
set EM=EM+1
if Bg[ujx]==0 then
if ujx==0 then
call Cdv("Nullpointer exception when calling GamecacheBuffer.getSynchronizerFunction","when calling error in GamecacheBuffer, line 97")
else
call Cdv("Called GamecacheBuffer.getSynchronizerFunction on invalid object.","when calling error in GamecacheBuffer, line 97")
endif
endif
set ukx=uCx(ujx,"when calling getSynchronizerFunction in GamecacheBuffer, line 97")
set EM=EM-1
return ukx
endfunction
function uKx takes integer ulx,string uLx returns nothing
set ZM[EM]=uLx
set EM=EM+1
if uh[ulx]==0 then
call Cdv("Double free: object of type SynchronizerFunction","when calling error in GamecacheBuffer, line 8")
else
set Ng[Mg]=ulx
set Mg=Mg+1
set uh[ulx]=0
endif
set EM=EM-1
endfunction
function umx takes integer uMx,string upx returns nothing
set ZM[EM]=upx
set EM=EM+1
call uKx(uMx,"when calling dealloc_SynchronizerFunction in GamecacheBuffer, line 8")
set EM=EM-1
endfunction
function uPx takes integer uqx,string uQx returns nothing
set ZM[EM]=uQx
set EM=EM+1
if uh[uqx]==0 then
if uqx==0 then
call Cdv("Nullpointer exception when calling SynchronizerFunction.SynchronizerFunction","when calling error in GamecacheBuffer, line 8")
else
call Cdv("Called SynchronizerFunction.SynchronizerFunction on invalid object.","when calling error in GamecacheBuffer, line 8")
endif
endif
call umx(uqx,"when calling destroySynchronizerFunction in GamecacheBuffer, line 8")
set EM=EM-1
endfunction
function usx takes integer uSx,string utx returns nothing
local integer uTx
local integer uux
local integer uUx
local integer uwx
local integer uWx
set ZM[EM]=utx
set EM=EM+1
set uTx=uHx(uSx,"when calling getSynchronizerFunction in GamecacheBuffer, line 117")
set YZ[uSx]=0
set uwx=oq
set uux=urx("when calling alloc_LimitedExecuteCondition_executeWhile_GamecacheBuffer_GamecacheBuffer in GamecacheBuffer, line 120")
set FZ[uux]=uSx
set uWx=uux
set uUx=unx("when calling alloc_LimitedExecuteAction_executeWhile_GamecacheBuffer_GamecacheBuffer in GamecacheBuffer, line 120")
set kZ[uUx]=uTx
set jZ[uUx]=uSx
call WOe(uwx,uWx,uUx,"when calling executeWhile in GamecacheBuffer, line 120")
call uPx(uTx,"when calling dispatch_SynchronizerFunction_destroySynchronizerFunction in GamecacheBuffer, line 124")
set EM=EM-1
endfunction
function uyx takes integer uYx,string uzx returns nothing
set ZM[EM]=uzx
set EM=EM+1
if Bg[uYx]==0 then
if uYx==0 then
call Cdv("Nullpointer exception when calling GamecacheBuffer.sync","when calling error in GamecacheBuffer, line 116")
else
call Cdv("Called GamecacheBuffer.sync on invalid object.","when calling error in GamecacheBuffer, line 116")
endif
endif
call usx(uYx,"when calling sync in GamecacheBuffer, line 116")
set EM=EM-1
endfunction
function uZx takes string u_x returns integer
local integer u0x
set ZM[EM]=u_x
set EM=EM+1
if PY==0 then
if AY<$8000 then
set AY=AY+1
set u0x=AY
set DY[u0x]=$CEF
else
call Cdv("Out of memory: Could not create LimitedExecuteAction_executeWhile_Network_NetworkData.","when calling error in NetworkData, line 381")
set u0x=0
endif
else
set PY=PY-1
set u0x=IY[PY]
set DY[u0x]=$CEF
endif
set EM=EM-1
return u0x
endfunction
function u1x takes string u2x returns integer
local integer u3x
set ZM[EM]=u2x
set EM=EM+1
if EY==0 then
if ZY<$8000 then
set ZY=ZY+1
set u3x=ZY
set UY[u3x]=$D13
else
call Cdv("Out of memory: Could not create LimitedExecuteCondition_executeWhile_Network_NetworkData.","when calling error in NetworkData, line 381")
set u3x=0
endif
else
set EY=EY-1
set u3x=WY[EY]
set UY[u3x]=$D13
endif
set EM=EM-1
return u3x
endfunction
function u4x takes integer u5x,string u6x returns nothing
local integer u7x
local integer u8x
local integer u9x
local integer Uvx
set ZM[EM]=u6x
set EM=EM+1
set u9x=oq
set u7x=u1x("when calling alloc_LimitedExecuteCondition_executeWhile_Network_NetworkData in NetworkData, line 381")
set RA[u7x]=u5x
set Uvx=u7x
set u8x=uZx("when calling alloc_LimitedExecuteAction_executeWhile_Network_NetworkData in NetworkData, line 381")
set TA[u8x]=u5x
call WOe(u9x,Uvx,u8x,"when calling executeWhile in NetworkData, line 381")
set EM=EM-1
endfunction
function Uex takes integer Uxx,string Uox returns nothing
set ZM[EM]=Uox
set EM=EM+1
if LF[Uxx]==0 then
if Uxx==0 then
call Cdv("Nullpointer exception when calling Network.writeStrings","when calling error in NetworkData, line 380")
else
call Cdv("Called Network.writeStrings on invalid object.","when calling error in NetworkData, line 380")
endif
endif
call u4x(Uxx,"when calling writeStrings in NetworkData, line 380")
set EM=EM-1
endfunction
function Urx takes string Uix returns integer
local integer Uax
set ZM[EM]=Uix
set EM=EM+1
if PY==0 then
if AY<$8000 then
set AY=AY+1
set Uax=AY
set DY[Uax]=$CED
else
call Cdv("Out of memory: Could not create LimitedExecuteAction_executeWhile_Network_NetworkData.","when calling error in NetworkData, line 369")
set Uax=0
endif
else
set PY=PY-1
set Uax=IY[PY]
set DY[Uax]=$CED
endif
set EM=EM-1
return Uax
endfunction
function Unx takes string UVx returns integer
local integer UEx
set ZM[EM]=UVx
set EM=EM+1
if EY==0 then
if ZY<$8000 then
set ZY=ZY+1
set UEx=ZY
set UY[UEx]=$D11
else
call Cdv("Out of memory: Could not create LimitedExecuteCondition_executeWhile_Network_NetworkData.","when calling error in NetworkData, line 369")
set UEx=0
endif
else
set EY=EY-1
set UEx=WY[EY]
set UY[UEx]=$D11
endif
set EM=EM-1
return UEx
endfunction
function UXx takes integer UOx,string URx returns nothing
local integer UIx
local integer UAx
local integer UNx
local integer Ubx
set ZM[EM]=URx
set EM=EM+1
set UNx=oq
set UIx=Unx("when calling alloc_LimitedExecuteCondition_executeWhile_Network_NetworkData in NetworkData, line 369")
set aA[UIx]=UOx
set Ubx=UIx
set UAx=Urx("when calling alloc_LimitedExecuteAction_executeWhile_Network_NetworkData in NetworkData, line 369")
set nA[UAx]=UOx
call WOe(UNx,Ubx,UAx,"when calling executeWhile in NetworkData, line 369")
set EM=EM-1
endfunction
function UBx takes integer Ucx,string UCx returns nothing
set ZM[EM]=UCx
set EM=EM+1
if LF[Ucx]==0 then
if Ucx==0 then
call Cdv("Nullpointer exception when calling Network.writeBooleans","when calling error in NetworkData, line 368")
else
call Cdv("Called Network.writeBooleans on invalid object.","when calling error in NetworkData, line 368")
endif
endif
call UXx(Ucx,"when calling writeBooleans in NetworkData, line 368")
set EM=EM-1
endfunction
function Udx takes string UDx returns integer
local integer Ufx
set ZM[EM]=UDx
set EM=EM+1
if qv==0 then
if av<$8000 then
set av=av+1
set Ufx=av
set nv[Ufx]=4638
else
call Cdv("Out of memory: Could not create SimpleSynchronizer.","when calling error in SyncSimple, line 113")
set Ufx=0
endif
else
set qv=qv-1
set Ufx=ev[qv]
set nv[Ufx]=4638
endif
set EM=EM-1
return Ufx
endfunction
function UFx takes nothing returns unit
local unit Ugx=vAe(Ty,KR,He,Je,vde(.0))
call O3e(Ugx)
set Rzv=Ugx
set Ugx=null
return Rzv
endfunction
function UGx takes unit Uhx returns integer
return GetUnitUserData(Uhx)
endfunction
function UHx takes unit Ujx returns integer
return UGx(Ujx)
endfunction
function UJx takes nothing returns integer
set DM=0
return DM
endfunction
function Ukx takes integer UKx returns nothing
set JR=JR+1
if JR==1 then
set DR=UKx
set yC[UKx]=0
else
set yC[UKx]=HR
set pC[HR]=UKx
set yC[DR]=UKx
endif
set pC[UKx]=0
set HR=UKx
endfunction
function Ulx takes integer ULx returns nothing
local integer Umx=UJx()
set lC[ULx]=Umx
set bC[ULx]=0
call Ukx(ULx)
endfunction
function UMx takes integer Upx returns nothing
call Ulx(Upx)
set OC[Upx]=UFx()
set PR[UHx(OC[Upx])]=Upx
endfunction
function UPx takes string Uqx returns integer
local integer UQx
set ZM[EM]=Uqx
set EM=EM+1
set UQx=Udx("when calling alloc_SimpleSynchronizer in SyncSimple, line 124")
call UMx(UQx)
set EM=EM-1
return UQx
endfunction
function Usx takes string USx returns integer
local integer Utx
set ZM[EM]=USx
set EM=EM+1
if PY==0 then
if AY<$8000 then
set AY=AY+1
set Utx=AY
set DY[Utx]=$CEB
else
call Cdv("Out of memory: Could not create LimitedExecuteAction_executeWhile_Network_NetworkData.","when calling error in NetworkData, line 357")
set Utx=0
endif
else
set PY=PY-1
set Utx=IY[PY]
set DY[Utx]=$CEB
endif
set EM=EM-1
return Utx
endfunction
function UTx takes string Uux returns integer
local integer UUx
set ZM[EM]=Uux
set EM=EM+1
if EY==0 then
if ZY<$8000 then
set ZY=ZY+1
set UUx=ZY
set UY[UUx]=$D0F
else
call Cdv("Out of memory: Could not create LimitedExecuteCondition_executeWhile_Network_NetworkData.","when calling error in NetworkData, line 357")
set UUx=0
endif
else
set EY=EY-1
set UUx=WY[EY]
set UY[UUx]=$D0F
endif
set EM=EM-1
return UUx
endfunction
function Uwx takes integer UWx,string Uyx returns nothing
local integer UYx
local integer Uzx
local integer UZx
local integer U_x
set ZM[EM]=Uyx
set EM=EM+1
set UZx=oq
set UYx=UTx("when calling alloc_LimitedExecuteCondition_executeWhile_Network_NetworkData in NetworkData, line 357")
set yA[UYx]=UWx
set U_x=UYx
set Uzx=Usx("when calling alloc_LimitedExecuteAction_executeWhile_Network_NetworkData in NetworkData, line 357")
set pA[Uzx]=UWx
call WOe(UZx,U_x,Uzx,"when calling executeWhile in NetworkData, line 357")
set EM=EM-1
endfunction
function U0x takes integer U1x,string U2x returns nothing
set ZM[EM]=U2x
set EM=EM+1
if LF[U1x]==0 then
if U1x==0 then
call Cdv("Nullpointer exception when calling Network.writeReals","when calling error in NetworkData, line 356")
else
call Cdv("Called Network.writeReals on invalid object.","when calling error in NetworkData, line 356")
endif
endif
call Uwx(U1x,"when calling writeReals in NetworkData, line 356")
set EM=EM-1
endfunction
function U3x takes player U4x,unit U5x returns nothing
if ta==U4x then
call SelectUnit(U5x,true)
endif
endfunction
function U6x takes group U7x,player U8x,boolexpr U9x returns nothing
call GroupEnumUnitsSelected(U7x,U8x,U9x)
endfunction
function wvx takes string wex returns integer
local integer wxx
set ZM[EM]=wex
set EM=EM+1
if ug==0 then
if rg<$8000 then
set rg=rg+1
set wxx=rg
set sg[wxx]=$879
else
call Cdv("Out of memory: Could not create ForGroupCallback_forUnitsSelected_SyncSimple.","when calling error in SyncSimple, line 96")
set wxx=0
endif
else
set ug=ug-1
set wxx=wg[ug]
set sg[wxx]=$879
endif
set EM=EM-1
return wxx
endfunction
function wox takes player wrx,unit wix returns nothing
if ta==wrx then
call SelectUnit(wix,false)
endif
endfunction
function wax takes player wnx,unit wVx,string wEx returns nothing
local integer wXx
local player wOx
set ZM[EM]=wEx
set EM=EM+1
call U6x(qe,wnx,null)
set UR=null
set IR=0
set wOx=wnx
set wXx=wvx("when calling alloc_ForGroupCallback_forUnitsSelected_SyncSimple in SyncSimple, line 96")
call kee(wOx,wXx,"when calling forUnitsSelected in SyncSimple, line 96")
if IR>=$C then
call wox(wnx,UR)
endif
if ta==wnx then
call U3x(wnx,wVx)
call wox(wnx,wVx)
endif
if IR>=$C then
call U3x(wnx,UR)
endif
set EM=EM-1
set wOx=null
endfunction
function wRx takes player wIx returns boolean
return Odx(wIx)==PLAYER_SLOT_STATE_PLAYING and Ofx(wIx)==MAP_CONTROL_USER
endfunction
function wAx takes integer wNx returns nothing
local integer wbx=0
local integer wBx=bj_MAX_PLAYER_SLOTS-1
local integer wcx
loop
exitwhen wbx>wBx
if not wRx(sa[wbx])then
set wcx=dpv(lC[wNx],wbx)
set lC[wNx]=wcx
endif
set wbx=wbx+1
endloop
endfunction
function wCx takes integer wdx,string wDx returns nothing
set ZM[EM]=wDx
set EM=EM+1
if nv[wdx]==0 then
if wdx==0 then
call Cdv("Nullpointer exception when calling SimpleSynchronizer.addOfflinePlayers","when calling error in SyncSimple, line 142")
else
call Cdv("Called SimpleSynchronizer.addOfflinePlayers on invalid object.","when calling error in SyncSimple, line 142")
endif
endif
call wAx(wdx)
set EM=EM-1
endfunction
function wfx takes integer wFx,string wgx returns nothing
set ZM[EM]=wgx
set EM=EM+1
call wCx(wFx,"when calling addOfflinePlayers in SyncSimple, line 135")
call wax(ta,OC[wFx],"when calling onceSelect in SyncSimple, line 136")
set EM=EM-1
endfunction
function wGx takes integer whx,string wHx returns nothing
set ZM[EM]=wHx
set EM=EM+1
if nv[whx]==0 then
if whx==0 then
call Cdv("Nullpointer exception when calling SimpleSynchronizer.sync","when calling error in SyncSimple, line 134")
else
call Cdv("Called SimpleSynchronizer.sync on invalid object.","when calling error in SyncSimple, line 134")
endif
endif
call wfx(whx,"when calling sync in SyncSimple, line 134")
set EM=EM-1
endfunction
function wjx takes string wJx returns integer
local integer wkx
set ZM[EM]=wJx
set EM=EM+1
if EY==0 then
if ZY<$8000 then
set ZY=ZY+1
set wkx=ZY
set UY[wkx]=$D0D
else
call Cdv("Out of memory: Could not create LimitedExecuteCondition_executeWhile_Network_NetworkData.","when calling error in NetworkData, line 345")
set wkx=0
endif
else
set EY=EY-1
set wkx=WY[EY]
set UY[wkx]=$D0D
endif
set EM=EM-1
return wkx
endfunction
function wKx takes string wlx returns integer
local integer wLx
set ZM[EM]=wlx
set EM=EM+1
if PY==0 then
if AY<$8000 then
set AY=AY+1
set wLx=AY
set DY[wLx]=$CE9
else
call Cdv("Out of memory: Could not create LimitedExecuteAction_executeWhile_Network_NetworkData.","when calling error in NetworkData, line 345")
set wLx=0
endif
else
set PY=PY-1
set wLx=IY[PY]
set DY[wLx]=$CE9
endif
set EM=EM-1
return wLx
endfunction
function wmx takes integer wMx,string wpx returns nothing
local integer wPx
local integer wqx
local integer wQx
local integer wsx
set ZM[EM]=wpx
set EM=EM+1
set wQx=oq
set wPx=wjx("when calling alloc_LimitedExecuteCondition_executeWhile_Network_NetworkData in NetworkData, line 345")
set oA[wPx]=wMx
set wsx=wPx
set wqx=wKx("when calling alloc_LimitedExecuteAction_executeWhile_Network_NetworkData in NetworkData, line 345")
set OA[wqx]=wMx
call WOe(wQx,wsx,wqx,"when calling executeWhile in NetworkData, line 345")
set EM=EM-1
endfunction
function wSx takes integer wtx,string wTx returns nothing
set ZM[EM]=wTx
set EM=EM+1
if LF[wtx]==0 then
if wtx==0 then
call Cdv("Nullpointer exception when calling Network.writeInts","when calling error in NetworkData, line 344")
else
call Cdv("Called Network.writeInts on invalid object.","when calling error in NetworkData, line 344")
endif
endif
call wmx(wtx,"when calling writeInts in NetworkData, line 344")
set EM=EM-1
endfunction
function wux takes string wUx returns integer
local integer wwx
set ZM[EM]=wUx
set EM=EM+1
if sk==0 then
if tk<$8000 then
set tk=tk+1
set wwx=tk
set ik[wwx]=4875
else
call Cdv("Out of memory: Could not create SynchronizationCallback_onSynced_Network_NetworkData.","when calling error in NetworkData, line 420")
set wwx=0
endif
else
set sk=sk-1
set wwx=rk[sk]
set ik[wwx]=4875
endif
set EM=EM-1
return wwx
endfunction
function wWx takes integer wyx,integer wYx returns nothing
set bC[wyx]=wYx
endfunction
function wzx takes integer wZx,integer w_x,string w0x returns nothing
set ZM[EM]=w0x
set EM=EM+1
if nv[wZx]==0 then
if wZx==0 then
call Cdv("Nullpointer exception when calling SimpleSynchronizer.onSynced","when calling error in SyncSimple, line 139")
else
call Cdv("Called SimpleSynchronizer.onSynced on invalid object.","when calling error in SyncSimple, line 139")
endif
endif
call wWx(wZx,w_x)
set EM=EM-1
endfunction
function w1x takes integer w2x,string w3x returns nothing
local integer w4x
local integer w5x
local integer w6x
set ZM[EM]=w3x
set EM=EM+1
set w4x=UPx("when calling new_SimpleSynchronizer in NetworkData, line 393")
call uex(ZP[w2x],"when calling reset in NetworkData, line 396")
call uex(UP[w2x],"when calling reset in NetworkData, line 397")
call uex(IP[w2x],"when calling reset in NetworkData, line 398")
call uex(PP[w2x],"when calling reset in NetworkData, line 399")
call T6x(lq,mP[w2x])
call T6x(bq,mP[w2x])
if ta==DP[w2x]then
call wSx(w2x,"when calling writeInts in NetworkData, line 407")
call UBx(w2x,"when calling writeBooleans in NetworkData, line 408")
call U0x(w2x,"when calling writeReals in NetworkData, line 409")
call Uex(w2x,"when calling writeStrings in NetworkData, line 410")
call uyx(ZP[w2x],"when calling sync in NetworkData, line 413")
call uyx(IP[w2x],"when calling sync in NetworkData, line 414")
call uyx(UP[w2x],"when calling sync in NetworkData, line 415")
call uyx(PP[w2x],"when calling sync in NetworkData, line 416")
endif
call wGx(w4x,"when calling sync in NetworkData, line 419")
set w6x=w4x
set w5x=wux("when calling alloc_SynchronizationCallback_onSynced_Network_NetworkData in NetworkData, line 420")
set gA[w5x]=w2x
call wzx(w6x,w5x,"when calling onSynced in NetworkData, line 420")
set EM=EM-1
endfunction
function w7x takes integer w8x,string w9x returns nothing
set ZM[EM]=w9x
set EM=EM+1
if LF[w8x]==0 then
if w8x==0 then
call Cdv("Nullpointer exception when calling Network.sendRound","when calling error in NetworkData, line 392")
else
call Cdv("Called Network.sendRound on invalid object.","when calling error in NetworkData, line 392")
endif
endif
call w1x(w8x,"when calling sendRound in NetworkData, line 392")
set EM=EM-1
endfunction
function Wvx takes string Wex returns integer
local integer Wxx
set ZM[EM]=Wex
set EM=EM+1
if EY==0 then
if ZY<$8000 then
set ZY=ZY+1
set Wxx=ZY
set UY[Wxx]=$D1B
else
call Cdv("Out of memory: Could not create LimitedExecuteCondition_executeWhile_StringEncoder_StringEncoder.","when calling error in StringEncoder, line 105")
set Wxx=0
endif
else
set EY=EY-1
set Wxx=WY[EY]
set UY[Wxx]=$D1B
endif
set EM=EM-1
return Wxx
endfunction
function Wox takes string Wrx returns integer
local integer Wix
set ZM[EM]=Wrx
set EM=EM+1
if PY==0 then
if AY<$8000 then
set AY=AY+1
set Wix=AY
set DY[Wix]=$CF7
else
call Cdv("Out of memory: Could not create LimitedExecuteAction_executeWhile_StringEncoder_StringEncoder.","when calling error in StringEncoder, line 105")
set Wix=0
endif
else
set PY=PY-1
set Wix=IY[PY]
set DY[Wix]=$CF7
endif
set EM=EM-1
return Wix
endfunction
function Wax takes integer Wnx,string WVx returns nothing
local integer WEx
local integer WXx
local integer WOx
local integer WRx
set ZM[EM]=WVx
set EM=EM+1
set QX[Wnx]=T2x(mX[Wnx],"when calling intoReader in StringEncoder, line 103")
set mX[Wnx]=0
set WOx=oq
set WEx=Wvx("when calling alloc_LimitedExecuteCondition_executeWhile_StringEncoder_StringEncoder in StringEncoder, line 105")
set JX[WEx]=Wnx
set WRx=WEx
set WXx=Wox("when calling alloc_LimitedExecuteAction_executeWhile_StringEncoder_StringEncoder in StringEncoder, line 105")
set KX[WXx]=Wnx
call WOe(WOx,WRx,WXx,"when calling executeWhile in StringEncoder, line 105")
set EX[Wnx]=T2x(WX[Wnx],"when calling intoReader in StringEncoder, line 106")
set WX[Wnx]=0
set EM=EM-1
endfunction
function WIx takes integer WAx,string WNx returns nothing
set ZM[EM]=WNx
set EM=EM+1
if Ov[WAx]==0 then
if WAx==0 then
call Cdv("Nullpointer exception when calling StringEncoder.encode","when calling error in StringEncoder, line 102")
else
call Cdv("Called StringEncoder.encode on invalid object.","when calling error in StringEncoder, line 102")
endif
endif
call Wax(WAx,"when calling encode in StringEncoder, line 102")
set EM=EM-1
endfunction
function Wbx takes string WBx returns integer
local integer Wcx
set ZM[EM]=WBx
set EM=EM+1
if PY==0 then
if AY<$8000 then
set AY=AY+1
set Wcx=AY
set DY[Wcx]=$CE8
else
call Cdv("Out of memory: Could not create LimitedExecuteAction_executeWhile_Network_NetworkData.","when calling error in NetworkData, line 298")
set Wcx=0
endif
else
set PY=PY-1
set Wcx=IY[PY]
set DY[Wcx]=$CE8
endif
set EM=EM-1
return Wcx
endfunction
function WCx takes string Wdx returns integer
local integer WDx
set ZM[EM]=Wdx
set EM=EM+1
if EY==0 then
if ZY<$8000 then
set ZY=ZY+1
set WDx=ZY
set UY[WDx]=$D0C
else
call Cdv("Out of memory: Could not create LimitedExecuteCondition_executeWhile_Network_NetworkData.","when calling error in NetworkData, line 298")
set WDx=0
endif
else
set EY=EY-1
set WDx=WY[EY]
set UY[WDx]=$D0C
endif
set EM=EM-1
return WDx
endfunction
function Wfx takes integer WFx,string Wgx returns integer
local integer WGx
set ZM[EM]=Wgx
set EM=EM+1
set WGx=B5x(WFx,3,"when calling getCount in HashData, line 205")
set EM=EM-1
return WGx
endfunction
function Whx takes integer WHx,string Wjx returns integer
local integer WJx
set ZM[EM]=Wjx
set EM=EM+1
if gY[WHx]==0 then
if WHx==0 then
call Cdv("Nullpointer exception when calling HashReader.getBooleanCount","when calling error in HashData, line 204")
else
call Cdv("Called HashReader.getBooleanCount on invalid object.","when calling error in HashData, line 204")
endif
endif
set WJx=Wfx(WHx,"when calling getBooleanCount in HashData, line 204")
set EM=EM-1
return WJx
endfunction
function Wkx takes integer WKx,string Wlx returns nothing
local integer WLx
local integer Wmx
local integer WMx
local integer Wpx
local integer WPx
local integer Wqx
local integer WQx
local boolean Wsx
local integer WSx
local integer Wtx
local integer WTx
local integer Wux
local integer WUx
local integer Wwx
local integer WWx
local integer Wyx
local integer WYx
local integer Wzx
set ZM[EM]=Wlx
set EM=EM+1
if not wRx(DP[WKx])then
call tNx(WKx,"when calling abort in NetworkData, line 288")
set EM=EM-1
return
endif
if ta==DP[WKx]then
set WP[WKx]=T2x(QP[WKx],"when calling intoReader in NetworkData, line 293")
set QP[WKx]=0
set WTx=oq
set WLx=WCx("when calling alloc_LimitedExecuteCondition_executeWhile_Network_NetworkData in NetworkData, line 298")
set SA[WLx]=WKx
set Wux=WLx
set Wmx=Wbx("when calling alloc_LimitedExecuteAction_executeWhile_Network_NetworkData in NetworkData, line 298")
set cA[Wmx]=WKx
call WOe(WTx,Wux,Wmx,"when calling executeWhile in NetworkData, line 298")
call WIx(EP[WKx],"when calling encode in NetworkData, line 302")
set WMx=Trx(WP[WKx],"when calling getIntCount in NetworkData, line 305")
set Wpx=tfx(WP[WKx],"when calling getRealCount in NetworkData, line 306")
set WPx=Whx(WP[WKx],"when calling getBooleanCount in NetworkData, line 307")
set Wqx=TRx(EP[WKx],"when calling getIntCount in NetworkData, line 308")
set WQx=t3x(WMx,Wpx,WPx,Wqx)
set Wsx=ModuloInteger(WQx,ee)>0
set WUx=WQx/ee
if Wsx then
set Wtx=1
else
set Wtx=0
endif
set WSx=WUx+Wtx
set Wwx=WMx
set WWx=Wpx
set Wyx=WPx
set WYx=Wqx
set Wzx=WSx
set HP[WKx]=Wwx
set JP[WKx]=WWx
set KP[WKx]=Wyx
set LP[WKx]=WYx
set XP[WKx]=Wzx
set CP[WKx]=true
call tyx(AP[WKx],HP[WKx],JP[WKx],KP[WKx],LP[WKx],XP[WKx],"when calling setCounts in NetworkData, line 322")
call Tjx(AP[WKx],"when calling sync in NetworkData, line 323")
endif
call w7x(WKx,"when calling sendRound in NetworkData, line 327")
set EM=EM-1
endfunction
function WZx takes integer W_x,string W0x returns nothing
set ZM[EM]=W0x
set EM=EM+1
if LF[W_x]==0 then
if W_x==0 then
call Cdv("Nullpointer exception when calling Network.sendMetadata","when calling error in NetworkData, line 285")
else
call Cdv("Called Network.sendMetadata on invalid object.","when calling error in NetworkData, line 285")
endif
endif
call Wkx(W_x,"when calling sendMetadata in NetworkData, line 285")
set EM=EM-1
endfunction
function W1x takes integer W2x,integer W3x,string W4x returns nothing
set ZM[EM]=W4x
set EM=EM+1
set uA[W2x]=W3x
call WZx(W2x,"when calling sendMetadata in NetworkData, line 464")
set EM=EM-1
endfunction
function W5x takes integer W6x,integer W7x,string W8x returns nothing
set ZM[EM]=W8x
set EM=EM+1
if LF[W6x]==0 then
if W6x==0 then
call Cdv("Nullpointer exception when calling Network.start","when calling error in NetworkData, line 462")
else
call Cdv("Called Network.start on invalid object.","when calling error in NetworkData, line 462")
endif
endif
call W1x(W6x,W7x,"when calling start in NetworkData, line 462")
set EM=EM-1
endfunction
function W9x takes string yvx returns integer
local integer yex
set ZM[EM]=yvx
set EM=EM+1
if JF==0 then
if KF<$8000 then
set KF=KF+1
set yex=KF
set LF[yex]=$E52
else
call Cdv("Out of memory: Could not create Network.","when calling error in NetworkData, line 204")
set yex=0
endif
else
set JF=JF-1
set yex=HF[JF]
set LF[yex]=$E52
endif
set EM=EM-1
return yex
endfunction
function yxx takes string yox returns integer
local integer yrx
set ZM[EM]=yox
set EM=EM+1
if cv==0 then
if ov<$8000 then
set ov=ov+1
set yrx=ov
set Ov[yrx]=4812
else
call Cdv("Out of memory: Could not create StringEncoder.","when calling error in StringEncoder, line 59")
set yrx=0
endif
else
set cv=cv-1
set yrx=Sv[cv]
set Ov[yrx]=4812
endif
set EM=EM-1
return yrx
endfunction
function yix takes integer yax,string ynx returns nothing
set ZM[EM]=ynx
set EM=EM+1
set rU[yax]=a6x("when calling new_Table in HashData, line 9")
set sU[yax]=0
set tU[yax]=0
set iU[yax]=0
set SU[yax]=0
set EM=EM-1
endfunction
function yVx takes integer yEx,string yXx returns nothing
set ZM[EM]=yXx
set EM=EM+1
call yix(yEx,"when calling HashWriter_init in HashData, line 8")
set EM=EM-1
endfunction
function yOx takes string yRx returns integer
local integer yIx
set ZM[EM]=yRx
set EM=EM+1
if FY==0 then
if kY<$8000 then
set kY=kY+1
set yIx=kY
set jY[yIx]=$6E2
else
call Cdv("Out of memory: Could not create HashWriter.","when calling error in HashData, line 8")
set yIx=0
endif
else
set FY=FY-1
set yIx=hY[FY]
set jY[yIx]=$6E2
endif
set EM=EM-1
return yIx
endfunction
function yAx takes string yNx returns integer
local integer ybx
set ZM[EM]=yNx
set EM=EM+1
set ybx=yOx("when calling alloc_HashWriter in HashData, line 8")
call yVx(ybx,"when calling construct_HashWriter in HashData, line 8")
set EM=EM-1
return ybx
endfunction
function yBx takes integer ycx,string yCx returns nothing
set ZM[EM]=yCx
set EM=EM+1
set xX[ycx]=""
set vX[ycx]=0
set mX[ycx]=yAx("when calling new_HashWriter in StringEncoder, line 63")
set WX[ycx]=yAx("when calling new_HashWriter in StringEncoder, line 66")
set EM=EM-1
endfunction
function ydx takes integer yDx,string yfx returns nothing
set ZM[EM]=yfx
set EM=EM+1
call yBx(yDx,"when calling StringEncoder_init in StringEncoder, line 58")
set EM=EM-1
endfunction
function yFx takes string ygx returns integer
local integer yGx
set ZM[EM]=ygx
set EM=EM+1
set yGx=yxx("when calling alloc_StringEncoder in StringEncoder, line 58")
call ydx(yGx,"when calling construct_StringEncoder in StringEncoder, line 58")
set EM=EM-1
return yGx
endfunction
function yhx takes integer yHx returns nothing
set fZ[yHx]=-1
set RZ[yHx]=-1
set YZ[yHx]=0
endfunction
function yjx takes integer yJx,gamecache ykx,string yKx,integer ylx returns nothing
call yhx(yJx)
set nZ[yJx]=ykx
set dZ[yJx]=yKx
set TZ[yJx]=ylx
endfunction
function yLx takes string ymx returns integer
local integer yMx
set ZM[EM]=ymx
set EM=EM+1
if Cg==0 then
if Vg<$8000 then
set Vg=Vg+1
set yMx=Vg
set Bg[yMx]=$8D9
else
call Cdv("Out of memory: Could not create GamecacheBuffer.","when calling error in GamecacheBuffer, line 21")
set yMx=0
endif
else
set Cg=Cg-1
set yMx=Xg[Cg]
set Bg[yMx]=$8D9
endif
set EM=EM-1
return yMx
endfunction
function ypx takes gamecache yPx,string yqx,integer yQx,string ysx returns integer
local integer ySx
set ZM[EM]=ysx
set EM=EM+1
set ySx=yLx("when calling alloc_GamecacheBuffer in GamecacheBuffer, line 29")
call yjx(ySx,yPx,yqx,yQx)
set EM=EM-1
return ySx
endfunction
function ytx takes string yTx returns integer
local integer yux
set ZM[EM]=yTx
set EM=EM+1
if CF==0 then
if VF<$8000 then
set VF=VF+1
set yux=VF
set BF[yux]=$E57
else
call Cdv("Out of memory: Could not create NetworkFinishedCallback_Network_NetworkData.","when calling error in NetworkData, line 244")
set yux=0
endif
else
set CF=CF-1
set yux=XF[CF]
set BF[yux]=$E57
endif
set EM=EM-1
return yux
endfunction
function yUx takes string ywx returns integer
local integer yWx
set ZM[EM]=ywx
set EM=EM+1
if EF==0 then
if ZF<$8000 then
set ZF=ZF+1
set yWx=ZF
set UF[yWx]=$DBD
else
call Cdv("Out of memory: Could not create MetadataStore.","when calling error in Metadata, line 12")
set yWx=0
endif
else
set EF=EF-1
set yWx=WF[EF]
set UF[yWx]=$DBD
endif
set EM=EM-1
return yWx
endfunction
function yyx takes integer yYx,string yzx returns nothing
set ZM[EM]=yzx
set EM=EM+1
set nP[yYx]=Tbx(yYx,"when calling get in Metadata, line 24")
set EM=EM-1
endfunction
function yZx takes integer y_x,string y0x returns nothing
set ZM[EM]=y0x
set EM=EM+1
call yyx(y_x,"when calling MetadataStore_init in Metadata, line 26")
call T6x(wq,nP[y_x])
set EM=EM-1
endfunction
function y1x takes string y2x returns integer
local integer y3x
set ZM[EM]=y2x
set EM=EM+1
set y3x=yUx("when calling alloc_MetadataStore in Metadata, line 26")
call yZx(y3x,"when calling construct_MetadataStore in Metadata, line 26")
set EM=EM-1
return y3x
endfunction
function y4x takes integer y5x,string y6x returns nothing
local integer y7x
local integer y8x
local integer y9x
local integer Yvx
local integer Yex
local integer Yxx
local integer Yox
local integer Yrx
local integer Yix
local integer Yax
local integer Ynx
set ZM[EM]=y6x
set EM=EM+1
set mP[y5x]=Tbx(y5x,"when calling get in NetworkData, line 213")
set QP[y5x]=yAx("when calling new_HashWriter in NetworkData, line 216")
set EP[y5x]=yFx("when calling new_StringEncoder in NetworkData, line 222")
set ZP[y5x]=ypx(lq,mP[y5x],0,"when calling new_GamecacheBuffer in NetworkData, line 225")
set UP[y5x]=ypx(lq,mP[y5x],1,"when calling new_GamecacheBuffer in NetworkData, line 226")
set IP[y5x]=ypx(lq,mP[y5x],2,"when calling new_GamecacheBuffer in NetworkData, line 227")
set PP[y5x]=ypx(bq,mP[y5x],0,"when calling new_GamecacheBuffer in NetworkData, line 228")
set AP[y5x]=y1x("when calling new_MetadataStore in NetworkData, line 231")
set y8x=Ce
set y9x=Ve
set Yvx=Be
set Yex=Ne
set Yxx=Me
set HP[y5x]=y8x
set JP[y5x]=y9x
set KP[y5x]=Yvx
set LP[y5x]=Yex
set XP[y5x]=Yxx
set CP[y5x]=false
set Yox=Ce
set Yrx=Ve
set Yix=Be
set Yax=Ne
set Ynx=Me
set VP[y5x]=Yox
set BP[y5x]=Yrx
set NP[y5x]=Yix
set MP[y5x]=Yax
set wA[y5x]=Ynx
set y7x=ytx("when calling alloc_NetworkFinishedCallback_Network_NetworkData in NetworkData, line 244")
set uA[y5x]=y7x
set EM=EM-1
endfunction
function YVx takes integer YEx,player YXx,string YOx returns nothing
set ZM[EM]=YOx
set EM=EM+1
call y4x(YEx,"when calling Network_init in NetworkData, line 246")
set DP[YEx]=YXx
set EM=EM-1
endfunction
function YRx takes player YIx,string YAx returns integer
local integer YNx
set ZM[EM]=YAx
set EM=EM+1
set YNx=W9x("when calling alloc_Network in NetworkData, line 246")
call YVx(YNx,YIx,"when calling construct_Network in NetworkData, line 246")
set EM=EM-1
return YNx
endfunction
function Ybx takes integer YBx,integer Ycx,string YCx returns nothing
local integer Ydx
local integer YDx
local integer Yfx
set ZM[EM]=YCx
set EM=EM+1
set Ydx=YRx(xD[YBx],"when calling new_Network in PersistableData, line 134")
if ta==xD[YBx]then
call BWx(YBx,Ydx,"when calling readIntoNetwork in PersistableData, line 137")
endif
set Yfx=Ydx
set YDx=N2x("when calling alloc_NetworkFinishedCallback_start_Persistable_PersistableData in PersistableData, line 139")
set ID[YDx]=YBx
set PD[YDx]=Ycx
call W5x(Yfx,YDx,"when calling start in PersistableData, line 139")
set EM=EM-1
endfunction
function YFx takes integer Ygx,integer YGx,string Yhx returns nothing
set ZM[EM]=Yhx
set EM=EM+1
if Gg[Ygx]==0 then
if Ygx==0 then
call Cdv("Nullpointer exception when calling Persistable.load","when calling error in PersistableData, line 133")
else
call Cdv("Called Persistable.load on invalid object.","when calling error in PersistableData, line 133")
endif
endif
call Ybx(Ygx,YGx,"when calling load in PersistableData, line 133")
set EM=EM-1
endfunction
function YHx takes rect Yjx returns real
set F1=jse(Yjx)
set k1=jte(Yjx)
return F1
endfunction
function YJx takes integer Ykx returns rect
return QH[Ykx]
endfunction
function YKx takes integer Ylx,string YLx returns rect
local rect Ymx
set ZM[EM]=YLx
set EM=EM+1
if Jk[Ylx]==0 then
if Ylx==0 then
call Cdv("Nullpointer exception when calling RectDrawing.asRect","when calling error in RectDrawing, line 110")
else
call Cdv("Called RectDrawing.asRect on invalid object.","when calling error in RectDrawing, line 110")
endif
endif
set Ymx=YJx(Ylx)
set EM=EM-1
set Idv=Ymx
set Ymx=null
return Idv
endfunction
function YMx takes rect Ypx returns integer
return C0v(Ypx)
endfunction
function YPx takes integer Yqx,string YQx returns integer
local integer Ysx
local integer YSx
local integer Ytx
set ZM[EM]=YQx
set EM=EM+1
set Ysx=yTv("when calling new_LinkedList in SotfrpGuiRegions, line 78")
set YSx=jdv(qR[Yqx],"when calling iterator in SotfrpGuiRegions, line 79")
loop
exitwhen not Jgv(YSx,"when calling hasNext in SotfrpGuiRegions, line 79")
set Ytx=jTv(YSx,"when calling next in SotfrpGuiRegions, line 79")
call zGv(Ysx,YMx(YKx(Ytx,"when calling asRect in SotfrpGuiRegions, line 80")),"when calling add in SotfrpGuiRegions, line 80")
endloop
call Jqv(YSx,"when calling close in SotfrpGuiRegions, line 79")
set EM=EM-1
return Ysx
endfunction
function YTx takes real Yux,real YUx,real Ywx returns real
set V1=Yux/Ywx
set B1=YUx/Ywx
return V1
endfunction
function YWx takes hashtable Yyx,integer YYx,integer Yzx returns rect
return LoadRectHandle(Yyx,YYx,Yzx)
endfunction
function YZx takes integer Y_x,integer Y0x returns rect
return YWx(XR,Y_x,Y0x)
endfunction
function Y1x takes integer Y2x,integer Y3x,string Y4x returns rect
local rect Y5x
set ZM[EM]=Y4x
set EM=EM+1
if ph[Y2x]==0 then
if Y2x==0 then
call Cdv("Nullpointer exception when calling Table.loadRect","when calling error in Table, line 147")
else
call Cdv("Called Table.loadRect on invalid object.","when calling error in Table, line 147")
endif
endif
set Y5x=YZx(Y2x,Y3x)
set EM=EM-1
set Iuv=Y5x
set Y5x=null
return Iuv
endfunction
function Y6x takes hashtable Y7x,integer Y8x,integer Y9x,fogstate zvx returns nothing
call SaveFogStateHandle(Y7x,Y8x,Y9x,zvx)
endfunction
function zex takes integer zxx,integer zox,fogstate zrx returns nothing
call Y6x(XR,zxx,zox,zrx)
endfunction
function zix takes integer zax,integer znx,fogstate zVx,string zEx returns nothing
set ZM[EM]=zEx
set EM=EM+1
if ph[zax]==0 then
if zax==0 then
call Cdv("Nullpointer exception when calling Table.saveFogState","when calling error in Table, line 168")
else
call Cdv("Called Table.saveFogState on invalid object.","when calling error in Table, line 168")
endif
endif
call zex(zax,znx,zVx)
set EM=EM-1
endfunction
function zXx takes integer zOx,string zRx returns rect
local rect zIx
set ZM[EM]=zRx
set EM=EM+1
call zix(RT,0,ConvertFogState(zOx),"when calling saveFogState in TypeCasting, line 137")
set zIx=Y1x(RT,0,"when calling loadRect in TypeCasting, line 138")
set EM=EM-1
set R3v=zIx
set zIx=null
return R3v
endfunction
function zAx takes integer zNx,string zbx returns real
local real zBx
local real zcx
local integer zCx
local integer zdx
local rect zDx
local real zfx
local real zFx
local real zgx
local real zGx
set ZM[EM]=zbx
set EM=EM+1
set zfx=.0
set zFx=.0
set zBx=zfx
set zcx=zFx
set zCx=YPx(zNx,"when calling getSelectedRects in SotfrpGuiRegions, line 85")
set zdx=Xle(zCx,"when calling iterator in SotfrpGuiRegions, line 86")
loop
exitwhen not Xie(zdx)
set zDx=zXx(E3e(zdx),"when calling rectFromIndex in SotfrpGuiRegions, line 86")
set zgx=I_e(zBx,zcx,YTx(YHx(zDx),k1,DQv(hye(zCx,"when calling size in SotfrpGuiRegions, line 87"))),B1)
set zGx=O1
set zBx=zgx
set zcx=zGx
endloop
call Xpe(zdx,"when calling close in SotfrpGuiRegions, line 86")
call Hcv(zCx,"when calling dispatch_LinkedList_destroyLinkedList in SotfrpGuiRegions, line 88")
set EM=EM-1
set L1=zBx
set X1=zcx
set zDx=null
return L1
endfunction
function zhx takes integer cDi,integer zHx,integer zjx,string zJx returns integer
local real zkx
local real zKx
local integer zlx
local integer zLx
local integer zmx
local integer zMx
local integer zpx
local real zPx
local real zqx
local real zQx
local real zsx
set ZM[EM]=zJx
set EM=EM+1
set zPx=zAx(QGv(zHx,"when calling getPlayerId in SotfrpGuiRegions, line 159"),"when calling getSelectedOrigin in SotfrpGuiRegions, line 159")
set zqx=X1
set zkx=zPx
set zKx=zqx
set zlx=Nzx(sa[QGv(zHx,"when calling getPlayerId in SotfrpGuiRegions, line 160")],Mqv(M7v(zjx,0,"when calling get in SotfrpGuiRegions, line 160"),"when calling getInner in SotfrpGuiRegions, line 160"),"when calling new_RegionData in SotfrpGuiRegions, line 160")
set zLx=QGv(zHx,"when calling getPlayerId in SotfrpGuiRegions, line 161")
call GDe("Чтение файла и синхронизация данных...",30.,sa[zLx])
set zpx=zlx
set zmx=ABx("when calling alloc_PersistableLoadCallback_load_setArgumentsTypes_registerProtectedBuiltin_SotfrpGuiRegions in SotfrpGuiRegions, line 163")
set BL[zmx]=zlx
set zQx=zkx
set zsx=zKx
set NL[zmx]=zQx
set ML[zmx]=zsx
set wX[zmx]=zLx
call YFx(zpx,zmx,"when calling load in SotfrpGuiRegions, line 163")
set zMx=MLv("when calling nullptr in SotfrpGuiRegions, line 178")
set EM=EM-1
return zMx
endfunction
function zSx takes integer pFt,integer eFt,integer ztx,string zTx returns integer
local string zux
local integer zUx
local integer zwx
local integer zWx
local string zyx
set ZM[EM]=zTx
set EM=EM+1
set zux=""
set zUx=MRe(ztx,"when calling iterator in ScmdCoreBuiltins, line 119")
loop
exitwhen not Jgv(zUx,"when calling hasNext in ScmdCoreBuiltins, line 119")
set zwx=jTv(zUx,"when calling next in ScmdCoreBuiltins, line 119")
set zyx=zux
call fge(1,m0v(zwx,"when calling get in ScmdCoreBuiltins, line 120"),"when calling toString in ScmdCoreBuiltins, line 120")
set zux=zyx+RHv
endloop
call Jqv(zUx,"when calling close in ScmdCoreBuiltins, line 119")
set zWx=p0v(Ppv(zux,"when calling new_String in ScmdCoreBuiltins, line 121"),"when calling new_SharedPointer in ScmdCoreBuiltins, line 121")
set EM=EM-1
return zWx
endfunction
function zYx takes integer nbi,integer zzx,integer fbi,string zZx returns integer
local integer z_x
set ZM[EM]=zZx
set EM=EM+1
set z_x=p0v(SSv(zJv(Mov(zzx,"when calling getEnumUnit in ScmdUnitBuiltins, line 278")),"when calling new_Integer in ScmdUnitBuiltins, line 278"),"when calling new_SharedPointer in ScmdUnitBuiltins, line 278")
set EM=EM-1
return z_x
endfunction
function z0x takes integer nli,integer dli,integer z1x,string z2x returns integer
local integer z3x
set ZM[EM]=z2x
set EM=EM+1
call UnitResetCooldown(PCv(M7v(z1x,0,"when calling get in ScmdUnitBuiltins, line 246"),"when calling getInner in ScmdUnitBuiltins, line 246"))
set z3x=MLv("when calling nullptr in ScmdUnitBuiltins, line 247")
set EM=EM-1
return z3x
endfunction
function z4x takes integer nmt,integer dmt,integer z5x,string z6x returns integer
local integer z7x
set ZM[EM]=z6x
set EM=EM+1
set z7x=p0v(qRv(ModuloInteger(QNv(M7v(z5x,0,"when calling get in ScmdCoreBuiltins, line 282"),"when calling intValue in ScmdCoreBuiltins, line 282"),2)==0,"when calling new_Boolean in ScmdCoreBuiltins, line 282"),"when calling new_SharedPointer in ScmdCoreBuiltins, line 282")
set EM=EM-1
return z7x
endfunction
function z8x takes unit z9x,unitweaponstringfield Zvx,integer Zex,string Zxx returns boolean
return BlzSetUnitWeaponStringField(z9x,Zvx,Zex,Zxx)
endfunction
function Zox takes integer nni,integer dni,integer Zrx,string Zix returns integer
local integer Zax
set ZM[EM]=Zix
set EM=EM+1
set Zax=p0v(qRv(z8x(PCv(M7v(Zrx,0,"when calling get in ScmdUnitBuiltins, line 461"),"when calling getInner in ScmdUnitBuiltins, line 461"),UNIT_WEAPON_SF_ATTACK_PROJECTILE_ART,QNv(M7v(Zrx,1,"when calling get in ScmdUnitBuiltins, line 461"),"when calling intValue in ScmdUnitBuiltins, line 461"),Mqv(M7v(Zrx,2,"when calling get in ScmdUnitBuiltins, line 461"),"when calling getInner in ScmdUnitBuiltins, line 461")),"when calling new_Boolean in ScmdUnitBuiltins, line 461"),"when calling new_SharedPointer in ScmdUnitBuiltins, line 461")
set EM=EM-1
return Zax
endfunction
function Znx takes integer npi,integer dpi,integer ZVx,string ZEx returns integer
local integer ZXx
set ZM[EM]=ZEx
set EM=EM+1
call N6e(PCv(M7v(ZVx,0,"when calling get in ScmdUnitBuiltins, line 335"),"when calling getInner in ScmdUnitBuiltins, line 335"),QNv(M7v(ZVx,1,"when calling get in ScmdUnitBuiltins, line 335"),"when calling intValue in ScmdUnitBuiltins, line 335"),QNv(M7v(ZVx,2,"when calling get in ScmdUnitBuiltins, line 335"),"when calling intValue in ScmdUnitBuiltins, line 335"))
set ZXx=MLv("when calling nullptr in ScmdUnitBuiltins, line 336")
set EM=EM-1
return ZXx
endfunction
function ZOx takes integer ept,integer ZRx,integer ZIx,string ZAx returns integer
local boolean ZNx
local string Zbx
local integer ZBx
local integer Zcx
set ZM[EM]=ZAx
set EM=EM+1
set ZNx=true
set Zbx=XAx(Mqv(M7v(ZIx,0,"when calling get in SLangChatSystem, line 181"),"when calling getInner in SLangChatSystem, line 181"))
if Zbx=="IC" then
call HFe(Ha,QGv(ZRx,"when calling getPlayerId in SLangChatSystem, line 183"),Mqv(M7v(ZIx,1,"when calling get in SLangChatSystem, line 183"),"when calling getInner in SLangChatSystem, line 183"),ta,"when calling send in SLangChatSystem, line 183")
elseif Zbx=="OOC" then
call HFe(Ja,QGv(ZRx,"when calling getPlayerId in SLangChatSystem, line 185"),Mqv(M7v(ZIx,1,"when calling get in SLangChatSystem, line 185"),"when calling getInner in SLangChatSystem, line 185"),ta,"when calling send in SLangChatSystem, line 185")
else
set ZNx=false
endif
if ZNx then
set ZBx=MLv("when calling nullptr in SLangChatSystem, line 188")
else
set ZBx=p0v(tJv("Wrong channel","when calling new_Exception in SLangChatSystem, line 188"),"when calling new_SharedPointer in SLangChatSystem, line 188")
endif
set Zcx=ZBx
set EM=EM-1
return Zcx
endfunction
function ZCx takes integer nqi,integer Zdx,integer ZDx,string Zfx returns integer
local integer ZFx
set ZM[EM]=Zfx
set EM=EM+1
call mbe(Mov(Zdx,"when calling getEnumUnit in ScmdUnitBuiltins, line 389"),UNIT_RF_SIGHT_RADIUS,PEv(M7v(ZDx,0,"when calling get in ScmdUnitBuiltins, line 389"),"when calling realValue in ScmdUnitBuiltins, line 389"))
set ZFx=MLv("when calling nullptr in ScmdUnitBuiltins, line 390")
set EM=EM-1
return ZFx
endfunction
function Zgx takes rect ZGx,real Zhx,real ZHx returns nothing
call MoveRectTo(ZGx,Zhx,ZHx)
endfunction
function Zjx takes integer nri,integer dri,integer ZJx,string Zkx returns integer
local integer ZKx
set ZM[EM]=Zkx
set EM=EM+1
call Zgx(gOe(M7v(ZJx,0,"when calling get in ScmdRectBuiltins, line 32"),"when calling getInner in ScmdRectBuiltins, line 32"),PEv(M7v(ZJx,1,"when calling get in ScmdRectBuiltins, line 32"),"when calling realValue in ScmdRectBuiltins, line 32"),PEv(M7v(ZJx,2,"when calling get in ScmdRectBuiltins, line 32"),"when calling realValue in ScmdRectBuiltins, line 32"))
set ZKx=MLv("when calling nullptr in ScmdRectBuiltins, line 33")
set EM=EM-1
return ZKx
endfunction
function Zlx takes integer v0i,integer m0i,integer ZLx,string Zmx returns integer
local integer ZMx
set ZM[EM]=Zmx
set EM=EM+1
call IAe(Wlv(M7v(ZLx,0,"when calling get in ScmdItemBuiltins, line 38"),"when calling getInner in ScmdItemBuiltins, line 38"),Mqv(M7v(ZLx,1,"when calling get in ScmdItemBuiltins, line 38"),"when calling getInner in ScmdItemBuiltins, line 38"))
set ZMx=MLv("when calling nullptr in ScmdItemBuiltins, line 39")
set EM=EM-1
return ZMx
endfunction
function Zpx takes player ZPx,integer Zqx,string ZQx,real Zsx,real ZSx returns group
local group Ztx=CreateGroup()
local integer ZTx=UnitId(ZQx)
local integer Zux=0
local integer ZUx=Zqx-1
loop
exitwhen Zux>ZUx
call KWe(Ztx,CreateUnit(ZPx,ZTx,Zsx,ZSx,bj_UNIT_FACING))
set Zux=Zux+1
endloop
set Ryv=Ztx
set Ztx=null
return Ryv
endfunction
function Zwx takes integer vEi,integer ZWx,integer Zyx,string ZYx returns integer
local integer Zzx
set ZM[EM]=ZYx
set EM=EM+1
set Zzx=p0v(jle(Zpx(sa[PLAYER_NEUTRAL_AGGRESSIVE],QNv(M7v(Zyx,0,"when calling get in SotfrpGuiCoreUnit, line 114"),"when calling intValue in SotfrpGuiCoreUnit, line 114"),Mqv(M7v(Zyx,1,"when calling get in SotfrpGuiCoreUnit, line 114"),"when calling getInner in SotfrpGuiCoreUnit, line 114"),uov(vf[QGv(ZWx,"when calling getPlayerId in SotfrpGuiCoreUnit, line 114")]),c3),"when calling new_Group in SotfrpGuiCoreUnit, line 114"),"when calling new_SharedPointer in SotfrpGuiCoreUnit, line 114")
set EM=EM-1
return Zzx
endfunction
function ZZx takes integer vRi,integer Z_x,integer Z0x,string Z1x returns integer
local integer Z2x
set ZM[EM]=Z1x
set EM=EM+1
call SetUnitFacing(Mov(Z_x,"when calling getEnumUnit in ScmdUnitBuiltins, line 638"),PEv(M7v(Z0x,0,"when calling get in ScmdUnitBuiltins, line 638"),"when calling realValue in ScmdUnitBuiltins, line 638"))
set Z2x=MLv("when calling nullptr in ScmdUnitBuiltins, line 639")
set EM=EM-1
return Z2x
endfunction
function Z3x takes integer vYi,integer mYi,integer Z4x,string Z5x returns integer
local integer Z6x
set ZM[EM]=Z5x
set EM=EM+1
set Z6x=p0v(SSv(umv(PCv(M7v(Z4x,0,"when calling get in ScmdUnitBuiltins, line 693"),"when calling getInner in ScmdUnitBuiltins, line 693")),"when calling new_Integer in ScmdUnitBuiltins, line 693"),"when calling new_SharedPointer in ScmdUnitBuiltins, line 693")
set EM=EM-1
return Z6x
endfunction
function Z7x takes integer vci,integer Z8x,integer Z9x,string vvo returns integer
local integer vxo
set ZM[EM]=vvo
set EM=EM+1
call AWe(Mov(Z8x,"when calling getEnumUnit in ScmdUnitBuiltins, line 142"),PEv(M7v(Z9x,0,"when calling get in ScmdUnitBuiltins, line 142"),"when calling realValue in ScmdUnitBuiltins, line 142"))
set vxo=MLv("when calling nullptr in ScmdUnitBuiltins, line 143")
set EM=EM-1
return vxo
endfunction
function vVo takes integer vdi,integer mdi,integer vEo,string vXo returns integer
local integer vIo
set ZM[EM]=vXo
set EM=EM+1
set vIo=p0v(SSv(dDe(PCv(M7v(vEo,0,"when calling get in ScmdUnitBuiltins, line 570"),"when calling getInner in ScmdUnitBuiltins, line 570")),"when calling new_Integer in ScmdUnitBuiltins, line 570"),"when calling new_SharedPointer in ScmdUnitBuiltins, line 570")
set EM=EM-1
return vIo
endfunction
function vAo takes integer hdt,integer vNo,integer vBo,string vCo returns integer
local player vDo
local integer vFo
local integer vgo
local integer vho
local player vHo
local integer vjo
set ZM[EM]=vCo
set EM=EM+1
set vHo=Onx(Mqv(M7v(vBo,0,"when calling get in SLangPlayerFunctions, line 108"),"when calling getInner in SLangPlayerFunctions, line 108"),"when calling resolvePlayer in SLangPlayerFunctions, line 108")
set vjo=v1
set vDo=vHo
set vFo=vjo
if vFo==0 then
call SetPlayerAllianceStateVisionBJ(sa[QGv(vNo,"when calling getPlayerId in SLangPlayerFunctions, line 110")],vDo,false)
endif
if vFo!=0 then
set vgo=vFo
else
set vgo=MLv("when calling nullptr in SLangPlayerFunctions, line 111")
endif
set vho=vgo
set EM=EM-1
set vDo=null
set vHo=null
return vho
endfunction
function vJo takes integer nht,integer dht,integer vko,string vKo returns integer
local boolean vLo
local boolean vmo
local integer vMo
local integer vPo
local integer vQo
local real vUo
local integer vWo
local integer vzo
local integer vZo
local integer v3o
local integer evo
local integer exo
local integer eVo
local integer eEo
set ZM[EM]=vKo
set EM=EM+1
set vLo=false
set vmo=false
set vMo=0
set vPo=SNv(vko,"when calling size in ScmdCoreBuiltins, line 64")-1
loop
exitwhen vMo>vPo
set eVo=ox[M7v(vko,vMo,"when calling get in ScmdCoreBuiltins, line 65")]
if not(eVo==$EFD or eVo==$F03)then
set vLo=true
endif
if SNv(vko,"when calling size in ScmdCoreBuiltins, line 67")==1 or vMo>0 and kge(M7v(vko,vMo,"when calling get in ScmdCoreBuiltins, line 67"),"when calling realValue in ScmdCoreBuiltins, line 67")==.0 then
set vmo=true
exitwhen true
endif
set vMo=vMo+1
endloop
set vQo=kZe(M7v(vko,0,"when calling get in ScmdCoreBuiltins, line 70"),"when calling intValue in ScmdCoreBuiltins, line 70")
set vUo=kge(M7v(vko,0,"when calling get in ScmdCoreBuiltins, line 71"),"when calling realValue in ScmdCoreBuiltins, line 71")
if not vmo then
if vLo then
if SNv(vko,"when calling size in ScmdCoreBuiltins, line 74")==1 then
set vUo=1./vUo
else
set vWo=1
set vzo=SNv(vko,"when calling size in ScmdCoreBuiltins, line 77")-1
loop
exitwhen vWo>vzo
set vUo=vUo/kge(M7v(vko,vWo,"when calling get in ScmdCoreBuiltins, line 78"),"when calling realValue in ScmdCoreBuiltins, line 78")
set vWo=vWo+1
endloop
endif
elseif SNv(vko,"when calling size in ScmdCoreBuiltins, line 80")==1 then
set vQo=1/vQo
else
set vZo=1
set v3o=SNv(vko,"when calling size in ScmdCoreBuiltins, line 83")-1
loop
exitwhen vZo>v3o
set vQo=vQo/kZe(M7v(vko,vZo,"when calling get in ScmdCoreBuiltins, line 84"),"when calling intValue in ScmdCoreBuiltins, line 84")
set vZo=vZo+1
endloop
endif
endif
if vmo then
set exo=tJv("Division by zero","when calling new_Exception in ScmdCoreBuiltins, line 85")
else
if vLo then
set evo=q2v(vUo,"when calling new_Real in ScmdCoreBuiltins, line 85")
else
set evo=SSv(vQo,"when calling new_Integer in ScmdCoreBuiltins, line 85")
endif
set exo=evo
endif
set eEo=p0v(exo,"when calling new_SharedPointer in ScmdCoreBuiltins, line 85")
set EM=EM-1
return eEo
endfunction
function eXo takes integer xmt,integer vmt,integer eIo,string eAo returns integer
local integer eNo
local integer eBo
set ZM[EM]=eAo
set EM=EM+1
set eNo=ox[M7v(eIo,0,"when calling get in ScmdCoreBuiltins, line 288")]
set eBo=p0v(qRv(eNo==$EFD or eNo==$F03,"when calling new_Boolean in ScmdCoreBuiltins, line 288"),"when calling new_SharedPointer in ScmdCoreBuiltins, line 288")
set EM=EM-1
return eBo
endfunction
function eCo takes integer voi,integer eDo,integer eFo,string ego returns integer
local integer eho
set ZM[EM]=ego
set EM=EM+1
call bze(Mov(eDo,"when calling getEnumUnit in ScmdUnitBuiltins, line 169"),QNv(M7v(eFo,0,"when calling get in ScmdUnitBuiltins, line 169"),"when calling intValue in ScmdUnitBuiltins, line 169"))
set eho=MLv("when calling nullptr in ScmdUnitBuiltins, line 170")
set EM=EM-1
return eho
endfunction
function eHo takes integer hti,integer ejo,integer eJo,string eko returns integer
local string eKo
local playercolor eLo
local playercolor emo
local boolean eMo
local integer ePo
local integer eQo
set ZM[EM]=eko
set EM=EM+1
set eKo=tYv(Mqv(M7v(eJo,0,"when calling get in ScmdUnitBuiltins, line 58"),"when calling getInner in ScmdUnitBuiltins, line 58"))
if eKo=="black" then
set emo=ia
else
set emo=tZv(eKo)
endif
set eLo=emo
set eMo=eLo!=null or tYv(eKo)=="red"
if eMo then
call tuv(Mov(ejo,"when calling getEnumUnit in ScmdUnitBuiltins, line 62"),eLo)
endif
if eMo then
set ePo=MLv("when calling nullptr in ScmdUnitBuiltins, line 63")
else
set ePo=tLv("when calling newWCNException in ScmdUnitBuiltins, line 63")
endif
set eQo=ePo
set EM=EM-1
set eLo=null
set emo=null
return eQo
endfunction
function eUo takes string eWo returns integer
local integer ezo
set ZM[EM]=eWo
set EM=EM+1
if Xj==0 then
if Cj<$8000 then
set Cj=Cj+1
set ezo=Cj
set Vj[ezo]=$C45
else
call Cdv("Out of memory: Could not create IntBinOp_reduceNumbers_setArgumentsTypes_setVariadicArgumentTypes_registerProtectedBuiltin_ScmdCoreBuiltins.","when calling error in ScmdCoreBuiltins, line 267")
set ezo=0
endif
else
set Xj=Xj-1
set ezo=Lj[Xj]
set Vj[ezo]=$C45
endif
set EM=EM-1
return ezo
endfunction
function eZo takes string e3o returns integer
local integer xvo
set ZM[EM]=e3o
set EM=EM+1
if Nj==0 then
if Mj<$8000 then
set Mj=Mj+1
set xvo=Mj
set wx[xvo]=4160
else
call Cdv("Out of memory: Could not create RealBinOp_reduceNumbers_setArgumentsTypes_setVariadicArgumentTypes_registerProtectedBuiltin_ScmdCoreBuiltins.","when calling error in ScmdCoreBuiltins, line 267")
set xvo=0
endif
else
set Nj=Nj-1
set xvo=Bj[Nj]
set wx[xvo]=4160
endif
set EM=EM-1
return xvo
endfunction
function xxo takes integer gvt,integer hvt,integer xVo,string xEo returns integer
local integer xXo
local integer xIo
local integer xAo
local integer xNo
local integer xBo
local integer xCo
local real xDo
set ZM[EM]=xEo
set EM=EM+1
set xNo=xVo
set xBo=je
set xXo=eUo("when calling alloc_IntBinOp_reduceNumbers_setArgumentsTypes_setVariadicArgumentTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdCoreBuiltins, line 267")
set xCo=xXo
set xDo=Fa
set xIo=eZo("when calling alloc_RealBinOp_reduceNumbers_setArgumentsTypes_setVariadicArgumentTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdCoreBuiltins, line 267")
set xAo=Kde(xNo,xBo,xCo,xDo,xIo,"when calling reduceNumbers in ScmdCoreBuiltins, line 267")
set EM=EM-1
return xAo
endfunction
function xFo takes integer fxt,integer Rxt,integer xgo,string xho returns integer
local boolean xHo
local integer xjo
local integer xJo
local integer xko
local real xKo
local integer xLo
local integer xmo
local integer xMo
local integer xPo
local integer xQo
local integer xUo
local integer xWo
set ZM[EM]=xho
set EM=EM+1
set xHo=false
set xjo=0
set xJo=SNv(xgo,"when calling size in ScmdCoreBuiltins, line 218")-1
loop
exitwhen xjo>xJo
set xUo=ox[M7v(xgo,xjo,"when calling get in ScmdCoreBuiltins, line 219")]
if not(xUo==$EFD or xUo==$F03)then
set xHo=true
endif
set xjo=xjo+1
endloop
set xko=kZe(M7v(xgo,0,"when calling get in ScmdCoreBuiltins, line 221"),"when calling intValue in ScmdCoreBuiltins, line 221")
set xKo=kge(M7v(xgo,0,"when calling get in ScmdCoreBuiltins, line 222"),"when calling realValue in ScmdCoreBuiltins, line 222")
if xHo then
if SNv(xgo,"when calling size in ScmdCoreBuiltins, line 224")==1 then
set xKo=-xKo
else
set xLo=1
set xmo=SNv(xgo,"when calling size in ScmdCoreBuiltins, line 227")-1
loop
exitwhen xLo>xmo
set xKo=xKo-kge(M7v(xgo,xLo,"when calling get in ScmdCoreBuiltins, line 228"),"when calling realValue in ScmdCoreBuiltins, line 228")
set xLo=xLo+1
endloop
endif
elseif SNv(xgo,"when calling size in ScmdCoreBuiltins, line 230")==1 then
set xko=-xko
else
set xMo=1
set xPo=SNv(xgo,"when calling size in ScmdCoreBuiltins, line 233")-1
loop
exitwhen xMo>xPo
set xko=xko-kZe(M7v(xgo,xMo,"when calling get in ScmdCoreBuiltins, line 234"),"when calling intValue in ScmdCoreBuiltins, line 234")
set xMo=xMo+1
endloop
endif
if xHo then
set xQo=q2v(xKo,"when calling new_Real in ScmdCoreBuiltins, line 235")
else
set xQo=SSv(xko,"when calling new_Integer in ScmdCoreBuiltins, line 235")
endif
set xWo=pIe(xQo,"when calling new_GenericSharedPointer in ScmdCoreBuiltins, line 235")
set EM=EM-1
return xWo
endfunction
function xzo takes integer lGi,integer bGi,integer xZo,string x3o returns integer
local string ovo
local integer oxo
set ZM[EM]=x3o
set EM=EM+1
set ovo=Mqv(M7v(xZo,1,"when calling get in ScmdUnitBuiltins, line 709"),"when calling getInner in ScmdUnitBuiltins, line 709")
if ovo!=null then
call Nee(PCv(M7v(xZo,0,"when calling get in ScmdUnitBuiltins, line 711"),"when calling getInner in ScmdUnitBuiltins, line 711"),ovo)
endif
set oxo=MLv("when calling nullptr in ScmdUnitBuiltins, line 712")
set EM=EM-1
return oxo
endfunction
function oVo takes integer bbi,integer ybi,integer oEo,string oXo returns integer
local integer oIo
set ZM[EM]=oXo
set EM=EM+1
call bVe(PCv(M7v(oEo,0,"when calling get in ScmdUnitBuiltins, line 274"),"when calling getInner in ScmdUnitBuiltins, line 274"),QNv(M7v(oEo,1,"when calling get in ScmdUnitBuiltins, line 274"),"when calling intValue in ScmdUnitBuiltins, line 274"))
set oIo=MLv("when calling nullptr in ScmdUnitBuiltins, line 275")
set EM=EM-1
return oIo
endfunction
function oAo takes integer bgt,integer oNo,integer oBo,string oCo returns integer
local integer oDo
set ZM[EM]=oCo
set EM=EM+1
if ta==sa[QGv(oNo,"when calling getPlayerId in ScmdCameraSetupBuiltins, line 33")]then
call CameraSetupApplyForceDurationWithZ(FVe(M7v(oBo,0,"when calling get in ScmdCameraSetupBuiltins, line 34"),"when calling getInner in ScmdCameraSetupBuiltins, line 34"),PEv(M7v(oBo,1,"when calling get in ScmdCameraSetupBuiltins, line 34"),"when calling realValue in ScmdCameraSetupBuiltins, line 34"),PEv(M7v(oBo,2,"when calling get in ScmdCameraSetupBuiltins, line 34"),"when calling realValue in ScmdCameraSetupBuiltins, line 34"))
endif
set oDo=MLv("when calling nullptr in ScmdCameraSetupBuiltins, line 35")
set EM=EM-1
return oDo
endfunction
function oFo takes integer wht,integer uht,integer ogo,string oho returns integer
local boolean oHo
local integer ojo
local integer oJo
local integer oko
local real oKo
local integer oLo
local integer omo
local integer oMo
local integer oPo
local integer oQo
local integer oUo
local integer oWo
set ZM[EM]=oho
set EM=EM+1
set oHo=false
set ojo=0
set oJo=SNv(ogo,"when calling size in ScmdCoreBuiltins, line 42")-1
loop
exitwhen ojo>oJo
set oUo=ox[M7v(ogo,ojo,"when calling get in ScmdCoreBuiltins, line 43")]
if not(oUo==$EFD or oUo==$F03)then
set oHo=true
endif
set ojo=ojo+1
endloop
set oko=kZe(M7v(ogo,0,"when calling get in ScmdCoreBuiltins, line 45"),"when calling intValue in ScmdCoreBuiltins, line 45")
set oKo=kge(M7v(ogo,0,"when calling get in ScmdCoreBuiltins, line 46"),"when calling realValue in ScmdCoreBuiltins, line 46")
if oHo then
if SNv(ogo,"when calling size in ScmdCoreBuiltins, line 48")==1 then
set oKo=-oKo
else
set oLo=1
set omo=SNv(ogo,"when calling size in ScmdCoreBuiltins, line 51")-1
loop
exitwhen oLo>omo
set oKo=oKo-kge(M7v(ogo,oLo,"when calling get in ScmdCoreBuiltins, line 52"),"when calling realValue in ScmdCoreBuiltins, line 52")
set oLo=oLo+1
endloop
endif
elseif SNv(ogo,"when calling size in ScmdCoreBuiltins, line 54")==1 then
set oko=-oko
else
set oMo=1
set oPo=SNv(ogo,"when calling size in ScmdCoreBuiltins, line 57")-1
loop
exitwhen oMo>oPo
set oko=oko-kZe(M7v(ogo,oMo,"when calling get in ScmdCoreBuiltins, line 58"),"when calling intValue in ScmdCoreBuiltins, line 58")
set oMo=oMo+1
endloop
endif
if oHo then
set oQo=q2v(oKo,"when calling new_Real in ScmdCoreBuiltins, line 59")
else
set oQo=SSv(oko,"when calling new_Integer in ScmdCoreBuiltins, line 59")
endif
set oWo=pIe(oQo,"when calling new_GenericSharedPointer in ScmdCoreBuiltins, line 59")
set EM=EM-1
return oWo
endfunction
function ozo takes integer bli,integer oZo,integer pli,string o3o returns integer
local integer rvo
set ZM[EM]=o3o
set EM=EM+1
call UnitResetCooldown(Mov(oZo,"when calling getEnumUnit in ScmdUnitBuiltins, line 243"))
set rvo=MLv("when calling nullptr in ScmdUnitBuiltins, line 244")
set EM=EM-1
return rvo
endfunction
function rxo takes integer bmt,integer ymt,integer rVo,string rEo returns integer
local integer rXo
set ZM[EM]=rEo
set EM=EM+1
set rXo=p0v(qRv(kge(M7v(rVo,0,"when calling get in ScmdCoreBuiltins, line 279"),"when calling realValue in ScmdCoreBuiltins, line 279")<.0,"when calling new_Boolean in ScmdCoreBuiltins, line 279"),"when calling new_SharedPointer in ScmdCoreBuiltins, line 279")
set EM=EM-1
return rXo
endfunction
function rIo takes integer bni,integer rAo,integer rNo,string rBo returns integer
local integer rCo
set ZM[EM]=rBo
set EM=EM+1
set rCo=p0v(qRv(z8x(Mov(rAo,"when calling getEnumUnit in ScmdUnitBuiltins, line 459"),UNIT_WEAPON_SF_ATTACK_PROJECTILE_ART,QNv(M7v(rNo,0,"when calling get in ScmdUnitBuiltins, line 459"),"when calling intValue in ScmdUnitBuiltins, line 459"),Mqv(M7v(rNo,1,"when calling get in ScmdUnitBuiltins, line 459"),"when calling getInner in ScmdUnitBuiltins, line 459")),"when calling new_Boolean in ScmdUnitBuiltins, line 459"),"when calling new_SharedPointer in ScmdUnitBuiltins, line 459")
set EM=EM-1
return rCo
endfunction
function rDo takes integer bpi,integer rFo,integer rgo,string rho returns integer
local integer rHo
set ZM[EM]=rho
set EM=EM+1
call N6e(Mov(rFo,"when calling getEnumUnit in ScmdUnitBuiltins, line 332"),QNv(M7v(rgo,0,"when calling get in ScmdUnitBuiltins, line 332"),"when calling intValue in ScmdUnitBuiltins, line 332"),QNv(M7v(rgo,1,"when calling get in ScmdUnitBuiltins, line 332"),"when calling intValue in ScmdUnitBuiltins, line 332"))
set rHo=MLv("when calling nullptr in ScmdUnitBuiltins, line 333")
set EM=EM-1
return rHo
endfunction
function rjo takes integer bqi,integer yqi,integer rJo,string rko returns integer
local integer rKo
set ZM[EM]=rko
set EM=EM+1
call mbe(PCv(M7v(rJo,0,"when calling get in ScmdUnitBuiltins, line 385"),"when calling getInner in ScmdUnitBuiltins, line 385"),UNIT_RF_MANA_REGENERATION,PEv(M7v(rJo,1,"when calling get in ScmdUnitBuiltins, line 385"),"when calling realValue in ScmdUnitBuiltins, line 385"))
set rKo=MLv("when calling nullptr in ScmdUnitBuiltins, line 386")
set EM=EM-1
return rKo
endfunction
function rLo takes integer bri,integer yri,integer rmo,string rMo returns integer
local integer rPo
set ZM[EM]=rMo
set EM=EM+1
set rPo=p0v(q2v(jte(gOe(M7v(rmo,0,"when calling get in ScmdRectBuiltins, line 29"),"when calling getInner in ScmdRectBuiltins, line 29")),"when calling new_Real in ScmdRectBuiltins, line 29"),"when calling new_SharedPointer in ScmdRectBuiltins, line 29")
set EM=EM-1
return rPo
endfunction
function rQo takes integer S0i,integer c0i,integer rUo,string rWo returns integer
local integer rzo
set ZM[EM]=rWo
set EM=EM+1
call Ihe(Wlv(M7v(rUo,0,"when calling get in ScmdItemBuiltins, line 22"),"when calling getInner in ScmdItemBuiltins, line 22"),Mqv(M7v(rUo,1,"when calling get in ScmdItemBuiltins, line 22"),"when calling getInner in ScmdItemBuiltins, line 22"))
set rzo=MLv("when calling nullptr in ScmdItemBuiltins, line 23")
set EM=EM-1
return rzo
endfunction
function rZo takes integer r3o,string ivo,string ixo,integer iVo,string iEo returns boolean
local boolean iXo
set ZM[EM]=iEo
set EM=EM+1
set iXo=Cie(r3o,ivo,ixo,null,iVo,"when calling assign in ScmdDataTypes, line 275")
set EM=EM-1
return iXo
endfunction
function iIo takes integer iAo returns integer
return mZv(iAo)
endfunction
function iNo takes integer iBo,string iCo returns integer
local integer iDo
set ZM[EM]=iCo
set EM=EM+1
if gx[iBo]==0 then
if iBo==0 then
call Cdv("Nullpointer exception when calling SharedPointer.get","when calling error in ScmdDataTypes, line 180")
else
call Cdv("Called SharedPointer.get on invalid object.","when calling error in ScmdDataTypes, line 180")
endif
endif
set iDo=iIo(iBo)
set EM=EM-1
return iDo
endfunction
function iFo takes integer sEt,integer igo,integer iho,string iHo returns integer
local integer ijo
local integer iJo
local integer iko
local string iKo
set ZM[EM]=iHo
set EM=EM+1
set iko=QGv(igo,"when calling getPlayerId in ScmdCoreBuiltins, line 378")
set iKo=Mqv(M7v(iho,0,"when calling get in ScmdCoreBuiltins, line 378"),"when calling getInner in ScmdCoreBuiltins, line 378")
call fge(1,iNo(Joe(iho,1,"when calling getPtr in ScmdCoreBuiltins, line 378"),"when calling get in ScmdCoreBuiltins, line 378"),"when calling toString in ScmdCoreBuiltins, line 378")
if rZo(iko,iKo,RHv,MJv(Joe(iho,2,"when calling getPtr in ScmdCoreBuiltins, line 378"),"when calling clone in ScmdCoreBuiltins, line 378"),"when calling assign in ScmdCoreBuiltins, line 378")then
set ijo=MLv("when calling nullptr in ScmdCoreBuiltins, line 378")
else
set ijo=p0v(tJv("Symbol is protected","when calling new_Exception in ScmdCoreBuiltins, line 378"),"when calling new_SharedPointer in ScmdCoreBuiltins, line 378")
endif
set iJo=ijo
set EM=EM-1
return iJo
endfunction
function iLo takes unit imo,string iMo returns boolean
local heroattribute iPo=HERO_ATTRIBUTE_STR
local boolean iQo=true
local string iUo=iMo
local boolean iWo
if iUo=="str" or iUo=="strength" then
set iPo=HERO_ATTRIBUTE_STR
elseif iUo=="agi" or iUo=="agility" then
set iPo=HERO_ATTRIBUTE_AGI
elseif iUo=="int" or iUo=="intelligence" then
set iPo=HERO_ATTRIBUTE_INT
else
set iQo=false
endif
if iQo then
set iWo=SYv(imo,UNIT_IF_PRIMARY_ATTRIBUTE,C0v(iPo))
else
set iWo=false
endif
set iPo=null
return iWo
endfunction
function izo takes integer SRi,integer iZo,integer i3o,string avo returns integer
local integer axo
set ZM[EM]=avo
set EM=EM+1
set axo=p0v(qRv(iLo(Mov(iZo,"when calling getEnumUnit in ScmdUnitBuiltins, line 625"),Mqv(M7v(i3o,0,"when calling get in ScmdUnitBuiltins, line 625"),"when calling getInner in ScmdUnitBuiltins, line 625")),"when calling new_Boolean in ScmdUnitBuiltins, line 625"),"when calling new_SharedPointer in ScmdUnitBuiltins, line 625")
set EM=EM-1
return axo
endfunction
function aVo takes integer SYi,integer cYi,integer aEo,string aXo returns integer
local integer aIo
set ZM[EM]=aXo
set EM=EM+1
call RWe(PCv(M7v(aEo,0,"when calling get in ScmdUnitBuiltins, line 679"),"when calling getInner in ScmdUnitBuiltins, line 679"),dve(QJv(PCv(M7v(aEo,0,"when calling get in ScmdUnitBuiltins, line 679"),"when calling getInner in ScmdUnitBuiltins, line 679"))+PEv(M7v(aEo,1,"when calling get in ScmdUnitBuiltins, line 679"),"when calling realValue in ScmdUnitBuiltins, line 679"),XT,LT))
set aIo=MLv("when calling nullptr in ScmdUnitBuiltins, line 680")
set EM=EM-1
return aIo
endfunction
function aAo takes integer Sci,integer aNo,integer aBo,string aCo returns integer
local integer aDo
set ZM[EM]=aCo
set EM=EM+1
call ASe(Mov(aNo,"when calling getEnumUnit in ScmdUnitBuiltins, line 130"),PEv(M7v(aBo,0,"when calling get in ScmdUnitBuiltins, line 130"),"when calling realValue in ScmdUnitBuiltins, line 130"))
set aDo=MLv("when calling nullptr in ScmdUnitBuiltins, line 131")
set EM=EM-1
return aDo
endfunction
function aFo takes integer Soi,integer ago,integer aho,string aHo returns integer
local integer ajo
set ZM[EM]=aHo
set EM=EM+1
call Nde(Mov(ago,"when calling getEnumUnit in ScmdUnitBuiltins, line 155"),PEv(M7v(aho,0,"when calling get in ScmdUnitBuiltins, line 155"),"when calling realValue in ScmdUnitBuiltins, line 155"))
set ajo=MLv("when calling nullptr in ScmdUnitBuiltins, line 156")
set EM=EM-1
return ajo
endfunction
function aJo takes unit ako,unitweaponbooleanfield aKo,integer aLo,boolean amo returns boolean
return BlzSetUnitWeaponBooleanField(ako,aKo,aLo,amo)
endfunction
function aMo takes integer rai,integer aPo,integer aQo,string aUo returns integer
local integer aWo
set ZM[EM]=aUo
set EM=EM+1
set aWo=p0v(qRv(aJo(Mov(aPo,"when calling getEnumUnit in ScmdUnitBuiltins, line 408"),UNIT_WEAPON_BF_ATTACKS_ENABLED,QNv(M7v(aQo,0,"when calling get in ScmdUnitBuiltins, line 408"),"when calling intValue in ScmdUnitBuiltins, line 408"),WCv(M7v(aQo,1,"when calling get in ScmdUnitBuiltins, line 408"),"when calling booleanValue in ScmdUnitBuiltins, line 408")),"when calling new_Boolean in ScmdUnitBuiltins, line 408"),"when calling new_SharedPointer in ScmdUnitBuiltins, line 408")
set EM=EM-1
return aWo
endfunction
function azo takes unit aZo,string a3o returns boolean
local movetype nvo=MOVE_TYPE_UNKNOWN
local boolean nxo=true
local string nVo=a3o
local boolean nEo
if nVo=="amphibious" or nVo=="amph" then
set nvo=MOVE_TYPE_AMPHIBIOUS
elseif nVo=="float" then
set nvo=MOVE_TYPE_FLOAT
elseif nVo=="fly" then
set nvo=MOVE_TYPE_FLY
elseif nVo=="foot" then
set nvo=MOVE_TYPE_FOOT
elseif nVo=="horse" then
set nvo=MOVE_TYPE_HORSE
elseif nVo=="hover" then
set nvo=MOVE_TYPE_HOVER
elseif nVo=="unbuildable" then
set nvo=MOVE_TYPE_UNBUILDABLE
elseif nVo=="unknown" then
set nvo=MOVE_TYPE_UNKNOWN
else
set nxo=false
endif
if nxo then
set nEo=SYv(aZo,UNIT_IF_MOVE_TYPE,C0v(nvo))
else
set nEo=false
endif
set nvo=null
return nEo
endfunction
function nXo takes integer rdi,integer sdi,integer nIo,string nAo returns integer
local integer nNo
set ZM[EM]=nAo
set EM=EM+1
set nNo=p0v(qRv(azo(PCv(M7v(nIo,0,"when calling get in ScmdUnitBuiltins, line 548"),"when calling getInner in ScmdUnitBuiltins, line 548"),Mqv(M7v(nIo,1,"when calling get in ScmdUnitBuiltins, line 548"),"when calling getInner in ScmdUnitBuiltins, line 548")),"when calling new_Boolean in ScmdUnitBuiltins, line 548"),"when calling new_SharedPointer in ScmdUnitBuiltins, line 548")
set EM=EM-1
return nNo
endfunction
function nBo takes integer rei,integer sei,integer nCo,string nDo returns integer
local integer nFo
set ZM[EM]=nDo
set EM=EM+1
set nFo=p0v(SSv(oVe(PCv(M7v(nCo,0,"when calling get in ScmdUnitBuiltins, line 353"),"when calling getInner in ScmdUnitBuiltins, line 353"),QNv(M7v(nCo,1,"when calling get in ScmdUnitBuiltins, line 353"),"when calling intValue in ScmdUnitBuiltins, line 353")),"when calling new_Integer in ScmdUnitBuiltins, line 353"),"when calling new_SharedPointer in ScmdUnitBuiltins, line 353")
set EM=EM-1
return nFo
endfunction
function ngo takes integer nho,integer nHo,real njo returns integer
return DSv(nho*(1.-njo)+nHo*njo)
endfunction
function nJo takes integer nko,integer nKo,integer nLo,integer nmo,integer nMo,integer nPo,real nQo returns integer
set a3=ngo(nko,nmo,nQo)
set n3=ngo(nKo,nMo,nQo)
set d3=ngo(nLo,nPo,nQo)
return a3
endfunction
function nUo takes integer Bpt,integer nWo,integer nzo,string nZo returns integer
local integer n3o
local unit Vvo
local string Vxo
local string VVo
local integer VEo
set ZM[EM]=nZo
set EM=EM+1
set n3o=QGv(nWo,"when calling getPlayerId in SLangChatSystem, line 214")
set Vvo=Mov(nWo,"when calling getEnumUnit in SLangChatSystem, line 215")
if IsHeroUnitId(umv(Vvo))then
set VVo=Zev(Vvo)
else
set VVo=zAv(Vvo)
endif
set Vxo=VVo
call HFe(Ha,n3o,gye(nJo(g5e(g_e(sa[n3o])),b3,y3,g1e(dp,fp,Rp,Tp),e3,q3,.25),n3,d3)+Vxo+"|r "+gye(nJo(g1e(ep,qp,ap,np),e3,q3,g1e(dp,fp,Rp,Tp),e3,q3,.25),n3,d3)+Mqv(M7v(nzo,0,"when calling get in SLangChatSystem, line 217"),"when calling getInner in SLangChatSystem, line 217")+"|r",ta,"when calling send in SLangChatSystem, line 217")
set VEo=MLv("when calling nullptr in SLangChatSystem, line 218")
set EM=EM-1
set Vvo=null
return VEo
endfunction
function VXo takes integer rii,integer sii,integer VIo,string VAo returns integer
local integer VNo
set ZM[EM]=VAo
set EM=EM+1
call NQe(PCv(M7v(VIo,0,"when calling get in ScmdUnitBuiltins, line 76"),"when calling getInner in ScmdUnitBuiltins, line 76"),WCv(M7v(VIo,1,"when calling get in ScmdUnitBuiltins, line 76"),"when calling booleanValue in ScmdUnitBuiltins, line 76"))
set VNo=MLv("when calling nullptr in ScmdUnitBuiltins, line 77")
set EM=EM-1
return VNo
endfunction
function VBo takes integer VCo returns boolean
return cC[VCo]<oC[VCo]
endfunction
function VDo takes integer VFo,string Vgo returns boolean
local boolean VGo
set ZM[EM]=Vgo
set EM=EM+1
if pv[VFo]==0 then
if VFo==0 then
call Cdv("Nullpointer exception when calling StringIterator.hasNext","when calling error in String, line 223")
else
call Cdv("Called StringIterator.hasNext on invalid object.","when calling error in String, line 223")
endif
endif
set VGo=VBo(VFo)
set EM=EM-1
return VGo
endfunction
function Vho takes integer VHo returns string
local string Vjo=Psv(SC[VHo],cC[VHo],cC[VHo]+1)
set cC[VHo]=cC[VHo]+1
return Vjo
endfunction
function VJo takes integer Vko,string VKo returns string
local string VLo
set ZM[EM]=VKo
set EM=EM+1
if pv[Vko]==0 then
if Vko==0 then
call Cdv("Nullpointer exception when calling StringIterator.next","when calling error in String, line 226")
else
call Cdv("Called StringIterator.next on invalid object.","when calling error in String, line 226")
endif
endif
set VLo=Vho(Vko)
set EM=EM-1
return VLo
endfunction
function Vmo takes string VMo returns integer
local integer VPo
set ZM[EM]=VMo
set EM=EM+1
if bv==0 then
if yv<$8000 then
set yv=yv+1
set VPo=yv
set pv[VPo]=4816
else
call Cdv("Out of memory: Could not create StringIterator.","when calling error in String, line 213")
set VPo=0
endif
else
set bv=bv-1
set VPo=lv[bv]
set pv[VPo]=4816
endif
set EM=EM-1
return VPo
endfunction
function VQo takes integer YNi returns nothing
endfunction
function VUo takes integer VWo,string Vzo,integer VZo,integer V3o returns nothing
call VQo(VWo)
set SC[VWo]=Vzo
set cC[VWo]=VZo
set oC[VWo]=V3o
endfunction
function Evo takes string Exo,integer EVo,integer EEo,string EXo returns integer
local integer EIo
set ZM[EM]=EXo
set EM=EM+1
set EIo=Vmo("when calling alloc_StringIterator in String, line 218")
call VUo(EIo,Exo,EVo,EEo)
set EM=EM-1
return EIo
endfunction
function EAo takes string ENo,string EBo returns integer
local integer ECo
set ZM[EM]=EBo
set EM=EM+1
set ECo=Evo(ENo,0,GZv(ENo),"when calling new_StringIterator in String, line 211")
set EM=EM-1
return ECo
endfunction
function EDo takes integer EFo returns string
return JT[EFo]
endfunction
function Ego takes integer Eho returns boolean
return Eho>=$80 and Eho<$C0
endfunction
function EHo takes integer Ejo,string EJo returns nothing
set ZM[EM]=EJo
set EM=EM+1
if pv[Ejo]==0 then
call Cdv("Double free: object of type StringIterator","when calling error in String, line 213")
else
set lv[bv]=Ejo
set bv=bv+1
set pv[Ejo]=0
endif
set EM=EM-1
endfunction
function Eko takes integer xNi returns nothing
endfunction
function EKo takes integer ELo,string Emo returns nothing
set ZM[EM]=Emo
set EM=EM+1
call Eko(ELo)
call EHo(ELo,"when calling dealloc_StringIterator in String, line 213")
set EM=EM-1
endfunction
function EMo takes integer EPo,string EQo returns nothing
set ZM[EM]=EQo
set EM=EM+1
if pv[EPo]==0 then
if EPo==0 then
call Cdv("Nullpointer exception when calling StringIterator.StringIterator","when calling error in String, line 213")
else
call Cdv("Called StringIterator.StringIterator on invalid object.","when calling error in String, line 213")
endif
endif
call EKo(EPo,"when calling destroyStringIterator in String, line 213")
set EM=EM-1
endfunction
function EUo takes integer EWo,string Ezo returns nothing
set ZM[EM]=Ezo
set EM=EM+1
call EMo(EWo,"when calling dispatch_StringIterator_destroyStringIterator in String, line 232")
set EM=EM-1
endfunction
function EZo takes integer E3o,string Xvo returns nothing
set ZM[EM]=Xvo
set EM=EM+1
if pv[E3o]==0 then
if E3o==0 then
call Cdv("Nullpointer exception when calling StringIterator.close","when calling error in String, line 231")
else
call Cdv("Called StringIterator.close on invalid object.","when calling error in String, line 231")
endif
endif
call EUo(E3o,"when calling close in String, line 231")
set EM=EM-1
endfunction
function Xxo takes string XVo,integer XEo,string XXo returns integer
local string XIo
local integer XAo
set ZM[EM]=XXo
set EM=EM+1
set XIo=duv(XVo,XEo)
set XAo=0
loop
exitwhen XAo>$FF
if XIo==JT[XAo]then
set EM=EM-1
set q9=XAo
return q9
endif
set XAo=XAo+1
endloop
call Cdv("Invalid utf-8 code unit in string \""+XVo+"\" at index "+SMv(XEo),"when calling error in Utf8CodeUnit, line 38")
set EM=EM-1
set q9=-1
return q9
endfunction
function XNo takes integer VFt,integer BFt,integer XBo,string XCo returns integer
local string XDo
local integer XFo
local string Xgo
local string XGo
local integer Xho
local integer XHo
local integer Xjo
set ZM[EM]=XCo
set EM=EM+1
set XDo=Mqv(M7v(XBo,0,"when calling get in ScmdCoreBuiltins, line 135"),"when calling getInner in ScmdCoreBuiltins, line 135")
set XFo=EAo(XDo,"when calling iterator in ScmdCoreBuiltins, line 136")
set Xgo=""
set XGo=""
loop
exitwhen not VDo(XFo,"when calling hasNext in ScmdCoreBuiltins, line 139")
set Xjo=Xxo(VJo(XFo,"when calling next in ScmdCoreBuiltins, line 140"),0,"when calling utf8CodeUnitAt in ScmdCoreBuiltins, line 140")
set Xho=Xjo
if not Ego(Xho)then
set Xgo=XGo+Xgo
set XGo=""
endif
set XGo=XGo+EDo(Xho)
endloop
set Xgo=XGo+Xgo
call EZo(XFo,"when calling close in ScmdCoreBuiltins, line 146")
set XHo=p0v(Ppv(Xgo,"when calling new_String in ScmdCoreBuiltins, line 147"),"when calling new_SharedPointer in ScmdCoreBuiltins, line 147")
set EM=EM-1
return XHo
endfunction
function XJo takes integer rmi,integer smi,integer Xko,string XKo returns integer
local integer XLo
set ZM[EM]=XKo
set EM=EM+1
call U2v(PCv(M7v(Xko,0,"when calling get in SotFRP_AbilitySystem, line 69"),"when calling getInner in SotFRP_AbilitySystem, line 69"),Mqv(M7v(Xko,1,"when calling get in SotFRP_AbilitySystem, line 69"),"when calling getInner in SotFRP_AbilitySystem, line 69"),QNv(M7v(Xko,2,"when calling get in SotFRP_AbilitySystem, line 69"),"when calling intValue in SotFRP_AbilitySystem, line 69"),"when calling setAbilityLevel in SotFRP_AbilitySystem, line 69")
set XLo=MLv("when calling nullptr in SotFRP_AbilitySystem, line 70")
set EM=EM-1
return XLo
endfunction
function Xmo takes integer rsi,integer ssi,integer XMo,string XPo returns integer
local integer XQo
set ZM[EM]=XPo
set EM=EM+1
call StopMusic(WCv(M7v(XMo,0,"when calling get in ScmdSoundFunctions, line 23"),"when calling booleanValue in ScmdSoundFunctions, line 23"))
set XQo=MLv("when calling nullptr in ScmdSoundFunctions, line 24")
set EM=EM-1
return XQo
endfunction
function XUo takes integer ryi,integer XWo,integer Xzo,string XZo returns integer
local integer X3o
set ZM[EM]=XZo
set EM=EM+1
call SetWidgetLife(Mov(XWo,"when calling getEnumUnit in ScmdUnitBuiltins, line 295"),PEv(M7v(Xzo,0,"when calling get in ScmdUnitBuiltins, line 295"),"when calling realValue in ScmdUnitBuiltins, line 295"))
set X3o=MLv("when calling nullptr in ScmdUnitBuiltins, line 296")
set EM=EM-1
return X3o
endfunction
function Ovo takes effect Oxo,real OVo returns nothing
call BlzSetSpecialEffectRoll(Oxo,OVo)
endfunction
function OEo takes integer pRt,integer eRt,integer OXo,string OIo returns integer
local integer OAo
set ZM[EM]=OIo
set EM=EM+1
call Ovo(Pov(M7v(OXo,0,"when calling get in SLangSpecialEffectFunctions, line 56"),"when calling getInner in SLangSpecialEffectFunctions, line 56"),PEv(M7v(OXo,1,"when calling get in SLangSpecialEffectFunctions, line 56"),"when calling realValue in SLangSpecialEffectFunctions, line 56"))
set OAo=MLv("when calling nullptr in SLangSpecialEffectFunctions, line 57")
set EM=EM-1
return OAo
endfunction
function ONo takes integer pYt,integer OBo,integer qYt,string OCo returns integer
local integer ODo
set ZM[EM]=OCo
set EM=EM+1
set ODo=p0v(lte(Pbe(OBo,"when calling getManipulatedItem in SLangTriggerFunctions, line 115"),"when calling new_Item in SLangTriggerFunctions, line 115"),"when calling new_SharedPointer in SLangTriggerFunctions, line 115")
set EM=EM-1
return ODo
endfunction
function OFo takes nothing returns integer
return cd
endfunction
function Ogo takes string Oho returns integer
local integer OHo
set ZM[EM]=Oho
set EM=EM+1
if ex==0 then
if qx<$8000 then
set qx=qx+1
set OHo=qx
set ax[OHo]=$44B
else
call Cdv("Out of memory: Could not create BuiltinData.","when calling error in ScmdDataTypes, line 1376")
set OHo=0
endif
else
set ex=ex-1
set OHo=px[ex]
set ax[OHo]=$44B
endif
set EM=EM-1
return OHo
endfunction
function Ojo takes integer OJo,string Oko returns nothing
set ZM[EM]=Oko
set EM=EM+1
set jJ[OJo]=yTv("when calling new_LinkedList in ScmdDataTypes, line 1379")
set EM=EM-1
endfunction
function OKo takes integer OLo,integer Omo,string OMo returns nothing
set ZM[EM]=OMo
set EM=EM+1
call Ojo(OLo,"when calling BuiltinData_init in ScmdDataTypes, line 1385")
set kJ[OLo]=Omo
set xJ[OLo]=0
set vJ[OLo]=false
set mJ[OLo]=false
set EM=EM-1
endfunction
function OPo takes integer OQo,string OUo returns integer
local integer OWo
set ZM[EM]=OUo
set EM=EM+1
set OWo=Ogo("when calling alloc_BuiltinData in ScmdDataTypes, line 1385")
call OKo(OWo,OQo,"when calling construct_BuiltinData in ScmdDataTypes, line 1385")
set EM=EM-1
return OWo
endfunction
function Ozo takes integer OZo,integer O3o,string Rvo returns nothing
set ZM[EM]=Rvo
set EM=EM+1
set xJ[OZo]=0
call zGv(jJ[OZo],O3o,"when calling add in ScmdDataTypes, line 1394")
set xJ[OZo]=xJ[OZo]+1
set EM=EM-1
endfunction
function Rxo takes integer RVo,integer REo,string RXo returns nothing
set ZM[EM]=RXo
set EM=EM+1
if ax[RVo]==0 then
if RVo==0 then
call Cdv("Nullpointer exception when calling BuiltinData.setArgumentsTypes","when calling error in ScmdDataTypes, line 1391")
else
call Cdv("Called BuiltinData.setArgumentsTypes on invalid object.","when calling error in ScmdDataTypes, line 1391")
endif
endif
call Ozo(RVo,REo,"when calling setArgumentsTypes in ScmdDataTypes, line 1391")
set EM=EM-1
endfunction
function RIo takes string RAo returns integer
local integer RNo
set ZM[EM]=RAo
set EM=EM+1
if Sx==0 then
if cx<$8000 then
set cx=cx+1
set RNo=cx
set ox[RNo]=$EEC
else
call Cdv("Out of memory: Could not create BuiltinFunction.","when calling error in ScmdDataTypes, line 1514")
set RNo=0
endif
else
set Sx=Sx-1
set RNo=ix[Sx]
set ox[RNo]=$EEC
endif
set EM=EM-1
return RNo
endfunction
function RBo takes integer ILt returns nothing
endfunction
function RCo takes integer RDo returns nothing
call RBo(RDo)
endfunction
function RFo takes integer Rgo,string Rho returns nothing
set ZM[EM]=Rho
set EM=EM+1
set WJ[Rgo]=TEv("when calling new_HashList in ScmdDataTypes, line 1429")
set EJ[Rgo]=0
set EM=EM-1
endfunction
function RHo takes integer Rjo,string RJo returns nothing
set ZM[EM]=RJo
set EM=EM+1
call RFo(Rjo,"when calling construct_BuiltinFunction_BuiltinModule in ScmdDataTypes, line 1428")
set EM=EM-1
endfunction
function Rko takes integer RKo,integer RLo,string Rmo returns nothing
set ZM[EM]=Rmo
set EM=EM+1
call Cxv(de,RKo,RLo,div(RKo,RLo,"when calling count in HashList, line 22")-1)
set EM=EM-1
endfunction
function RMo takes integer RPo,integer RQo,string RUo returns nothing
set ZM[EM]=RUo
set EM=EM+1
if Oh[RPo]==0 then
if RPo==0 then
call Cdv("Nullpointer exception when calling HashList.decrOccurences","when calling error in HashList, line 21")
else
call Cdv("Called HashList.decrOccurences on invalid object.","when calling error in HashList, line 21")
endif
endif
call Rko(RPo,RQo,"when calling decrOccurences in HashList, line 21")
set EM=EM-1
endfunction
function RWo takes integer Rzo,integer RZo,integer R3o,string Ivo returns nothing
set ZM[EM]=Ivo
set EM=EM+1
call RMo(Rzo,jqv(Rzo,RZo,"when calling get in HashList, line 33"),"when calling decrOccurences in HashList, line 33")
call Cxv(ne,Rzo,RZo,R3o)
call dAv(Rzo,R3o,"when calling incrOccurences in HashList, line 35")
set EM=EM-1
endfunction
function Ixo takes integer IVo,integer IEo,integer IXo,string IIo returns nothing
set ZM[EM]=IIo
set EM=EM+1
if Oh[IVo]==0 then
if IVo==0 then
call Cdv("Nullpointer exception when calling HashList.set","when calling error in HashList, line 32")
else
call Cdv("Called HashList.set on invalid object.","when calling error in HashList, line 32")
endif
endif
call RWo(IVo,IEo,IXo,"when calling set in HashList, line 32")
set EM=EM-1
endfunction
function IAo takes integer INo,integer IBo,string ICo returns nothing
local integer IDo
set ZM[EM]=ICo
set EM=EM+1
if vJ[IBo]then
if EJ[INo]!=0 then
call JDv(EJ[INo],"when calling dispatch_BuiltinData_destroyBuiltinData in ScmdDataTypes, line 1435")
endif
set EJ[INo]=IBo
else
call dlv(WJ[INo],0,"when calling add in ScmdDataTypes, line 1438")
set IDo=dgv(WJ[INo],"when calling size in ScmdDataTypes, line 1439")-2
loop
exitwhen not(IDo>=0 and xJ[IBo]<xJ[jqv(WJ[INo],IDo,"when calling get in ScmdDataTypes, line 1440")])
call Ixo(WJ[INo],IDo+1,jqv(WJ[INo],IDo,"when calling get in ScmdDataTypes, line 1441"),"when calling set in ScmdDataTypes, line 1441")
set IDo=IDo-1
endloop
call Ixo(WJ[INo],IDo+1,IBo,"when calling set in ScmdDataTypes, line 1443")
endif
set EM=EM-1
endfunction
function IFo takes integer Igo,integer Iho,string IHo returns nothing
set ZM[EM]=IHo
set EM=EM+1
if ox[Igo]==0 then
if Igo==0 then
call Cdv("Nullpointer exception when calling BuiltinFunction.addOverload","when calling error in ScmdDataTypes, line 1432")
else
call Cdv("Called BuiltinFunction.addOverload on invalid object.","when calling error in ScmdDataTypes, line 1432")
endif
endif
call IAo(Igo,Iho,"when calling addOverload in ScmdDataTypes, line 1432")
set EM=EM-1
endfunction
function Ijo takes integer IJo,integer Iko,string IKo returns nothing
set ZM[EM]=IKo
set EM=EM+1
call RCo(IJo)
call RHo(IJo,"when calling BuiltinFunction_init in ScmdDataTypes, line 1520")
call IFo(IJo,Iko,"when calling addOverload in ScmdDataTypes, line 1521")
set EM=EM-1
endfunction
function ILo takes integer Imo,string IMo returns integer
local integer IPo
set ZM[EM]=IMo
set EM=EM+1
set IPo=RIo("when calling alloc_BuiltinFunction in ScmdDataTypes, line 1520")
call Ijo(IPo,Imo,"when calling construct_BuiltinFunction in ScmdDataTypes, line 1520")
set EM=EM-1
return IPo
endfunction
function IQo takes string IUo returns integer
local integer IWo
set ZM[EM]=IUo
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set IWo=Yj
set Gj[IWo]=$AA7
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_assign_setArgumentsTypes_registerBuiltin_SLangChatSystem.","when calling error in SLangChatSystem, line 222")
set IWo=0
endif
else
set Tj=Tj-1
set IWo=Rj[Tj]
set Gj[IWo]=$AA7
endif
set EM=EM-1
return IWo
endfunction
function Izo takes integer oet,integer IZo,integer I3o,string Avo returns integer
local string Axo
local integer AVo
local integer AEo
local integer AXo
local integer AIo
local string AAo
set ZM[EM]=Avo
set EM=EM+1
set Axo=Mqv(M7v(I3o,1,"when calling get in SLangChatSystem, line 221"),"when calling getInner in SLangChatSystem, line 221")
set AIo=QGv(IZo,"when calling getPlayerId in SLangChatSystem, line 222")
set AAo=Mqv(M7v(I3o,0,"when calling get in SLangChatSystem, line 222"),"when calling getInner in SLangChatSystem, line 222")
set AVo=IQo("when calling alloc_IBuiltin_setArgumentsTypes_assign_setArgumentsTypes_registerBuiltin_SLangChatSystem in SLangChatSystem, line 222")
set uJ[AVo]=Axo
set AEo=OPo(AVo,"when calling new_BuiltinData in SLangChatSystem, line 222")
call Rxo(AEo,OFo(),"when calling setArgumentsTypes in SLangChatSystem, line 225")
set AXo=p0v(qRv(CIe(AIo,AAo,p0v(ILo(AEo,"when calling new_BuiltinFunction in SLangChatSystem, line 222"),"when calling new_SharedPointer in SLangChatSystem, line 222"),"when calling assign in SLangChatSystem, line 222"),"when calling new_Boolean in SLangChatSystem, line 222"),"when calling new_SharedPointer in SLangChatSystem, line 222")
set EM=EM-1
return AXo
endfunction
function ANo takes unit ABo,string ACo returns boolean
return IssueImmediateOrder(ABo,ACo)
endfunction
function ADo takes integer phi,integer AFo,integer Ago,string AGo returns integer
local integer Aho
set ZM[EM]=AGo
set EM=EM+1
set Aho=p0v(qRv(ANo(Mov(AFo,"when calling getEnumUnit in ScmdUnitBuiltins, line 771"),Mqv(M7v(Ago,0,"when calling get in ScmdUnitBuiltins, line 771"),"when calling getInner in ScmdUnitBuiltins, line 771")),"when calling new_Boolean in ScmdUnitBuiltins, line 771"),"when calling new_SharedPointer in ScmdUnitBuiltins, line 771")
set EM=EM-1
return Aho
endfunction
function AHo takes string Ajo returns integer
local integer AJo
set ZM[EM]=Ajo
set EM=EM+1
set AJo=p0v(tJv("Unknown camera setting","when calling new_Exception in ScmdPlayerCameraSettingsBuiltins, line 46"),"when calling new_SharedPointer in ScmdPlayerCameraSettingsBuiltins, line 46")
set EM=EM-1
return AJo
endfunction
function Ako takes camerafield AKo returns integer
return C0v(AKo)
endfunction
function ALo takes real Amo returns integer
return c6v(Amo*TT)
endfunction
function AMo takes integer APo,camerafield AQo,real AUo,string AWo returns nothing
set ZM[EM]=AWo
set EM=EM+1
call WTv(hd[APo],Ako(AQo),ALo(AUo),"when calling put in ScmdPlayerCameraSettingsBuiltins, line 20")
if ta==sa[APo]then
call SetCameraField(AQo,AUo,.0)
endif
set EM=EM-1
endfunction
function Azo takes integer AZo,string A3o returns nothing
set ZM[EM]=A3o
set EM=EM+1
if ph[AZo]==0 then
if AZo==0 then
call Cdv("Nullpointer exception when calling IterableMap.flush","when calling error in HashMap, line 71")
else
call Cdv("Called IterableMap.flush on invalid object.","when calling error in HashMap, line 71")
endif
endif
call lDv(AZo,"when calling flush in HashMap, line 71")
set EM=EM-1
endfunction
function Nvo takes integer Nxo,string NVo returns nothing
set ZM[EM]=NVo
set EM=EM+1
call Azo(hd[Nxo],"when calling flush in ScmdPlayerCameraSettingsBuiltins, line 31")
call AMo(Nxo,CAMERA_FIELD_FARZ,Fa,"when calling setCameraField in ScmdPlayerCameraSettingsBuiltins, line 32")
if ta==sa[Nxo]then
call ResetToGameCamera(.0)
call SetCameraField(CAMERA_FIELD_FARZ,Fa,.0)
endif
set EM=EM-1
endfunction
function NEo takes integer bui,integer NXo,integer NIo,string NAo returns integer
local string NNo
local integer NBo
local integer NCo
set ZM[EM]=NAo
set EM=EM+1
set NNo=Mqv(M7v(NIo,0,"when calling get in ScmdPlayerCameraSettingsBuiltins, line 74"),"when calling getInner in ScmdPlayerCameraSettingsBuiltins, line 74")
if NNo=="reset" then
call Nvo(QGv(NXo,"when calling getPlayerId in ScmdPlayerCameraSettingsBuiltins, line 76"),"when calling resetCamera in ScmdPlayerCameraSettingsBuiltins, line 76")
endif
if NNo!="reset" then
set NBo=AHo("when calling makeUnknownCameraSettingException in ScmdPlayerCameraSettingsBuiltins, line 77")
else
set NBo=MLv("when calling nullptr in ScmdPlayerCameraSettingsBuiltins, line 77")
endif
set NCo=NBo
set EM=EM-1
return NCo
endfunction
function NDo takes integer FUt returns nothing
endfunction
function NFo takes integer Ngo,boolean NGo,string Nho returns nothing
call Pkv(Ngo,Nho)
call qxv(Ngo)
set hJ[Ngo]=NGo
endfunction
function NHo takes integer Njo,boolean NJo,string Nko,string NKo returns nothing
call NFo(Njo,NJo,Nko)
call NDo(Njo)
set FJ[Njo]=NKo
endfunction
function NLo takes string Nmo returns integer
local integer NMo
set ZM[EM]=Nmo
set EM=EM+1
if Sx==0 then
if cx<$8000 then
set cx=cx+1
set NMo=cx
set ox[NMo]=$EFC
else
call Cdv("Out of memory: Could not create LiteralBoolean.","when calling error in ScmdDataTypes, line 369")
set NMo=0
endif
else
set Sx=Sx-1
set NMo=ix[Sx]
set ox[NMo]=$EFC
endif
set EM=EM-1
return NMo
endfunction
function NPo takes boolean NQo,string NUo,string NWo,string Nzo returns integer
local integer NZo
set ZM[EM]=Nzo
set EM=EM+1
set NZo=NLo("when calling alloc_LiteralBoolean in ScmdDataTypes, line 373")
call NHo(NZo,NQo,NUo,NWo)
set EM=EM-1
return NZo
endfunction
function N3o takes string bvo,string bxo,string bVo returns integer
local integer bEo
set ZM[EM]=bVo
set EM=EM+1
set bEo=NPo(tYv(bvo)=="true",bvo,bxo,"when calling new_LiteralBoolean in ScmdDataTypes, line 393")
set EM=EM-1
return bEo
endfunction
function bXo takes integer uMt returns nothing
endfunction
function bIo takes integer bAo,real bNo,string bBo,string bCo returns nothing
call SKv(bAo,bNo,bBo)
call bXo(bAo)
set pK[bAo]=bCo
endfunction
function bDo takes string bFo returns integer
local integer bgo
set ZM[EM]=bFo
set EM=EM+1
if Sx==0 then
if cx<$8000 then
set cx=cx+1
set bgo=cx
set ox[bgo]=$EFE
else
call Cdv("Out of memory: Could not create LiteralReal.","when calling error in ScmdDataTypes, line 438")
set bgo=0
endif
else
set Sx=Sx-1
set bgo=ix[Sx]
set ox[bgo]=$EFE
endif
set EM=EM-1
return bgo
endfunction
function bho takes real bHo,string bjo,string bJo,string bko returns integer
local integer bKo
set ZM[EM]=bko
set EM=EM+1
set bKo=bDo("when calling alloc_LiteralReal in ScmdDataTypes, line 442")
call bIo(bKo,bHo,bjo,bJo)
set EM=EM-1
return bKo
endfunction
function bLo takes string bmo,string bMo,string bPo returns integer
local integer bQo
set ZM[EM]=bPo
set EM=EM+1
set bQo=bho(d7v(bmo),bmo,bMo,"when calling new_LiteralReal in ScmdDataTypes, line 462")
set EM=EM-1
return bQo
endfunction
function bUo takes string bWo returns boolean
return bWo=="0" or bWo=="1" or bWo=="2" or bWo=="3" or bWo=="4" or bWo=="5" or bWo=="6" or bWo=="7" or bWo=="8" or bWo=="9"
endfunction
function bzo takes string bZo returns integer
local integer b3o
set ZM[EM]=bZo
set EM=EM+1
if Sx==0 then
if cx<$8000 then
set cx=cx+1
set b3o=cx
set ox[b3o]=$EFF
else
call Cdv("Out of memory: Could not create LiteralString.","when calling error in ScmdDataTypes, line 311")
set b3o=0
endif
else
set Sx=Sx-1
set b3o=ix[Sx]
set ox[b3o]=$EFF
endif
set EM=EM-1
return b3o
endfunction
function Bvo takes integer l2t returns nothing
endfunction
function Bxo takes integer BVo,string BEo,string BXo returns nothing
call Pkv(BVo,BEo)
call Bvo(BVo)
set gK[BVo]=BXo
endfunction
function BIo takes string BAo,string BNo,string BBo returns integer
local integer BCo
set ZM[EM]=BBo
set EM=EM+1
set BCo=bzo("when calling alloc_LiteralString in ScmdDataTypes, line 315")
call Bxo(BCo,BAo,BNo)
set EM=EM-1
return BCo
endfunction
function BDo takes string BFo,string Bgo,string BGo returns integer
local integer Bho
set ZM[EM]=BGo
set EM=EM+1
set Bho=BIo(BFo,Bgo,"when calling new_LiteralString in ScmdDataTypes, line 335")
set EM=EM-1
return Bho
endfunction
function BHo takes string Bjo returns integer
local integer BJo
set ZM[EM]=Bjo
set EM=EM+1
if Sx==0 then
if cx<$8000 then
set cx=cx+1
set BJo=cx
set ox[BJo]=$EFD
else
call Cdv("Out of memory: Could not create LiteralInteger.","when calling error in ScmdDataTypes, line 493")
set BJo=0
endif
else
set Sx=Sx-1
set BJo=ix[Sx]
set ox[BJo]=$EFD
endif
set EM=EM-1
return BJo
endfunction
function Bko takes integer IVt returns nothing
endfunction
function BKo takes integer BLo,integer Bmo,string BMo returns nothing
call SKv(BLo,DQv(Bmo),BMo)
call SPv(BLo)
set OK[BLo]=Bmo
endfunction
function BPo takes integer BQo,integer BUo,string BWo,string Bzo returns nothing
call BKo(BQo,BUo,BWo)
call Bko(BQo)
set lK[BQo]=Bzo
endfunction
function BZo takes integer B3o,string cvo,string cxo,string cVo returns integer
local integer cEo
set ZM[EM]=cVo
set EM=EM+1
set cEo=BHo("when calling alloc_LiteralInteger in ScmdDataTypes, line 497")
call BPo(cEo,B3o,cvo,cxo)
set EM=EM-1
return cEo
endfunction
function cXo takes string cIo,string cAo,string cNo returns integer
local integer cBo
set ZM[EM]=cNo
set EM=EM+1
set cBo=BZo(uqv(cIo),cIo,cAo,"when calling new_LiteralInteger in ScmdDataTypes, line 517")
set EM=EM-1
return cBo
endfunction
function cCo takes string cDo,string cFo,string cgo returns integer
local integer cho
local integer cHo
local integer cjo
local string cJo
local boolean cko
local integer cKo
local integer cLo
local integer cmo
local integer cMo
set ZM[EM]=cgo
set EM=EM+1
if tYv(cDo)=="true" or tYv(cDo)=="false" then
set cLo=N3o(cDo,cFo,"when calling forLiteral in ScmdDataTypes, line 540")
set EM=EM-1
return cLo
endif
set cho=GZv(cDo)
if duv(cDo,0)=="+" or duv(cDo,0)=="-" then
set cjo=1
else
set cjo=0
endif
set cHo=cjo
set cJo=duv(cDo,cHo)
if bUo(cJo)then
set cko=false
loop
exitwhen not(cHo<cho and bUo(cJo)or(cJo=="." and(not cko)))
if cJo=="." then
set cko=true
endif
set cHo=cHo+1
set cJo=duv(cDo,cHo)
endloop
if cHo==cho then
if cko then
set cKo=bLo(cDo,cFo,"when calling forLiteral in ScmdDataTypes, line 552")
else
set cKo=cXo(cDo,cFo,"when calling forLiteral in ScmdDataTypes, line 552")
endif
set cmo=cKo
set EM=EM-1
return cmo
endif
endif
set cMo=BDo(cDo,cFo,"when calling forLiteral in ScmdDataTypes, line 553")
set EM=EM-1
return cMo
endfunction
function cPo takes integer cQt,integer oQt,integer cQo,string cUo returns integer
local real cWo
local real czo
local integer cZo
set ZM[EM]=cUo
set EM=EM+1
set cWo=PEv(M7v(cQo,0,"when calling get in ScmdCoreBuiltins, line 299"),"when calling realValue in ScmdCoreBuiltins, line 299")
if cWo>.0 then
set czo=GetRandomReal(.0,cWo)
else
set czo=GetRandomReal(cWo,.0)
endif
set cZo=p0v(q2v(czo,"when calling new_Real in ScmdCoreBuiltins, line 300"),"when calling new_SharedPointer in ScmdCoreBuiltins, line 300")
set EM=EM-1
return cZo
endfunction
function c3o takes integer OTi,integer lTi,integer Cvo,string Cxo returns integer
local integer CVo
set ZM[EM]=Cxo
set EM=EM+1
call RWe(PCv(M7v(Cvo,0,"when calling get in ScmdUnitBuiltins, line 654"),"when calling getInner in ScmdUnitBuiltins, line 654"),dve(PEv(M7v(Cvo,1,"when calling get in ScmdUnitBuiltins, line 654"),"when calling realValue in ScmdUnitBuiltins, line 654"),XT,LT))
set CVo=MLv("when calling nullptr in ScmdUnitBuiltins, line 655")
set EM=EM-1
return CVo
endfunction
function CEo takes integer Ofi,integer CXo,integer CIo,string CAo returns integer
local integer CNo
set ZM[EM]=CAo
set EM=EM+1
call QMe(Mov(CXo,"when calling getEnumUnit in ScmdUnitBuiltins, line 585"),QNv(M7v(CIo,0,"when calling get in ScmdUnitBuiltins, line 585"),"when calling intValue in ScmdUnitBuiltins, line 585"))
set CNo=MLv("when calling nullptr in ScmdUnitBuiltins, line 586")
set EM=EM-1
return CNo
endfunction
function CBo takes effect CCo,real CDo returns nothing
call BlzSetSpecialEffectX(CCo,CDo)
endfunction
function CFo takes integer Oft,integer lft,integer Cgo,string CGo returns integer
local integer Cho
set ZM[EM]=CGo
set EM=EM+1
call CBo(Pov(M7v(Cgo,0,"when calling get in SLangSpecialEffectFunctions, line 19"),"when calling getInner in SLangSpecialEffectFunctions, line 19"),PEv(M7v(Cgo,1,"when calling get in SLangSpecialEffectFunctions, line 19"),"when calling realValue in SLangSpecialEffectFunctions, line 19"))
set Cho=MLv("when calling nullptr in SLangSpecialEffectFunctions, line 20")
set EM=EM-1
return Cho
endfunction
function CHo takes integer eai,integer Cjo,integer CJo,string Cko returns integer
local integer CKo
set ZM[EM]=Cko
set EM=EM+1
set CKo=p0v(q2v(oAe(Mov(Cjo,"when calling getEnumUnit in ScmdUnitBuiltins, line 413"),QNv(M7v(CJo,0,"when calling get in ScmdUnitBuiltins, line 413"),"when calling intValue in ScmdUnitBuiltins, line 413")),"when calling new_Real in ScmdUnitBuiltins, line 413"),"when calling new_SharedPointer in ScmdUnitBuiltins, line 413")
set EM=EM-1
return CKo
endfunction
function CLo takes integer eei,integer qei,integer Cmo,string CMo returns integer
local integer CPo
set ZM[EM]=CMo
set EM=EM+1
call N2e(PCv(M7v(Cmo,0,"when calling get in ScmdUnitBuiltins, line 359"),"when calling getInner in ScmdUnitBuiltins, line 359"),QNv(M7v(Cmo,1,"when calling get in ScmdUnitBuiltins, line 359"),"when calling intValue in ScmdUnitBuiltins, line 359"),QNv(M7v(Cmo,2,"when calling get in ScmdUnitBuiltins, line 359"),"when calling intValue in ScmdUnitBuiltins, line 359"))
set CPo=MLv("when calling nullptr in ScmdUnitBuiltins, line 360")
set EM=EM-1
return CPo
endfunction
function CQo takes integer eii,integer qii,integer CUo,string CWo returns integer
local integer Czo
set ZM[EM]=CWo
set EM=EM+1
call Age(PCv(M7v(CUo,0,"when calling get in ScmdUnitBuiltins, line 83"),"when calling getInner in ScmdUnitBuiltins, line 83"),vde(PEv(M7v(CUo,1,"when calling get in ScmdUnitBuiltins, line 83"),"when calling realValue in ScmdUnitBuiltins, line 83")))
set Czo=MLv("when calling nullptr in ScmdUnitBuiltins, line 84")
set EM=EM-1
return Czo
endfunction
function CZo takes unit C3o,string dvo,integer dxo,integer dVo,string dEo returns nothing
local integer dXo
local integer dIo
local integer dAo
set ZM[EM]=dEo
set EM=EM+1
set dXo=THv(dvo,"when calling getAbilityIdByName in SotFRP_AbilitySystem, line 33")
set dIo=jdv(dXo,"when calling iterator in SotFRP_AbilitySystem, line 34")
loop
exitwhen not Jgv(dIo,"when calling hasNext in SotFRP_AbilitySystem, line 34")
set dAo=jTv(dIo,"when calling next in SotFRP_AbilitySystem, line 34")
call BlzSetUnitAbilityManaCost(C3o,dAo,dxo,dVo)
endloop
call Jqv(dIo,"when calling close in SotFRP_AbilitySystem, line 34")
call JEv(dXo,"when calling dispatch_HashList_destroyHashList in SotFRP_AbilitySystem, line 36")
set EM=EM-1
endfunction
function dNo takes integer emi,integer qmi,integer dBo,string dCo returns integer
local integer dDo
set ZM[EM]=dCo
set EM=EM+1
call CZo(PCv(M7v(dBo,0,"when calling get in SotFRP_AbilitySystem, line 76"),"when calling getInner in SotFRP_AbilitySystem, line 76"),Mqv(M7v(dBo,1,"when calling get in SotFRP_AbilitySystem, line 76"),"when calling getInner in SotFRP_AbilitySystem, line 76"),QNv(M7v(dBo,2,"when calling get in SotFRP_AbilitySystem, line 76"),"when calling intValue in SotFRP_AbilitySystem, line 76"),QNv(M7v(dBo,3,"when calling get in SotFRP_AbilitySystem, line 76"),"when calling intValue in SotFRP_AbilitySystem, line 76"),"when calling setAbilityManaCost in SotFRP_AbilitySystem, line 76")
set dDo=MLv("when calling nullptr in SotFRP_AbilitySystem, line 77")
set EM=EM-1
return dDo
endfunction
function dFo takes integer esi,integer qsi,integer dgo,string dho returns integer
local integer dHo
set ZM[EM]=dho
set EM=EM+1
set dHo=p0v(SSv(GetSoundFileDuration(Mqv(M7v(dgo,0,"when calling get in ScmdSoundFunctions, line 31"),"when calling getInner in ScmdSoundFunctions, line 31")),"when calling new_Integer in ScmdSoundFunctions, line 31"),"when calling new_SharedPointer in ScmdSoundFunctions, line 31")
set EM=EM-1
return dHo
endfunction
function djo takes integer eyi,integer dJo,integer ayi,string dko returns integer
local integer dKo
set ZM[EM]=dko
set EM=EM+1
set dKo=p0v(q2v(GetWidgetLife(Mov(dJo,"when calling getEnumUnit in ScmdUnitBuiltins, line 302")),"when calling new_Real in ScmdUnitBuiltins, line 302"),"when calling new_SharedPointer in ScmdUnitBuiltins, line 302")
set EM=EM-1
return dKo
endfunction
function dLo takes integer a9i,integer n9i,integer dmo,string dMo returns integer
local boolean dPo
local string dQo
local integer dUo
local integer dWo
set ZM[EM]=dMo
set EM=EM+1
set dPo=true
set dQo=Mqv(M7v(dmo,0,"when calling get in ScmdFogOfWarBuiltins, line 29"),"when calling getInner in ScmdFogOfWarBuiltins, line 29")
if dQo=="on" or dQo=="true" then
call FogMaskEnable(false)
call FogEnable(false)
elseif dQo=="off" or dQo=="false" then
call FogMaskEnable(true)
call FogEnable(true)
else
set dPo=false
endif
if dPo then
set dUo=MLv("when calling nullptr in ScmdFogOfWarBuiltins, line 38")
else
set dUo=B6e("Parameter should be \"on\" (\"true\") or \"off\" (\"false\")","when calling wrap in ScmdFogOfWarBuiltins, line 38")
endif
set dWo=dUo
set EM=EM-1
return dWo
endfunction
function dzo takes integer I7i,integer dZo returns boolean
return ox[dZo]==$F0D
endfunction
function d3o takes integer UCt,integer Dvo returns boolean
local integer Dxo=ox[Dvo]
return Dxo>=$EF5 and Dxo<=$EFA
endfunction
function DVo takes integer CMt,integer DEo returns boolean
return ox[DEo]==$F04
endfunction
function DXo takes integer KLt,integer DIo returns boolean
local integer DAo=ox[DIo]
return DAo==$EEC or(DAo>=$EEE and DAo<=$EEF)
endfunction
function DNo takes integer P6i,integer DBo returns boolean
return ox[DBo]==$F0C
endfunction
function DCo takes integer PDt,integer DDo returns boolean
return ox[DDo]==$EF2
endfunction
function DFo takes integer mEt,integer Dgo returns boolean
local integer DGo=ox[Dgo]
return(DGo>=$EEA and DGo<=$EEC)or(DGo>=$EEC and DGo<=$EEF)
endfunction
function Dho takes integer gEt,integer hEt returns boolean
return true
endfunction
function DHo takes integer ZPt,integer Djo returns boolean
return ox[Djo]==$EEC
endfunction
function DJo takes integer DBt,integer Dko returns boolean
return ox[Dko]==$F00
endfunction
function DKo takes integer D4t,integer DLo returns boolean
local integer Dmo=ox[DLo]
return(Dmo>=$EFC and Dmo<=$EFF)or(Dmo>=$F02 and Dmo<=$F03)or(Dmo>=$F08 and Dmo<=$F09)
endfunction
function DMo takes integer JEt,integer DPo returns boolean
return ox[DPo]==$EF6
endfunction
function DQo takes integer VJt,integer DUo returns boolean
return ox[DUo]==$EF8
endfunction
function DWo takes integer dBt,integer Dzo returns boolean
return ox[Dzo]==$EF9
endfunction
function DZo takes integer f3t,integer D3o returns boolean
return ox[D3o]==$F05
endfunction
function fvo takes integer W8i,integer fxo returns boolean
local integer fVo=ox[fxo]
return fVo>=$EF7 and fVo<=$EFA
endfunction
function fEo takes integer mLt,integer fXo returns boolean
return ox[fXo]==$EF3
endfunction
function fIo takes integer vNt,integer fAo returns boolean
local integer fNo=ox[fAo]
return(fNo>=$EFD and fNo<=$EFE)or(fNo>=$F02 and fNo<=$F03)
endfunction
function fBo takes integer K3t,integer fCo returns boolean
return ox[fCo]==$EEF
endfunction
function fDo takes integer iDt,integer fFo returns boolean
return ox[fFo]==$EED
endfunction
function fgo takes integer tUt,integer fho returns boolean
local integer fHo=ox[fho]
return fHo==$EFC or fHo==$F09
endfunction
function fjo takes integer qVt,integer fJo returns boolean
local integer fko=ox[fJo]
return fko==$EFD or fko==$F03
endfunction
function fKo takes integer y8i,integer fLo returns boolean
return ox[fLo]==$F0E
endfunction
function fmo takes integer nCt,integer fMo returns boolean
return ox[fMo]==$EF4
endfunction
function fPo takes integer G1t,integer fQo returns boolean
return ox[fQo]==$F06
endfunction
function fUo takes integer hKt,integer fWo returns boolean
local integer fzo=ox[fWo]
return fzo>=$EF1 and fzo<=$EF2
endfunction
function fZo takes integer p4t,integer f3o returns boolean
return ox[f3o]==$F07
endfunction
function Fvo takes integer p5i,integer Fxo returns boolean
return ox[Fxo]==$F0A
endfunction
function FVo takes integer p7i,integer FEo returns boolean
return ox[FEo]==$EFA
endfunction
function FXo takes integer kEt,integer FIo returns boolean
local integer FAo=ox[FIo]
return(FAo>=$EFD and FAo<=$EFE)or(FAo>=$F01 and FAo<=$F03)
endfunction
function FNo takes integer N5i,integer FBo returns boolean
return ox[FBo]==$F0B
endfunction
function FCo takes integer kDt,integer FDo returns boolean
return ox[FDo]==$EF0
endfunction
function FFo takes integer Fgo,integer Fho,string FHo returns boolean
local boolean Fjo
set ZM[EM]=FHo
set EM=EM+1
if tx[Fgo]==0 then
if Fgo==0 then
call Cdv("Nullpointer exception when calling IsInstanceChecker.isInstance","when calling error in ScmdDataTypes, line 21")
else
call Cdv("Called IsInstanceChecker.isInstance on invalid object.","when calling error in ScmdDataTypes, line 21")
endif
endif
if tx[Fgo]<=$C73 then
if tx[Fgo]<=$C6B then
if tx[Fgo]<=$C67 then
if tx[Fgo]<=$C65 then
if tx[Fgo]<=$C64 then
set Fjo=DMo(Fgo,Fho)
else
set Fjo=fgo(Fgo,Fho)
endif
elseif tx[Fgo]<=$C66 then
set Fjo=DHo(Fgo,Fho)
else
set Fjo=fDo(Fgo,Fho)
endif
elseif tx[Fgo]<=$C69 then
if tx[Fgo]<=$C68 then
set Fjo=FCo(Fgo,Fho)
else
set Fjo=DCo(Fgo,Fho)
endif
elseif tx[Fgo]<=$C6A then
set Fjo=DQo(Fgo,Fho)
else
set Fjo=fUo(Fgo,Fho)
endif
elseif tx[Fgo]<=$C6F then
if tx[Fgo]<=$C6D then
if tx[Fgo]<=$C6C then
set Fjo=fEo(Fgo,Fho)
else
set Fjo=DXo(Fgo,Fho)
endif
elseif tx[Fgo]<=$C6E then
set Fjo=fmo(Fgo,Fho)
else
set Fjo=d3o(Fgo,Fho)
endif
elseif tx[Fgo]<=$C71 then
if tx[Fgo]<=$C70 then
set Fjo=fjo(Fgo,Fho)
else
set Fjo=DWo(Fgo,Fho)
endif
elseif tx[Fgo]<=$C72 then
set Fjo=DJo(Fgo,Fho)
else
set Fjo=fIo(Fgo,Fho)
endif
elseif tx[Fgo]<=$C7B then
if tx[Fgo]<=$C77 then
if tx[Fgo]<=$C75 then
if tx[Fgo]<=$C74 then
set Fjo=DVo(Fgo,Fho)
else
set Fjo=DZo(Fgo,Fho)
endif
elseif tx[Fgo]<=$C76 then
set Fjo=fBo(Fgo,Fho)
else
set Fjo=Dho(Fgo,Fho)
endif
elseif tx[Fgo]<=$C79 then
if tx[Fgo]<=$C78 then
set Fjo=FXo(Fgo,Fho)
else
set Fjo=DFo(Fgo,Fho)
endif
elseif tx[Fgo]<=$C7A then
set Fjo=fPo(Fgo,Fho)
else
set Fjo=fZo(Fgo,Fho)
endif
elseif tx[Fgo]<=$C7F then
if tx[Fgo]<=$C7D then
if tx[Fgo]<=$C7C then
set Fjo=DKo(Fgo,Fho)
else
set Fjo=Fvo(Fgo,Fho)
endif
elseif tx[Fgo]<=$C7E then
set Fjo=FNo(Fgo,Fho)
else
set Fjo=DNo(Fgo,Fho)
endif
elseif tx[Fgo]<=$C81 then
if tx[Fgo]<=$C80 then
set Fjo=FVo(Fgo,Fho)
else
set Fjo=dzo(Fgo,Fho)
endif
elseif tx[Fgo]<=$C82 then
set Fjo=fKo(Fgo,Fho)
else
set Fjo=fvo(Fgo,Fho)
endif
set EM=EM-1
return Fjo
endfunction
function FJo takes integer Fko,integer FKo,string FLo returns boolean
local boolean Fmo
set ZM[EM]=FLo
set EM=EM+1
set Fmo=FFo(EK[Fko],FKo,"when calling isInstance in ScmdDataTypes, line 39")
set EM=EM-1
return Fmo
endfunction
function FMo takes integer FPo,integer FQo,string FUo returns boolean
local boolean FWo
set ZM[EM]=FUo
set EM=EM+1
if Qx[FPo]==0 then
if FPo==0 then
call Cdv("Nullpointer exception when calling GenericTypeToken.isInstance","when calling error in ScmdDataTypes, line 18")
else
call Cdv("Called GenericTypeToken.isInstance on invalid object.","when calling error in ScmdDataTypes, line 18")
endif
endif
set FWo=FJo(FPo,FQo,"when calling isInstance in ScmdDataTypes, line 18")
set EM=EM-1
return FWo
endfunction
function Fzo takes integer FZo,integer F3o,string gvo returns nothing
local integer gxo
local integer gVo
set ZM[EM]=gvo
set EM=EM+1
call RMo(FZo,c8v(ne,FZo,F3o),"when calling decrOccurences in HashList, line 54")
set gxo=F3o
set gVo=OU[FZo]
loop
exitwhen gxo>gVo
call Cxv(ne,FZo,gxo,c8v(ne,FZo,gxo+1))
set gxo=gxo+1
endloop
set OU[FZo]=OU[FZo]-1
set EM=EM-1
endfunction
function gEo takes integer gXo,integer gIo,string gAo returns nothing
local integer gNo
local integer gBo
set ZM[EM]=gAo
set EM=EM+1
call Mtv(fe,gXo,jqv(gXo,gIo,"when calling get in HashSet, line 22"))
set gNo=gIo+1
set gBo=dgv(gXo,"when calling size in HashSet, line 23")
loop
exitwhen gNo>gBo
call Cxv(fe,gXo,jqv(gXo,gNo,"when calling get in HashSet, line 24"),c8v(fe,gXo,jqv(gXo,gNo,"when calling get in HashSet, line 24"))-1)
set gNo=gNo+1
endloop
call Fzo(gXo,gIo,"when calling removeAt in HashSet, line 25")
set EM=EM-1
endfunction
function gCo takes integer gDo,integer gFo,string ggo returns nothing
set ZM[EM]=ggo
set EM=EM+1
if Oh[gDo]==0 then
if gDo==0 then
call Cdv("Nullpointer exception when calling HashList.removeAt","when calling error in HashList, line 53")
else
call Cdv("Called HashList.removeAt on invalid object.","when calling error in HashList, line 53")
endif
endif
if Oh[gDo]<=$966 then
call Fzo(gDo,gFo,"when calling removeAt in HashList, line 53")
else
call gEo(gDo,gFo,"when calling removeAt in HashList, line 53")
endif
set EM=EM-1
endfunction
function gho takes integer gHo,integer gjo,string gJo returns nothing
set ZM[EM]=gJo
set EM=EM+1
call gCo(gJ[gHo],gjo,"when calling removeAt in ScmdDataTypes, line 1259")
set EM=EM-1
endfunction
function gko takes integer gKo,integer gLo,string gmo returns nothing
set ZM[EM]=gmo
set EM=EM+1
if yx[gKo]==0 then
if gKo==0 then
call Cdv("Nullpointer exception when calling Arguments.removeAt","when calling error in ScmdDataTypes, line 1258")
else
call Cdv("Called Arguments.removeAt on invalid object.","when calling error in ScmdDataTypes, line 1258")
endif
endif
call gho(gKo,gLo,"when calling removeAt in ScmdDataTypes, line 1258")
set EM=EM-1
endfunction
function gMo takes integer gPo,integer gQo,string gUo returns nothing
set ZM[EM]=gUo
set EM=EM+1
call dlv(gJ[gPo],gQo,"when calling add in ScmdDataTypes, line 1253")
set EM=EM-1
endfunction
function gWo takes integer gzo,integer gZo,string g3o returns nothing
set ZM[EM]=g3o
set EM=EM+1
if yx[gzo]==0 then
if gzo==0 then
call Cdv("Nullpointer exception when calling Arguments.add","when calling error in ScmdDataTypes, line 1252")
else
call Cdv("Called Arguments.add on invalid object.","when calling error in ScmdDataTypes, line 1252")
endif
endif
call gMo(gzo,gZo,"when calling add in ScmdDataTypes, line 1252")
set EM=EM-1
endfunction
function Gvo takes integer Gxo,integer GVo,string GEo returns integer
local integer GXo
local integer GIo
local string GAo
local string GNo
local integer GBo
local integer GCo
local integer GDo
local integer GFo
local integer Ggo
local integer Gho
local integer GHo
local integer Gjo
set ZM[EM]=GEo
set EM=EM+1
set GXo=0
set GIo=SNv(GVo,"when calling size in ScmdDataTypes, line 1447")-1
loop
exitwhen GIo<0
set GHo=ox[M7v(GVo,GIo,"when calling get in ScmdDataTypes, line 1448")]
if GHo>=$EFB and GHo<=$EFF then
set GXo=GXo+1
else
exitwhen true
endif
set GIo=GIo-1
endloop
set GAo=""
set GNo=""
set GBo=dgv(ZJ[Gxo],"when calling size in ScmdDataTypes, line 1454")-1
loop
exitwhen GBo<0
set GCo=jqv(ZJ[Gxo],GBo,"when calling get in ScmdDataTypes, line 1455")
if SNv(GVo,"when calling size in ScmdDataTypes, line 1456")>xJ[GCo]then
if SNv(GVo,"when calling size in ScmdDataTypes, line 1457")-xJ[GCo]>GXo-1 then
exitwhen true
endif
set GDo=0
set GFo=SNv(GVo,"when calling size in ScmdDataTypes, line 1460")-xJ[GCo]+1
loop
exitwhen not(GDo!=GFo)
set Ggo=Joe(GVo,SNv(GVo,"when calling size in ScmdDataTypes, line 1462")-1,"when calling getPtr in ScmdDataTypes, line 1462")
set Gjo=ox[iNo(Ggo,"when calling get in ScmdDataTypes, line 1463")]
if not(Gjo>=$EFB and Gjo<=$EFF)then
exitwhen true
endif
call gko(GVo,SNv(GVo,"when calling size in ScmdDataTypes, line 1465")-1,"when calling removeAt in ScmdDataTypes, line 1465")
call fge(1,iNo(Ggo,"when calling get in ScmdDataTypes, line 1466"),"when calling toString in ScmdDataTypes, line 1466")
set GNo=RHv+GAo+GNo
set GAo=M8e(iNo(Ggo,"when calling get in ScmdDataTypes, line 1467"),"when calling getPreviousWhitespaces in ScmdDataTypes, line 1467")
call mfv(17,Ggo,"when calling dispatch_SharedPointer_destroySharedPointer in ScmdDataTypes, line 1468")
set GXo=GXo-1
set GDo=GDo+1
endloop
if GDo!=0 then
call gWo(GVo,p0v(cCo(GNo,GAo,"when calling forStrings in ScmdDataTypes, line 1472"),"when calling new_SharedPointer in ScmdDataTypes, line 1472"),"when calling add in ScmdDataTypes, line 1472")
endif
endif
if SNv(GVo,"when calling size in ScmdDataTypes, line 1473")==xJ[GCo]then
set Gho=1
loop
exitwhen not(Gho<=GXo and FMo(G8e(jJ[GCo],xJ[GCo]-Gho,"when calling get in ScmdDataTypes, line 1475"),M7v(GVo,xJ[GCo]-Gho,"when calling get in ScmdDataTypes, line 1475"),"when calling isInstance in ScmdDataTypes, line 1475"))
set Gho=Gho+1
endloop
if Gho>GXo then
set EM=EM-1
return GCo
endif
endif
set GBo=GBo-1
endloop
set EM=EM-1
return UJ[Gxo]
endfunction
function GJo takes integer Gko,integer GKo,string GLo returns integer
local integer Gmo
set ZM[EM]=GLo
set EM=EM+1
if ox[Gko]==0 then
if Gko==0 then
call Cdv("Nullpointer exception when calling BuiltinSpecialForm.resolveOverload","when calling error in ScmdDataTypes, line 1445")
else
call Cdv("Called BuiltinSpecialForm.resolveOverload on invalid object.","when calling error in ScmdDataTypes, line 1445")
endif
endif
set Gmo=Gvo(Gko,GKo,"when calling resolveOverload in ScmdDataTypes, line 1445")
set EM=EM-1
return Gmo
endfunction
function GMo takes integer A5i returns nothing
endfunction
function GPo takes trigger GQo,boolexpr GUo returns triggercondition
return TriggerAddCondition(GQo,GUo)
endfunction
function GWo takes integer Gzo,integer GZo,string G3o returns nothing
set ZM[EM]=G3o
set EM=EM+1
call GMo(Gzo)
set jK[Gzo]=CreateTrigger()
set xK[Gzo]=C0v(jK[Gzo])
set vK[Gzo]=GPo(jK[Gzo],qd)
set mK[Gzo]=cQv(jK[Gzo],ad)
set QK[Gzo]=TEv("when calling new_HashList in ScmdDataTypes, line 944")
call Dyv(ed,xK[Gzo],qUe(GZo,"when calling clone in ScmdDataTypes, line 945"),"when calling saveInt in ScmdDataTypes, line 945")
set EM=EM-1
endfunction
function hvo takes string hxo returns integer
local integer hVo
set ZM[EM]=hxo
set EM=EM+1
if Sx==0 then
if cx<$8000 then
set cx=cx+1
set hVo=cx
set ox[hVo]=$F0B
else
call Cdv("Out of memory: Could not create Trigger.","when calling error in ScmdDataTypes, line 893")
set hVo=0
endif
else
set Sx=Sx-1
set hVo=ix[Sx]
set ox[hVo]=$F0B
endif
set EM=EM-1
return hVo
endfunction
function hEo takes integer hXo,string hIo returns integer
local integer hAo
set ZM[EM]=hIo
set EM=EM+1
set hAo=hvo("when calling alloc_Trigger in ScmdDataTypes, line 939")
call GWo(hAo,hXo,"when calling construct_Trigger in ScmdDataTypes, line 939")
set EM=EM-1
return hAo
endfunction
function hNo takes integer fRt,integer hBo,integer TRt,string hCo returns integer
local integer hDo
set ZM[EM]=hCo
set EM=EM+1
set hDo=p0v(hEo(hBo,"when calling new_Trigger in SLangTriggerFunctions, line 9"),"when calling new_SharedPointer in SLangTriggerFunctions, line 9")
set EM=EM-1
return hDo
endfunction
function hFo takes integer edt,integer hgo,integer hho,string hHo returns integer
local player hjo
local integer hJo
local integer hko
local integer hKo
local player hLo
local integer hmo
set ZM[EM]=hHo
set EM=EM+1
set hLo=Onx(Mqv(M7v(hho,0,"when calling get in SLangPlayerFunctions, line 102"),"when calling getInner in SLangPlayerFunctions, line 102"),"when calling resolvePlayer in SLangPlayerFunctions, line 102")
set hmo=v1
set hjo=hLo
set hJo=hmo
if hJo==0 then
call SetPlayerAllianceStateVisionBJ(sa[QGv(hgo,"when calling getPlayerId in SLangPlayerFunctions, line 104")],hjo,true)
endif
if hJo!=0 then
set hko=hJo
else
set hko=MLv("when calling nullptr in SLangPlayerFunctions, line 105")
endif
set hKo=hko
set EM=EM-1
set hjo=null
set hLo=null
return hKo
endfunction
function hMo takes integer hPo,integer hQo,integer hUo,string hWo returns integer
local integer hzo
set ZM[EM]=hWo
set EM=EM+1
call HFe(Ha,QGv(hQo,"when calling getPlayerId in SLangChatSystem, line 223"),gye(g5e(g_e(sa[QGv(hQo,"when calling getPlayerId in SLangChatSystem, line 223")])),b3,y3)+uJ[hPo]+"|r: "+Mqv(M7v(hUo,0,"when calling get in SLangChatSystem, line 223"),"when calling getInner in SLangChatSystem, line 223"),ta,"when calling send in SLangChatSystem, line 223")
set hzo=MLv("when calling nullptr in SLangChatSystem, line 224")
set EM=EM-1
return hzo
endfunction
function hZo takes integer fhi,integer Rhi,integer h3o,string Hvo returns integer
local integer Hxo
set ZM[EM]=Hvo
set EM=EM+1
set Hxo=p0v(qRv(ANo(PCv(M7v(h3o,0,"when calling get in ScmdUnitBuiltins, line 773"),"when calling getInner in ScmdUnitBuiltins, line 773"),Mqv(M7v(h3o,1,"when calling get in ScmdUnitBuiltins, line 773"),"when calling getInner in ScmdUnitBuiltins, line 773")),"when calling new_Boolean in ScmdUnitBuiltins, line 773"),"when calling new_SharedPointer in ScmdUnitBuiltins, line 773")
set EM=EM-1
return Hxo
endfunction
function HVo takes unit HEo returns player
return GetOwningPlayer(HEo)
endfunction
function HXo takes integer ati,integer nti,integer HIo,string HAo returns integer
local player HNo
local string HBo
local string HCo
local integer HDo
set ZM[EM]=HAo
set EM=EM+1
set HNo=HVo(PCv(M7v(HIo,0,"when calling get in ScmdUnitBuiltins, line 54"),"when calling getInner in ScmdUnitBuiltins, line 54"))
if HNo==sa[PLAYER_NEUTRAL_AGGRESSIVE]then
set HCo="hostile"
else
if HNo==sa[PLAYER_NEUTRAL_PASSIVE]then
set HBo="neutral"
else
set HBo=jXe(g_e(HNo))
endif
set HCo=HBo
endif
set HDo=p0v(Ppv(HCo,"when calling new_String in ScmdUnitBuiltins, line 55"),"when calling new_SharedPointer in ScmdUnitBuiltins, line 55")
set EM=EM-1
set HNo=null
return HDo
endfunction
function HFo takes integer Rai,integer Tai,integer Hgo,string HGo returns integer
local integer Hho
set ZM[EM]=HGo
set EM=EM+1
set Hho=p0v(q2v(oAe(PCv(M7v(Hgo,0,"when calling get in ScmdUnitBuiltins, line 415"),"when calling getInner in ScmdUnitBuiltins, line 415"),QNv(M7v(Hgo,1,"when calling get in ScmdUnitBuiltins, line 415"),"when calling intValue in ScmdUnitBuiltins, line 415")),"when calling new_Real in ScmdUnitBuiltins, line 415"),"when calling new_SharedPointer in ScmdUnitBuiltins, line 415")
set EM=EM-1
return Hho
endfunction
function HHo takes integer Rei,integer Hjo,integer HJo,string Hko returns integer
local integer HKo
set ZM[EM]=Hko
set EM=EM+1
set HKo=p0v(SSv(oBe(Mov(Hjo,"when calling getEnumUnit in ScmdUnitBuiltins, line 363"),QNv(M7v(HJo,0,"when calling get in ScmdUnitBuiltins, line 363"),"when calling intValue in ScmdUnitBuiltins, line 363")),"when calling new_Integer in ScmdUnitBuiltins, line 363"),"when calling new_SharedPointer in ScmdUnitBuiltins, line 363")
set EM=EM-1
return HKo
endfunction
function HLo takes integer Rii,integer Hmo,integer Yii,string HMo returns integer
local integer HPo
set ZM[EM]=HMo
set EM=EM+1
set HPo=p0v(q2v(T6v(e_e(Mov(Hmo,"when calling getEnumUnit in ScmdUnitBuiltins, line 87"))),"when calling new_Real in ScmdUnitBuiltins, line 87"),"when calling new_SharedPointer in ScmdUnitBuiltins, line 87")
set EM=EM-1
return HPo
endfunction
function HQo takes group HUo,unit HWo returns nothing
call GroupRemoveUnit(HUo,HWo)
endfunction
function Hzo takes unit HZo returns integer
return C0v(HZo)
endfunction
function H3o takes group jvo returns integer
return C0v(jvo)
endfunction
function jxo takes hashtable jVo,integer jEo,integer jXo returns group
return LoadGroupHandle(jVo,jEo,jXo)
endfunction
function jIo takes integer jAo,integer jNo returns group
return jxo(XR,jAo,jNo)
endfunction
function jBo takes integer jCo,integer jDo,string jFo returns group
local group jgo
set ZM[EM]=jFo
set EM=EM+1
if ph[jCo]==0 then
if jCo==0 then
call Cdv("Nullpointer exception when calling Table.loadGroup","when calling error in Table, line 105")
else
call Cdv("Called Table.loadGroup on invalid object.","when calling error in Table, line 105")
endif
endif
set jgo=jIo(jCo,jDo)
set EM=EM-1
set Itv=jgo
set jgo=null
return Itv
endfunction
function jho takes integer jHo,string jjo returns group
local group jJo
set ZM[EM]=jjo
set EM=EM+1
call zix(RT,0,ConvertFogState(jHo),"when calling saveFogState in TypeCasting, line 88")
set jJo=jBo(RT,0,"when calling loadGroup in TypeCasting, line 89")
set EM=EM-1
set R1v=jJo
set jJo=null
return R1v
endfunction
function jko takes integer jKo,unit jLo,string jmo returns group
local group jMo
local group jPo
set ZM[EM]=jmo
set EM=EM+1
set jMo=jho(f3v(aL[jKo],Hzo(jLo),"when calling get in ScmdUnitParamLinkingBuiltins, line 25"),"when calling groupFromIndex in ScmdUnitParamLinkingBuiltins, line 25")
if jMo==null then
set jPo=CreateGroup()
call KWe(jPo,jLo)
set jMo=jPo
call WTv(aL[jKo],Hzo(jLo),H3o(jMo),"when calling put in ScmdUnitParamLinkingBuiltins, line 28")
endif
set EM=EM-1
set Iiv=jMo
set jMo=null
set jPo=null
return Iiv
endfunction
function jQo takes integer jUo,unit jWo,string jzo returns group
local group jZo
set ZM[EM]=jzo
set EM=EM+1
if Bx[jUo]==0 then
if jUo==0 then
call Cdv("Nullpointer exception when calling DisjointGroups.getOrMakeGroup","when calling error in ScmdUnitParamLinkingBuiltins, line 24")
else
call Cdv("Called DisjointGroups.getOrMakeGroup on invalid object.","when calling error in ScmdUnitParamLinkingBuiltins, line 24")
endif
endif
set jZo=jko(jUo,jWo,"when calling getOrMakeGroup in ScmdUnitParamLinkingBuiltins, line 24")
set EM=EM-1
set Ipv=jZo
set jZo=null
return Ipv
endfunction
function j3o takes group Jvo,group Jxo returns integer
return BlzGroupAddGroupFast(Jxo,Jvo)
endfunction
function JVo takes integer JEo,unit JXo,unit JIo,string JAo returns nothing
local group JNo
local group JBo
local group JCo
local group JDo
local group JFo
local group Jgo
local unit JGo
local group Jho
local group JHo
local group Jjo
local group JJo
local group Jko
local group JKo
local group JLo
set ZM[EM]=JAo
set EM=EM+1
set JNo=jQo(JEo,JXo,"when calling getOrMakeGroup in ScmdUnitParamLinkingBuiltins, line 35")
set JBo=jQo(JEo,JIo,"when calling getOrMakeGroup in ScmdUnitParamLinkingBuiltins, line 36")
if JNo!=JBo then
if d5e(JNo)<d5e(JBo)then
set JHo=JNo
set Jjo=JBo
set JFo=JHo
set Jgo=Jjo
else
set JJo=JBo
set Jko=JNo
set JFo=JJo
set Jgo=Jko
endif
set JKo=JFo
set JLo=Jgo
set JCo=JKo
set JDo=JLo
call j3o(JDo,JCo)
set Jho=JCo
loop
exitwhen not F9e(Jho)
set JGo=F6e(Jho)
call WTv(aL[JEo],Hzo(JGo),H3o(JDo),"when calling put in ScmdUnitParamLinkingBuiltins, line 41")
endloop
call kcv(JCo)
endif
set EM=EM-1
set JNo=null
set JBo=null
set JCo=null
set JDo=null
set JFo=null
set Jgo=null
set JGo=null
set Jho=null
set JHo=null
set Jjo=null
set JJo=null
set Jko=null
set JKo=null
set JLo=null
endfunction
function Jmo takes integer JMo,unit JPo,unit JQo,string JUo returns nothing
set ZM[EM]=JUo
set EM=EM+1
if Bx[JMo]==0 then
if JMo==0 then
call Cdv("Nullpointer exception when calling DisjointGroups.unite","when calling error in ScmdUnitParamLinkingBuiltins, line 34")
else
call Cdv("Called DisjointGroups.unite on invalid object.","when calling error in ScmdUnitParamLinkingBuiltins, line 34")
endif
endif
call JVo(JMo,JPo,JQo,"when calling unite in ScmdUnitParamLinkingBuiltins, line 34")
set EM=EM-1
endfunction
function JWo takes group Jzo,integer JZo,string J3o returns nothing
local unit kvo
local integer kxo
local unit kVo
local group kEo
set ZM[EM]=J3o
set EM=EM+1
set kvo=FirstOfGroup(Jzo)
if kvo==null then
set EM=EM-1
set kvo=null
set kVo=null
set kEo=null
return
endif
call HQo(Jzo,kvo)
set kxo=f3v(Wd,JZo,"when calling get in ScmdUnitParamLinkingBuiltins, line 151")
set kEo=Jzo
loop
exitwhen not F9e(kEo)
set kVo=F6e(kEo)
call Jmo(kxo,kvo,kVo,"when calling unite in ScmdUnitParamLinkingBuiltins, line 153")
endloop
set EM=EM-1
set kvo=null
set kVo=null
set kEo=null
endfunction
function kXo takes string kIo returns integer
local integer kAo
set ZM[EM]=kIo
set EM=EM+1
if ug==0 then
if rg<$8000 then
set rg=rg+1
set kAo=rg
set sg[kAo]=$87A
else
call Cdv("Out of memory: Could not create ForGroupCallback_forUnitsSelected_setArgumentsTypes_registerBuiltin_ScmdUnitParamLinkingBuiltins.","when calling error in ScmdUnitParamLinkingBuiltins, line 182")
set kAo=0
endif
else
set ug=ug-1
set kAo=wg[ug]
set sg[kAo]=$87A
endif
set EM=EM-1
return kAo
endfunction
function kNo takes integer bji,integer kBo,integer kCo,string kDo returns integer
local boolean kFo
local integer kgo
local group kho
local integer kHo
local group kjo
local integer kJo
local integer kko
local player kKo
local boolean kLo
local integer kmo
set ZM[EM]=kDo
set EM=EM+1
set kLo=Jte(Mqv(M7v(kCo,0,"when calling get in ScmdUnitParamLinkingBuiltins, line 179"),"when calling getInner in ScmdUnitParamLinkingBuiltins, line 179"))
set kmo=K1
set kFo=kLo
set kgo=kmo
if kFo then
set kho=CreateGroup()
set kKo=sa[QGv(kBo,"when calling getPlayerId in ScmdUnitParamLinkingBuiltins, line 182")]
set kHo=kXo("when calling alloc_ForGroupCallback_forUnitsSelected_setArgumentsTypes_registerBuiltin_ScmdUnitParamLinkingBuiltins in ScmdUnitParamLinkingBuiltins, line 182")
set yL[kHo]=kBo
set pL[kHo]=kho
call kee(kKo,kHo,"when calling forUnitsSelected in ScmdUnitParamLinkingBuiltins, line 182")
set kjo=kho
call JWo(kjo,kgo,"when calling linkParameter in ScmdUnitParamLinkingBuiltins, line 185")
endif
if kFo then
set kJo=MLv("when calling nullptr in ScmdUnitParamLinkingBuiltins, line 186")
else
set kJo=B6e("unknown parameter","when calling wrap in ScmdUnitParamLinkingBuiltins, line 186")
endif
set kko=kJo
set EM=EM-1
set kho=null
set kjo=null
set kKo=null
return kko
endfunction
function kMo takes unit kPo,string kQo,integer kUo,real kWo,string kzo returns nothing
local integer kZo
local integer k3o
local integer Kvo
set ZM[EM]=kzo
set EM=EM+1
set kZo=THv(kQo,"when calling getAbilityIdByName in SotFRP_AbilitySystem, line 39")
set k3o=jdv(kZo,"when calling iterator in SotFRP_AbilitySystem, line 40")
loop
exitwhen not Jgv(k3o,"when calling hasNext in SotFRP_AbilitySystem, line 40")
set Kvo=jTv(k3o,"when calling next in SotFRP_AbilitySystem, line 40")
call Ole(kPo,Kvo,kUo,kWo)
endloop
call Jqv(k3o,"when calling close in SotFRP_AbilitySystem, line 40")
call JEv(kZo,"when calling dispatch_HashList_destroyHashList in SotFRP_AbilitySystem, line 42")
set EM=EM-1
endfunction
function Kxo takes integer Rmi,integer KVo,integer KEo,string KXo returns integer
local integer KIo
set ZM[EM]=KXo
set EM=EM+1
call kMo(Mov(KVo,"when calling getEnumUnit in SotFRP_AbilitySystem, line 80"),Mqv(M7v(KEo,0,"when calling get in SotFRP_AbilitySystem, line 80"),"when calling getInner in SotFRP_AbilitySystem, line 80"),QNv(M7v(KEo,1,"when calling get in SotFRP_AbilitySystem, line 80"),"when calling intValue in SotFRP_AbilitySystem, line 80"),PEv(M7v(KEo,2,"when calling get in SotFRP_AbilitySystem, line 80"),"when calling realValue in SotFRP_AbilitySystem, line 80"),"when calling setAbilityCooldown in SotFRP_AbilitySystem, line 80")
set KIo=MLv("when calling nullptr in SotFRP_AbilitySystem, line 81")
set EM=EM-1
return KIo
endfunction
function KAo takes player KNo,integer KBo returns nothing
set wZ[Hpe(KNo)]=KBo
endfunction
function KCo takes integer Rsi,integer KDo,integer KFo,string Kgo returns integer
local integer KGo
set ZM[EM]=Kgo
set EM=EM+1
call KAo(sa[QGv(KDo,"when calling getPlayerId in ScmdSystemsSettingsBuiltins, line 9")],QNv(M7v(KFo,0,"when calling get in ScmdSystemsSettingsBuiltins, line 9"),"when calling intValue in ScmdSystemsSettingsBuiltins, line 9"))
set KGo=MLv("when calling nullptr in ScmdSystemsSettingsBuiltins, line 10")
set EM=EM-1
return KGo
endfunction
function Kho takes integer fui,integer KHo,integer Kjo,string KJo returns integer
local real Kko
local integer KKo
set ZM[EM]=KJo
set EM=EM+1
set Kko=PEv(M7v(Kjo,0,"when calling get in ScmdPlayerCameraSettingsBuiltins, line 81"),"when calling realValue in ScmdPlayerCameraSettingsBuiltins, line 81")
call AMo(QGv(KHo,"when calling getPlayerId in ScmdPlayerCameraSettingsBuiltins, line 82"),CAMERA_FIELD_TARGET_DISTANCE,Kko,"when calling setCameraField in ScmdPlayerCameraSettingsBuiltins, line 82")
set KKo=MLv("when calling nullptr in ScmdPlayerCameraSettingsBuiltins, line 83")
set EM=EM-1
return KKo
endfunction
function KLo takes integer Ryi,integer Tyi,integer Kmo,string KMo returns integer
local integer KPo
set ZM[EM]=KMo
set EM=EM+1
set KPo=p0v(q2v(GetWidgetLife(qqv(M7v(Kmo,0,"when calling get in ScmdUnitBuiltins, line 304"),"when calling getInner in ScmdUnitBuiltins, line 304")),"when calling new_Real in ScmdUnitBuiltins, line 304"),"when calling new_SharedPointer in ScmdUnitBuiltins, line 304")
set EM=EM-1
return KPo
endfunction
function KQo takes integer w0i,integer u0i,integer KUo,string KWo returns integer
local integer Kzo
set ZM[EM]=KWo
set EM=EM+1
call Iie(Wlv(M7v(KUo,0,"when calling get in ScmdItemBuiltins, line 18"),"when calling getInner in ScmdItemBuiltins, line 18"),WCv(M7v(KUo,1,"when calling get in ScmdItemBuiltins, line 18"),"when calling booleanValue in ScmdItemBuiltins, line 18"))
set Kzo=MLv("when calling nullptr in ScmdItemBuiltins, line 19")
set EM=EM-1
return Kzo
endfunction
function KZo takes integer wRi,integer uRi,integer K3o,string lvo returns integer
local integer lxo
set ZM[EM]=lvo
set EM=EM+1
set lxo=p0v(SSv(Zov(PCv(M7v(K3o,0,"when calling get in ScmdUnitBuiltins, line 606"),"when calling getInner in ScmdUnitBuiltins, line 606"),WCv(M7v(K3o,1,"when calling get in ScmdUnitBuiltins, line 606"),"when calling booleanValue in ScmdUnitBuiltins, line 606")),"when calling new_Integer in ScmdUnitBuiltins, line 606"),"when calling new_SharedPointer in ScmdUnitBuiltins, line 606")
set EM=EM-1
return lxo
endfunction
function lVo takes integer MQi,integer lEo,integer lXo,string lIo returns integer
local rect lAo
local integer lNo
set ZM[EM]=lIo
set EM=EM+1
call PreloadGenClear()
set lAo=gOe(M7v(lXo,0,"when calling get in SotFRP_SaveLoad, line 154"),"when calling getInner in SotFRP_SaveLoad, line 154")
call gee(QGv(lEo,"when calling getPlayerId in SotFRP_SaveLoad, line 155"),lAo,"when calling writeUnits in SotFRP_SaveLoad, line 155")
call mie(lAo)
call jue(lAo)
if ta==sa[QGv(lEo,"when calling getPlayerId in SotFRP_SaveLoad, line 158")]then
call PreloadGenEnd("SotFRP\\Save\\"+Mqv(M7v(lXo,1,"when calling get in SotFRP_SaveLoad, line 159"),"when calling getInner in SotFRP_SaveLoad, line 159")+".pld")
endif
set lNo=p0v(dpe("when calling new_Null in SotFRP_SaveLoad, line 160"),"when calling new_SharedPointer in SotFRP_SaveLoad, line 160")
set EM=EM-1
set lAo=null
return lNo
endfunction
function lBo takes integer wYi,integer lCo,integer lDo,string lFo returns integer
local integer lgo
set ZM[EM]=lFo
set EM=EM+1
call RWe(Mov(lCo,"when calling getEnumUnit in ScmdUnitBuiltins, line 676"),QJv(Mov(lCo,"when calling getEnumUnit in ScmdUnitBuiltins, line 676"))+dve(PEv(M7v(lDo,0,"when calling get in ScmdUnitBuiltins, line 676"),"when calling realValue in ScmdUnitBuiltins, line 676"),XT,LT))
set lgo=MLv("when calling nullptr in ScmdUnitBuiltins, line 677")
set EM=EM-1
return lgo
endfunction
function lho takes integer B0i,integer N0i,integer lHo,string ljo returns integer
local integer lJo
local integer lko
local integer lKo
local integer lLo
set ZM[EM]=ljo
set EM=EM+1
set lJo=j5e("when calling new_Vector in ScmdParser, line 148")
set lko=MRe(lHo,"when calling iterator in ScmdParser, line 149")
loop
exitwhen not Jgv(lko,"when calling hasNext in ScmdParser, line 149")
set lKo=jTv(lko,"when calling next in ScmdParser, line 149")
call JRe(lJo,P_v(lKo,"when calling clone in ScmdParser, line 150"),"when calling push in ScmdParser, line 150")
endloop
call Jqv(lko,"when calling close in ScmdParser, line 149")
set lLo=p0v(lJo,"when calling new_SharedPointer in ScmdParser, line 151")
set EM=EM-1
return lLo
endfunction
function lmo takes integer wci,integer uci,integer lMo,string lPo returns integer
local integer lQo
set ZM[EM]=lPo
set EM=EM+1
set lQo=p0v(q2v(LHe(PCv(M7v(lMo,0,"when calling get in ScmdUnitBuiltins, line 127"),"when calling getInner in ScmdUnitBuiltins, line 127")),"when calling new_Real in ScmdUnitBuiltins, line 127"),"when calling new_SharedPointer in ScmdUnitBuiltins, line 127")
set EM=EM-1
return lQo
endfunction
function lUo takes integer Nci,integer Mci,integer lWo,string lzo returns integer
local unit lZo
local real l3o
local integer Lvo
set ZM[EM]=lzo
set EM=EM+1
set lZo=PCv(M7v(lWo,0,"when calling get in ScmdUnitBuiltins, line 151"),"when calling getInner in ScmdUnitBuiltins, line 151")
if q6v(lZo)then
set l3o=q8v(lZo)
else
set l3o=1.
endif
set Lvo=p0v(q2v(l3o,"when calling new_Real in ScmdUnitBuiltins, line 152"),"when calling new_SharedPointer in ScmdUnitBuiltins, line 152")
set EM=EM-1
set lZo=null
return Lvo
endfunction
function Lxo takes integer LVo,string LEo,string LXo returns integer
local integer LIo
local integer LAo
local integer LNo
set ZM[EM]=LXo
set EM=EM+1
set LIo=f3v(NJ[LVo],KCv(LEo,"when calling stringToIndex in ScmdDataTypes, line 1227"),"when calling get in ScmdDataTypes, line 1227")
if LIo!=0 then
set LAo=P_v(LIo,"when calling clone in ScmdDataTypes, line 1228")
else
set LAo=0
endif
set LNo=LAo
set EM=EM-1
return LNo
endfunction
function LBo takes integer LCo,string LDo,string LFo returns integer
local integer Lgo
set ZM[EM]=LFo
set EM=EM+1
if Rx[LCo]==0 then
if LCo==0 then
call Cdv("Nullpointer exception when calling Context.resolve","when calling error in ScmdDataTypes, line 1226")
else
call Cdv("Called Context.resolve on invalid object.","when calling error in ScmdDataTypes, line 1226")
endif
endif
set Lgo=Lxo(LCo,LDo,"when calling resolve in ScmdDataTypes, line 1226")
set EM=EM-1
return Lgo
endfunction
function LGo takes integer Lho,string LHo returns string
local string Ljo
set ZM[EM]=LHo
set EM=EM+1
if ox[Lho]==0 then
if Lho==0 then
call Cdv("Nullpointer exception when calling Symbol.toString","when calling error in ScmdDataTypes, line 259")
else
call Cdv("Called Symbol.toString on invalid object.","when calling error in ScmdDataTypes, line 259")
endif
endif
set Ljo=D4e(Lho)
set EM=EM-1
return Ljo
endfunction
function LJo takes integer GFt,integer gFt,integer Lko,string LKo returns integer
local integer LLo
set ZM[EM]=LKo
set EM=EM+1
set LLo=p0v(SSv(GZv(Mqv(M7v(Lko,0,"when calling get in ScmdCoreBuiltins, line 124"),"when calling getInner in ScmdCoreBuiltins, line 124")),"when calling new_Integer in ScmdCoreBuiltins, line 124"),"when calling new_SharedPointer in ScmdCoreBuiltins, line 124")
set EM=EM-1
return LLo
endfunction
function Lmo takes integer Gbi,integer gbi,integer LMo,string LPo returns integer
local integer LQo
set ZM[EM]=LPo
set EM=EM+1
set LQo=p0v(SSv(zJv(PCv(M7v(LMo,0,"when calling get in ScmdUnitBuiltins, line 280"),"when calling getInner in ScmdUnitBuiltins, line 280")),"when calling new_Integer in ScmdUnitBuiltins, line 280"),"when calling new_SharedPointer in ScmdUnitBuiltins, line 280")
set EM=EM-1
return LQo
endfunction
function LUo takes integer Gli,integer LWo,integer Lzo,string LZo returns integer
local integer L3o
set ZM[EM]=LZo
set EM=EM+1
set L3o=p0v(pjv(CreateUnit(sa[QGv(LWo,"when calling getPlayerId in ScmdUnitBuiltins, line 250")],UnitId(Mqv(M7v(Lzo,0,"when calling get in ScmdUnitBuiltins, line 250"),"when calling getInner in ScmdUnitBuiltins, line 250")),dve(PEv(M7v(Lzo,1,"when calling get in ScmdUnitBuiltins, line 250"),"when calling realValue in ScmdUnitBuiltins, line 250"),XT,LT),dve(PEv(M7v(Lzo,2,"when calling get in ScmdUnitBuiltins, line 250"),"when calling realValue in ScmdUnitBuiltins, line 250"),VT,CT),PEv(M7v(Lzo,3,"when calling get in ScmdUnitBuiltins, line 250"),"when calling realValue in ScmdUnitBuiltins, line 250")),"when calling new_Unit in ScmdUnitBuiltins, line 250"),"when calling new_SharedPointer in ScmdUnitBuiltins, line 250")
set EM=EM-1
return L3o
endfunction
function mvo takes integer Gmt,integer gmt,integer mxo,string mVo returns integer
local integer mEo
set ZM[EM]=mVo
set EM=EM+1
set mEo=p0v(qRv(ModuloInteger(QNv(M7v(mxo,0,"when calling get in ScmdCoreBuiltins, line 285"),"when calling intValue in ScmdCoreBuiltins, line 285"),2)!=0,"when calling new_Boolean in ScmdCoreBuiltins, line 285"),"when calling new_SharedPointer in ScmdCoreBuiltins, line 285")
set EM=EM-1
return mEo
endfunction
function mXo takes integer Gni,integer mIo,integer mAo,string mNo returns integer
local integer mBo
set ZM[EM]=mNo
set EM=EM+1
set mBo=p0v(qRv(UOv(Mov(mIo,"when calling getEnumUnit in ScmdUnitBuiltins, line 488"),Mqv(M7v(mAo,0,"when calling get in ScmdUnitBuiltins, line 488"),"when calling getInner in ScmdUnitBuiltins, line 488")),"when calling new_Boolean in ScmdUnitBuiltins, line 488"),"when calling new_SharedPointer in ScmdUnitBuiltins, line 488")
set EM=EM-1
return mBo
endfunction
function mCo takes integer Gpi,integer mDo,integer mFo,string mgo returns integer
local integer mho
set ZM[EM]=mgo
set EM=EM+1
set mho=p0v(SSv(Ufv(Mov(mDo,"when calling getEnumUnit in ScmdUnitBuiltins, line 339"),QNv(M7v(mFo,0,"when calling get in ScmdUnitBuiltins, line 339"),"when calling intValue in ScmdUnitBuiltins, line 339")),"when calling new_Integer in ScmdUnitBuiltins, line 339"),"when calling new_SharedPointer in ScmdUnitBuiltins, line 339")
set EM=EM-1
return mho
endfunction
function mHo takes integer Gqi,integer gqi,integer mjo,string mJo returns integer
local integer mko
set ZM[EM]=mJo
set EM=EM+1
call mbe(PCv(M7v(mjo,0,"when calling get in ScmdUnitBuiltins, line 392"),"when calling getInner in ScmdUnitBuiltins, line 392"),UNIT_RF_SIGHT_RADIUS,PEv(M7v(mjo,1,"when calling get in ScmdUnitBuiltins, line 392"),"when calling realValue in ScmdUnitBuiltins, line 392"))
set mko=MLv("when calling nullptr in ScmdUnitBuiltins, line 393")
set EM=EM-1
return mko
endfunction
function mKo takes integer Gri,integer gri,integer hri,string mLo returns integer
local integer mmo
set ZM[EM]=mLo
set EM=EM+1
set mmo=MJv(vd,"when calling clone in ScmdRectBuiltins, line 36")
set EM=EM-1
return mmo
endfunction
function mMo takes integer YFi,integer mPo,integer mQo,string mUo returns integer
local integer mWo
set ZM[EM]=mUo
set EM=EM+1
call Rux(Mov(mPo,"when calling getEnumUnit in ScmdUnitBuiltins, line 800"),QNv(M7v(mQo,0,"when calling get in ScmdUnitBuiltins, line 800"),"when calling intValue in ScmdUnitBuiltins, line 800"))
set mWo=MLv("when calling nullptr in ScmdUnitBuiltins, line 801")
set EM=EM-1
return mWo
endfunction
function mzo takes integer YTt,integer mZo,integer gTt,string m3o returns integer
local integer Mvo
set ZM[EM]=m3o
set EM=EM+1
set Mvo=p0v(SSv(qoe(mZo,"when calling getSpellAbilityId in SLangTriggerFunctions, line 94"),"when calling new_Integer in SLangTriggerFunctions, line 94"),"when calling new_SharedPointer in SLangTriggerFunctions, line 94")
set EM=EM-1
return Mvo
endfunction
function Mxo takes string MVo returns integer
local integer MEo=0
local integer MXo=0
local integer MIo=0
local integer MAo=MEo
local integer MNo=MXo
local integer MBo=MIo
local integer MCo=0
local integer MDo=kp
local integer MFo
local integer Mgo
local integer MGo
loop
exitwhen MCo>MDo
if tYv(MVo)==mp[MCo]then
set MFo=jp[MCo]
set Mgo=xp[MCo]
set MGo=vp[MCo]
set MAo=MFo
set MNo=Mgo
set MBo=MGo
exitwhen true
endif
set MCo=MCo+1
endloop
set f3=MAo
set R3=MNo
set T3=MBo
return f3
endfunction
function Mho takes integer Yat,integer Gat,integer MHo,string Mjo returns integer
local integer MJo
set ZM[EM]=Mjo
set EM=EM+1
set MJo=p0v(Ppv(gye(Mxo(Mqv(M7v(MHo,0,"when calling get in SLangPlayerFunctions, line 21"),"when calling getInner in SLangPlayerFunctions, line 21")),R3,T3),"when calling new_String in SLangPlayerFunctions, line 21"),"when calling new_SharedPointer in SLangPlayerFunctions, line 21")
set EM=EM-1
return MJo
endfunction
function Mko takes real MKo,real MLo returns real
call MoveLocation(wY,MKo,MLo)
return GetLocationZ(wY)
endfunction
function Mmo takes effect MMo,real MPo returns nothing
call BlzSetSpecialEffectZ(MMo,MPo)
endfunction
function MQo takes effect MUo returns real
set I3=BlzGetLocalSpecialEffectX(MUo)
set P3=BlzGetLocalSpecialEffectY(MUo)
return I3
endfunction
function MWo takes integer Tft,integer Yft,integer Mzo,string MZo returns integer
local effect M3o
local integer pvo
set ZM[EM]=MZo
set EM=EM+1
set M3o=Pov(M7v(Mzo,0,"when calling get in SLangSpecialEffectFunctions, line 27"),"when calling getInner in SLangSpecialEffectFunctions, line 27")
call Mmo(M3o,Mko(MQo(M3o),P3)+PEv(M7v(Mzo,1,"when calling get in SLangSpecialEffectFunctions, line 28"),"when calling realValue in SLangSpecialEffectFunctions, line 28"))
set pvo=MLv("when calling nullptr in SLangSpecialEffectFunctions, line 29")
set EM=EM-1
set M3o=null
return pvo
endfunction
function pxo takes integer Ygi,integer Ggi,integer pVo,string pEo returns integer
local integer pXo
set ZM[EM]=pEo
set EM=EM+1
call E9x(PCv(M7v(pVo,0,"when calling get in ScmdUnitBuiltins, line 746"),"when calling getInner in ScmdUnitBuiltins, line 746"))
set pXo=MLv("when calling nullptr in ScmdUnitBuiltins, line 747")
set EM=EM-1
return pXo
endfunction
function pIo takes string pAo,string pNo returns boolean
local integer pBo
if pNo=="" then
return true
endif
set pBo=GZv(pAo)
if GZv(pNo)>pBo then
return false
endif
return Psv(pAo,pBo-GZv(pNo),pBo)==pNo
endfunction
function pCo takes integer Yjt,integer Gjt,integer pDo,string pFo returns integer
local integer pgo
set ZM[EM]=pFo
set EM=EM+1
set pgo=p0v(qRv(pIo(Mqv(M7v(pDo,0,"when calling get in ScmdCoreBuiltins, line 181"),"when calling getInner in ScmdCoreBuiltins, line 181"),Mqv(M7v(pDo,1,"when calling get in ScmdCoreBuiltins, line 181"),"when calling getInner in ScmdCoreBuiltins, line 181")),"when calling new_Boolean in ScmdCoreBuiltins, line 181"),"when calling new_SharedPointer in ScmdCoreBuiltins, line 181")
set EM=EM-1
return pgo
endfunction
function pho takes integer Ykt,integer Gkt,integer pHo,string pjo returns integer
local integer pJo
set ZM[EM]=pjo
set EM=EM+1
set pJo=p0v(Ppv(tYv(Mqv(M7v(pHo,0,"when calling get in ScmdCoreBuiltins, line 157"),"when calling getInner in ScmdCoreBuiltins, line 157")),"when calling new_String in ScmdCoreBuiltins, line 157"),"when calling new_SharedPointer in ScmdCoreBuiltins, line 157")
set EM=EM-1
return pJo
endfunction
function pko takes string pKo returns integer
local integer pLo
set ZM[EM]=pKo
set EM=EM+1
if CY==0 then
if VY<$8000 then
set VY=VY+1
set pLo=VY
set BY[pLo]=$86B
else
call Cdv("Out of memory: Could not create ForForceCallback_execute_setArgumentsTypes_setProvidingEnumUnit_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 191")
set pLo=0
endif
else
set CY=CY-1
set pLo=XY[CY]
set BY[pLo]=$86B
endif
set EM=EM-1
return pLo
endfunction
function pmo takes integer ibi,integer pMo,integer pPo,string pQo returns integer
local integer pUo
set ZM[EM]=pQo
set EM=EM+1
call bVe(Mov(pMo,"when calling getEnumUnit in ScmdUnitBuiltins, line 271"),QNv(M7v(pPo,0,"when calling get in ScmdUnitBuiltins, line 271"),"when calling intValue in ScmdUnitBuiltins, line 271"))
set pUo=MLv("when calling nullptr in ScmdUnitBuiltins, line 272")
set EM=EM-1
return pUo
endfunction
function pWo takes integer igt,integer pzo,integer pZo,string p3o returns integer
local integer Pvo
set ZM[EM]=p3o
set EM=EM+1
if ta==sa[QGv(pzo,"when calling getPlayerId in ScmdCameraSetupBuiltins, line 28")]then
call CameraSetupApplyForceDuration(FVe(M7v(pZo,0,"when calling get in ScmdCameraSetupBuiltins, line 29"),"when calling getInner in ScmdCameraSetupBuiltins, line 29"),WCv(M7v(pZo,1,"when calling get in ScmdCameraSetupBuiltins, line 29"),"when calling booleanValue in ScmdCameraSetupBuiltins, line 29"),PEv(M7v(pZo,2,"when calling get in ScmdCameraSetupBuiltins, line 29"),"when calling realValue in ScmdCameraSetupBuiltins, line 29"))
endif
set Pvo=MLv("when calling nullptr in ScmdCameraSetupBuiltins, line 30")
set EM=EM-1
return Pvo
endfunction
function Pxo takes integer ili,integer PVo,integer cli,string PEo returns integer
local integer PXo
set ZM[EM]=PEo
set EM=EM+1
if ta==sa[QGv(PVo,"when calling getPlayerId in ScmdUnitBuiltins, line 238")]then
call ClearSelection()
endif
set PXo=MLv("when calling nullptr in ScmdUnitBuiltins, line 240")
set EM=EM-1
return PXo
endfunction
function PIo takes integer imt,integer Smt,integer PAo,string PNo returns integer
local integer PBo
set ZM[EM]=PNo
set EM=EM+1
set PBo=p0v(qRv(kge(M7v(PAo,0,"when calling get in ScmdCoreBuiltins, line 276"),"when calling realValue in ScmdCoreBuiltins, line 276")>.0,"when calling new_Boolean in ScmdCoreBuiltins, line 276"),"when calling new_SharedPointer in ScmdCoreBuiltins, line 276")
set EM=EM-1
return PBo
endfunction
function PCo takes unit PDo,unitweaponintegerfield PFo,integer Pgo,integer Pho returns boolean
return BlzSetUnitWeaponIntegerField(PDo,PFo,Pgo,Pho)
endfunction
function PHo takes unit Pjo,integer PJo,string Pko returns boolean
local attacktype PKo=ATTACK_TYPE_NORMAL
local boolean PLo=true
local string Pmo=Pko
local boolean PMo
if Pmo=="chaos" then
set PKo=ATTACK_TYPE_CHAOS
elseif Pmo=="hero" then
set PKo=ATTACK_TYPE_HERO
elseif Pmo=="magic" then
set PKo=ATTACK_TYPE_MAGIC
elseif Pmo=="melee" then
set PKo=ATTACK_TYPE_MELEE
elseif Pmo=="normal" then
set PKo=ATTACK_TYPE_NORMAL
elseif Pmo=="pierce" then
set PKo=ATTACK_TYPE_PIERCE
elseif Pmo=="siege" then
set PKo=ATTACK_TYPE_SIEGE
else
set PLo=false
endif
if PLo then
set PMo=PCo(Pjo,UNIT_WEAPON_IF_ATTACK_ATTACK_TYPE,PJo,C0v(PKo))
else
set PMo=false
endif
set PKo=null
return PMo
endfunction
function PPo takes integer ini,integer Sni,integer PQo,string PUo returns integer
local integer PWo
set ZM[EM]=PUo
set EM=EM+1
set PWo=p0v(qRv(PHo(PCv(M7v(PQo,0,"when calling get in ScmdUnitBuiltins, line 456"),"when calling getInner in ScmdUnitBuiltins, line 456"),QNv(M7v(PQo,1,"when calling get in ScmdUnitBuiltins, line 456"),"when calling intValue in ScmdUnitBuiltins, line 456"),Mqv(M7v(PQo,2,"when calling get in ScmdUnitBuiltins, line 456"),"when calling getInner in ScmdUnitBuiltins, line 456")),"when calling new_Boolean in ScmdUnitBuiltins, line 456"),"when calling new_SharedPointer in ScmdUnitBuiltins, line 456")
set EM=EM-1
return PWo
endfunction
function Pzo takes unit PZo returns nothing
call UnitResetCooldown(PZo)
endfunction
function P3o takes unit qvo returns nothing
local unit qxo=qvo
local unit qVo
local unit qEo
call O0e(qxo,b7e(qvo))
set qVo=qxo
call Rqe(qVo,bOe(qvo))
set qEo=qVo
call Pzo(qEo)
set qxo=null
set qVo=null
set qEo=null
endfunction
function qXo takes integer ipi,integer Spi,integer qIo,string qAo returns integer
local integer qNo
set ZM[EM]=qAo
set EM=EM+1
call P3o(PCv(M7v(qIo,0,"when calling get in ScmdUnitBuiltins, line 327"),"when calling getInner in ScmdUnitBuiltins, line 327"))
set qNo=MLv("when calling nullptr in ScmdUnitBuiltins, line 328")
set EM=EM-1
return qNo
endfunction
function qBo takes integer iqi,integer qCo,integer qDo,string qFo returns integer
local integer qgo
set ZM[EM]=qFo
set EM=EM+1
call mbe(Mov(qCo,"when calling getEnumUnit in ScmdUnitBuiltins, line 382"),UNIT_RF_MANA_REGENERATION,PEv(M7v(qDo,0,"when calling get in ScmdUnitBuiltins, line 382"),"when calling realValue in ScmdUnitBuiltins, line 382"))
set qgo=MLv("when calling nullptr in ScmdUnitBuiltins, line 383")
set EM=EM-1
return qgo
endfunction
function qho takes integer iri,integer Sri,integer qHo,string qjo returns integer
local integer qJo
set ZM[EM]=qjo
set EM=EM+1
set qJo=p0v(q2v(jse(gOe(M7v(qHo,0,"when calling get in ScmdRectBuiltins, line 26"),"when calling getInner in ScmdRectBuiltins, line 26")),"when calling new_Real in ScmdRectBuiltins, line 26"),"when calling new_SharedPointer in ScmdRectBuiltins, line 26")
set EM=EM-1
return qJo
endfunction
function qko takes integer Mwi,integer qKo,integer qLo,string qmo returns integer
local string qMo
local real qPo
local camerafield qQo
local boolean qUo
local string qWo
local integer qzo
local integer qZo
set ZM[EM]=qmo
set EM=EM+1
set qMo=Mqv(M7v(qLo,0,"when calling get in ScmdPlayerCameraSettingsBuiltins, line 51"),"when calling getInner in ScmdPlayerCameraSettingsBuiltins, line 51")
set qPo=PEv(M7v(qLo,1,"when calling get in ScmdPlayerCameraSettingsBuiltins, line 52"),"when calling realValue in ScmdPlayerCameraSettingsBuiltins, line 52")
set qQo=null
set qUo=true
set qWo=qMo
if qWo=="dist" or qWo=="distance" or qWo=="targetdistance" then
set qQo=CAMERA_FIELD_TARGET_DISTANCE
elseif qWo=="farz" then
set qQo=CAMERA_FIELD_FARZ
elseif qWo=="aoa" or qWo=="angleofattack" then
set qQo=CAMERA_FIELD_ANGLE_OF_ATTACK
elseif qWo=="fov" or qWo=="fieldofview" then
set qQo=CAMERA_FIELD_FIELD_OF_VIEW
elseif qWo=="roll" then
set qQo=CAMERA_FIELD_ROLL
elseif qWo=="rot" or qWo=="rotation" then
set qQo=CAMERA_FIELD_ROTATION
else
set qUo=false
endif
if qUo then
call AMo(QGv(qKo,"when calling getPlayerId in ScmdPlayerCameraSettingsBuiltins, line 71"),qQo,qPo,"when calling setCameraField in ScmdPlayerCameraSettingsBuiltins, line 71")
endif
if qUo then
set qzo=MLv("when calling nullptr in ScmdPlayerCameraSettingsBuiltins, line 72")
else
set qzo=AHo("when calling makeUnknownCameraSettingException in ScmdPlayerCameraSettingsBuiltins, line 72")
endif
set qZo=qzo
set EM=EM-1
set qQo=null
return qZo
endfunction
function q3o takes string Qvo returns integer
local integer Qxo
set ZM[EM]=Qvo
set EM=EM+1
if Xj==0 then
if Cj<$8000 then
set Cj=Cj+1
set Qxo=Cj
set Vj[Qxo]=$C47
else
call Cdv("Out of memory: Could not create IntBinOp_reduceNumbers_setVariadicArgumentTypes_registerProtectedBuiltin_ScmdCoreBuiltins.","when calling error in ScmdCoreBuiltins, line 214")
set Qxo=0
endif
else
set Xj=Xj-1
set Qxo=Lj[Xj]
set Vj[Qxo]=$C47
endif
set EM=EM-1
return Qxo
endfunction
function QVo takes string QEo returns integer
local integer QXo
set ZM[EM]=QEo
set EM=EM+1
if Nj==0 then
if Mj<$8000 then
set Mj=Mj+1
set QXo=Mj
set wx[QXo]=4162
else
call Cdv("Out of memory: Could not create RealBinOp_reduceNumbers_setVariadicArgumentTypes_registerProtectedBuiltin_ScmdCoreBuiltins.","when calling error in ScmdCoreBuiltins, line 214")
set QXo=0
endif
else
set Nj=Nj-1
set QXo=Bj[Nj]
set wx[QXo]=4162
endif
set EM=EM-1
return QXo
endfunction
function QIo takes integer uxt,integer rxt,integer QAo,string QNo returns integer
local integer QBo
local integer QCo
local integer QDo
local integer QFo
local integer Qgo
set ZM[EM]=QNo
set EM=EM+1
set QFo=QAo
set QBo=q3o("when calling alloc_IntBinOp_reduceNumbers_setVariadicArgumentTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdCoreBuiltins, line 214")
set Qgo=QBo
set QCo=QVo("when calling alloc_RealBinOp_reduceNumbers_setVariadicArgumentTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdCoreBuiltins, line 214")
set QDo=Kde(QFo,1,Qgo,1.,QCo,"when calling reduceNumbers in ScmdCoreBuiltins, line 214")
set EM=EM-1
return QDo
endfunction
function Qho takes integer QHo returns integer
return NJ[QHo]
endfunction
function Qjo takes integer QJo,string Qko returns integer
local integer QKo
set ZM[EM]=Qko
set EM=EM+1
if Rx[QJo]==0 then
if QJo==0 then
call Cdv("Nullpointer exception when calling Context.getSymbolMap","when calling error in ScmdDataTypes, line 1230")
else
call Cdv("Called Context.getSymbolMap on invalid object.","when calling error in ScmdDataTypes, line 1230")
endif
endif
set QKo=Qho(QJo)
set EM=EM-1
return QKo
endfunction
function QLo takes integer g3t returns nothing
endfunction
function Qmo takes integer QMo,integer QPo,integer QQo,integer QUo,string QWo returns nothing
local integer Qzo
local integer QZo
local integer Q3o
local string svo
local integer sxo
set ZM[EM]=QWo
set EM=EM+1
call RCo(QMo)
call QLo(QMo)
set aK[QMo]=TEv("when calling new_HashList in ScmdDataTypes, line 1327")
set Qzo=jdv(QQo,"when calling iterator in ScmdDataTypes, line 1328")
loop
exitwhen not Jgv(Qzo,"when calling hasNext in ScmdDataTypes, line 1328")
set QZo=jTv(Qzo,"when calling next in ScmdDataTypes, line 1328")
set sxo=aK[QMo]
call fge(1,m0v(QZo,"when calling get in ScmdDataTypes, line 1329"),"when calling toString in ScmdDataTypes, line 1329")
call dlv(sxo,KCv(RHv,"when calling stringToIndex in ScmdDataTypes, line 1329"),"when calling add in ScmdDataTypes, line 1329")
endloop
call Jqv(Qzo,"when calling close in ScmdDataTypes, line 1328")
set nK[QMo]=QUo
set dK[QMo]=PTe("when calling new_IterableMap in ScmdDataTypes, line 1331")
set Q3o=jjv(Qjo(QPo,"when calling getSymbolMap in ScmdDataTypes, line 1332"),"when calling iterator in ScmdDataTypes, line 1332")
loop
exitwhen not Jgv(Q3o,"when calling hasNext in ScmdDataTypes, line 1332")
set svo=hxv(jTv(Q3o,"when calling next in ScmdDataTypes, line 1332"),"when calling stringFromIndex in ScmdDataTypes, line 1332")
call WTv(dK[QMo],KCv(svo,"when calling stringToIndex in ScmdDataTypes, line 1333"),LBo(QPo,svo,"when calling resolve in ScmdDataTypes, line 1333"),"when calling put in ScmdDataTypes, line 1333")
endloop
call Jqv(Q3o,"when calling close in ScmdDataTypes, line 1332")
set EM=EM-1
endfunction
function sVo takes string sEo returns integer
local integer sXo
set ZM[EM]=sEo
set EM=EM+1
if Sx==0 then
if cx<$8000 then
set cx=cx+1
set sXo=cx
set ox[sXo]=$EEF
else
call Cdv("Out of memory: Could not create RuntimeFunction.","when calling error in ScmdDataTypes, line 1318")
set sXo=0
endif
else
set Sx=Sx-1
set sXo=ix[Sx]
set ox[sXo]=$EEF
endif
set EM=EM-1
return sXo
endfunction
function sIo takes integer sAo,integer sNo,integer sBo,string sCo returns integer
local integer sDo
set ZM[EM]=sCo
set EM=EM+1
set sDo=sVo("when calling alloc_RuntimeFunction in ScmdDataTypes, line 1326")
call Qmo(sDo,sAo,sNo,sBo,"when calling construct_RuntimeFunction in ScmdDataTypes, line 1326")
set EM=EM-1
return sDo
endfunction
function sFo takes integer dDt returns nothing
endfunction
function sgo takes integer sho returns nothing
call sFo(sho)
if Dn==0 then
set IJ[sho]=CreateCameraSetup()
else
set IJ[sho]=An[Dn-1]
set Dn=Dn-1
call CameraSetupSetField(IJ[sho],CAMERA_FIELD_ZOFFSET,.0,.0)
call CameraSetupSetField(IJ[sho],CAMERA_FIELD_ROTATION,.0,.0)
call CameraSetupSetField(IJ[sho],CAMERA_FIELD_ANGLE_OF_ATTACK,.0,.0)
call CameraSetupSetField(IJ[sho],CAMERA_FIELD_TARGET_DISTANCE,.0,.0)
call CameraSetupSetField(IJ[sho],CAMERA_FIELD_ROLL,.0,.0)
call CameraSetupSetField(IJ[sho],CAMERA_FIELD_FIELD_OF_VIEW,.0,.0)
call CameraSetupSetField(IJ[sho],CAMERA_FIELD_FARZ,.0,.0)
call CameraSetupSetDestPosition(IJ[sho],.0,.0,.0)
endif
endfunction
function sHo takes string sjo returns integer
local integer sJo
set ZM[EM]=sjo
set EM=EM+1
if Sx==0 then
if cx<$8000 then
set cx=cx+1
set sJo=cx
set ox[sJo]=$EF0
else
call Cdv("Out of memory: Could not create CameraSetup.","when calling error in ScmdDataTypes, line 854")
set sJo=0
endif
else
set Sx=Sx-1
set sJo=ix[Sx]
set ox[sJo]=$EF0
endif
set EM=EM-1
return sJo
endfunction
function sko takes string sKo returns integer
local integer sLo
set ZM[EM]=sKo
set EM=EM+1
set sLo=sHo("when calling alloc_CameraSetup in ScmdDataTypes, line 865")
call sgo(sLo)
set EM=EM-1
return sLo
endfunction
function smo takes integer FGt,integer kGt,integer jGt,string sMo returns integer
local integer sPo
set ZM[EM]=sMo
set EM=EM+1
set sPo=p0v(sko("when calling new_CameraSetup in ScmdCameraSetupBuiltins, line 7"),"when calling new_SharedPointer in ScmdCameraSetupBuiltins, line 7")
set EM=EM-1
return sPo
endfunction
function sQo takes integer sUo returns nothing
call jje(sUo)
set cK[sUo]=CreateGroup()
endfunction
function sWo takes string szo returns integer
local integer sZo
set ZM[EM]=szo
set EM=EM+1
set sZo=jGe("when calling alloc_Group in ScmdDataTypes, line 739")
call sQo(sZo)
set EM=EM-1
return sZo
endfunction
function s3o takes integer FOi,integer kOi,integer jOi,string Svo returns integer
local integer Sxo
set ZM[EM]=Svo
set EM=EM+1
set Sxo=p0v(sWo("when calling new_Group in ScmdUnitBuiltins, line 223"),"when calling new_SharedPointer in ScmdUnitBuiltins, line 223")
set EM=EM-1
return Sxo
endfunction
function SVo takes integer gQi,integer SEo,integer SXo,string SIo returns integer
local integer SAo
local rect SNo
local integer SBo
set ZM[EM]=SIo
set EM=EM+1
set SAo=QGv(SEo,"when calling getPlayerId in SotFRP_SaveLoad, line 125")
set SNo=gOe(M7v(SXo,0,"when calling get in SotFRP_SaveLoad, line 126"),"when calling getInner in SotFRP_SaveLoad, line 126")
set af[SAo]=DQv(DSv((jse(SNo)-64.)/128.))*128.+64.
set nf[SAo]=DQv(DSv((jte(SNo)-64.)/128.))*128.+64.
set SBo=p0v(dpe("when calling new_Null in SotFRP_SaveLoad, line 129"),"when calling new_SharedPointer in SotFRP_SaveLoad, line 129")
set EM=EM-1
set SNo=null
return SBo
endfunction
function SCo takes integer Fai,integer SDo,integer SFo,string Sgo returns integer
local integer Sho
set ZM[EM]=Sgo
set EM=EM+1
call gge(Mov(SDo,"when calling getEnumUnit in ScmdUnitBuiltins, line 418"),UNIT_WEAPON_RF_ATTACK_RANGE,QNv(M7v(SFo,1,"when calling get in ScmdUnitBuiltins, line 418"),"when calling intValue in ScmdUnitBuiltins, line 418"),PEv(M7v(SFo,0,"when calling get in ScmdUnitBuiltins, line 418"),"when calling realValue in ScmdUnitBuiltins, line 418"))
set Sho=MLv("when calling nullptr in ScmdUnitBuiltins, line 419")
set EM=EM-1
return Sho
endfunction
function SHo takes integer Fei,integer kei,integer Sjo,string SJo returns integer
local integer Sko
set ZM[EM]=SJo
set EM=EM+1
set Sko=p0v(SSv(oBe(PCv(M7v(Sjo,0,"when calling get in ScmdUnitBuiltins, line 365"),"when calling getInner in ScmdUnitBuiltins, line 365"),QNv(M7v(Sjo,1,"when calling get in ScmdUnitBuiltins, line 365"),"when calling intValue in ScmdUnitBuiltins, line 365")),"when calling new_Integer in ScmdUnitBuiltins, line 365"),"when calling new_SharedPointer in ScmdUnitBuiltins, line 365")
set EM=EM-1
return Sko
endfunction
function SKo takes integer Fii,integer kii,integer SLo,string Smo returns integer
local integer SMo
set ZM[EM]=Smo
set EM=EM+1
set SMo=p0v(q2v(T6v(e_e(PCv(M7v(SLo,0,"when calling get in ScmdUnitBuiltins, line 89"),"when calling getInner in ScmdUnitBuiltins, line 89"))),"when calling new_Real in ScmdUnitBuiltins, line 89"),"when calling new_SharedPointer in ScmdUnitBuiltins, line 89")
set EM=EM-1
return SMo
endfunction
function SPo takes integer SQo returns boolean
return OU[SQo]==0
endfunction
function SUo takes integer SWo,string Szo returns boolean
local boolean SZo
set ZM[EM]=Szo
set EM=EM+1
if Oh[SWo]==0 then
if SWo==0 then
call Cdv("Nullpointer exception when calling HashList.isEmpty","when calling error in HashList, line 75")
else
call Cdv("Called HashList.isEmpty on invalid object.","when calling error in HashList, line 75")
endif
endif
set SZo=SPo(SWo)
set EM=EM-1
return SZo
endfunction
function S3o takes integer Fmi,integer kmi,integer tvo,string txo returns integer
local integer tVo
set ZM[EM]=txo
set EM=EM+1
call kMo(PCv(M7v(tvo,0,"when calling get in SotFRP_AbilitySystem, line 83"),"when calling getInner in SotFRP_AbilitySystem, line 83"),Mqv(M7v(tvo,1,"when calling get in SotFRP_AbilitySystem, line 83"),"when calling getInner in SotFRP_AbilitySystem, line 83"),QNv(M7v(tvo,2,"when calling get in SotFRP_AbilitySystem, line 83"),"when calling intValue in SotFRP_AbilitySystem, line 83"),PEv(M7v(tvo,3,"when calling get in SotFRP_AbilitySystem, line 83"),"when calling realValue in SotFRP_AbilitySystem, line 83"),"when calling setAbilityCooldown in SotFRP_AbilitySystem, line 83")
set tVo=MLv("when calling nullptr in SotFRP_AbilitySystem, line 84")
set EM=EM-1
return tVo
endfunction
function tEo takes integer tXo returns integer
return sJ[tXo]
endfunction
function tIo takes integer tAo,string tNo returns integer
local integer tBo
set ZM[EM]=tNo
set EM=EM+1
if kj[tAo]==0 then
if tAo==0 then
call Cdv("Nullpointer exception when calling Channel.log","when calling error in SLangChatSystem, line 152")
else
call Cdv("Called Channel.log on invalid object.","when calling error in SLangChatSystem, line 152")
endif
endif
set tBo=tEo(tAo)
set EM=EM-1
return tBo
endfunction
function tCo takes integer tDo,string tFo,player tgo,string tho returns nothing
local integer tHo
local string tjo
set ZM[EM]=tho
set EM=EM+1
call PreloadGenClear()
set tHo=Xle(tJ[tDo],"when calling iterator in SLangChatSystem, line 121")
loop
exitwhen not Xie(tHo)
set tjo=hxv(E3e(tHo),"when calling stringFromIndex in SLangChatSystem, line 121")
call Preload(tjo)
endloop
call Xpe(tHo,"when calling close in SLangChatSystem, line 121")
if ta==tgo then
call PreloadGenEnd("SotFRP\\LogDumps\\"+tFo+".pld")
endif
set EM=EM-1
endfunction
function tJo takes integer tko,string tKo,player tLo,string tmo returns nothing
set ZM[EM]=tmo
set EM=EM+1
if mj[tko]==0 then
if tko==0 then
call Cdv("Nullpointer exception when calling Log.dump","when calling error in SLangChatSystem, line 119")
else
call Cdv("Called Log.dump on invalid object.","when calling error in SLangChatSystem, line 119")
endif
endif
call tCo(tko,tKo,tLo,"when calling dump in SLangChatSystem, line 119")
set EM=EM-1
endfunction
function tMo takes integer Gpt,integer tPo,integer tQo,string tUo returns integer
local boolean tWo
local string tzo
local integer tZo
local integer t3o
set ZM[EM]=tUo
set EM=EM+1
set tWo=true
set tzo=XAx(Mqv(M7v(tQo,0,"when calling get in SLangChatSystem, line 192"),"when calling getInner in SLangChatSystem, line 192"))
if tzo=="IC" then
call tJo(tIo(Ha,"when calling log in SLangChatSystem, line 194"),Mqv(M7v(tQo,1,"when calling get in SLangChatSystem, line 194"),"when calling getInner in SLangChatSystem, line 194"),sa[QGv(tPo,"when calling getPlayerId in SLangChatSystem, line 194")],"when calling dump in SLangChatSystem, line 194")
elseif tzo=="OOC" then
call tJo(tIo(Ja,"when calling log in SLangChatSystem, line 196"),Mqv(M7v(tQo,1,"when calling get in SLangChatSystem, line 196"),"when calling getInner in SLangChatSystem, line 196"),sa[QGv(tPo,"when calling getPlayerId in SLangChatSystem, line 196")],"when calling dump in SLangChatSystem, line 196")
else
set tWo=false
endif
if tWo then
set tZo=MLv("when calling nullptr in SLangChatSystem, line 199")
else
set tZo=p0v(tJv("Wrong channel","when calling new_Exception in SLangChatSystem, line 199"),"when calling new_SharedPointer in SLangChatSystem, line 199")
endif
set t3o=tZo
set EM=EM-1
return t3o
endfunction
function Tvo takes player Txo,real TVo returns nothing
set uZ[Hpe(Txo)]=TVo
endfunction
function TEo takes integer Fsi,integer TXo,integer TIo,string TAo returns integer
local integer TNo
set ZM[EM]=TAo
set EM=EM+1
call Tvo(sa[QGv(TXo,"when calling getPlayerId in ScmdSystemsSettingsBuiltins, line 13")],PEv(M7v(TIo,0,"when calling get in ScmdSystemsSettingsBuiltins, line 13"),"when calling realValue in ScmdSystemsSettingsBuiltins, line 13"))
set TNo=MLv("when calling nullptr in ScmdSystemsSettingsBuiltins, line 14")
set EM=EM-1
return TNo
endfunction
function TBo takes integer YMt returns nothing
endfunction
function TCo takes integer TDo,real TFo,real Tgo,real Tho,real THo returns nothing
call TBo(TDo)
set eK[TDo]=Rect(TFo,Tgo,Tho,THo)
endfunction
function Tjo takes string TJo returns integer
local integer Tko
set ZM[EM]=TJo
set EM=EM+1
if Sx==0 then
if cx<$8000 then
set cx=cx+1
set Tko=cx
set ox[Tko]=$F04
else
call Cdv("Out of memory: Could not create Rect.","when calling error in ScmdDataTypes, line 678")
set Tko=0
endif
else
set Sx=Sx-1
set Tko=ix[Sx]
set ox[Tko]=$F04
endif
set EM=EM-1
return Tko
endfunction
function TKo takes real TLo,real Tmo,real TMo,real TPo,string TQo returns integer
local integer TUo
set ZM[EM]=TQo
set EM=EM+1
set TUo=Tjo("when calling alloc_Rect in ScmdDataTypes, line 687")
call TCo(TUo,TLo,Tmo,TMo,TPo)
set EM=EM-1
return TUo
endfunction
function TWo takes integer Fui,integer kui,integer Tzo,string TZo returns integer
local integer T3o
set ZM[EM]=TZo
set EM=EM+1
set T3o=p0v(TKo(PEv(M7v(Tzo,0,"when calling get in ScmdRectBuiltins, line 11"),"when calling realValue in ScmdRectBuiltins, line 11"),PEv(M7v(Tzo,1,"when calling get in ScmdRectBuiltins, line 11"),"when calling realValue in ScmdRectBuiltins, line 11"),PEv(M7v(Tzo,2,"when calling get in ScmdRectBuiltins, line 11"),"when calling realValue in ScmdRectBuiltins, line 11"),PEv(M7v(Tzo,3,"when calling get in ScmdRectBuiltins, line 11"),"when calling realValue in ScmdRectBuiltins, line 11"),"when calling new_Rect in ScmdRectBuiltins, line 11"),"when calling new_SharedPointer in ScmdRectBuiltins, line 11")
set EM=EM-1
return T3o
endfunction
function uvo takes integer Fyi,integer uxo,integer uVo,string uEo returns integer
local integer uXo
set ZM[EM]=uEo
set EM=EM+1
call Rqe(Mov(uxo,"when calling getEnumUnit in ScmdUnitBuiltins, line 307"),PEv(M7v(uVo,0,"when calling get in ScmdUnitBuiltins, line 307"),"when calling realValue in ScmdUnitBuiltins, line 307"))
set uXo=MLv("when calling nullptr in ScmdUnitBuiltins, line 308")
set EM=EM-1
return uXo
endfunction
function uIo takes integer y0i,integer p0i,integer uAo,string uNo returns integer
local integer uBo
set ZM[EM]=uNo
set EM=EM+1
call IOe(Wlv(M7v(uAo,0,"when calling get in ScmdItemBuiltins, line 26"),"when calling getInner in ScmdItemBuiltins, line 26"),Mqv(M7v(uAo,1,"when calling get in ScmdItemBuiltins, line 26"),"when calling getInner in ScmdItemBuiltins, line 26"))
set uBo=MLv("when calling nullptr in ScmdItemBuiltins, line 27")
set EM=EM-1
return uBo
endfunction
function uCo takes integer yRi,integer pRi,integer uDo,string uFo returns integer
local integer ugo
set ZM[EM]=uFo
set EM=EM+1
set ugo=p0v(qRv(iLo(PCv(M7v(uDo,0,"when calling get in ScmdUnitBuiltins, line 627"),"when calling getInner in ScmdUnitBuiltins, line 627"),Mqv(M7v(uDo,1,"when calling get in ScmdUnitBuiltins, line 627"),"when calling getInner in ScmdUnitBuiltins, line 627")),"when calling new_Boolean in ScmdUnitBuiltins, line 627"),"when calling new_SharedPointer in ScmdUnitBuiltins, line 627")
set EM=EM-1
return ugo
endfunction
function uho takes integer yYi,integer uHo,integer ujo,string uJo returns integer
local integer uko
set ZM[EM]=uJo
set EM=EM+1
call Rue(Mov(uHo,"when calling getEnumUnit in ScmdUnitBuiltins, line 683"),dve(uev(Mov(uHo,"when calling getEnumUnit in ScmdUnitBuiltins, line 683"))+PEv(M7v(ujo,0,"when calling get in ScmdUnitBuiltins, line 683"),"when calling realValue in ScmdUnitBuiltins, line 683"),VT,CT))
set uko=MLv("when calling nullptr in ScmdUnitBuiltins, line 684")
set EM=EM-1
return uko
endfunction
function uKo takes integer yci,integer pci,integer uLo,string umo returns integer
local integer uMo
set ZM[EM]=umo
set EM=EM+1
call ASe(PCv(M7v(uLo,0,"when calling get in ScmdUnitBuiltins, line 133"),"when calling getInner in ScmdUnitBuiltins, line 133"),PEv(M7v(uLo,1,"when calling get in ScmdUnitBuiltins, line 133"),"when calling realValue in ScmdUnitBuiltins, line 133"))
set uMo=MLv("when calling nullptr in ScmdUnitBuiltins, line 134")
set EM=EM-1
return uMo
endfunction
function uPo takes integer lnt,integer uQo,integer uUo,string uWo returns integer
local player uzo
local integer uZo
local integer u3o
set ZM[EM]=uWo
set EM=EM+1
set uzo=l8e(tZv(Mqv(M7v(uUo,0,"when calling get in SLangPlayerFunctions, line 51"),"when calling getInner in SLangPlayerFunctions, line 51")))
if uzo!=null then
set uZo=p0v(qRv(GetPlayerAlliance(sa[QGv(uQo,"when calling getPlayerId in SLangPlayerFunctions, line 52")],uzo,ALLIANCE_SHARED_VISION),"when calling new_Boolean in SLangPlayerFunctions, line 52"),"when calling new_SharedPointer in SLangPlayerFunctions, line 52")
else
set uZo=l5e("when calling newWCNException in SLangPlayerFunctions, line 52")
endif
set u3o=uZo
set EM=EM-1
set uzo=null
return u3o
endfunction
function Uvo takes integer yoi,integer poi,integer Uxo,string UVo returns integer
local integer UEo
set ZM[EM]=UVo
set EM=EM+1
call Nde(PCv(M7v(Uxo,0,"when calling get in ScmdUnitBuiltins, line 158"),"when calling getInner in ScmdUnitBuiltins, line 158"),PEv(M7v(Uxo,1,"when calling get in ScmdUnitBuiltins, line 158"),"when calling realValue in ScmdUnitBuiltins, line 158"))
set UEo=MLv("when calling nullptr in ScmdUnitBuiltins, line 159")
set EM=EM-1
return UEo
endfunction
function UXo takes integer UIo returns integer
return sK[UIo]
endfunction
function UAo takes integer UNo,string UBo returns integer
local integer UCo
set ZM[EM]=UBo
set EM=EM+1
if ox[UNo]==0 then
if UNo==0 then
call Cdv("Nullpointer exception when calling Expression.getArgs","when calling error in ScmdDataTypes, line 1610")
else
call Cdv("Called Expression.getArgs on invalid object.","when calling error in ScmdDataTypes, line 1610")
endif
endif
set UCo=UXo(UNo)
set EM=EM-1
return UCo
endfunction
function UDo takes integer sTi,integer UFo,integer Ugo,string Uho returns integer
local integer UHo
set ZM[EM]=Uho
set EM=EM+1
call RWe(Mov(UFo,"when calling getEnumUnit in ScmdUnitBuiltins, line 651"),dve(PEv(M7v(Ugo,0,"when calling get in ScmdUnitBuiltins, line 651"),"when calling realValue in ScmdUnitBuiltins, line 651"),XT,LT))
set UHo=MLv("when calling nullptr in ScmdUnitBuiltins, line 652")
set EM=EM-1
return UHo
endfunction
function Ujo takes integer rWt,integer sWt,integer UJo,string Uko returns integer
local integer UKo
local integer ULo
set ZM[EM]=Uko
set EM=EM+1
if SNv(UJo,"when calling size in ScmdCoreBuiltins, line 327")!=0 then
set UKo=MJv(Joe(UJo,SNv(UJo,"when calling size in ScmdCoreBuiltins, line 327")-1,"when calling getPtr in ScmdCoreBuiltins, line 327"),"when calling clone in ScmdCoreBuiltins, line 327")
else
set UKo=MLv("when calling nullptr in ScmdCoreBuiltins, line 327")
endif
set ULo=UKo
set EM=EM-1
return ULo
endfunction
function Umo takes integer sfi,integer tfi,integer UMo,string UPo returns integer
local integer UQo
set ZM[EM]=UPo
set EM=EM+1
set UQo=p0v(SSv(Zav(PCv(M7v(UMo,0,"when calling get in ScmdUnitBuiltins, line 582"),"when calling getInner in ScmdUnitBuiltins, line 582"),WCv(M7v(UMo,1,"when calling get in ScmdUnitBuiltins, line 582"),"when calling booleanValue in ScmdUnitBuiltins, line 582")),"when calling new_Integer in ScmdUnitBuiltins, line 582"),"when calling new_SharedPointer in ScmdUnitBuiltins, line 582")
set EM=EM-1
return UQo
endfunction
function UUo takes effect UWo,integer Uzo,integer UZo,integer U3o,integer wvo returns nothing
call BlzSetSpecialEffectColor(UWo,Uzo,UZo,U3o)
call BlzSetSpecialEffectAlpha(UWo,wvo)
endfunction
function wxo takes integer sft,integer tft,integer wVo,string wEo returns integer
local integer wXo
set ZM[EM]=wEo
set EM=EM+1
call UUo(Pov(M7v(wVo,0,"when calling get in SLangSpecialEffectFunctions, line 15"),"when calling getInner in SLangSpecialEffectFunctions, line 15"),QNv(M7v(wVo,1,"when calling get in SLangSpecialEffectFunctions, line 15"),"when calling intValue in SLangSpecialEffectFunctions, line 15"),QNv(M7v(wVo,2,"when calling get in SLangSpecialEffectFunctions, line 15"),"when calling intValue in SLangSpecialEffectFunctions, line 15"),QNv(M7v(wVo,3,"when calling get in SLangSpecialEffectFunctions, line 15"),"when calling intValue in SLangSpecialEffectFunctions, line 15"),QNv(M7v(wVo,4,"when calling get in SLangSpecialEffectFunctions, line 15"),"when calling intValue in SLangSpecialEffectFunctions, line 15"))
set wXo=MLv("when calling nullptr in SLangSpecialEffectFunctions, line 16")
set EM=EM-1
return wXo
endfunction
function wIo takes integer oai,integer Oai,integer wAo,string wNo returns integer
local integer wBo
set ZM[EM]=wNo
set EM=EM+1
set wBo=p0v(qRv(aJo(PCv(M7v(wAo,0,"when calling get in ScmdUnitBuiltins, line 410"),"when calling getInner in ScmdUnitBuiltins, line 410"),UNIT_WEAPON_BF_ATTACKS_ENABLED,QNv(M7v(wAo,1,"when calling get in ScmdUnitBuiltins, line 410"),"when calling intValue in ScmdUnitBuiltins, line 410"),WCv(M7v(wAo,2,"when calling get in ScmdUnitBuiltins, line 410"),"when calling booleanValue in ScmdUnitBuiltins, line 410")),"when calling new_Boolean in ScmdUnitBuiltins, line 410"),"when calling new_SharedPointer in ScmdUnitBuiltins, line 410")
set EM=EM-1
return wBo
endfunction
function wCo takes integer sdt,integer wDo,integer wFo,string wgo returns integer
local player who
local integer wHo
local integer wjo
local integer wJo
local player wko
local integer wKo
set ZM[EM]=wgo
set EM=EM+1
set wko=Onx(Mqv(M7v(wFo,0,"when calling get in SLangPlayerFunctions, line 96"),"when calling getInner in SLangPlayerFunctions, line 96"),"when calling resolvePlayer in SLangPlayerFunctions, line 96")
set wKo=v1
set who=wko
set wHo=wKo
if wHo==0 then
call SetPlayerAllianceStateAllyBJ(sa[QGv(wDo,"when calling getPlayerId in SLangPlayerFunctions, line 98")],who,false)
endif
if wHo!=0 then
set wjo=wHo
else
set wjo=MLv("when calling nullptr in SLangPlayerFunctions, line 99")
endif
set wJo=wjo
set EM=EM-1
set who=null
set wko=null
return wJo
endfunction
function wLo takes integer oei,integer wmo,integer wMo,string wPo returns integer
local integer wQo
set ZM[EM]=wPo
set EM=EM+1
call N2e(Mov(wmo,"when calling getEnumUnit in ScmdUnitBuiltins, line 356"),QNv(M7v(wMo,0,"when calling get in ScmdUnitBuiltins, line 356"),"when calling intValue in ScmdUnitBuiltins, line 356"),QNv(M7v(wMo,1,"when calling get in ScmdUnitBuiltins, line 356"),"when calling intValue in ScmdUnitBuiltins, line 356"))
set wQo=MLv("when calling nullptr in ScmdUnitBuiltins, line 357")
set EM=EM-1
return wQo
endfunction
function wUo takes integer oii,integer wWo,integer wzo,string wZo returns integer
local integer w3o
set ZM[EM]=wZo
set EM=EM+1
call Age(Mov(wWo,"when calling getEnumUnit in ScmdUnitBuiltins, line 80"),vde(PEv(M7v(wzo,0,"when calling get in ScmdUnitBuiltins, line 80"),"when calling realValue in ScmdUnitBuiltins, line 80")))
set w3o=MLv("when calling nullptr in ScmdUnitBuiltins, line 81")
set EM=EM-1
return w3o
endfunction
function Wvo takes integer okt,integer Okt,integer Wxo,string WVo returns integer
local integer WEo
set ZM[EM]=WVo
set EM=EM+1
set WEo=p0v(Ppv(HXe(Mqv(M7v(Wxo,0,"when calling get in ScmdCoreBuiltins, line 150"),"when calling getInner in ScmdCoreBuiltins, line 150"),Mqv(M7v(Wxo,1,"when calling get in ScmdCoreBuiltins, line 150"),"when calling getInner in ScmdCoreBuiltins, line 150"),Mqv(M7v(Wxo,2,"when calling get in ScmdCoreBuiltins, line 150"),"when calling getInner in ScmdCoreBuiltins, line 150")),"when calling new_String in ScmdCoreBuiltins, line 150"),"when calling new_SharedPointer in ScmdCoreBuiltins, line 150")
set EM=EM-1
return WEo
endfunction
function WXo takes integer omi,integer WIo,integer WAo,string WNo returns integer
local integer WBo
set ZM[EM]=WNo
set EM=EM+1
call CZo(Mov(WIo,"when calling getEnumUnit in SotFRP_AbilitySystem, line 73"),Mqv(M7v(WAo,0,"when calling get in SotFRP_AbilitySystem, line 73"),"when calling getInner in SotFRP_AbilitySystem, line 73"),QNv(M7v(WAo,1,"when calling get in SotFRP_AbilitySystem, line 73"),"when calling intValue in SotFRP_AbilitySystem, line 73"),QNv(M7v(WAo,2,"when calling get in SotFRP_AbilitySystem, line 73"),"when calling intValue in SotFRP_AbilitySystem, line 73"),"when calling setAbilityManaCost in SotFRP_AbilitySystem, line 73")
set WBo=MLv("when calling nullptr in SotFRP_AbilitySystem, line 74")
set EM=EM-1
return WBo
endfunction
function WCo takes integer osi,integer Osi,integer lsi,string WDo returns integer
local integer WFo
set ZM[EM]=WDo
set EM=EM+1
call ResumeMusic()
set WFo=MLv("when calling nullptr in ScmdSoundFunctions, line 28")
set EM=EM-1
return WFo
endfunction
function Wgo takes integer oyi,integer Oyi,integer Who,string WHo returns integer
local integer Wjo
set ZM[EM]=WHo
set EM=EM+1
call SetWidgetLife(qqv(M7v(Who,0,"when calling get in ScmdUnitBuiltins, line 298"),"when calling getInner in ScmdUnitBuiltins, line 298"),PEv(M7v(Who,1,"when calling get in ScmdUnitBuiltins, line 298"),"when calling realValue in ScmdUnitBuiltins, line 298"))
set Wjo=MLv("when calling nullptr in ScmdUnitBuiltins, line 299")
set EM=EM-1
return Wjo
endfunction
function WJo takes integer l9i,integer b9i,integer y9i,string Wko returns integer
local integer WKo
set ZM[EM]=Wko
set EM=EM+1
call FogMaskEnable(false)
call FogEnable(false)
set WKo=MLv("when calling nullptr in ScmdFogOfWarBuiltins, line 26")
set EM=EM-1
return WKo
endfunction
function WLo takes integer lFi,integer Wmo,integer WMo,string WPo returns integer
local integer WQo
set ZM[EM]=WPo
set EM=EM+1
call S1e(Mov(Wmo,"when calling getEnumUnit in ScmdUnitBuiltins, line 793"),Mqv(M7v(WMo,0,"when calling get in ScmdUnitBuiltins, line 793"),"when calling getInner in ScmdUnitBuiltins, line 793"))
set WQo=MLv("when calling nullptr in ScmdUnitBuiltins, line 794")
set EM=EM-1
return WQo
endfunction
function WUo takes integer WWo,integer Wzo,string WZo returns integer
local integer W3o
local integer yvo
local string yxo
local string yVo
local integer yEo
local integer yXo
local integer yIo
local integer yAo
local integer yNo
local integer yBo
local integer yCo
local integer yDo
set ZM[EM]=WZo
set EM=EM+1
set W3o=0
set yvo=SNv(Wzo,"when calling size in ScmdDataTypes, line 1447")-1
loop
exitwhen yvo<0
set yCo=ox[M7v(Wzo,yvo,"when calling get in ScmdDataTypes, line 1448")]
if yCo>=$EFB and yCo<=$EFF then
set W3o=W3o+1
else
exitwhen true
endif
set yvo=yvo-1
endloop
set yxo=""
set yVo=""
set yEo=dgv(WJ[WWo],"when calling size in ScmdDataTypes, line 1454")-1
loop
exitwhen yEo<0
set yXo=jqv(WJ[WWo],yEo,"when calling get in ScmdDataTypes, line 1455")
if SNv(Wzo,"when calling size in ScmdDataTypes, line 1456")>xJ[yXo]then
if SNv(Wzo,"when calling size in ScmdDataTypes, line 1457")-xJ[yXo]>W3o-1 then
exitwhen true
endif
set yIo=0
set yAo=SNv(Wzo,"when calling size in ScmdDataTypes, line 1460")-xJ[yXo]+1
loop
exitwhen not(yIo!=yAo)
set yNo=Joe(Wzo,SNv(Wzo,"when calling size in ScmdDataTypes, line 1462")-1,"when calling getPtr in ScmdDataTypes, line 1462")
set yDo=ox[iNo(yNo,"when calling get in ScmdDataTypes, line 1463")]
if not(yDo>=$EFB and yDo<=$EFF)then
exitwhen true
endif
call gko(Wzo,SNv(Wzo,"when calling size in ScmdDataTypes, line 1465")-1,"when calling removeAt in ScmdDataTypes, line 1465")
call fge(1,iNo(yNo,"when calling get in ScmdDataTypes, line 1466"),"when calling toString in ScmdDataTypes, line 1466")
set yVo=RHv+yxo+yVo
set yxo=M8e(iNo(yNo,"when calling get in ScmdDataTypes, line 1467"),"when calling getPreviousWhitespaces in ScmdDataTypes, line 1467")
call mfv(17,yNo,"when calling dispatch_SharedPointer_destroySharedPointer in ScmdDataTypes, line 1468")
set W3o=W3o-1
set yIo=yIo+1
endloop
if yIo!=0 then
call gWo(Wzo,p0v(cCo(yVo,yxo,"when calling forStrings in ScmdDataTypes, line 1472"),"when calling new_SharedPointer in ScmdDataTypes, line 1472"),"when calling add in ScmdDataTypes, line 1472")
endif
endif
if SNv(Wzo,"when calling size in ScmdDataTypes, line 1473")==xJ[yXo]then
set yBo=1
loop
exitwhen not(yBo<=W3o and FMo(G8e(jJ[yXo],xJ[yXo]-yBo,"when calling get in ScmdDataTypes, line 1475"),M7v(Wzo,xJ[yXo]-yBo,"when calling get in ScmdDataTypes, line 1475"),"when calling isInstance in ScmdDataTypes, line 1475"))
set yBo=yBo+1
endloop
if yBo>W3o then
set EM=EM-1
return yXo
endif
endif
set yEo=yEo-1
endloop
set EM=EM-1
return EJ[WWo]
endfunction
function yFo takes integer ygo,integer yho,string yHo returns integer
local integer yjo
set ZM[EM]=yHo
set EM=EM+1
if ox[ygo]==0 then
if ygo==0 then
call Cdv("Nullpointer exception when calling BuiltinFunction.resolveOverload","when calling error in ScmdDataTypes, line 1445")
else
call Cdv("Called BuiltinFunction.resolveOverload on invalid object.","when calling error in ScmdDataTypes, line 1445")
endif
endif
set yjo=WUo(ygo,yho,"when calling resolveOverload in ScmdDataTypes, line 1445")
set EM=EM-1
return yjo
endfunction
function yJo takes integer yko,integer yKo returns nothing
set EW[yko]=yKo
endfunction
function yLo takes integer ymo,integer yMo,string yPo returns nothing
set ZM[EM]=yPo
set EM=EM+1
if Gg[ymo]==0 then
if ymo==0 then
call Cdv("Nullpointer exception when calling CustomUnitType.setBaseTypeId","when calling error in CustomUnitTypes, line 111")
else
call Cdv("Called CustomUnitType.setBaseTypeId on invalid object.","when calling error in CustomUnitTypes, line 111")
endif
endif
call yJo(ymo,yMo)
set EM=EM-1
endfunction
function yQo takes integer yUo,integer yWo,integer yzo,string yZo returns nothing
set ZM[EM]=yZo
set EM=EM+1
call yLo(tQe(yUo,yWo,"when calling getSlot in PlayerDefinedUnitTypes, line 42"),yzo,"when calling setBaseTypeId in PlayerDefinedUnitTypes, line 42")
call VIx(yUo,"when calling save in PlayerDefinedUnitTypes, line 43")
set EM=EM-1
endfunction
function y3o takes integer Yvo,integer Yxo,integer YVo,string YEo returns nothing
set ZM[EM]=YEo
set EM=EM+1
if Gg[Yvo]==0 then
if Yvo==0 then
call Cdv("Nullpointer exception when calling PlayerDefinedUnitTypes.setBaseTypeId","when calling error in PlayerDefinedUnitTypes, line 41")
else
call Cdv("Called PlayerDefinedUnitTypes.setBaseTypeId on invalid object.","when calling error in PlayerDefinedUnitTypes, line 41")
endif
endif
call yQo(Yvo,Yxo,YVo,"when calling setBaseTypeId in PlayerDefinedUnitTypes, line 41")
set EM=EM-1
endfunction
function YXo takes integer YIo,integer YAo,integer YNo,string YBo returns nothing
set ZM[EM]=YBo
set EM=EM+1
call y3o(Vq[YIo],YAo,YNo,"when calling setBaseTypeId in UnitShops, line 143")
call Vwx(YIo,YAo,true,"when calling makeSlotAvailable in UnitShops, line 144")
set EM=EM-1
endfunction
function YCo takes integer lSS,integer YDo,integer YFo,string Ygo returns integer
local integer Yho
set ZM[EM]=Ygo
set EM=EM+1
call YXo(QGv(YDo,"when calling getPlayerId in UnitShopsBuiltins, line 9"),QNv(M7v(YFo,0,"when calling get in UnitShopsBuiltins, line 9"),"when calling intValue in UnitShopsBuiltins, line 9"),QNv(M7v(YFo,1,"when calling get in UnitShopsBuiltins, line 9"),"when calling intValue in UnitShopsBuiltins, line 9"),"when calling setCustomUnitTypeBaseId in UnitShopsBuiltins, line 9")
set Yho=MLv("when calling nullptr in UnitShopsBuiltins, line 10")
set EM=EM-1
return Yho
endfunction
function YHo takes trigger Yjo,region YJo,boolexpr Yko returns event
return TriggerRegisterEnterRegion(Yjo,YJo,Yko)
endfunction
function YKo takes region YLo,rect Ymo returns nothing
call RegionAddRect(YLo,Ymo)
endfunction
function YMo takes string YPo returns integer
local integer YQo
set ZM[EM]=YPo
set EM=EM+1
if Sx==0 then
if cx<$8000 then
set cx=cx+1
set YQo=cx
set ox[YQo]=$F05
else
call Cdv("Out of memory: Could not create Region.","when calling error in ScmdDataTypes, line 708")
set YQo=0
endif
else
set Sx=Sx-1
set YQo=ix[Sx]
set ox[YQo]=$F05
endif
set EM=EM-1
return YQo
endfunction
function YUo takes integer o3t returns nothing
endfunction
function YWo takes integer Yzo,region YZo returns nothing
call YUo(Yzo)
set qK[Yzo]=YZo
endfunction
function Y3o takes region zvo,string zeo returns integer
local integer zxo
set ZM[EM]=zeo
set EM=EM+1
set zxo=YMo("when calling alloc_Region in ScmdDataTypes, line 714")
call YWo(zxo,zvo)
set EM=EM-1
return zxo
endfunction
function zoo takes integer zro,integer zio,string zao returns nothing
set ZM[EM]=zao
set EM=EM+1
call dlv(QK[zro],zio,"when calling add in ScmdDataTypes, line 978")
set EM=EM-1
endfunction
function zno takes integer zVo,integer zEo,string zXo returns nothing
set ZM[EM]=zXo
set EM=EM+1
if ox[zVo]==0 then
if zVo==0 then
call Cdv("Nullpointer exception when calling Trigger.addOwnedObject","when calling error in ScmdDataTypes, line 977")
else
call Cdv("Called Trigger.addOwnedObject on invalid object.","when calling error in ScmdDataTypes, line 977")
endif
endif
call zoo(zVo,zEo,"when calling addOwnedObject in ScmdDataTypes, line 977")
set EM=EM-1
endfunction
function zOo takes integer cTt,integer oTt,integer zRo,string zIo returns integer
local integer zAo
local rect zNo
local region zbo
local integer zBo
set ZM[EM]=zIo
set EM=EM+1
set zAo=M7v(zRo,0,"when calling get in SLangTriggerFunctions, line 76")
set zNo=gOe(M7v(zRo,1,"when calling get in SLangTriggerFunctions, line 77"),"when calling getInner in SLangTriggerFunctions, line 77")
if zNo==We then
call YHo(qGv(zAo,"when calling getInner in SLangTriggerFunctions, line 79"),Ee,null)
else
set zbo=CreateRegion()
call YKo(zbo,zNo)
call YHo(qGv(zAo,"when calling getInner in SLangTriggerFunctions, line 83"),zbo,null)
call zno(zAo,Y3o(zbo,"when calling new_Region in SLangTriggerFunctions, line 84"),"when calling addOwnedObject in SLangTriggerFunctions, line 84")
endif
call GPo(qGv(zAo,"when calling getInner in SLangTriggerFunctions, line 85"),Condition(Rdv))
set zBo=MLv("when calling nullptr in SLangTriggerFunctions, line 88")
set EM=EM-1
set zNo=null
set zbo=null
return zBo
endfunction
function zco takes integer odi,integer zCo,integer zdo,string zDo returns integer
local unit zfo
local integer zFo
local integer zgo
set ZM[EM]=zDo
set EM=EM+1
set zfo=Mov(zCo,"when calling getEnumUnit in ScmdUnitBuiltins, line 551")
set zFo=QNv(M7v(zdo,0,"when calling get in ScmdUnitBuiltins, line 552"),"when calling intValue in ScmdUnitBuiltins, line 552")
if zFo>=dDe(zfo)then
call dAe(zfo,zFo,false)
else
call dce(zfo,dDe(zfo)-zFo)
endif
set zgo=MLv("when calling nullptr in ScmdUnitBuiltins, line 557")
set EM=EM-1
set zfo=null
return zgo
endfunction
function zGo takes integer lgi,integer bgi,integer zho,string zHo returns integer
local integer zjo
set ZM[EM]=zHo
set EM=EM+1
call O3e(PCv(M7v(zho,0,"when calling get in ScmdUnitBuiltins, line 739"),"when calling getInner in ScmdUnitBuiltins, line 739"))
set zjo=MLv("when calling nullptr in ScmdUnitBuiltins, line 740")
set EM=EM-1
return zjo
endfunction
function zJo takes string zko returns boolean
return zko!=null and GZv(Puv(zko))>0
endfunction
function zKo takes integer ljt,integer bjt,integer zlo,string zLo returns integer
local integer zmo
set ZM[EM]=zLo
set EM=EM+1
set zmo=p0v(qRv(not zJo(Mqv(M7v(zlo,0,"when calling get in ScmdCoreBuiltins, line 175"),"when calling getInner in ScmdCoreBuiltins, line 175")),"when calling new_Boolean in ScmdCoreBuiltins, line 175"),"when calling new_SharedPointer in ScmdCoreBuiltins, line 175")
set EM=EM-1
return zmo
endfunction
function zMo takes integer cti,integer zpo,integer Oti,string zPo returns integer
local player zqo
local string zQo
local string zso
local integer zSo
set ZM[EM]=zPo
set EM=EM+1
set zqo=HVo(Mov(zpo,"when calling getEnumUnit in ScmdUnitBuiltins, line 51"))
if zqo==sa[PLAYER_NEUTRAL_AGGRESSIVE]then
set zso="hostile"
else
if zqo==sa[PLAYER_NEUTRAL_PASSIVE]then
set zQo="neutral"
else
set zQo=jXe(g_e(zqo))
endif
set zso=zQo
endif
set zSo=p0v(Ppv(zso,"when calling new_String in ScmdUnitBuiltins, line 52"),"when calling new_SharedPointer in ScmdUnitBuiltins, line 52")
set EM=EM-1
set zqo=null
return zSo
endfunction
function zto takes string zTo returns integer
local integer zuo
set ZM[EM]=zTo
set EM=EM+1
if Xj==0 then
if Cj<$8000 then
set Cj=Cj+1
set zuo=Cj
set Vj[zuo]=$C44
else
call Cdv("Out of memory: Could not create IntBinOp_reduceNumbers_setArgumentsTypes_setVariadicArgumentTypes_registerProtectedBuiltin_ScmdCoreBuiltins.","when calling error in ScmdCoreBuiltins, line 264")
set zuo=0
endif
else
set Xj=Xj-1
set zuo=Lj[Xj]
set Vj[zuo]=$C44
endif
set EM=EM-1
return zuo
endfunction
function zUo takes string zwo returns integer
local integer zWo
set ZM[EM]=zwo
set EM=EM+1
if Nj==0 then
if Mj<$8000 then
set Mj=Mj+1
set zWo=Mj
set wx[zWo]=4159
else
call Cdv("Out of memory: Could not create RealBinOp_reduceNumbers_setArgumentsTypes_setVariadicArgumentTypes_registerProtectedBuiltin_ScmdCoreBuiltins.","when calling error in ScmdCoreBuiltins, line 264")
set zWo=0
endif
else
set Nj=Nj-1
set zWo=Bj[Nj]
set wx[zWo]=4159
endif
set EM=EM-1
return zWo
endfunction
function zyo takes integer tvt,integer ivt,integer zYo,string zzo returns integer
local integer zZo
local integer z_o
local integer z0o
local integer z1o
local integer z2o
local integer z3o
local real z4o
set ZM[EM]=zzo
set EM=EM+1
set z1o=zYo
set z2o=xe
set zZo=zto("when calling alloc_IntBinOp_reduceNumbers_setArgumentsTypes_setVariadicArgumentTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdCoreBuiltins, line 264")
set z3o=zZo
set z4o=ka
set z_o=zUo("when calling alloc_RealBinOp_reduceNumbers_setArgumentsTypes_setVariadicArgumentTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdCoreBuiltins, line 264")
set z0o=Kde(z1o,z2o,z3o,z4o,z_o,"when calling reduceNumbers in ScmdCoreBuiltins, line 264")
set EM=EM-1
return z0o
endfunction
function z5o takes integer VWt,integer z6o,integer z7o,string z8o returns integer
local integer z9o
local integer Zvo
set ZM[EM]=z8o
set EM=EM+1
if CIe(QGv(z6o,"when calling getPlayerId in ScmdCoreBuiltins, line 376"),Mqv(M7v(z7o,0,"when calling get in ScmdCoreBuiltins, line 376"),"when calling getInner in ScmdCoreBuiltins, line 376"),MJv(Joe(z7o,1,"when calling getPtr in ScmdCoreBuiltins, line 376"),"when calling clone in ScmdCoreBuiltins, line 376"),"when calling assign in ScmdCoreBuiltins, line 376")then
set z9o=MLv("when calling nullptr in ScmdCoreBuiltins, line 376")
else
set z9o=p0v(tJv("Symbol is protected","when calling new_Exception in ScmdCoreBuiltins, line 376"),"when calling new_SharedPointer in ScmdCoreBuiltins, line 376")
endif
set Zvo=z9o
set EM=EM-1
return Zvo
endfunction
function Zxo takes integer BYi,integer NYi,integer ZVo,string ZEo returns integer
local integer ZXo
set ZM[EM]=ZEo
set EM=EM+1
set ZXo=p0v(qRv(IsUnitType(PCv(M7v(ZVo,0,"when calling get in ScmdUnitBuiltins, line 701"),"when calling getInner in ScmdUnitBuiltins, line 701"),UNIT_TYPE_STRUCTURE),"when calling new_Boolean in ScmdUnitBuiltins, line 701"),"when calling new_SharedPointer in ScmdUnitBuiltins, line 701")
set EM=EM-1
return ZXo
endfunction
function ZIo takes integer Boi,integer Noi,integer ZAo,string ZNo returns integer
local integer ZBo
set ZM[EM]=ZNo
set EM=EM+1
set ZBo=p0v(SSv(rde(PCv(M7v(ZAo,0,"when calling get in ScmdUnitBuiltins, line 178"),"when calling getInner in ScmdUnitBuiltins, line 178")),"when calling new_Integer in ScmdUnitBuiltins, line 178"),"when calling new_SharedPointer in ScmdUnitBuiltins, line 178")
set EM=EM-1
return ZBo
endfunction
function ZCo takes integer BRi,integer NRi,integer ZDo,string ZFo returns integer
local integer Zgo
set ZM[EM]=ZFo
set EM=EM+1
set Zgo=p0v(q2v(GetUnitFacing(PCv(M7v(ZDo,0,"when calling get in ScmdUnitBuiltins, line 647"),"when calling getInner in ScmdUnitBuiltins, line 647")),"when calling new_Real in ScmdUnitBuiltins, line 647"),"when calling new_SharedPointer in ScmdUnitBuiltins, line 647")
set EM=EM-1
return Zgo
endfunction
function Zho takes integer Knt,integer ZHo,integer Zjo,string ZJo returns integer
local player Zko
local integer ZKo
local integer ZLo
local integer Zmo
local player ZMo
local integer ZPo
set ZM[EM]=ZJo
set EM=EM+1
set ZMo=Onx(Mqv(M7v(Zjo,0,"when calling get in SLangPlayerFunctions, line 90"),"when calling getInner in SLangPlayerFunctions, line 90"),"when calling resolvePlayer in SLangPlayerFunctions, line 90")
set ZPo=v1
set Zko=ZMo
set ZKo=ZPo
if ZKo==0 then
call SetPlayerAllianceStateAllyBJ(sa[QGv(ZHo,"when calling getPlayerId in SLangPlayerFunctions, line 92")],Zko,true)
endif
if ZKo!=0 then
set ZLo=ZKo
else
set ZLo=MLv("when calling nullptr in SLangPlayerFunctions, line 93")
endif
set Zmo=ZLo
set EM=EM-1
set Zko=null
set ZMo=null
return Zmo
endfunction
function ZQo takes integer Bdi,integer ZUo,integer ZWo,string Zzo returns integer
local integer ZZo
set ZM[EM]=Zzo
set EM=EM+1
set ZZo=p0v(SSv(Zav(Mov(ZUo,"when calling getEnumUnit in ScmdUnitBuiltins, line 580"),WCv(M7v(ZWo,0,"when calling get in ScmdUnitBuiltins, line 580"),"when calling booleanValue in ScmdUnitBuiltins, line 580")),"when calling new_Integer in ScmdUnitBuiltins, line 580"),"when calling new_SharedPointer in ScmdUnitBuiltins, line 580")
set EM=EM-1
return ZZo
endfunction
function Z3o takes integer Bdt,integer Ndt,integer var,string vzr returns integer
local integer v7r
set ZM[EM]=vzr
set EM=EM+1
set v7r=p0v(O4x(Mqv(M7v(var,1,"when calling get in SLangSpecialEffectFunctions, line 12"),"when calling getInner in SLangSpecialEffectFunctions, line 12"),qqv(M7v(var,0,"when calling get in SLangSpecialEffectFunctions, line 12"),"when calling getInner in SLangSpecialEffectFunctions, line 12"),Mqv(M7v(var,2,"when calling get in SLangSpecialEffectFunctions, line 12"),"when calling getInner in SLangSpecialEffectFunctions, line 12"),"when calling new_SpecialEffect in SLangSpecialEffectFunctions, line 12"),"when calling new_SharedPointer in SLangSpecialEffectFunctions, line 12")
set EM=EM-1
return v7r
endfunction
function ezr takes integer N8i,integer M8i,integer e7r,string xzr returns integer
local integer x7r
set ZM[EM]=xzr
set EM=EM+1
call FogEnable(WCv(M7v(e7r,0,"when calling get in ScmdFogOfWarBuiltins, line 17"),"when calling booleanValue in ScmdFogOfWarBuiltins, line 17"))
set x7r=MLv("when calling nullptr in ScmdFogOfWarBuiltins, line 18")
set EM=EM-1
return x7r
endfunction
function ozr takes integer Nhi,integer o7r,integer rzr,string r7r returns integer
local integer izr
set ZM[EM]=r7r
set EM=EM+1
call m9e(Mov(o7r,"when calling getEnumUnit in ScmdUnitBuiltins, line 786"),Mqv(M7v(rzr,0,"when calling get in ScmdUnitBuiltins, line 786"),"when calling getInner in ScmdUnitBuiltins, line 786"))
set izr=MLv("when calling nullptr in ScmdUnitBuiltins, line 787")
set EM=EM-1
return izr
endfunction
function i7r takes integer NGi,integer MGi,integer azr,string a7r returns integer
local integer nzr
set ZM[EM]=a7r
set EM=EM+1
set nzr=p0v(Ppv(GetHeroProperName(PCv(M7v(azr,0,"when calling get in ScmdUnitBuiltins, line 733"),"when calling getInner in ScmdUnitBuiltins, line 733")),"when calling new_String in ScmdUnitBuiltins, line 733"),"when calling new_SharedPointer in ScmdUnitBuiltins, line 733")
set EM=EM-1
return nzr
endfunction
function n7r takes integer Uxt,integer Ixt,integer Vzr,string V7r returns integer
local boolean Ezr
local boolean E7r
local integer Xzr
local integer X7r
local integer Ozr
local real O7r
local integer Rzr
local integer R7r
local integer Izr
local integer I7r
local integer Azr
local integer A7r
local integer Nzr
local integer N7r
set ZM[EM]=V7r
set EM=EM+1
set Ezr=false
set E7r=false
set Xzr=0
set X7r=SNv(Vzr,"when calling size in ScmdCoreBuiltins, line 240")-1
loop
exitwhen Xzr>X7r
set Nzr=ox[M7v(Vzr,Xzr,"when calling get in ScmdCoreBuiltins, line 241")]
if not(Nzr==$EFD or Nzr==$F03)then
set Ezr=true
endif
if SNv(Vzr,"when calling size in ScmdCoreBuiltins, line 243")==1 or Xzr>0 and kge(M7v(Vzr,Xzr,"when calling get in ScmdCoreBuiltins, line 243"),"when calling realValue in ScmdCoreBuiltins, line 243")==.0 then
set E7r=true
exitwhen true
endif
set Xzr=Xzr+1
endloop
set Ozr=kZe(M7v(Vzr,0,"when calling get in ScmdCoreBuiltins, line 246"),"when calling intValue in ScmdCoreBuiltins, line 246")
set O7r=kge(M7v(Vzr,0,"when calling get in ScmdCoreBuiltins, line 247"),"when calling realValue in ScmdCoreBuiltins, line 247")
if not E7r then
if Ezr then
if SNv(Vzr,"when calling size in ScmdCoreBuiltins, line 250")==1 then
set O7r=1./O7r
else
set Rzr=1
set R7r=SNv(Vzr,"when calling size in ScmdCoreBuiltins, line 253")-1
loop
exitwhen Rzr>R7r
set O7r=O7r/kge(M7v(Vzr,Rzr,"when calling get in ScmdCoreBuiltins, line 254"),"when calling realValue in ScmdCoreBuiltins, line 254")
set Rzr=Rzr+1
endloop
endif
elseif SNv(Vzr,"when calling size in ScmdCoreBuiltins, line 256")==1 then
set Ozr=1/Ozr
else
set Izr=1
set I7r=SNv(Vzr,"when calling size in ScmdCoreBuiltins, line 259")-1
loop
exitwhen Izr>I7r
set Ozr=Ozr/kZe(M7v(Vzr,Izr,"when calling get in ScmdCoreBuiltins, line 260"),"when calling intValue in ScmdCoreBuiltins, line 260")
set Izr=Izr+1
endloop
endif
endif
if E7r then
set A7r=tJv("Division by zero","when calling new_Exception in ScmdCoreBuiltins, line 261")
else
if Ezr then
set Azr=q2v(O7r,"when calling new_Real in ScmdCoreBuiltins, line 261")
else
set Azr=SSv(Ozr,"when calling new_Integer in ScmdCoreBuiltins, line 261")
endif
set A7r=Azr
endif
set N7r=pIe(A7r,"when calling new_GenericSharedPointer in ScmdCoreBuiltins, line 261")
set EM=EM-1
return N7r
endfunction
function bzr takes string b7r returns integer
local integer Bzr
set ZM[EM]=b7r
set EM=EM+1
if Tk==0 then
if Yk<$8000 then
set Yk=Yk+1
set Bzr=Yk
set Gk[Bzr]=$FE3
else
call Cdv("Out of memory: Could not create PersistableLoadCallback_load_setArgumentsTypes_registerProtectedBuiltin_SotfrpGuiRegions.","when calling error in SotfrpGuiRegions, line 185")
set Bzr=0
endif
else
set Tk=Tk-1
set Bzr=Rk[Tk]
set Gk[Bzr]=$FE3
endif
set EM=EM-1
return Bzr
endfunction
function B7r takes string czr returns integer
local integer c7r
set ZM[EM]=czr
set EM=EM+1
if Tg==0 then
if Yg<$8000 then
set Yg=Yg+1
set c7r=Yg
set Gg[c7r]=$6D4
else
call Cdv("Out of memory: Could not create LegacySaveData.","when calling error in LegacySaveData, line 21")
set c7r=0
endif
else
set Tg=Tg-1
set c7r=Rg[Tg]
set Gg[c7r]=$6D4
endif
set EM=EM-1
return c7r
endfunction
function Czr takes integer C7r,string dzr returns nothing
set ZM[EM]=dzr
set EM=EM+1
set pI[C7r]=TEv("when calling new_HashList in LegacyUnitData, line 394")
set EM=EM-1
endfunction
function d7r takes integer Dzr,integer D7r,string for returns nothing
set ZM[EM]=for
set EM=EM+1
call Czr(Dzr,"when calling LegacyPositionedUnitData_init in LegacyUnitData, line 396")
set yI[Dzr]=D7r
set EM=EM-1
endfunction
function fzr takes string f7r returns integer
local integer Fzr
set ZM[EM]=f7r
set EM=EM+1
if Bh==0 then
if Nh<$8000 then
set Nh=Nh+1
set Fzr=Nh
set Mh[Fzr]=$CC4
else
call Cdv("Out of memory: Could not create LegacyPositionedUnitData.","when calling error in LegacyUnitData, line 390")
set Fzr=0
endif
else
set Bh=Bh-1
set Fzr=Vh[Bh]
set Mh[Fzr]=$CC4
endif
set EM=EM-1
return Fzr
endfunction
function F7r takes integer gzr,string g7r returns integer
local integer Gzr
set ZM[EM]=g7r
set EM=EM+1
set Gzr=fzr("when calling alloc_LegacyPositionedUnitData in LegacyUnitData, line 396")
call d7r(Gzr,gzr,"when calling construct_LegacyPositionedUnitData in LegacyUnitData, line 396")
set EM=EM-1
return Gzr
endfunction
function G7r takes integer hzr,string h7r returns nothing
local integer Hzr
set ZM[EM]=h7r
set EM=EM+1
set Hzr=0
set sI[hzr]=Hzr
set tI[hzr]=g1v("when calling new_StringHashMap in LegacyStringTable, line 19")
set iI[hzr]=yov("when calling new_StringHashList in LegacyStringTable, line 20")
set EM=EM-1
endfunction
function H7r takes integer jzr,string j7r returns nothing
set ZM[EM]=j7r
set EM=EM+1
call G7r(jzr,"when calling StringTable_init in LegacyStringTable, line 15")
set EM=EM-1
endfunction
function Jzr takes string J7r returns integer
local integer kzr
set ZM[EM]=J7r
set EM=EM+1
if Tg==0 then
if Yg<$8000 then
set Yg=Yg+1
set kzr=Yg
set Gg[kzr]=$6DA
else
call Cdv("Out of memory: Could not create StringTable.","when calling error in LegacyStringTable, line 15")
set kzr=0
endif
else
set Tg=Tg-1
set kzr=Rg[Tg]
set Gg[kzr]=$6DA
endif
set EM=EM-1
return kzr
endfunction
function k7r takes string Kzr returns integer
local integer K7r
set ZM[EM]=Kzr
set EM=EM+1
set K7r=Jzr("when calling alloc_StringTable in LegacyStringTable, line 15")
call H7r(K7r,"when calling construct_StringTable in LegacyStringTable, line 15")
set EM=EM-1
return K7r
endfunction
function lzr takes integer l7r,string Lzr returns nothing
local real L7r
local real mzr
set ZM[EM]=Lzr
set EM=EM+1
set L7r=.0
set mzr=.0
set BU[l7r]=L7r
set NU[l7r]=mzr
set MU[l7r]=k7r("when calling new_StringTable in LegacySaveData, line 30")
set wI[l7r]=F7r(MU[l7r],"when calling new_LegacyPositionedUnitData in LegacySaveData, line 31")
set EM=EM-1
endfunction
function m7r takes integer Mzr,player M7r,string pzr,string p7r returns nothing
set ZM[EM]=p7r
set EM=EM+1
call NQx(Mzr,M7r)
call lzr(Mzr,"when calling LegacySaveData_init in LegacySaveData, line 33")
set VU[Mzr]=pzr
set EM=EM-1
endfunction
function Pzr takes player P7r,string qzr,string q7r returns integer
local integer Qzr
set ZM[EM]=q7r
set EM=EM+1
set Qzr=B7r("when calling alloc_LegacySaveData in LegacySaveData, line 33")
call m7r(Qzr,P7r,qzr,"when calling construct_LegacySaveData in LegacySaveData, line 33")
set EM=EM-1
return Qzr
endfunction
function Q7r takes integer DDi,integer szr,integer s7r,string Szr returns integer
local real S7r
local real tzr
local integer t7r
local integer Tzr
local integer T7r
local integer uzr
local integer u7r
local real Uzr
local real U7r
local real wzr
local real w7r
set ZM[EM]=Szr
set EM=EM+1
set Uzr=zAx(QGv(szr,"when calling getPlayerId in SotfrpGuiRegions, line 181"),"when calling getSelectedOrigin in SotfrpGuiRegions, line 181")
set U7r=X1
set S7r=Uzr
set tzr=U7r
set t7r=Pzr(sa[QGv(szr,"when calling getPlayerId in SotfrpGuiRegions, line 182")],Mqv(M7v(s7r,0,"when calling get in SotfrpGuiRegions, line 182"),"when calling getInner in SotfrpGuiRegions, line 182"),"when calling new_LegacySaveData in SotfrpGuiRegions, line 182")
set Tzr=QGv(szr,"when calling getPlayerId in SotfrpGuiRegions, line 183")
call GDe("Чтение файла и синхронизация данных...",30.,sa[Tzr])
set u7r=t7r
set T7r=bzr("when calling alloc_PersistableLoadCallback_load_setArgumentsTypes_registerProtectedBuiltin_SotfrpGuiRegions in SotfrpGuiRegions, line 185")
set iX[T7r]=t7r
set wzr=S7r
set w7r=tzr
set SX[T7r]=wzr
set cX[T7r]=w7r
set oX[T7r]=Tzr
call YFx(u7r,T7r,"when calling load in SotfrpGuiRegions, line 185")
set uzr=MLv("when calling nullptr in SotfrpGuiRegions, line 200")
set EM=EM-1
return uzr
endfunction
function Wzr takes integer Mii,integer wSi,integer W7r,string yzr returns integer
local integer y7r
set ZM[EM]=yzr
set EM=EM+1
call NIe(PCv(M7v(W7r,0,"when calling get in ScmdUnitBuiltins, line 100"),"when calling getInner in ScmdUnitBuiltins, line 100"),PEv(M7v(W7r,1,"when calling get in ScmdUnitBuiltins, line 100"),"when calling realValue in ScmdUnitBuiltins, line 100"))
set y7r=MLv("when calling nullptr in ScmdUnitBuiltins, line 101")
set EM=EM-1
return y7r
endfunction
function Yzr takes integer Mli,integer wbi,integer Y7r,string zvr returns integer
local integer zer
set ZM[EM]=zvr
set EM=EM+1
call KWe(mle(M7v(Y7r,0,"when calling get in ScmdUnitBuiltins, line 267"),"when calling getInner in ScmdUnitBuiltins, line 267"),PCv(M7v(Y7r,1,"when calling get in ScmdUnitBuiltins, line 267"),"when calling getInner in ScmdUnitBuiltins, line 267"))
set zer=MLv("when calling nullptr in ScmdUnitBuiltins, line 268")
set EM=EM-1
return zer
endfunction
function zxr takes integer MGt,integer zor,integer zrr,string zir returns integer
local integer zar
set ZM[EM]=zir
set EM=EM+1
if ta==sa[QGv(zor,"when calling getPlayerId in ScmdCameraSetupBuiltins, line 23")]then
call CameraSetupApplyWithZ(FVe(M7v(zrr,0,"when calling get in ScmdCameraSetupBuiltins, line 24"),"when calling getInner in ScmdCameraSetupBuiltins, line 24"),PEv(M7v(zrr,1,"when calling get in ScmdCameraSetupBuiltins, line 24"),"when calling realValue in ScmdCameraSetupBuiltins, line 24"))
endif
set zar=MLv("when calling nullptr in ScmdCameraSetupBuiltins, line 25")
set EM=EM-1
return zar
endfunction
function znr takes integer MOi,integer zVr,integer zEr,string zXr returns integer
local integer zOr
set ZM[EM]=zXr
set EM=EM+1
set zOr=p0v(jle(F0e(sa[QGv(zVr,"when calling getPlayerId in ScmdUnitBuiltins, line 235")],gOe(M7v(zEr,0,"when calling get in ScmdUnitBuiltins, line 235"),"when calling getInner in ScmdUnitBuiltins, line 235"),Filter(RGv)),"when calling new_Group in ScmdUnitBuiltins, line 235"),"when calling new_SharedPointer in ScmdUnitBuiltins, line 235")
set EM=EM-1
return zOr
endfunction
function zRr takes integer Mvt,integer wmt,integer zIr,string zAr returns integer
local integer zNr
set ZM[EM]=zAr
set EM=EM+1
set zNr=p0v(qRv(kge(M7v(zIr,0,"when calling get in ScmdCoreBuiltins, line 273"),"when calling realValue in ScmdCoreBuiltins, line 273")==.0,"when calling new_Boolean in ScmdCoreBuiltins, line 273"),"when calling new_SharedPointer in ScmdCoreBuiltins, line 273")
set EM=EM-1
return zNr
endfunction
function zbr takes integer Mai,integer zBr,integer zcr,string zCr returns integer
local integer zdr
set ZM[EM]=zCr
set EM=EM+1
set zdr=p0v(qRv(PHo(Mov(zBr,"when calling getEnumUnit in ScmdUnitBuiltins, line 454"),QNv(M7v(zcr,0,"when calling get in ScmdUnitBuiltins, line 454"),"when calling intValue in ScmdUnitBuiltins, line 454"),Mqv(M7v(zcr,1,"when calling get in ScmdUnitBuiltins, line 454"),"when calling getInner in ScmdUnitBuiltins, line 454")),"when calling new_Boolean in ScmdUnitBuiltins, line 454"),"when calling new_SharedPointer in ScmdUnitBuiltins, line 454")
set EM=EM-1
return zdr
endfunction
function zDr takes integer Myi,integer zfr,integer upi,string zFr returns integer
local integer zgr
set ZM[EM]=zFr
set EM=EM+1
call P3o(Mov(zfr,"when calling getEnumUnit in ScmdUnitBuiltins, line 324"))
set zgr=MLv("when calling nullptr in ScmdUnitBuiltins, line 325")
set EM=EM-1
return zgr
endfunction
function zGr takes integer Mei,integer wqi,integer zhr,string zHr returns integer
local integer zjr
set ZM[EM]=zHr
set EM=EM+1
call mbe(PCv(M7v(zhr,0,"when calling get in ScmdUnitBuiltins, line 378"),"when calling getInner in ScmdUnitBuiltins, line 378"),UNIT_RF_HIT_POINTS_REGENERATION_RATE,PEv(M7v(zhr,1,"when calling get in ScmdUnitBuiltins, line 378"),"when calling realValue in ScmdUnitBuiltins, line 378"))
set zjr=MLv("when calling nullptr in ScmdUnitBuiltins, line 379")
set EM=EM-1
return zjr
endfunction
function zJr takes integer Mui,integer wri,integer zkr,string zKr returns integer
local integer zlr
set ZM[EM]=zKr
set EM=EM+1
set zlr=p0v(q2v(foe(gOe(M7v(zkr,0,"when calling get in ScmdRectBuiltins, line 23"),"when calling getInner in ScmdRectBuiltins, line 23")),"when calling new_Real in ScmdRectBuiltins, line 23"),"when calling new_SharedPointer in ScmdRectBuiltins, line 23")
set EM=EM-1
return zlr
endfunction
function zLr takes string zmr returns integer
local integer zMr
set ZM[EM]=zmr
set EM=EM+1
if CY==0 then
if VY<$8000 then
set VY=VY+1
set zMr=VY
set BY[zMr]=$86D
else
call Cdv("Out of memory: Could not create ForForceCallback_execute_setArgumentsTypes_setProvidingEnumUnit_registerProtectedBuiltin_SotfrpGuiRegions.","when calling error in SotfrpGuiRegions, line 146")
set zMr=0
endif
else
set CY=CY-1
set zMr=XY[CY]
set BY[zMr]=$86D
endif
set EM=EM-1
return zMr
endfunction
function zpr takes integer EAi,integer zPr,integer zqr,string zQr returns integer
local integer zsr
local group zSr
local integer ztr
local integer zTr
local rect zur
local group zUr
local unit zwr
local group zWr
local unit zyr
local group zYr
local unit zzr
local integer zZr
local integer z_r
local integer z0r
set ZM[EM]=zQr
set EM=EM+1
set zsr=MLv("when calling nullptr in SotfrpGuiRegions, line 135")
set zSr=CreateGroup()
set ztr=YPx(QGv(zPr,"when calling getPlayerId in SotfrpGuiRegions, line 137"),"when calling getSelectedRects in SotfrpGuiRegions, line 137")
set zTr=Xle(ztr,"when calling iterator in SotfrpGuiRegions, line 138")
loop
exitwhen not Xie(zTr)
set zur=zXx(E3e(zTr),"when calling rectFromIndex in SotfrpGuiRegions, line 138")
set zUr=F0e(sa[QGv(zPr,"when calling getPlayerId in SotfrpGuiRegions, line 139")],zur,Filter(Rhv))
set zWr=zUr
loop
exitwhen not F9e(zWr)
set zwr=F6e(zWr)
call KWe(zSr,zwr)
endloop
call kcv(zUr)
endloop
call Xpe(zTr,"when calling close in SotfrpGuiRegions, line 138")
call Hcv(ztr,"when calling dispatch_LinkedList_destroyLinkedList in SotfrpGuiRegions, line 143")
set zyr=Mov(zPr,"when calling getEnumUnit in SotfrpGuiRegions, line 144")
set zYr=QEe(zSr)
loop
exitwhen not F9e(zYr)
set zzr=F6e(zYr)
set zZr=zLr("when calling alloc_ForForceCallback_execute_setArgumentsTypes_setProvidingEnumUnit_registerProtectedBuiltin_SotfrpGuiRegions in SotfrpGuiRegions, line 146")
set LL[zZr]=zPr
set XL[zZr]=zzr
set CL[zZr]=zqr
set VL[zZr]=zsr
call Fte(zZr,"when calling execute in SotfrpGuiRegions, line 146")
set z_r=ox[m0v(zsr,"when calling get in SotfrpGuiRegions, line 152")]
if z_r>=$EF1 and z_r<=$EF2 then
exitwhen true
endif
endloop
call QOe(zYr)
call m7v(zPr,zyr,"when calling setEnumUnit in SotfrpGuiRegions, line 154")
call kcv(zSr)
set z0r=zsr
set EM=EM-1
set zSr=null
set zur=null
set zUr=null
set zwr=null
set zWr=null
set zyr=null
set zYr=null
set zzr=null
return z0r
endfunction
function z1r takes integer VWi,integer z2r,integer NWi,string z3r returns integer
local integer z4r
set ZM[EM]=z3r
set EM=EM+1
set z4r=p0v(q2v(uev(QKv(QGv(z2r,"when calling getPlayerId in SotfrpGuiCoreUnit, line 81"))),"when calling new_Real in SotfrpGuiCoreUnit, line 81"),"when calling new_SharedPointer in SotfrpGuiCoreUnit, line 81")
set EM=EM-1
return z4r
endfunction
function z5r takes integer Xmi,integer z6r,integer z7r,string z8r returns integer
local integer z9r
local rect Zzr
local integer Z7r
set ZM[EM]=z8r
set EM=EM+1
set z9r=QGv(z6r,"when calling getPlayerId in SotFRP_LegacyLoad, line 230")
set Zzr=gOe(M7v(z7r,0,"when calling get in SotFRP_LegacyLoad, line 231"),"when calling getInner in SotFRP_LegacyLoad, line 231")
set Vd[z9r]=DQv(DSv((jse(Zzr)-32.)/64.))*64.+32.
set Bd[z9r]=DQv(DSv((jte(Zzr)-32.)/64.))*64.+32.
set Z7r=p0v(dpe("when calling new_Null in SotFRP_LegacyLoad, line 234"),"when calling new_SharedPointer in SotFRP_LegacyLoad, line 234")
set EM=EM-1
set Zzr=null
return Z7r
endfunction
function vzi takes integer LQt,integer XQt,integer v2i,string ezi returns integer
local integer e2i
local integer xzi
local integer x2i
local integer ozi
set ZM[EM]=ezi
set EM=EM+1
set e2i=M7v(v2i,0,"when calling get in ScmdCoreBuiltins, line 322")
set xzi=QNv(M7v(v2i,1,"when calling get in ScmdCoreBuiltins, line 323"),"when calling intValue in ScmdCoreBuiltins, line 323")
if xzi<skv(e2i,"when calling size in ScmdCoreBuiltins, line 324")and xzi>=0 then
set x2i=sTv(e2i,xzi,"when calling get in ScmdCoreBuiltins, line 324")
else
set x2i=p0v(tJv("Index out of bounds","when calling new_Exception in ScmdCoreBuiltins, line 324"),"when calling new_SharedPointer in ScmdCoreBuiltins, line 324")
endif
set ozi=x2i
set EM=EM-1
return ozi
endfunction
function o2i takes integer Vqi,integer Bqi,integer rzi,string r2i returns integer
local integer izi
set ZM[EM]=r2i
set EM=EM+1
call tEv(PCv(M7v(rzi,0,"when calling get in ScmdUnitBuiltins, line 404"),"when calling getInner in ScmdUnitBuiltins, line 404"),PEv(M7v(rzi,1,"when calling get in ScmdUnitBuiltins, line 404"),"when calling realValue in ScmdUnitBuiltins, line 404"),QNv(M7v(rzi,2,"when calling get in ScmdUnitBuiltins, line 404"),"when calling intValue in ScmdUnitBuiltins, line 404"))
set izi=MLv("when calling nullptr in ScmdUnitBuiltins, line 405")
set EM=EM-1
return izi
endfunction
function i2i takes integer Vni,integer azi,integer a2i,string nzi returns integer
local integer n2i
set ZM[EM]=nzi
set EM=EM+1
set n2i=p0v(qRv(azo(Mov(azi,"when calling getEnumUnit in ScmdUnitBuiltins, line 546"),Mqv(M7v(a2i,0,"when calling get in ScmdUnitBuiltins, line 546"),"when calling getInner in ScmdUnitBuiltins, line 546")),"when calling new_Boolean in ScmdUnitBuiltins, line 546"),"when calling new_SharedPointer in ScmdUnitBuiltins, line 546")
set EM=EM-1
return n2i
endfunction
function Vzi takes integer Vpi,integer V2i,integer Ezi,string E2i returns integer
local integer Xzi
set ZM[EM]=E2i
set EM=EM+1
set Xzi=p0v(SSv(oVe(Mov(V2i,"when calling getEnumUnit in ScmdUnitBuiltins, line 351"),QNv(M7v(Ezi,0,"when calling get in ScmdUnitBuiltins, line 351"),"when calling intValue in ScmdUnitBuiltins, line 351")),"when calling new_Integer in ScmdUnitBuiltins, line 351"),"when calling new_SharedPointer in ScmdUnitBuiltins, line 351")
set EM=EM-1
return Xzi
endfunction
function X2i takes integer Vti,integer Ozi,integer O2i,string Rzi returns integer
local integer R2i
set ZM[EM]=Rzi
set EM=EM+1
call NQe(Mov(Ozi,"when calling getEnumUnit in ScmdUnitBuiltins, line 73"),WCv(M7v(O2i,0,"when calling get in ScmdUnitBuiltins, line 73"),"when calling booleanValue in ScmdUnitBuiltins, line 73"))
set R2i=MLv("when calling nullptr in ScmdUnitBuiltins, line 74")
set EM=EM-1
return R2i
endfunction
function Izi takes integer Vvi,integer I2i,integer Azi,string A2i returns integer
local integer Nzi
set ZM[EM]=A2i
set EM=EM+1
call U2v(Mov(I2i,"when calling getEnumUnit in SotFRP_AbilitySystem, line 66"),Mqv(M7v(Azi,0,"when calling get in SotFRP_AbilitySystem, line 66"),"when calling getInner in SotFRP_AbilitySystem, line 66"),QNv(M7v(Azi,1,"when calling get in SotFRP_AbilitySystem, line 66"),"when calling intValue in SotFRP_AbilitySystem, line 66"),"when calling setAbilityLevel in SotFRP_AbilitySystem, line 66")
set Nzi=MLv("when calling nullptr in SotFRP_AbilitySystem, line 67")
set EM=EM-1
return Nzi
endfunction
function N2i takes integer Xat,integer bzi,integer b2i,string Bzi returns integer
local player B2i
local integer czi
local integer c2i
set ZM[EM]=Bzi
set EM=EM+1
set B2i=l8e(tZv(Mqv(M7v(b2i,0,"when calling get in SLangPlayerFunctions, line 41"),"when calling getInner in SLangPlayerFunctions, line 41")))
if B2i!=null then
set czi=p0v(qRv(GetPlayerAlliance(sa[QGv(bzi,"when calling getPlayerId in SLangPlayerFunctions, line 42")],B2i,ALLIANCE_PASSIVE),"when calling new_Boolean in SLangPlayerFunctions, line 42"),"when calling new_SharedPointer in SLangPlayerFunctions, line 42")
else
set czi=l5e("when calling newWCNException in SLangPlayerFunctions, line 42")
endif
set c2i=czi
set EM=EM-1
set B2i=null
return c2i
endfunction
function Czi takes integer Vri,integer Bri,integer C2i,string dzi returns integer
local integer d2i
set ZM[EM]=dzi
set EM=EM+1
call SetMusicVolume(QNv(M7v(C2i,0,"when calling get in ScmdSoundFunctions, line 19"),"when calling intValue in ScmdSoundFunctions, line 19"))
set d2i=MLv("when calling nullptr in ScmdSoundFunctions, line 20")
set EM=EM-1
return d2i
endfunction
function Dzi takes integer Vbi,integer Bbi,integer D2i,string fzi returns integer
local integer f2i
set ZM[EM]=fzi
set EM=EM+1
set f2i=p0v(SSv(Shv(PCv(M7v(D2i,1,"when calling get in ScmdUnitBuiltins, line 292"),"when calling getInner in ScmdUnitBuiltins, line 292")),"when calling new_Integer in ScmdUnitBuiltins, line 292"),"when calling new_SharedPointer in ScmdUnitBuiltins, line 292")
set EM=EM-1
return f2i
endfunction
function Fzi takes string F2i returns integer
local integer gzi
set ZM[EM]=F2i
set EM=EM+1
if kk==0 then
if jk<$8000 then
set jk=jk+1
set gzi=jk
set xk[gzi]=$FE7
else
call Cdv("Out of memory: Could not create PersistableSaveCallback_save_setArgumentsTypes_registerProtectedBuiltin_SotfrpGuiRegions.","when calling error in SotfrpGuiRegions, line 129")
set gzi=0
endif
else
set kk=kk-1
set gzi=Fk[kk]
set xk[gzi]=$FE7
endif
set EM=EM-1
return gzi
endfunction
function g2i takes player Gzi,integer G2i,string hzi returns nothing
set ZM[EM]=hzi
set EM=EM+1
call J9e(G2i)
call GroupEnumUnitsOfPlayer(sp,Gzi,op)
call J7e("when calling popCallback in ClosureForGroups, line 69")
set EM=EM-1
endfunction
function h2i takes string Hzi returns integer
local integer H2i
set ZM[EM]=Hzi
set EM=EM+1
if ug==0 then
if rg<$8000 then
set rg=rg+1
set H2i=rg
set sg[H2i]=$876
else
call Cdv("Out of memory: Could not create ForGroupCallback_forUnitsOfPlayer_PositionedUnitData_UnitData.","when calling error in UnitData, line 1427")
set H2i=0
endif
else
set ug=ug-1
set H2i=wg[ug]
set sg[H2i]=$876
endif
set EM=EM-1
return H2i
endfunction
function jzi takes integer j2i,player Jzi,rect J2i,real kzi,real k2i,string Kzi returns nothing
local integer K2i
local player lzi
local real l2i
local real Lzi
set ZM[EM]=Kzi
set EM=EM+1
set lzi=Jzi
set K2i=h2i("when calling alloc_ForGroupCallback_forUnitsOfPlayer_PositionedUnitData_UnitData in UnitData, line 1427")
set sV[K2i]=J2i
set tV[K2i]=j2i
set l2i=kzi
set Lzi=k2i
set iV[K2i]=l2i
set SV[K2i]=Lzi
call g2i(lzi,K2i,"when calling forUnitsOfPlayer in UnitData, line 1427")
set EM=EM-1
set lzi=null
endfunction
function L2i takes integer mzi,player m2i,rect Mzi,real M2i,real pzi,string p2i returns nothing
set ZM[EM]=p2i
set EM=EM+1
if Gg[mzi]==0 then
if mzi==0 then
call Cdv("Nullpointer exception when calling PositionedUnitData.scanRect","when calling error in UnitData, line 1426")
else
call Cdv("Called PositionedUnitData.scanRect on invalid object.","when calling error in UnitData, line 1426")
endif
endif
call jzi(mzi,m2i,Mzi,M2i,pzi,"when calling scanRect in UnitData, line 1426")
set EM=EM-1
endfunction
function Pzi takes string P2i returns integer
local integer qzi
set ZM[EM]=P2i
set EM=EM+1
if ig==0 then
if Sg<$8000 then
set Sg=Sg+1
set qzi=Sg
set cg[qzi]=$87D
else
call Cdv("Out of memory: Could not create ForGroupCallbackD_forDestructablesInRect_PositionedDestructableData_DestructableData.","when calling error in DestructableData, line 270")
set qzi=0
endif
else
set ig=ig-1
set qzi=tg[ig]
set cg[qzi]=$87D
endif
set EM=EM-1
return qzi
endfunction
function q2i takes integer Qzi returns nothing
set Op[lp]=Qzi
set lp=lp+1
endfunction
function Q2i takes integer szi,string s2i returns nothing
set ZM[EM]=s2i
set EM=EM+1
if cg[szi]==0 then
call Cdv("Double free: object of type ForGroupCallbackD","when calling error in ClosureForGroups, line 148")
else
set tg[ig]=szi
set ig=ig+1
set cg[szi]=0
endif
set EM=EM-1
endfunction
function Szi takes integer S2i,string tzi returns nothing
set ZM[EM]=tzi
set EM=EM+1
call Q2i(S2i,"when calling dealloc_ForGroupCallbackD in ClosureForGroups, line 148")
set EM=EM-1
endfunction
function t2i takes integer Tzi,string T2i returns nothing
set ZM[EM]=T2i
set EM=EM+1
if cg[Tzi]==0 then
if Tzi==0 then
call Cdv("Nullpointer exception when calling ForGroupCallbackD.ForGroupCallbackD","when calling error in ClosureForGroups, line 148")
else
call Cdv("Called ForGroupCallbackD.ForGroupCallbackD on invalid object.","when calling error in ClosureForGroups, line 148")
endif
endif
call Szi(Tzi,"when calling destroyForGroupCallbackD in ClosureForGroups, line 148")
set EM=EM-1
endfunction
function uzi takes string u2i returns nothing
set ZM[EM]=u2i
set EM=EM+1
set lp=lp-1
call t2i(Op[lp],"when calling dispatch_ForGroupCallbackD_destroyForGroupCallbackD in ClosureForGroups, line 164")
set EM=EM-1
endfunction
function Uzi takes rect U2i,integer wzi,string w2i returns nothing
set ZM[EM]=w2i
set EM=EM+1
call q2i(wzi)
call EnumDestructablesInRect(U2i,null,Oqv)
call uzi("when calling popCallbackD in ClosureForGroups, line 182")
set EM=EM-1
endfunction
function Wzi takes integer W2i,player yzi,rect y2i,real Yzi,real Y2i,string zvi returns nothing
local integer zei
local rect zxi
local real zoi
local real zri
set ZM[EM]=zvi
set EM=EM+1
set zxi=y2i
set zei=Pzi("when calling alloc_ForGroupCallbackD_forDestructablesInRect_PositionedDestructableData_DestructableData in DestructableData, line 270")
set OE[zei]=yzi
set lE[zei]=W2i
set zoi=Yzi
set zri=Y2i
set bE[zei]=zoi
set yE[zei]=zri
call Uzi(zxi,zei,"when calling forDestructablesInRect in DestructableData, line 270")
set EM=EM-1
set zxi=null
endfunction
function zii takes integer zai,player zni,rect zVi,real zEi,real zXi,string zOi returns nothing
set ZM[EM]=zOi
set EM=EM+1
if Gg[zai]==0 then
if zai==0 then
call Cdv("Nullpointer exception when calling PositionedDestructableData.scanRect","when calling error in DestructableData, line 269")
else
call Cdv("Called PositionedDestructableData.scanRect on invalid object.","when calling error in DestructableData, line 269")
endif
endif
call Wzi(zai,zni,zVi,zEi,zXi,"when calling scanRect in DestructableData, line 269")
set EM=EM-1
endfunction
function zRi takes integer zIi,rect zAi,string zNi returns nothing
set ZM[EM]=zNi
set EM=EM+1
if fee(zAi)<ZH[zIi]then
set ZH[zIi]=fee(zAi)
endif
if fie(zAi)>UH[zIi]then
set UH[zIi]=fie(zAi)
endif
if foe(zAi)<IH[zIi]then
set IH[zIi]=foe(zAi)
endif
if D9e(zAi)>PH[zIi]then
set PH[zIi]=D9e(zAi)
endif
set HH[zIi]=UH[zIi]-ZH[zIi]
set JH[zIi]=PH[zIi]-IH[zIi]
call zii(XH[zIi],xD[zIi],zAi,AH[zIi],DH[zIi],"when calling scanRect in RegionData, line 111")
call L2i(CH[zIi],xD[zIi],zAi,AH[zIi],DH[zIi],"when calling scanRect in RegionData, line 112")
set EM=EM-1
endfunction
function zbi takes integer zBi,rect zci,string zCi returns nothing
set ZM[EM]=zCi
set EM=EM+1
if Gg[zBi]==0 then
if zBi==0 then
call Cdv("Nullpointer exception when calling RegionData.scanRect","when calling error in RegionData, line 98")
else
call Cdv("Called RegionData.scanRect on invalid object.","when calling error in RegionData, line 98")
endif
endif
call zRi(zBi,zci,"when calling scanRect in RegionData, line 98")
set EM=EM-1
endfunction
function zdi takes integer nAi,integer zDi,integer zfi,string zFi returns integer
local integer zgi
local integer zGi
local integer zhi
local integer zHi
local rect zji
local integer zJi
local integer zki
local integer zKi
local integer zli
set ZM[EM]=zFi
set EM=EM+1
set zGi=Nzx(sa[QGv(zDi,"when calling getPlayerId in SotfrpGuiRegions, line 123")],Mqv(M7v(zfi,0,"when calling get in SotfrpGuiRegions, line 123"),"when calling getInner in SotfrpGuiRegions, line 123"),"when calling new_RegionData in SotfrpGuiRegions, line 123")
call Pfx(zGi,zAx(QGv(zDi,"when calling getPlayerId in SotfrpGuiRegions, line 123"),"when calling getSelectedOrigin in SotfrpGuiRegions, line 123"),X1,"when calling setOrigin in SotfrpGuiRegions, line 123")
set zgi=zGi
set zhi=YPx(QGv(zDi,"when calling getPlayerId in SotfrpGuiRegions, line 124"),"when calling getSelectedRects in SotfrpGuiRegions, line 124")
set zHi=Xle(zhi,"when calling iterator in SotfrpGuiRegions, line 125")
loop
exitwhen not Xie(zHi)
set zji=zXx(E3e(zHi),"when calling rectFromIndex in SotfrpGuiRegions, line 125")
call zbi(zgi,zji,"when calling scanRect in SotfrpGuiRegions, line 126")
endloop
call Xpe(zHi,"when calling close in SotfrpGuiRegions, line 125")
call Hcv(zhi,"when calling dispatch_LinkedList_destroyLinkedList in SotfrpGuiRegions, line 127")
set zJi=QGv(zDi,"when calling getPlayerId in SotfrpGuiRegions, line 128")
set zli=zgi
set zki=Fzi("when calling alloc_PersistableSaveCallback_save_setArgumentsTypes_registerProtectedBuiltin_SotfrpGuiRegions in SotfrpGuiRegions, line 129")
set JL[zki]=zJi
set KL[zki]=zgi
call Vax(zli,zki,"when calling save in SotfrpGuiRegions, line 129")
set zKi=MLv("when calling nullptr in SotfrpGuiRegions, line 132")
set EM=EM-1
set zji=null
return zKi
endfunction
function zLi takes integer gGi,integer hGi,integer zmi,string zMi returns integer
local string zpi
local integer zPi
set ZM[EM]=zMi
set EM=EM+1
set zpi=Mqv(M7v(zmi,1,"when calling get in ScmdUnitBuiltins, line 720"),"when calling getInner in ScmdUnitBuiltins, line 720")
if zpi!=null then
call Rfe(PCv(M7v(zmi,0,"when calling get in ScmdUnitBuiltins, line 722"),"when calling getInner in ScmdUnitBuiltins, line 722"),zpi)
endif
set zPi=MLv("when calling nullptr in ScmdUnitBuiltins, line 723")
set EM=EM-1
return zPi
endfunction
function zqi takes trigger zQi returns nothing
call EnableTrigger(zQi)
endfunction
function zsi takes integer hRt,integer FRt,integer zSi,string zti returns integer
local integer zTi
set ZM[EM]=zti
set EM=EM+1
call zqi(qGv(M7v(zSi,0,"when calling get in SLangTriggerFunctions, line 12"),"when calling getInner in SLangTriggerFunctions, line 12"))
set zTi=MLv("when calling nullptr in SLangTriggerFunctions, line 13")
set EM=EM-1
return zTi
endfunction
function zui takes integer het,integer zUi,integer zwi,string zWi returns integer
local integer zyi
set ZM[EM]=zWi
set EM=EM+1
call HFe(Ja,QGv(zUi,"when calling getPlayerId in SLangChatSystem, line 228"),Mqv(M7v(zwi,0,"when calling get in SLangChatSystem, line 228"),"when calling getInner in SLangChatSystem, line 228"),ta,"when calling send in SLangChatSystem, line 228")
set zyi=MLv("when calling nullptr in SLangChatSystem, line 229")
set EM=EM-1
return zyi
endfunction
function zYi takes integer hhi,integer zzi,integer zZi,string z_i returns integer
local integer z0i
set ZM[EM]=z_i
set EM=EM+1
set z0i=p0v(qRv(X8x(Mov(zzi,"when calling getEnumUnit in ScmdUnitBuiltins, line 776"),Mqv(M7v(zZi,0,"when calling get in ScmdUnitBuiltins, line 776"),"when calling getInner in ScmdUnitBuiltins, line 776"),PEv(M7v(zZi,1,"when calling get in ScmdUnitBuiltins, line 776"),"when calling realValue in ScmdUnitBuiltins, line 776"),PEv(M7v(zZi,2,"when calling get in ScmdUnitBuiltins, line 776"),"when calling realValue in ScmdUnitBuiltins, line 776")),"when calling new_Boolean in ScmdUnitBuiltins, line 776"),"when calling new_SharedPointer in ScmdUnitBuiltins, line 776")
set EM=EM-1
return z0i
endfunction
function z1i takes integer Cht,integer Vht,integer z2i,string z3i returns integer
local integer z4i
set ZM[EM]=z3i
set EM=EM+1
set z4i=MJv(Joe(z2i,0,"when calling getPtr in ScmdCoreBuiltins, line 107"),"when calling clone in ScmdCoreBuiltins, line 107")
set EM=EM-1
return z4i
endfunction
function z5i takes integer Xmt,integer Cmt,integer z6i,string z7i returns integer
local integer z8i
local integer z9i
set ZM[EM]=z7i
set EM=EM+1
set z8i=ox[M7v(z6i,0,"when calling get in ScmdCoreBuiltins, line 294")]
set z9i=p0v(qRv((z8i>=$EFD and z8i<=$EFE)or(z8i>=$F01 and z8i<=$F03),"when calling new_Boolean in ScmdCoreBuiltins, line 294"),"when calling new_SharedPointer in ScmdCoreBuiltins, line 294")
set EM=EM-1
return z9i
endfunction
function Zzi takes effect Z2i,real vva returns nothing
call BlzSetSpecialEffectTime(Z2i,vva)
endfunction
function vea takes integer Cft,integer Vft,integer vxa,string voa returns integer
local integer vra
set ZM[EM]=voa
set EM=EM+1
call Zzi(Pov(M7v(vxa,0,"when calling get in SLangSpecialEffectFunctions, line 44"),"when calling getInner in SLangSpecialEffectFunctions, line 44"),PEv(M7v(vxa,1,"when calling get in SLangSpecialEffectFunctions, line 44"),"when calling realValue in SLangSpecialEffectFunctions, line 44"))
set vra=MLv("when calling nullptr in SLangSpecialEffectFunctions, line 45")
set EM=EM-1
return vra
endfunction
function via takes integer CTt,integer vaa,integer BTt,string vna returns integer
local integer vVa
set ZM[EM]=vna
set EM=EM+1
set vVa=p0v(q2v(ple(vaa,"when calling getSpellTargetY in SLangTriggerFunctions, line 106"),"when calling new_Real in SLangTriggerFunctions, line 106"),"when calling new_SharedPointer in SLangTriggerFunctions, line 106")
set EM=EM-1
return vVa
endfunction
function vEa takes integer Cgi,integer Vgi,integer vXa,string vOa returns integer
local integer vRa
set ZM[EM]=vOa
set EM=EM+1
call Sfe(PCv(M7v(vXa,0,"when calling get in ScmdUnitBuiltins, line 760"),"when calling getInner in ScmdUnitBuiltins, line 760"))
set vRa=MLv("when calling nullptr in ScmdUnitBuiltins, line 761")
set EM=EM-1
return vRa
endfunction
function vIa takes string vAa returns string
local integer vNa=GZv(vAa)
loop
exitwhen not(vNa!=0 and duv(vAa,vNa-1)==" ")
set vNa=vNa-1
endloop
return Psv(vAa,0,vNa)
endfunction
function vba takes integer Ckt,integer Vkt,integer vBa,string vca returns integer
local integer vCa
set ZM[EM]=vca
set EM=EM+1
set vCa=p0v(Ppv(vIa(Mqv(M7v(vBa,0,"when calling get in ScmdCoreBuiltins, line 169"),"when calling getInner in ScmdCoreBuiltins, line 169")),"when calling new_String in ScmdCoreBuiltins, line 169"),"when calling new_SharedPointer in ScmdCoreBuiltins, line 169")
set EM=EM-1
return vCa
endfunction
function vda takes integer CFi,integer vDa,integer vfa,string vFa returns integer
local integer vga
set ZM[EM]=vFa
set EM=EM+1
call Mwv(Mov(vDa,"when calling getEnumUnit in ScmdUnitBuiltins, line 814"),Mqv(M7v(vfa,0,"when calling get in ScmdUnitBuiltins, line 814"),"when calling getInner in ScmdUnitBuiltins, line 814"),false)
set vga=MLv("when calling nullptr in ScmdUnitBuiltins, line 815")
set EM=EM-1
return vga
endfunction
function vGa takes integer g0i,integer h0i,integer vha,string vHa returns integer
local integer vja
set ZM[EM]=vHa
set EM=EM+1
call IFe(Wlv(M7v(vha,0,"when calling get in ScmdItemBuiltins, line 34"),"when calling getInner in ScmdItemBuiltins, line 34"),Mqv(M7v(vha,1,"when calling get in ScmdItemBuiltins, line 34"),"when calling getInner in ScmdItemBuiltins, line 34"))
set vja=MLv("when calling nullptr in ScmdItemBuiltins, line 35")
set EM=EM-1
return vja
endfunction
function vJa takes integer gEi,integer vka,integer vKa,string vla returns integer
local integer vLa
set ZM[EM]=vla
set EM=EM+1
set vLa=p0v(jle(Zpx(sa[QGv(vka,"when calling getPlayerId in SotfrpGuiCoreUnit, line 111")],QNv(M7v(vKa,0,"when calling get in SotfrpGuiCoreUnit, line 111"),"when calling intValue in SotfrpGuiCoreUnit, line 111"),Mqv(M7v(vKa,1,"when calling get in SotfrpGuiCoreUnit, line 111"),"when calling getInner in SotfrpGuiCoreUnit, line 111"),uov(vf[QGv(vka,"when calling getPlayerId in SotfrpGuiCoreUnit, line 111")]),c3),"when calling new_Group in SotfrpGuiCoreUnit, line 111"),"when calling new_SharedPointer in SotfrpGuiCoreUnit, line 111")
set EM=EM-1
return vLa
endfunction
function vma takes integer gRi,integer hRi,integer vMa,string vpa returns integer
local integer vPa
set ZM[EM]=vpa
set EM=EM+1
call C1e(PCv(M7v(vMa,0,"when calling get in ScmdUnitBuiltins, line 634"),"when calling getInner in ScmdUnitBuiltins, line 634"),WCv(M7v(vMa,1,"when calling get in ScmdUnitBuiltins, line 634"),"when calling booleanValue in ScmdUnitBuiltins, line 634"),WCv(M7v(vMa,2,"when calling get in ScmdUnitBuiltins, line 634"),"when calling booleanValue in ScmdUnitBuiltins, line 634"))
set vPa=MLv("when calling nullptr in ScmdUnitBuiltins, line 635")
set EM=EM-1
return vPa
endfunction
function vqa takes integer gYi,integer vQa,integer FYi,string vsa returns integer
local integer vSa
set ZM[EM]=vsa
set EM=EM+1
set vSa=p0v(SSv(umv(Mov(vQa,"when calling getEnumUnit in ScmdUnitBuiltins, line 691")),"when calling new_Integer in ScmdUnitBuiltins, line 691"),"when calling new_SharedPointer in ScmdUnitBuiltins, line 691")
set EM=EM-1
return vSa
endfunction
function vta takes integer gci,integer hci,integer vTa,string vua returns integer
local integer vUa
set ZM[EM]=vua
set EM=EM+1
set vUa=p0v(q2v(e8e(PCv(M7v(vTa,0,"when calling get in ScmdUnitBuiltins, line 139"),"when calling getInner in ScmdUnitBuiltins, line 139")),"when calling new_Real in ScmdUnitBuiltins, line 139"),"when calling new_SharedPointer in ScmdUnitBuiltins, line 139")
set EM=EM-1
return vUa
endfunction
function vwa takes integer gdi,integer vWa,integer Fdi,string vya returns integer
local integer vYa
set ZM[EM]=vya
set EM=EM+1
set vYa=p0v(SSv(dDe(Mov(vWa,"when calling getEnumUnit in ScmdUnitBuiltins, line 568")),"when calling new_Integer in ScmdUnitBuiltins, line 568"),"when calling new_SharedPointer in ScmdUnitBuiltins, line 568")
set EM=EM-1
return vYa
endfunction
function vza takes integer goi,integer hoi,integer vZa,string v_a returns integer
local integer v0a
set ZM[EM]=v_a
set EM=EM+1
call Aqe(PCv(M7v(vZa,0,"when calling get in ScmdUnitBuiltins, line 165"),"when calling getInner in ScmdUnitBuiltins, line 165"),PEv(M7v(vZa,1,"when calling get in ScmdUnitBuiltins, line 165"),"when calling realValue in ScmdUnitBuiltins, line 165"))
set v0a=MLv("when calling nullptr in ScmdUnitBuiltins, line 166")
set EM=EM-1
return v0a
endfunction
function v1a takes integer rEi,integer v2a,integer tEi,string v3a returns integer
local unit v4a
local integer v5a
local integer v6a
local integer v7a
local integer v8a
local integer v9a
set ZM[EM]=v3a
set EM=EM+1
set v4a=Mov(v2a,"when calling getEnumUnit in SotfrpGuiCoreUnit, line 85")
set v5a=QGv(v2a,"when calling getPlayerId in SotfrpGuiCoreUnit, line 86")
set v6a=ybv("when calling new_StringTable in SotfrpGuiCoreUnit, line 87")
set v7a=YTv(v6a,"when calling new_SingleUnitData in SotfrpGuiCoreUnit, line 88")
call E_e(v7a,v4a,"when calling build in SotfrpGuiCoreUnit, line 88")
set v8a=v7a
call BSe(v8a,sa[v5a],uov(QKv(v5a)),c3,GetUnitFacing(v4a),"when calling create in SotfrpGuiCoreUnit, line 88")
call Xze(v8a,"when calling dispatch_SingleUnitData_destroySingleUnitData in SotfrpGuiCoreUnit, line 88")
call OJe(v6a,"when calling dispatch_StringTable_destroyStringTable in SotfrpGuiCoreUnit, line 89")
set v9a=MLv("when calling nullptr in SotfrpGuiCoreUnit, line 91")
set EM=EM-1
set v4a=null
return v9a
endfunction
function eva takes integer cFt,integer oFt,integer eea,string exa returns integer
local integer eoa
set ZM[EM]=exa
set EM=EM+1
set eoa=MJv(Joe(eea,0,"when calling getPtr in ScmdCoreBuiltins, line 113"),"when calling clone in ScmdCoreBuiltins, line 113")
set EM=EM-1
return eoa
endfunction
function era takes effect eia,real eaa returns nothing
call BlzSetSpecialEffectPitch(eia,eaa)
endfunction
function ena takes integer cRt,integer oRt,integer eVa,string eEa returns integer
local integer eXa
set ZM[EM]=eEa
set EM=EM+1
call era(Pov(M7v(eVa,0,"when calling get in SLangSpecialEffectFunctions, line 52"),"when calling getInner in SLangSpecialEffectFunctions, line 52"),PEv(M7v(eVa,1,"when calling get in SLangSpecialEffectFunctions, line 52"),"when calling realValue in SLangSpecialEffectFunctions, line 52"))
set eXa=MLv("when calling nullptr in SLangSpecialEffectFunctions, line 53")
set EM=EM-1
return eXa
endfunction
function eOa takes integer iSi,integer eRa,integer cSi,string eIa returns integer
local unit eAa
local integer eNa
local integer eba
set ZM[EM]=eIa
set EM=EM+1
set eAa=Mov(eRa,"when calling getEnumUnit in ScmdUnitBuiltins, line 104")
if v1e(eAa)then
set eNa=q2v(ere(eAa),"when calling new_Real in ScmdUnitBuiltins, line 105")
else
set eNa=cBe("when calling new_Undefined in ScmdUnitBuiltins, line 105")
endif
set eba=pIe(eNa,"when calling new_GenericSharedPointer in ScmdUnitBuiltins, line 105")
set EM=EM-1
set eAa=null
return eba
endfunction
function eBa takes integer cYt,integer eca,integer OYt,string eCa returns integer
local integer eda
set ZM[EM]=eCa
set EM=EM+1
set eda=p0v(lte(qfe(eca,"when calling getSpellTargetItem in SLangTriggerFunctions, line 112"),"when calling new_Item in SLangTriggerFunctions, line 112"),"when calling new_SharedPointer in SLangTriggerFunctions, line 112")
set EM=EM-1
return eda
endfunction
function eDa takes integer efa,string eFa returns nothing
set ZM[EM]=eFa
set EM=EM+1
set Kf[efa]=true
call s6e(efa,"when calling updateInfo in SotfrpGuiDestructables, line 178")
set EM=EM-1
endfunction
function ega takes integer eGa,string eha returns nothing
set ZM[EM]=eha
set EM=EM+1
set Df[eGa]=true
call s6e(eGa,"when calling updateInfo in SotfrpGuiDestructables, line 165")
set EM=EM-1
endfunction
function eHa takes string eja,string eJa returns string
local string eka=eja
local integer eKa=0
set eka=HXe(eka,"{"+SMv(eKa)+"}",eJa)
set eKa=eKa+1
return eka
endfunction
function ela takes integer eLa,integer ema,string eMa returns nothing
set ZM[EM]=eMa
set EM=EM+1
set Kf[eLa]=false
set Lf[eLa]=ema
call s6e(eLa,"when calling updateInfo in SotfrpGuiDestructables, line 174")
set EM=EM-1
endfunction
function epa takes integer ePa,real eqa,string eQa returns nothing
set ZM[EM]=eQa
set EM=EM+1
set Df[ePa]=false
set Hf[ePa]=eqa
call s6e(ePa,"when calling updateInfo in SotfrpGuiDestructables, line 161")
set EM=EM-1
endfunction
function esa takes integer eSa,real eta,string eTa returns nothing
set ZM[EM]=eTa
set EM=EM+1
set Jf[eSa]=eta
call s6e(eSa,"when calling updateInfo in SotfrpGuiDestructables, line 169")
set EM=EM-1
endfunction
function eua takes integer eUa,real ewa,string eWa returns nothing
set ZM[EM]=eWa
set EM=EM+1
set Af[eUa]=ewa
call s6e(eUa,"when calling updateInfo in SotfrpGuiDestructables, line 156")
set EM=EM-1
endfunction
function eya takes integer eYa,integer eza,integer eZa,string e_a returns integer
local string e0a
local boolean e1a
local integer e2a
local integer e3a
local integer e4a
local string e5a
local integer e6a
local integer e7a
local integer e8a
local integer e9a
local integer xva
local integer xea
local integer xxa
local integer xoa
local integer xra
local boolean xia
set ZM[EM]=e_a
set EM=EM+1
call fge(1,eZa,"when calling toString in SotfrpGuiDestructables, line 186")
set e0a=tYv(RHv)
set e1a=e0a=="rand" or e0a=="random"
set e6a=ox[eZa]
if not((e6a>=$EFD and e6a<=$EFE)or(e6a>=$F01 and e6a<=$F03)or e1a)then
set xea=B6e("Value should be a number or \"random\"","when calling wrap in SotfrpGuiDestructables, line 189")
set EM=EM-1
return xea
endif
if e1a then
set e3a=0
else
set e3a=eZa
endif
set e2a=e3a
set e4a=QGv(eYa,"when calling getPlayerId in SotfrpGuiDestructables, line 191")
call fge(1,eza,"when calling toString in SotfrpGuiDestructables, line 192")
set e5a=RHv
if e5a=="fly" or e5a=="fh" or e5a=="flyheight" then
if e2a==0 then
set xoa=B6e("Random fly height is not supported","when calling wrap in SotfrpGuiDestructables, line 195")
set EM=EM-1
return xoa
endif
call eua(e4a,kge(e2a,"when calling realValue in SotfrpGuiDestructables, line 196"),"when calling setFlyHeight in SotfrpGuiDestructables, line 196")
elseif e5a=="fa" or e5a=="facing" then
if e2a==0 then
call ega(e4a,"when calling setFacingRandom in SotfrpGuiDestructables, line 199")
else
call epa(e4a,kge(e2a,"when calling realValue in SotfrpGuiDestructables, line 201"),"when calling setFacing in SotfrpGuiDestructables, line 201")
endif
elseif e5a=="size" then
if e2a==0 then
set xva=B6e("Random size is not supported","when calling wrap in SotfrpGuiDestructables, line 204")
set EM=EM-1
return xva
endif
call esa(e4a,kge(e2a,"when calling realValue in SotfrpGuiDestructables, line 205")/100.,"when calling setScale in SotfrpGuiDestructables, line 205")
elseif e5a=="scale" then
if e2a==0 then
set xxa=B6e("Random scale is not supported","when calling wrap in SotfrpGuiDestructables, line 208")
set EM=EM-1
return xxa
endif
call esa(e4a,kge(e2a,"when calling realValue in SotfrpGuiDestructables, line 209"),"when calling setScale in SotfrpGuiDestructables, line 209")
elseif e5a=="var" or e5a=="variation" then
if e2a!=0 then
set e7a=ox[e2a]
set xia=not(e7a==$EFD or e7a==$F03)
else
set xia=false
endif
if xia then
set e9a=B6e("Variation should be an integer or \"random\"","when calling wrap in SotfrpGuiDestructables, line 212")
set EM=EM-1
return e9a
endif
if e2a==0 then
call eDa(e4a,"when calling setVariationRandom in SotfrpGuiDestructables, line 214")
else
call ela(e4a,kZe(e2a,"when calling intValue in SotfrpGuiDestructables, line 216"),"when calling setVariation in SotfrpGuiDestructables, line 216")
endif
elseif e5a=="occ" or e5a=="occluder" or e5a=="oh" or e5a=="occluderheight" then
elseif e5a=="aspeed" then
else
call fge(1,eza,"when calling toString in SotfrpGuiDestructables, line 222")
set e8a=B6e(eHa("Unknown parameter {0}",RHv),"when calling wrap in SotfrpGuiDestructables, line 222")
set EM=EM-1
return e8a
endif
set xra=MLv("when calling nullptr in SotfrpGuiDestructables, line 223")
set EM=EM-1
return xra
endfunction
function xaa takes integer cZi,integer xna,integer xVa,string xEa returns integer
local integer xXa
set ZM[EM]=xEa
set EM=EM+1
set xXa=eya(xna,M7v(xVa,0,"when calling get in SotfrpGuiDestructables, line 232"),M7v(xVa,1,"when calling get in SotfrpGuiDestructables, line 232"),"when calling doodCmd in SotfrpGuiDestructables, line 232")
set EM=EM-1
return xXa
endfunction
function xOa takes integer chi,integer ohi,integer xRa,string xIa returns integer
local integer xAa
set ZM[EM]=xIa
set EM=EM+1
call SHe(PCv(M7v(xRa,0,"when calling get in ScmdUnitBuiltins, line 767"),"when calling getInner in ScmdUnitBuiltins, line 767"))
set xAa=MLv("when calling nullptr in ScmdUnitBuiltins, line 768")
set EM=EM-1
return xAa
endfunction
function xNa takes integer cvi,integer xba,integer xBa,string xca returns integer
local integer xCa
set ZM[EM]=xca
set EM=EM+1
call wAv(Mov(xba,"when calling getEnumUnit in SotFRP_AbilitySystem, line 46"),Mqv(M7v(xBa,0,"when calling get in SotFRP_AbilitySystem, line 46"),"when calling getInner in SotFRP_AbilitySystem, line 46"),"when calling addAbility in SotFRP_AbilitySystem, line 46")
set xCa=MLv("when calling nullptr in SotFRP_AbilitySystem, line 47")
set EM=EM-1
return xCa
endfunction
function xda takes integer xDa,integer xfa,integer xFa,string xga,integer xGa,string xha,integer xHa,string xja returns nothing
local integer xJa
local integer xka
local integer xKa
local integer xla
local integer xLa
local integer xma
local integer xMa
local integer xpa
local string xPa
local string xqa
local integer xQa
local integer xsa
local integer xSa
local integer xta
local integer xTa
local integer xua
local integer xUa
local string xwa
local integer xWa
local integer xya
local integer xYa
local integer xza
local integer xZa
local boolean x_a
local integer x0a
local integer x1a
local integer x2a
local integer x3a
local integer x4a
local integer x5a
local integer x6a
local integer x7a
local integer x8a
local integer x9a
local integer ova
local integer oea
local integer oxa
local integer ooa
local integer ora
local integer oia
local unit oaa
local group ona
local unit oVa
local integer oEa
local integer oXa
local integer oOa
local integer oRa
local integer oIa
local integer oAa
local integer oNa
local integer oba
local integer oBa
local integer oca
local integer oCa
local integer oda
local integer oDa
local integer ofa
local integer oFa
local integer oga
local integer oGa
local integer oha
local integer oHa
local integer oja
local integer oJa
local integer oka
local integer oKa
local integer ola
local integer oLa
local integer oma
local integer oMa
local integer opa
local integer oPa
local integer oqa
local integer oQa
local integer osa
local integer oSa
local integer ota
local integer oTa
local integer oua
local integer oUa
local boolean owa
local integer oWa
local integer oya
local integer oYa
local integer oza
local integer oZa
local integer o_a
local integer o0a
local integer o1a
local integer o2a
local integer o3a
local integer o4a
local integer o5a
local integer o6a
local integer o7a
local integer o8a
local integer o9a
local integer rva
local integer rea
if xDa==0 then
set ZM[EM]=xga
set EM=EM+1
call xda(8,xFa,rK[xfa],"when calling resolve in ScmdDataTypes, line 1645",0,null,0,null)
set xJa=RJv
set xla=ox[m0v(xJa,"when calling get in ScmdDataTypes, line 1646")]
if xla>=$EF1 and xla<=$EF2 then
set EM=EM-1
set RJv=xJa
set oaa=null
set ona=null
set oVa=null
return
endif
set xLa=ox[m0v(xJa,"when calling get in ScmdDataTypes, line 1648")]
if not((xLa>=$EEA and xLa<=$EEC)or(xLa>=$EEC and xLa<=$EEF))then
set xka=B6e(DWe(DSe(m0v(xJa,"when calling get in ScmdDataTypes, line 1649"),"when calling getTypeToken in ScmdDataTypes, line 1649"),"when calling getName in ScmdDataTypes, line 1649")+" cannot be cast to Callable","when calling wrap in ScmdDataTypes, line 1649")
call mfv(20,xJa,"when calling dispatch_GenericSharedPointer_destroyGenericSharedPointer in ScmdDataTypes, line 1650")
set EM=EM-1
set RJv=xka
set oaa=null
set ona=null
set oVa=null
return
endif
call xda(2,m0v(xJa,"when calling get in ScmdDataTypes, line 1652"),xFa,null,sK[xfa],"when calling call in ScmdDataTypes, line 1652",0,null)
set xKa=RJv
call mfv(20,xJa,"when calling dispatch_GenericSharedPointer_destroyGenericSharedPointer in ScmdDataTypes, line 1653")
set xma=ox[m0v(xKa,"when calling get in ScmdDataTypes, line 1654")]
if xma>=$EF1 and xma<=$EF2 then
set rea=m0v(xKa,"when calling get in ScmdDataTypes, line 1655")
call fge(1,m0v(rK[xfa],"when calling get in ScmdDataTypes, line 1655"),"when calling toString in ScmdDataTypes, line 1655")
call lfe(rea,RHv,"when calling pushToTrace in ScmdDataTypes, line 1655")
endif
set EM=EM-1
set RJv=xKa
set oaa=null
set ona=null
set oVa=null
return
elseif xDa==1 then
set ZM[EM]=xha
set EM=EM+1
if ox[xfa]==0 then
if xfa==0 then
call Cdv("Nullpointer exception when calling Function.callImpl","when calling error in ScmdDataTypes, line 1304")
else
call Cdv("Called Function.callImpl on invalid object.","when calling error in ScmdDataTypes, line 1304")
endif
endif
if ox[xfa]<=$EEC then
call xda(9,xfa,xFa,null,xGa,"when calling callImpl in ScmdDataTypes, line 1304",0,null)
set xMa=RJv
else
call xda(3,xfa,xFa,null,xGa,"when calling callImpl in ScmdDataTypes, line 1304",0,null)
set xMa=RJv
endif
set EM=EM-1
set RJv=xMa
set oaa=null
set ona=null
set oVa=null
return
elseif xDa==2 then
set ZM[EM]=xha
set EM=EM+1
if ox[xfa]==0 then
if xfa==0 then
call Cdv("Nullpointer exception when calling Callable.call","when calling error in ScmdDataTypes, line 1295")
else
call Cdv("Called Callable.call on invalid object.","when calling error in ScmdDataTypes, line 1295")
endif
endif
if ox[xfa]<=$EED then
if ox[xfa]<=$EEC then
call xda(19,xfa,xFa,null,xGa,"when calling call in ScmdDataTypes, line 1295",0,null)
set xpa=RJv
else
call xda(23,xfa,xFa,null,xGa,"when calling call in ScmdDataTypes, line 1295",0,null)
set xpa=RJv
endif
else
call xda($F,xfa,xFa,null,xGa,"when calling call in ScmdDataTypes, line 1295",0,null)
set xpa=RJv
endif
set EM=EM-1
set RJv=xpa
set oaa=null
set ona=null
set oVa=null
return
elseif xDa==3 then
set ZM[EM]=xha
set EM=EM+1
set xPa=""
set xqa=""
if SNv(xGa,"when calling size in ScmdDataTypes, line 1341")>dgv(aK[xfa],"when calling size in ScmdDataTypes, line 1341")and(not SUo(aK[xfa],"when calling isEmpty in ScmdDataTypes, line 1341"))then
set xQa=0
set xsa=SNv(xGa,"when calling size in ScmdDataTypes, line 1343")-dgv(aK[xfa],"when calling size in ScmdDataTypes, line 1343")+1
loop
exitwhen not(xQa!=xsa)
set xSa=Joe(xGa,SNv(xGa,"when calling size in ScmdDataTypes, line 1345")-1,"when calling getPtr in ScmdDataTypes, line 1345")
set xya=ox[iNo(xSa,"when calling get in ScmdDataTypes, line 1346")]
if not(xya>=$EFB and xya<=$EFF)then
exitwhen true
endif
call gko(xGa,SNv(xGa,"when calling size in ScmdDataTypes, line 1348")-1,"when calling removeAt in ScmdDataTypes, line 1348")
call fge(1,iNo(xSa,"when calling get in ScmdDataTypes, line 1349"),"when calling toString in ScmdDataTypes, line 1349")
set xqa=RHv+xPa+xqa
set xPa=M8e(iNo(xSa,"when calling get in ScmdDataTypes, line 1350"),"when calling getPreviousWhitespaces in ScmdDataTypes, line 1350")
call mfv(17,xSa,"when calling dispatch_SharedPointer_destroySharedPointer in ScmdDataTypes, line 1351")
set xQa=xQa+1
endloop
if xQa!=0 then
call gWo(xGa,p0v(cCo(xqa,xPa,"when calling forStrings in ScmdDataTypes, line 1354"),"when calling new_SharedPointer in ScmdDataTypes, line 1354"),"when calling add in ScmdDataTypes, line 1354")
endif
endif
if SNv(xGa,"when calling size in ScmdDataTypes, line 1355")!=dgv(aK[xfa],"when calling size in ScmdDataTypes, line 1355")then
set xYa=p0v(tJv("Неверное количество аргументов, ожидалось "+SMv(dgv(aK[xfa],"when calling size in ScmdDataTypes, line 1356")),"when calling new_Exception in ScmdDataTypes, line 1356"),"when calling new_SharedPointer in ScmdDataTypes, line 1356")
set EM=EM-1
set RJv=xYa
set oaa=null
set ona=null
set oVa=null
return
endif
set xta=qUe(xFa,"when calling clone in ScmdDataTypes, line 1357")
set xTa=0
set xua=SNv(xGa,"when calling size in ScmdDataTypes, line 1358")-1
loop
exitwhen xTa>xua
call W1v(xta,hxv(jqv(aK[xfa],xTa,"when calling get in ScmdDataTypes, line 1359"),"when calling stringFromIndex in ScmdDataTypes, line 1359"),MJv(Joe(xGa,xTa,"when calling getPtr in ScmdDataTypes, line 1359"),"when calling clone in ScmdDataTypes, line 1359"),"when calling assign in ScmdDataTypes, line 1359")
set xTa=xTa+1
endloop
set xUa=jjv(dK[xfa],"when calling iterator in ScmdDataTypes, line 1360")
loop
exitwhen not Jgv(xUa,"when calling hasNext in ScmdDataTypes, line 1360")
set xwa=hxv(jTv(xUa,"when calling next in ScmdDataTypes, line 1360"),"when calling stringFromIndex in ScmdDataTypes, line 1360")
call W1v(xta,xwa,P_v(f3v(dK[xfa],KCv(xwa,"when calling stringToIndex in ScmdDataTypes, line 1361"),"when calling get in ScmdDataTypes, line 1361"),"when calling clone in ScmdDataTypes, line 1361"),"when calling assign in ScmdDataTypes, line 1361")
endloop
call Jqv(xUa,"when calling close in ScmdDataTypes, line 1360")
call xda(8,xta,nK[xfa],"when calling resolve in ScmdDataTypes, line 1362",0,null,0,null)
set xWa=RJv
call mfv(4,xta,"when calling dispatch_Context_destroyContext in ScmdDataTypes, line 1363")
set EM=EM-1
set RJv=xWa
set oaa=null
set ona=null
set oVa=null
return
elseif xDa==4 then
set ZM[EM]=xha
set EM=EM+1
if Gj[xfa]==0 then
if xfa==0 then
call Cdv("Nullpointer exception when calling IBuiltin.call","when calling error in ScmdDataTypes, line 1374")
else
call Cdv("Called IBuiltin.call on invalid object.","when calling error in ScmdDataTypes, line 1374")
endif
endif
if Gj[xfa]<=$ADF then
if Gj[xfa]<=$A7E then
if Gj[xfa]<=$A4E then
if Gj[xfa]<=$A36 then
if Gj[xfa]<=$A2A then
if Gj[xfa]<=$A24 then
if Gj[xfa]<=$A21 then
if Gj[xfa]<=$A1F then
if Gj[xfa]<=$A1E then
set xza=Q7e(xfa,xFa,xGa,"when calling call_addOverload_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdDataTypes, line 1374")
else
set xza=WJo(xfa,xFa,xGa,"when calling call_addOverload_registerProtectedBuiltin_ScmdFogOfWarBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$A20 then
set xza=jIe(xfa,xFa,xGa,"when calling call_registerProtectedBuiltin_SLangPlayerFunctions in ScmdDataTypes, line 1374")
else
set xza=hNo(xfa,xFa,xGa,"when calling call_registerProtectedBuiltin_SLangTriggerFunctions in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$A23 then
if Gj[xfa]<=$A22 then
set xza=Erx(xfa,xFa,xGa,"when calling call_registerProtectedBuiltin_SLangTriggerFunctions in ScmdDataTypes, line 1374")
else
set xza=mzo(xfa,xFa,xGa,"when calling call_registerProtectedBuiltin_SLangTriggerFunctions in ScmdDataTypes, line 1374")
endif
else
set xza=RZx(xfa,xFa,xGa,"when calling call_registerProtectedBuiltin_SLangTriggerFunctions in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$A27 then
if Gj[xfa]<=$A26 then
if Gj[xfa]<=$A25 then
set xza=p4v(xfa,xFa,xGa,"when calling call_registerProtectedBuiltin_SLangTriggerFunctions in ScmdDataTypes, line 1374")
else
set xza=ILx(xfa,xFa,xGa,"when calling call_registerProtectedBuiltin_SLangTriggerFunctions in ScmdDataTypes, line 1374")
endif
else
set xza=via(xfa,xFa,xGa,"when calling call_registerProtectedBuiltin_SLangTriggerFunctions in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$A29 then
if Gj[xfa]<=$A28 then
set xza=sJe(xfa,xFa,xGa,"when calling call_registerProtectedBuiltin_SLangTriggerFunctions in ScmdDataTypes, line 1374")
else
set xza=eBa(xfa,xFa,xGa,"when calling call_registerProtectedBuiltin_SLangTriggerFunctions in ScmdDataTypes, line 1374")
endif
else
set xza=ONo(xfa,xFa,xGa,"when calling call_registerProtectedBuiltin_SLangTriggerFunctions in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$A30 then
if Gj[xfa]<=$A2D then
if Gj[xfa]<=$A2C then
if Gj[xfa]<=$A2B then
set xza=smo(xfa,xFa,xGa,"when calling call_registerProtectedBuiltin_ScmdCameraSetupBuiltins in ScmdDataTypes, line 1374")
else
set xza=qbv(xfa,xFa,xGa,"when calling call_registerProtectedBuiltin_ScmdFogOfWarBuiltins in ScmdDataTypes, line 1374")
endif
else
set xza=m6e(xfa,xFa,xGa,"when calling call_registerProtectedBuiltin_ScmdFogOfWarBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$A2F then
if Gj[xfa]<=$A2E then
set xza=mKo(xfa,xFa,xGa,"when calling call_registerProtectedBuiltin_ScmdRectBuiltins in ScmdDataTypes, line 1374")
else
set xza=WCo(xfa,xFa,xGa,"when calling call_registerProtectedBuiltin_ScmdSoundFunctions in ScmdDataTypes, line 1374")
endif
else
set xza=s3o(xfa,xFa,xGa,"when calling call_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$A33 then
if Gj[xfa]<=$A32 then
if Gj[xfa]<=$A31 then
set xza=jpe(xfa,xFa,xGa,"when calling call_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
else
set xza=mee(xfa,xFa,xGa,"when calling call_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
else
set xza=Pxo(xfa,xFa,xGa,"when calling call_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$A35 then
if Gj[xfa]<=$A34 then
set xza=QLv(xfa,xFa,xGa,"when calling call_registerProtectedBuiltin_SotfrpGuiCoreUnit in ScmdDataTypes, line 1374")
else
set xza=z1r(xfa,xFa,xGa,"when calling call_registerProtectedBuiltin_SotfrpGuiCoreUnit in ScmdDataTypes, line 1374")
endif
else
set xza=Wjv(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_addOverload_registerProtectedBuiltin_SotFRP_AbilitySystem in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$A42 then
if Gj[xfa]<=$A3C then
if Gj[xfa]<=$A39 then
if Gj[xfa]<=$A38 then
if Gj[xfa]<=$A37 then
set xza=Z3o(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_SLangSpecialEffectFunctions in ScmdDataTypes, line 1374")
else
set xza=T2v(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdDataTypes, line 1374")
endif
else
set xza=QCv(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$A3B then
if Gj[xfa]<=$A3A then
set xza=cPo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdDataTypes, line 1374")
else
call xda(18,xfa,xFa,null,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdDataTypes, line 1374",0,null)
set xza=RJv
endif
else
call xda(5,xfa,xFa,null,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdDataTypes, line 1374",0,null)
set xza=RJv
endif
elseif Gj[xfa]<=$A3F then
if Gj[xfa]<=$A3E then
if Gj[xfa]<=$A3D then
set xza=z5o(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdDataTypes, line 1374")
else
set xza=iFo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdDataTypes, line 1374")
endif
else
set xza=dLo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdFogOfWarBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$A41 then
if Gj[xfa]<=$A40 then
set xza=lwe(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdItemBuiltins in ScmdDataTypes, line 1374")
else
set xza=qko(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdPlayerCameraSettingsBuiltins in ScmdDataTypes, line 1374")
endif
else
set xza=NEo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdPlayerCameraSettingsBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$A48 then
if Gj[xfa]<=$A45 then
if Gj[xfa]<=$A44 then
if Gj[xfa]<=$A43 then
set xza=SUe(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
else
set xza=HXo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
else
set xza=t3v(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$A47 then
if Gj[xfa]<=$A46 then
set xza=VXo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
else
set xza=CQo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
else
set xza=SKo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$A4B then
if Gj[xfa]<=$A4A then
if Gj[xfa]<=$A49 then
set xza=Jqe(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
else
set xza=Wzr(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
else
set xza=QGe(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$A4D then
if Gj[xfa]<=$A4C then
set xza=q3e(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
else
set xza=lze(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
else
set xza=lmo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$A66 then
if Gj[xfa]<=$A5A then
if Gj[xfa]<=$A54 then
if Gj[xfa]<=$A51 then
if Gj[xfa]<=$A50 then
if Gj[xfa]<=$A4F then
set xza=uKo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
else
set xza=vta(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
else
set xza=fPe(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$A53 then
if Gj[xfa]<=$A52 then
set xza=lUo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
else
set xza=Uvo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
else
set xza=vza(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$A57 then
if Gj[xfa]<=$A56 then
if Gj[xfa]<=$A55 then
set xza=Fxe(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
else
set xza=ZIo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
else
set xza=z0x(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$A59 then
if Gj[xfa]<=$A58 then
set xza=LUo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
else
set xza=Kze(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
else
set xza=Yzr(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$A60 then
if Gj[xfa]<=$A5D then
if Gj[xfa]<=$A5C then
if Gj[xfa]<=$A5B then
set xza=oVo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
else
set xza=Lmo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
else
set xza=udv(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$A5F then
if Gj[xfa]<=$A5E then
set xza=Dzi(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
else
set xza=Wgo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
else
set xza=KLo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$A63 then
if Gj[xfa]<=$A62 then
if Gj[xfa]<=$A61 then
set xza=Hze(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
else
set xza=mYe(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
else
set xza=qXo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$A65 then
if Gj[xfa]<=$A64 then
set xza=Znx(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
else
set xza=UGv(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
else
set xza=tiv(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$A72 then
if Gj[xfa]<=$A6C then
if Gj[xfa]<=$A69 then
if Gj[xfa]<=$A68 then
if Gj[xfa]<=$A67 then
set xza=nBo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
else
set xza=CLo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
else
set xza=SHo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$A6B then
if Gj[xfa]<=$A6A then
set xza=Jme(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
else
set xza=zGr(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
else
set xza=rjo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$A6F then
if Gj[xfa]<=$A6E then
if Gj[xfa]<=$A6D then
set xza=mHo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
else
set xza=uyv(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
else
set xza=o2i(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$A71 then
if Gj[xfa]<=$A70 then
set xza=wIo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
else
set xza=HFo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
else
set xza=gJe(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$A78 then
if Gj[xfa]<=$A75 then
if Gj[xfa]<=$A74 then
if Gj[xfa]<=$A73 then
set xza=mRe(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
else
set xza=PPo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
else
set xza=Zox(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$A77 then
if Gj[xfa]<=$A76 then
set xza=Ucv(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
else
set xza=S7v(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
else
set xza=nXo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$A7B then
if Gj[xfa]<=$A7A then
if Gj[xfa]<=$A79 then
set xza=dge(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
else
set xza=vVo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
else
set xza=Oyx(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$A7D then
if Gj[xfa]<=$A7C then
set xza=Umo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
else
set xza=Qqe(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
else
set xza=Qxe(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$AAF then
if Gj[xfa]<=$A97 then
if Gj[xfa]<=$A8B then
if Gj[xfa]<=$A85 then
if Gj[xfa]<=$A82 then
if Gj[xfa]<=$A80 then
if Gj[xfa]<=$A7F then
set xza=LRe(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
else
set xza=KZo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$A81 then
set xza=uCo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
else
set xza=vma(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$A84 then
if Gj[xfa]<=$A83 then
set xza=d0e(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
else
set xza=ZCo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
else
set xza=c3o(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$A88 then
if Gj[xfa]<=$A87 then
if Gj[xfa]<=$A86 then
set xza=WXv(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
else
set xza=Mue(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
else
set xza=LMe(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$A8A then
if Gj[xfa]<=$A89 then
set xza=aVo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
else
set xza=dae(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
else
set xza=Z3x(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$A91 then
if Gj[xfa]<=$A8E then
if Gj[xfa]<=$A8D then
if Gj[xfa]<=$A8C then
set xza=Zxo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
else
set xza=xzo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
else
set xza=zLi(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$A90 then
if Gj[xfa]<=$A8F then
set xza=H5e(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
else
set xza=i7r(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
else
set xza=zGo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$A94 then
if Gj[xfa]<=$A93 then
if Gj[xfa]<=$A92 then
set xza=pxo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
else
set xza=PGv(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
else
set xza=vEa(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$A96 then
if Gj[xfa]<=$A95 then
set xza=xOa(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
else
set xza=hZo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
else
set xza=Oox(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$AA3 then
if Gj[xfa]<=$A9D then
if Gj[xfa]<=$A9A then
if Gj[xfa]<=$A99 then
if Gj[xfa]<=$A98 then
set xza=QEv(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
else
set xza=Mxe(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
else
set xza=S4e(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$A9C then
if Gj[xfa]<=$A9B then
set xza=RWx(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
else
set xza=IJx(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
else
set xza=SLe(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$AA0 then
if Gj[xfa]<=$A9F then
if Gj[xfa]<=$A9E then
set xza=wDv(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_SotFRP_AbilitySystem in ScmdDataTypes, line 1374")
else
set xza=TZv(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_SotFRP_AbilitySystem in ScmdDataTypes, line 1374")
endif
else
set xza=XJo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_SotFRP_AbilitySystem in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$AA2 then
if Gj[xfa]<=$AA1 then
set xza=dNo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_SotFRP_AbilitySystem in ScmdDataTypes, line 1374")
else
set xza=S3o(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_SotFRP_AbilitySystem in ScmdDataTypes, line 1374")
endif
else
set xza=uRv(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_SotfrpGuiCoreUnit in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$AA9 then
if Gj[xfa]<=$AA6 then
if Gj[xfa]<=$AA5 then
if Gj[xfa]<=$AA4 then
set xza=BYe(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_SotfrpGuiCoreUnit in ScmdDataTypes, line 1374")
else
set xza=SNe(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_SotfrpGuiDestructables in ScmdDataTypes, line 1374")
endif
else
set xza=xaa(xfa,xFa,xGa,"when calling call_setArgumentsTypes_addOverload_registerProtectedBuiltin_SotfrpGuiDestructables in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$AA8 then
if Gj[xfa]<=$AA7 then
set xza=hMo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_assign_setArgumentsTypes_registerBuiltin_SLangChatSystem in ScmdDataTypes, line 1374")
else
set xza=HJe(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerBuiltin_SLangChatSystem in ScmdDataTypes, line 1374")
endif
else
set xza=Izo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerBuiltin_SLangChatSystem in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$AAC then
if Gj[xfa]<=$AAB then
if Gj[xfa]<=$AAA then
set xza=zui(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerBuiltin_SLangChatSystem in ScmdDataTypes, line 1374")
else
set xza=kNo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerBuiltin_ScmdUnitParamLinkingBuiltins in ScmdDataTypes, line 1374")
endif
else
set xza=kie(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerBuiltin_ScmdUnitParamLinkingBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$AAE then
if Gj[xfa]<=$AAD then
set xza=ZOx(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_SLangChatSystem in ScmdDataTypes, line 1374")
else
set xza=tMo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_SLangChatSystem in ScmdDataTypes, line 1374")
endif
else
set xza=Mho(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_SLangPlayerFunctions in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$AC7 then
if Gj[xfa]<=$ABB then
if Gj[xfa]<=$AB5 then
if Gj[xfa]<=$AB2 then
if Gj[xfa]<=$AB1 then
if Gj[xfa]<=$AB0 then
set xza=X0x(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_SLangPlayerFunctions in ScmdDataTypes, line 1374")
else
set xza=Lxe(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_SLangPlayerFunctions in ScmdDataTypes, line 1374")
endif
else
set xza=N2i(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_SLangPlayerFunctions in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$AB4 then
if Gj[xfa]<=$AB3 then
set xza=MHe(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_SLangPlayerFunctions in ScmdDataTypes, line 1374")
else
set xza=uPo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_SLangPlayerFunctions in ScmdDataTypes, line 1374")
endif
else
set xza=dQe(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_SLangPlayerFunctions in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$AB8 then
if Gj[xfa]<=$AB7 then
if Gj[xfa]<=$AB6 then
set xza=Ogx(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_SLangPlayerFunctions in ScmdDataTypes, line 1374")
else
set xza=Zho(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_SLangPlayerFunctions in ScmdDataTypes, line 1374")
endif
else
set xza=wCo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_SLangPlayerFunctions in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$ABA then
if Gj[xfa]<=$AB9 then
set xza=hFo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_SLangPlayerFunctions in ScmdDataTypes, line 1374")
else
set xza=vAo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_SLangPlayerFunctions in ScmdDataTypes, line 1374")
endif
else
set xza=f8e(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_SLangSpecialEffectFunctions in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$AC1 then
if Gj[xfa]<=$ABE then
if Gj[xfa]<=$ABD then
if Gj[xfa]<=$ABC then
set xza=wxo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_SLangSpecialEffectFunctions in ScmdDataTypes, line 1374")
else
set xza=CFo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_SLangSpecialEffectFunctions in ScmdDataTypes, line 1374")
endif
else
set xza=QUe(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_SLangSpecialEffectFunctions in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$AC0 then
if Gj[xfa]<=$ABF then
set xza=MWo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_SLangSpecialEffectFunctions in ScmdDataTypes, line 1374")
else
set xza=R5x(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_SLangSpecialEffectFunctions in ScmdDataTypes, line 1374")
endif
else
set xza=PIv(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_SLangSpecialEffectFunctions in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$AC4 then
if Gj[xfa]<=$AC3 then
if Gj[xfa]<=$AC2 then
set xza=Isx(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_SLangSpecialEffectFunctions in ScmdDataTypes, line 1374")
else
set xza=vea(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_SLangSpecialEffectFunctions in ScmdDataTypes, line 1374")
endif
else
set xza=soe(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_SLangSpecialEffectFunctions in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$AC6 then
if Gj[xfa]<=$AC5 then
set xza=ena(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_SLangSpecialEffectFunctions in ScmdDataTypes, line 1374")
else
set xza=OEo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_SLangSpecialEffectFunctions in ScmdDataTypes, line 1374")
endif
else
set xza=zsi(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_SLangTriggerFunctions in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$AD3 then
if Gj[xfa]<=$ACD then
if Gj[xfa]<=$ACA then
if Gj[xfa]<=$AC9 then
if Gj[xfa]<=$AC8 then
set xza=Xhx(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_SLangTriggerFunctions in ScmdDataTypes, line 1374")
else
set xza=jee(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_SLangTriggerFunctions in ScmdDataTypes, line 1374")
endif
else
call xda(7,xfa,xFa,null,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_SLangTriggerFunctions in ScmdDataTypes, line 1374",0,null)
set xza=RJv
endif
elseif Gj[xfa]<=$ACC then
if Gj[xfa]<=$ACB then
call xda(21,xfa,xFa,null,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_SLangTriggerFunctions in ScmdDataTypes, line 1374",0,null)
set xza=RJv
else
set xza=qtv(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_SLangTriggerFunctions in ScmdDataTypes, line 1374")
endif
else
set xza=sOe(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_SLangTriggerFunctions in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$AD0 then
if Gj[xfa]<=$ACF then
if Gj[xfa]<=$ACE then
set xza=zOo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_SLangTriggerFunctions in ScmdDataTypes, line 1374")
else
set xza=FRe(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_ScmdCameraSetupBuiltins in ScmdDataTypes, line 1374")
endif
else
set xza=jBe(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_ScmdCameraSetupBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$AD2 then
if Gj[xfa]<=$AD1 then
set xza=L6e(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_ScmdCameraSetupBuiltins in ScmdDataTypes, line 1374")
else
set xza=zxr(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_ScmdCameraSetupBuiltins in ScmdDataTypes, line 1374")
endif
else
set xza=pWo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_ScmdCameraSetupBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$AD9 then
if Gj[xfa]<=$AD6 then
if Gj[xfa]<=$AD5 then
if Gj[xfa]<=$AD4 then
set xza=oAo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_ScmdCameraSetupBuiltins in ScmdDataTypes, line 1374")
else
set xza=z1i(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdDataTypes, line 1374")
endif
else
set xza=Q3e(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$AD8 then
if Gj[xfa]<=$AD7 then
set xza=eva(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdDataTypes, line 1374")
else
set xza=LJo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdDataTypes, line 1374")
endif
else
set xza=u8v(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$ADC then
if Gj[xfa]<=$ADB then
if Gj[xfa]<=$ADA then
set xza=XNo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdDataTypes, line 1374")
else
set xza=Wvo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdDataTypes, line 1374")
endif
else
set xza=Xbx(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$ADE then
if Gj[xfa]<=$ADD then
set xza=pho(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdDataTypes, line 1374")
else
set xza=IGx(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdDataTypes, line 1374")
endif
else
set xza=Pyv(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$B40 then
if Gj[xfa]<=$B10 then
if Gj[xfa]<=$AF8 then
if Gj[xfa]<=$AEC then
if Gj[xfa]<=$AE6 then
if Gj[xfa]<=$AE3 then
if Gj[xfa]<=$AE1 then
if Gj[xfa]<=$AE0 then
set xza=AIx(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdDataTypes, line 1374")
else
set xza=vba(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$AE2 then
set xza=Mde(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdDataTypes, line 1374")
else
set xza=zKo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$AE5 then
if Gj[xfa]<=$AE4 then
set xza=XXx(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdDataTypes, line 1374")
else
set xza=pCo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdDataTypes, line 1374")
endif
else
set xza=IDx(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$AE9 then
if Gj[xfa]<=$AE8 then
if Gj[xfa]<=$AE7 then
set xza=mUe(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdDataTypes, line 1374")
else
set xza=zRr(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdDataTypes, line 1374")
endif
else
set xza=PIo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$AEB then
if Gj[xfa]<=$AEA then
set xza=rxo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdDataTypes, line 1374")
else
set xza=z4x(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdDataTypes, line 1374")
endif
else
set xza=mvo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$AF2 then
if Gj[xfa]<=$AEF then
if Gj[xfa]<=$AEE then
if Gj[xfa]<=$AED then
set xza=eXo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdDataTypes, line 1374")
else
set xza=Lbe(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdDataTypes, line 1374")
endif
else
set xza=z5i(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$AF1 then
if Gj[xfa]<=$AF0 then
set xza=CUe(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdDataTypes, line 1374")
else
set xza=vzi(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdDataTypes, line 1374")
endif
else
set xza=gde(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$AF5 then
if Gj[xfa]<=$AF4 then
if Gj[xfa]<=$AF3 then
set xza=Cfe(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdDataTypes, line 1374")
else
set xza=H1e(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_ScmdFogOfWarBuiltins in ScmdDataTypes, line 1374")
endif
else
set xza=ezr(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_ScmdFogOfWarBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$AF7 then
if Gj[xfa]<=$AF6 then
set xza=pBe(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_ScmdFogOfWarBuiltins in ScmdDataTypes, line 1374")
else
set xza=LFe(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_ScmdItemBuiltins in ScmdDataTypes, line 1374")
endif
else
set xza=KQo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_ScmdItemBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$B04 then
if Gj[xfa]<=$AFE then
if Gj[xfa]<=$AFB then
if Gj[xfa]<=$AFA then
if Gj[xfa]<=$AF9 then
set xza=uIo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_ScmdItemBuiltins in ScmdDataTypes, line 1374")
else
set xza=WQv(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_ScmdItemBuiltins in ScmdDataTypes, line 1374")
endif
else
set xza=vGa(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_ScmdItemBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$AFD then
if Gj[xfa]<=$AFC then
set xza=Zlx(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_ScmdItemBuiltins in ScmdDataTypes, line 1374")
else
set xza=dYe(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_ScmdItemBuiltins in ScmdDataTypes, line 1374")
endif
else
set xza=Opx(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_ScmdItemBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$B01 then
if Gj[xfa]<=$B00 then
if Gj[xfa]<=$AFF then
set xza=Kho(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_ScmdPlayerCameraSettingsBuiltins in ScmdDataTypes, line 1374")
else
set xza=TWo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_ScmdRectBuiltins in ScmdDataTypes, line 1374")
endif
else
set xza=Hwe(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_ScmdRectBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$B03 then
if Gj[xfa]<=$B02 then
set xza=lee(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_ScmdRectBuiltins in ScmdDataTypes, line 1374")
else
set xza=mSe(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_ScmdRectBuiltins in ScmdDataTypes, line 1374")
endif
else
set xza=zJr(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_ScmdRectBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$B0A then
if Gj[xfa]<=$B07 then
if Gj[xfa]<=$B06 then
if Gj[xfa]<=$B05 then
set xza=qho(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_ScmdRectBuiltins in ScmdDataTypes, line 1374")
else
set xza=rLo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_ScmdRectBuiltins in ScmdDataTypes, line 1374")
endif
else
set xza=Zjx(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_ScmdRectBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$B09 then
if Gj[xfa]<=$B08 then
set xza=ULv(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_ScmdSoundFunctions in ScmdDataTypes, line 1374")
else
set xza=u_v(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_ScmdSoundFunctions in ScmdDataTypes, line 1374")
endif
else
set xza=tcv(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_ScmdSoundFunctions in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$B0D then
if Gj[xfa]<=$B0C then
if Gj[xfa]<=$B0B then
set xza=Czi(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_ScmdSoundFunctions in ScmdDataTypes, line 1374")
else
set xza=Xmo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_ScmdSoundFunctions in ScmdDataTypes, line 1374")
endif
else
set xza=dFo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_ScmdSoundFunctions in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$B0F then
if Gj[xfa]<=$B0E then
set xza=KCo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_ScmdSystemsSettingsBuiltins in ScmdDataTypes, line 1374")
else
set xza=TEo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_ScmdSystemsSettingsBuiltins in ScmdDataTypes, line 1374")
endif
else
set xza=HSe(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_ScmdSystemsSettingsBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$B28 then
if Gj[xfa]<=$B1C then
if Gj[xfa]<=$B16 then
if Gj[xfa]<=$B13 then
if Gj[xfa]<=$B12 then
if Gj[xfa]<=$B11 then
set xza=znr(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
else
set xza=fLe(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
else
set xza=Rsx(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_ScmdWeatherEffectFunctions in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$B15 then
if Gj[xfa]<=$B14 then
set xza=z5r(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_SotFRP_LegacyLoad in ScmdDataTypes, line 1374")
else
set xza=SVo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_SotFRP_SaveLoad in ScmdDataTypes, line 1374")
endif
else
set xza=gNe(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_SotFRP_SaveLoad in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$B19 then
if Gj[xfa]<=$B18 then
if Gj[xfa]<=$B17 then
set xza=jwe(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_SotFRP_SaveLoad in ScmdDataTypes, line 1374")
else
set xza=mne(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_SotFRP_SaveLoad in ScmdDataTypes, line 1374")
endif
else
set xza=lVo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_SotFRP_SaveLoad in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$B1B then
if Gj[xfa]<=$B1A then
set xza=vJa(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_SotfrpGuiCoreUnit in ScmdDataTypes, line 1374")
else
set xza=Zwx(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_SotfrpGuiCoreUnit in ScmdDataTypes, line 1374")
endif
else
set xza=zdi(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_SotfrpGuiRegions in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$B22 then
if Gj[xfa]<=$B1F then
if Gj[xfa]<=$B1E then
if Gj[xfa]<=$B1D then
set xza=zhx(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_SotfrpGuiRegions in ScmdDataTypes, line 1374")
else
set xza=Q7r(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_SotfrpGuiRegions in ScmdDataTypes, line 1374")
endif
else
set xza=YCo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_UnitShopsBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$B21 then
if Gj[xfa]<=$B20 then
set xza=V9x(xfa,xFa,xGa,"when calling call_setArgumentsTypes_registerProtectedBuiltin_UnitShopsBuiltins in ScmdDataTypes, line 1374")
else
set xza=rQo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_setArgumentsTypes_registerProtectedBuiltin_ScmdItemBuiltins in ScmdDataTypes, line 1374")
endif
else
call xda($C,xfa,xFa,null,xGa,"when calling call_setArgumentsTypes_setProvidingEnumUnit_addOverload_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdDataTypes, line 1374",0,null)
set xza=RJv
endif
elseif Gj[xfa]<=$B25 then
if Gj[xfa]<=$B24 then
if Gj[xfa]<=$B23 then
call xda(24,xfa,xFa,null,xGa,"when calling call_setArgumentsTypes_setProvidingEnumUnit_addOverload_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdDataTypes, line 1374",0,null)
set xza=RJv
else
call xda($B,xfa,xFa,null,xGa,"when calling call_setArgumentsTypes_setProvidingEnumUnit_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdDataTypes, line 1374",0,null)
set xza=RJv
endif
else
call xda($A,xfa,xFa,null,xGa,"when calling call_setArgumentsTypes_setProvidingEnumUnit_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374",0,null)
set xza=RJv
endif
elseif Gj[xfa]<=$B27 then
if Gj[xfa]<=$B26 then
set xza=QIe(xfa,xFa,xGa,"when calling call_setArgumentsTypes_setProvidingEnumUnit_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
else
set xza=zpr(xfa,xFa,xGa,"when calling call_setArgumentsTypes_setProvidingEnumUnit_registerProtectedBuiltin_SotfrpGuiRegions in ScmdDataTypes, line 1374")
endif
else
set xza=xNa(xfa,xFa,xGa,"when calling call_setArgumentsTypes_setRequiringEnumUnit_addOverload_addOverload_addOverload_registerProtectedBuiltin_SotFRP_AbilitySystem in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$B34 then
if Gj[xfa]<=$B2E then
if Gj[xfa]<=$B2B then
if Gj[xfa]<=$B2A then
if Gj[xfa]<=$B29 then
set xza=QYe(xfa,xFa,xGa,"when calling call_setArgumentsTypes_setRequiringEnumUnit_addOverload_addOverload_addOverload_registerProtectedBuiltin_SotFRP_AbilitySystem in ScmdDataTypes, line 1374")
else
set xza=Rvx(xfa,xFa,xGa,"when calling call_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_SLangSpecialEffectFunctions in ScmdDataTypes, line 1374")
endif
else
set xza=Mme(xfa,xFa,xGa,"when calling call_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdItemBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$B2D then
if Gj[xfa]<=$B2C then
set xza=Rcx(xfa,xFa,xGa,"when calling call_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
else
set xza=eHo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
else
set xza=X2i(xfa,xFa,xGa,"when calling call_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$B31 then
if Gj[xfa]<=$B30 then
if Gj[xfa]<=$B2F then
set xza=wUo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
else
set xza=mGe(xfa,xFa,xGa,"when calling call_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
else
set xza=Wov(xfa,xFa,xGa,"when calling call_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$B33 then
if Gj[xfa]<=$B32 then
set xza=MQe(xfa,xFa,xGa,"when calling call_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
else
set xza=aAo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
else
set xza=Z7x(xfa,xFa,xGa,"when calling call_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$B3A then
if Gj[xfa]<=$B37 then
if Gj[xfa]<=$B36 then
if Gj[xfa]<=$B35 then
set xza=aFo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
else
set xza=due(xfa,xFa,xGa,"when calling call_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
else
set xza=eCo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$B39 then
if Gj[xfa]<=$B38 then
set xza=mpe(xfa,xFa,xGa,"when calling call_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
else
set xza=pmo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
else
set xza=Uav(xfa,xFa,xGa,"when calling call_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$B3D then
if Gj[xfa]<=$B3C then
if Gj[xfa]<=$B3B then
set xza=XUo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
else
set xza=uvo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
else
set xza=rDo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$B3F then
if Gj[xfa]<=$B3E then
set xza=mCo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
else
set xza=uJv(xfa,xFa,xGa,"when calling call_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
else
set xza=Vzi(xfa,xFa,xGa,"when calling call_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$B71 then
if Gj[xfa]<=$B59 then
if Gj[xfa]<=$B4D then
if Gj[xfa]<=$B47 then
if Gj[xfa]<=$B44 then
if Gj[xfa]<=$B42 then
if Gj[xfa]<=$B41 then
set xza=wLo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
else
set xza=HHo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$B43 then
set xza=gLe(xfa,xFa,xGa,"when calling call_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
else
set xza=mde(xfa,xFa,xGa,"when calling call_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$B46 then
if Gj[xfa]<=$B45 then
set xza=qBo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
else
set xza=ZCx(xfa,xFa,xGa,"when calling call_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
else
set xza=tIv(xfa,xFa,xGa,"when calling call_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$B4A then
if Gj[xfa]<=$B49 then
if Gj[xfa]<=$B48 then
set xza=aMo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
else
set xza=CHo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
else
set xza=SCo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$B4C then
if Gj[xfa]<=$B4B then
set xza=JJe(xfa,xFa,xGa,"when calling call_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
else
set xza=zbr(xfa,xFa,xGa,"when calling call_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
else
set xza=rIo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$B53 then
if Gj[xfa]<=$B50 then
if Gj[xfa]<=$B4F then
if Gj[xfa]<=$B4E then
set xza=mXo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
else
set xza=ugv(xfa,xFa,xGa,"when calling call_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
else
set xza=i2i(xfa,xFa,xGa,"when calling call_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$B52 then
if Gj[xfa]<=$B51 then
set xza=zco(xfa,xFa,xGa,"when calling call_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
else
set xza=fSe(xfa,xFa,xGa,"when calling call_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
else
set xza=ZQo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$B56 then
if Gj[xfa]<=$B55 then
if Gj[xfa]<=$B54 then
set xza=CEo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
else
set xza=WFv(xfa,xFa,xGa,"when calling call_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
else
set xza=Mye(xfa,xFa,xGa,"when calling call_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$B58 then
if Gj[xfa]<=$B57 then
set xza=LQe(xfa,xFa,xGa,"when calling call_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
else
set xza=izo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
else
set xza=C5e(xfa,xFa,xGa,"when calling call_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$B65 then
if Gj[xfa]<=$B5F then
if Gj[xfa]<=$B5C then
if Gj[xfa]<=$B5B then
if Gj[xfa]<=$B5A then
set xza=ZZx(xfa,xFa,xGa,"when calling call_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
else
set xza=UDo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
else
set xza=q7e(xfa,xFa,xGa,"when calling call_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$B5E then
if Gj[xfa]<=$B5D then
set xza=lBo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
else
set xza=uho(xfa,xFa,xGa,"when calling call_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
else
set xza=Mae(xfa,xFa,xGa,"when calling call_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$B62 then
if Gj[xfa]<=$B61 then
if Gj[xfa]<=$B60 then
set xza=CLe(xfa,xFa,xGa,"when calling call_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
else
set xza=ADo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
else
set xza=zYi(xfa,xFa,xGa,"when calling call_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$B64 then
if Gj[xfa]<=$B63 then
set xza=jie(xfa,xFa,xGa,"when calling call_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
else
set xza=ozr(xfa,xFa,xGa,"when calling call_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
else
set xza=WLo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$B6B then
if Gj[xfa]<=$B68 then
if Gj[xfa]<=$B67 then
if Gj[xfa]<=$B66 then
set xza=mMo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
else
set xza=pxv(xfa,xFa,xGa,"when calling call_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
else
set xza=vda(xfa,xFa,xGa,"when calling call_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$B6A then
if Gj[xfa]<=$B69 then
set xza=u3v(xfa,xFa,xGa,"when calling call_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_SotFRP_AbilitySystem in ScmdDataTypes, line 1374")
else
set xza=Izi(xfa,xFa,xGa,"when calling call_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_SotFRP_AbilitySystem in ScmdDataTypes, line 1374")
endif
else
set xza=WXo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_SotFRP_AbilitySystem in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$B6E then
if Gj[xfa]<=$B6D then
if Gj[xfa]<=$B6C then
set xza=Kxo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_SotFRP_AbilitySystem in ScmdDataTypes, line 1374")
else
set xza=Uxv(xfa,xFa,xGa,"when calling call_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_SotfrpGuiCoreUnit in ScmdDataTypes, line 1374")
endif
else
set xza=REx(xfa,xFa,xGa,"when calling call_setArgumentsTypes_setRequiringEnumUnit_registerBuiltin_SLangChatSystem in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$B70 then
if Gj[xfa]<=$B6F then
set xza=nUo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_setRequiringEnumUnit_registerBuiltin_SLangChatSystem in ScmdDataTypes, line 1374")
else
set xza=oFo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_setVariadicArgumentTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdDataTypes, line 1374")
endif
else
set xza=vJo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_setVariadicArgumentTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$B89 then
if Gj[xfa]<=$B7D then
if Gj[xfa]<=$B77 then
if Gj[xfa]<=$B74 then
if Gj[xfa]<=$B73 then
if Gj[xfa]<=$B72 then
set xza=xFo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_setVariadicArgumentTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdDataTypes, line 1374")
else
set xza=n7r(xfa,xFa,xGa,"when calling call_setArgumentsTypes_setVariadicArgumentTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdDataTypes, line 1374")
endif
else
set xza=zyo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_setVariadicArgumentTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$B76 then
if Gj[xfa]<=$B75 then
set xza=xxo(xfa,xFa,xGa,"when calling call_setArgumentsTypes_setVariadicArgumentTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdDataTypes, line 1374")
else
set xza=Jbe(xfa,xFa,xGa,"when calling call_setArgumentsTypes_setVariadicArgumentTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdDataTypes, line 1374")
endif
else
set xza=Ezx(xfa,xFa,xGa,"when calling call_setArgumentsTypes_setVariadicArgumentTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$B7A then
if Gj[xfa]<=$B79 then
if Gj[xfa]<=$B78 then
set xza=SCv(xfa,xFa,xGa,"when calling call_setArgumentsTypes_setVariadicArgumentTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdDataTypes, line 1374")
else
call xda($E,xfa,xFa,null,xGa,"when calling call_setArgumentsTypes_setVariadicArgumentTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdDataTypes, line 1374",0,null)
set xza=RJv
endif
else
call xda(17,xfa,xFa,null,xGa,"when calling call_setArgumentsTypes_setVariadicArgumentTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdDataTypes, line 1374",0,null)
set xza=RJv
endif
elseif Gj[xfa]<=$B7C then
if Gj[xfa]<=$B7B then
set xza=zMo(xfa,xFa,xGa,"when calling call_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
else
set xza=HLo(xfa,xFa,xGa,"when calling call_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
else
set xza=gqe(xfa,xFa,xGa,"when calling call_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$B83 then
if Gj[xfa]<=$B80 then
if Gj[xfa]<=$B7F then
if Gj[xfa]<=$B7E then
set xza=eOa(xfa,xFa,xGa,"when calling call_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
else
set xza=LJe(xfa,xFa,xGa,"when calling call_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
else
set xza=dXe(xfa,xFa,xGa,"when calling call_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$B82 then
if Gj[xfa]<=$B81 then
set xza=Qvv(xfa,xFa,xGa,"when calling call_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
else
set xza=Rix(xfa,xFa,xGa,"when calling call_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
else
set xza=ozo(xfa,xFa,xGa,"when calling call_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$B86 then
if Gj[xfa]<=$B85 then
if Gj[xfa]<=$B84 then
set xza=zYx(xfa,xFa,xGa,"when calling call_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
else
set xza=SUv(xfa,xFa,xGa,"when calling call_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
else
set xza=djo(xfa,xFa,xGa,"when calling call_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$B88 then
if Gj[xfa]<=$B87 then
set xza=lie(xfa,xFa,xGa,"when calling call_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
else
set xza=zDr(xfa,xFa,xGa,"when calling call_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
else
set xza=UJv(xfa,xFa,xGa,"when calling call_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$B95 then
if Gj[xfa]<=$B8F then
if Gj[xfa]<=$B8C then
if Gj[xfa]<=$B8B then
if Gj[xfa]<=$B8A then
set xza=vwa(xfa,xFa,xGa,"when calling call_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
else
set xza=Osx(xfa,xFa,xGa,"when calling call_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
else
set xza=QKe(xfa,xFa,xGa,"when calling call_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$B8E then
if Gj[xfa]<=$B8D then
set xza=l1e(xfa,xFa,xGa,"when calling call_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
else
set xza=vqa(xfa,xFa,xGa,"when calling call_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
else
set xza=Oux(xfa,xFa,xGa,"when calling call_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$B92 then
if Gj[xfa]<=$B91 then
if Gj[xfa]<=$B90 then
set xza=Xfx(xfa,xFa,xGa,"when calling call_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
else
set xza=qCv(xfa,xFa,xGa,"when calling call_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
else
set xza=Mbe(xfa,xFa,xGa,"when calling call_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$B94 then
if Gj[xfa]<=$B93 then
set xza=Xex(xfa,xFa,xGa,"when calling call_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
else
set xza=R9x(xfa,xFa,xGa,"when calling call_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
else
set xza=Iux(xfa,xFa,xGa,"when calling call_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$B9B then
if Gj[xfa]<=$B98 then
if Gj[xfa]<=$B97 then
if Gj[xfa]<=$B96 then
set xza=SJe(xfa,xFa,xGa,"when calling call_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
else
set xza=v1a(xfa,xFa,xGa,"when calling call_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_SotfrpGuiCoreUnit in ScmdDataTypes, line 1374")
endif
else
set xza=Fbe(xfa,xFa,xGa,"when calling call_setRequiringEnumUnit_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$B9A then
if Gj[xfa]<=$B99 then
set xza=lho(xfa,xFa,xGa,"when calling call_setVariadicArgumentTypes_ScmdParser in ScmdDataTypes, line 1374")
else
set xza=Iox(xfa,xFa,xGa,"when calling call_setVariadicArgumentTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdDataTypes, line 1374")
endif
else
set xza=Lue(xfa,xFa,xGa,"when calling call_setVariadicArgumentTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$B9E then
if Gj[xfa]<=$B9D then
if Gj[xfa]<=$B9C then
set xza=Avx(xfa,xFa,xGa,"when calling call_setVariadicArgumentTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdDataTypes, line 1374")
else
set xza=zSx(xfa,xFa,xGa,"when calling call_setVariadicArgumentTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdDataTypes, line 1374")
endif
else
set xza=KQe(xfa,xFa,xGa,"when calling call_setVariadicArgumentTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdDataTypes, line 1374")
endif
elseif Gj[xfa]<=$BA0 then
if Gj[xfa]<=$B9F then
set xza=QIo(xfa,xFa,xGa,"when calling call_setVariadicArgumentTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdDataTypes, line 1374")
else
set xza=qYe(xfa,xFa,xGa,"when calling call_setVariadicArgumentTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdDataTypes, line 1374")
endif
else
set xza=Ujo(xfa,xFa,xGa,"when calling call_setVariadicArgumentTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdDataTypes, line 1374")
endif
set EM=EM-1
set RJv=xza
set oaa=null
set ona=null
set oVa=null
return
elseif xDa==5 then
set ZM[EM]=xha
set EM=EM+1
call xda(8,xFa,Joe(xGa,0,"when calling getPtr in ScmdCoreBuiltins, line 357"),"when calling resolve in ScmdCoreBuiltins, line 357",0,null,0,null)
set xZa=RJv
set x1a=ox[m0v(xZa,"when calling get in ScmdCoreBuiltins, line 358")]
if not(x1a>=$EF1 and x1a<=$EF2)then
set x2a=ox[m0v(xZa,"when calling get in ScmdCoreBuiltins, line 359")]
set x_a=not((x2a==$EFC or x2a==$F09 and WCv(m0v(xZa,"when calling get in ScmdCoreBuiltins, line 359"),"when calling booleanValue in ScmdCoreBuiltins, line 359")==false)or ox[m0v(xZa,"when calling get in ScmdCoreBuiltins, line 359")]==$F00 or ox[m0v(xZa,"when calling get in ScmdCoreBuiltins, line 359")]==$F0C)
call mfv(20,xZa,"when calling dispatch_GenericSharedPointer_destroyGenericSharedPointer in ScmdCoreBuiltins, line 360")
if x_a then
call xda(8,xFa,Joe(xGa,1,"when calling getPtr in ScmdCoreBuiltins, line 361"),"when calling resolve in ScmdCoreBuiltins, line 361",0,null,0,null)
set x0a=RJv
else
call xda(8,xFa,Joe(xGa,2,"when calling getPtr in ScmdCoreBuiltins, line 361"),"when calling resolve in ScmdCoreBuiltins, line 361",0,null,0,null)
set x0a=RJv
endif
set xZa=x0a
endif
set x3a=xZa
set EM=EM-1
set RJv=x3a
set oaa=null
set ona=null
set oVa=null
return
elseif xDa==6 then
set ZM[EM]=xja
set EM=EM+1
call xda(20,xfa,xGa,null,xHa,"when calling makeFn in ScmdCoreBuiltins, line 449",0,null)
set x4a=RJv
set x5a=ox[m0v(x4a,"when calling get in ScmdCoreBuiltins, line 450")]
if x5a>=$EF1 and x5a<=$EF2 then
set EM=EM-1
set RJv=x4a
set oaa=null
set ona=null
set oVa=null
return
endif
if not rZo(QGv(xfa,"when calling getPlayerId in ScmdCoreBuiltins, line 452"),Mqv(xFa,"when calling getInner in ScmdCoreBuiltins, line 452"),xga,x4a,"when calling assign in ScmdCoreBuiltins, line 452")then
set x7a=p0v(tJv("Symbol is protected","when calling new_Exception in ScmdCoreBuiltins, line 453"),"when calling new_SharedPointer in ScmdCoreBuiltins, line 453")
set EM=EM-1
set RJv=x7a
set oaa=null
set ona=null
set oVa=null
return
endif
set x6a=MLv("when calling nullptr in ScmdCoreBuiltins, line 454")
set EM=EM-1
set RJv=x6a
set oaa=null
set ona=null
set oVa=null
return
elseif xDa==7 then
set ZM[EM]=xha
set EM=EM+1
call xda(8,xFa,Joe(xGa,0,"when calling getPtr in SLangTriggerFunctions, line 23"),"when calling resolve in SLangTriggerFunctions, line 23",0,null,0,null)
set x8a=RJv
if not(ox[m0v(x8a,"when calling get in SLangTriggerFunctions, line 24")]==$F0B)then
call mfv(20,x8a,"when calling dispatch_GenericSharedPointer_destroyGenericSharedPointer in SLangTriggerFunctions, line 25")
set x8a=p0v(tJv("...cannot be cast to Trigger","when calling new_Exception in SLangTriggerFunctions, line 26"),"when calling new_SharedPointer in SLangTriggerFunctions, line 26")
else
call lKe(m0v(x8a,"when calling get in SLangTriggerFunctions, line 28"),Joe(xGa,1,"when calling getPtr in SLangTriggerFunctions, line 28"),"when calling addCondition in SLangTriggerFunctions, line 28")
call mfv(20,x8a,"when calling dispatch_GenericSharedPointer_destroyGenericSharedPointer in SLangTriggerFunctions, line 29")
set x8a=MLv("when calling nullptr in SLangTriggerFunctions, line 30")
endif
set x9a=x8a
set EM=EM-1
set RJv=x9a
set oaa=null
set ona=null
set oVa=null
return
elseif xDa==8 then
set ZM[EM]=xga
set EM=EM+1
if ox[m0v(xFa,"when calling get in ScmdDataTypes, line 1234")]==$EF3 then
call xda(22,m0v(xFa,"when calling get in ScmdDataTypes, line 1235"),xfa,"when calling evaluate in ScmdDataTypes, line 1235",0,null,0,null)
set oxa=RJv
set EM=EM-1
set RJv=oxa
set oaa=null
set ona=null
set oVa=null
return
endif
if ox[m0v(xFa,"when calling get in ScmdDataTypes, line 1236")]==$F0A then
set ova=LBo(xfa,LGo(m0v(xFa,"when calling get in ScmdDataTypes, line 1237"),"when calling toString in ScmdDataTypes, line 1237"),"when calling resolve in ScmdDataTypes, line 1237")
if ova==0 then
set ova=cHe(m0v(xFa,"when calling get in ScmdDataTypes, line 1239"),QGv(xfa,"when calling getPlayerId in ScmdDataTypes, line 1239"),"when calling resolve in ScmdDataTypes, line 1239")
endif
set EM=EM-1
set RJv=ova
set oaa=null
set ona=null
set oVa=null
return
endif
set oea=P_v(xFa,"when calling clone in ScmdDataTypes, line 1241")
set EM=EM-1
set RJv=oea
set oaa=null
set ona=null
set oVa=null
return
elseif xDa==9 then
set ZM[EM]=xha
set EM=EM+1
call xda($D,xfa,xFa,null,xGa,"when calling call in ScmdDataTypes, line 1530",0,null)
set ooa=RJv
set EM=EM-1
set RJv=ooa
set oaa=null
set ona=null
set oVa=null
return
elseif xDa==$A then
set ZM[EM]=xha
set EM=EM+1
call xda(8,xFa,Joe(xGa,0,"when calling getPtr in ScmdUnitBuiltins, line 181"),"when calling resolve in ScmdUnitBuiltins, line 181",0,null,0,null)
set ora=RJv
if not(ox[m0v(ora,"when calling get in ScmdUnitBuiltins, line 183")]==$EF4)then
set oia=p0v(tJv("...cannot be cast to Group","when calling new_Exception in ScmdUnitBuiltins, line 184"),"when calling new_SharedPointer in ScmdUnitBuiltins, line 184")
else
set oXa=ox[m0v(ora,"when calling get in ScmdUnitBuiltins, line 185")]
if oXa>=$EF1 and oXa<=$EF2 then
set oia=P_v(ora,"when calling clone in ScmdUnitBuiltins, line 186")
else
set oia=MLv("when calling nullptr in ScmdUnitBuiltins, line 188")
set oaa=Mov(xFa,"when calling getEnumUnit in ScmdUnitBuiltins, line 189")
set ona=QEe(mle(m0v(ora,"when calling get in ScmdUnitBuiltins, line 190"),"when calling getInner in ScmdUnitBuiltins, line 190"))
loop
exitwhen not F9e(ona)
set oVa=F6e(ona)
set oEa=pko("when calling alloc_ForForceCallback_execute_setArgumentsTypes_setProvidingEnumUnit_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 191")
set KK[oEa]=xFa
set LK[oEa]=oVa
set XK[oEa]=xGa
set CK[oEa]=oia
call Fte(oEa,"when calling execute in ScmdUnitBuiltins, line 191")
set oOa=ox[m0v(oia,"when calling get in ScmdUnitBuiltins, line 199")]
if oOa>=$EF1 and oOa<=$EF2 then
exitwhen true
endif
endloop
call QOe(ona)
call m7v(xFa,oaa,"when calling setEnumUnit in ScmdUnitBuiltins, line 201")
endif
endif
call mfv(20,ora,"when calling dispatch_GenericSharedPointer_destroyGenericSharedPointer in ScmdUnitBuiltins, line 202")
set oRa=oia
set EM=EM-1
set RJv=oRa
set oaa=null
set ona=null
set oVa=null
return
elseif xDa==$B then
set ZM[EM]=xha
set EM=EM+1
call xda(20,xFa,Joe(xGa,0,"when calling getPtr in ScmdCoreBuiltins, line 445"),null,Joe(xGa,1,"when calling getPtr in ScmdCoreBuiltins, line 445"),"when calling makeFn in ScmdCoreBuiltins, line 445",0,null)
set oIa=RJv
set EM=EM-1
set RJv=oIa
set oaa=null
set ona=null
set oVa=null
return
elseif xDa==$C then
set ZM[EM]=xha
set EM=EM+1
call xda(6,xFa,M7v(xGa,0,"when calling get in ScmdCoreBuiltins, line 458"),null,Joe(xGa,1,"when calling getPtr in ScmdCoreBuiltins, line 458"),null,Joe(xGa,2,"when calling getPtr in ScmdCoreBuiltins, line 458"),"when calling defnCmd in ScmdCoreBuiltins, line 458")
set oAa=RJv
set EM=EM-1
set RJv=oAa
set oaa=null
set ona=null
set oVa=null
return
elseif xDa==$D then
set ZM[EM]=xha
set EM=EM+1
set oNa=yFo(xfa,xGa,"when calling resolveOverload in ScmdDataTypes, line 1482")
if oNa!=0 then
set oba=0
loop
exitwhen not(oba!=SNv(xGa,"when calling size in ScmdDataTypes, line 1485")and FMo(G8e(jJ[oNa],bUe(hye(jJ[oNa],"when calling size in ScmdDataTypes, line 1485")-1,oba),"when calling get in ScmdDataTypes, line 1485"),M7v(xGa,oba,"when calling get in ScmdDataTypes, line 1485"),"when calling isInstance in ScmdDataTypes, line 1485"))
set oba=oba+1
endloop
if oba!=SNv(xGa,"when calling size in ScmdDataTypes, line 1487")then
set oca=B6e(DWe(DSe(M7v(xGa,oba,"when calling get in ScmdDataTypes, line 1488"),"when calling getTypeToken in ScmdDataTypes, line 1488"),"when calling getName in ScmdDataTypes, line 1488")+" cannot be cast to "+DWe(G8e(jJ[oNa],bUe(hye(jJ[oNa],"when calling size in ScmdDataTypes, line 1488")-1,oba),"when calling get in ScmdDataTypes, line 1488"),"when calling getName in ScmdDataTypes, line 1488"),"when calling wrap in ScmdDataTypes, line 1488")
set EM=EM-1
set RJv=oca
set oaa=null
set ona=null
set oVa=null
return
endif
if oba==SNv(xGa,"when calling size in ScmdDataTypes, line 1489")then
call xda(4,kJ[oNa],xFa,null,xGa,"when calling call in ScmdDataTypes, line 1490",0,null)
set oCa=RJv
set EM=EM-1
set RJv=oCa
set oaa=null
set ona=null
set oVa=null
return
endif
endif
set oBa=p0v(tJv("No overload found","when calling new_Exception in ScmdDataTypes, line 1491"),"when calling new_SharedPointer in ScmdDataTypes, line 1491")
set EM=EM-1
set RJv=oBa
set oaa=null
set ona=null
set oVa=null
return
elseif xDa==$E then
set ZM[EM]=xha
set EM=EM+1
set oda=skv(iNo(Joe(xGa,1,"when calling getPtr in ScmdCoreBuiltins, line 389"),"when calling get in ScmdCoreBuiltins, line 389"),"when calling size in ScmdCoreBuiltins, line 389")
set oDa=2
loop
exitwhen not(oDa<SNv(xGa,"when calling size in ScmdCoreBuiltins, line 391"))
if skv(M7v(xGa,oDa,"when calling get in ScmdCoreBuiltins, line 392"),"when calling size in ScmdCoreBuiltins, line 392")<oda then
set oda=skv(M7v(xGa,oDa,"when calling get in ScmdCoreBuiltins, line 393"),"when calling size in ScmdCoreBuiltins, line 393")
endif
set oDa=oDa+1
endloop
set ofa=p0v(j5e("when calling new_Vector in ScmdCoreBuiltins, line 395"),"when calling new_SharedPointer in ScmdCoreBuiltins, line 395")
set oDa=0
loop
exitwhen not(oDa<oda)
set oFa=wYv(MJv(Joe(xGa,0,"when calling getPtr in ScmdCoreBuiltins, line 398"),"when calling clone in ScmdCoreBuiltins, line 398"),"when calling new_Expression in ScmdCoreBuiltins, line 398")
set oga=1
loop
exitwhen not(oga<SNv(xGa,"when calling size in ScmdCoreBuiltins, line 400"))
call gWo(UAo(oFa,"when calling getArgs in ScmdCoreBuiltins, line 401"),P_v(sTv(M7v(xGa,oga,"when calling get in ScmdCoreBuiltins, line 401"),oDa,"when calling get in ScmdCoreBuiltins, line 401"),"when calling clone in ScmdCoreBuiltins, line 401"),"when calling add in ScmdCoreBuiltins, line 401")
set oga=oga+1
endloop
call xda(22,oFa,xFa,"when calling evaluate in ScmdCoreBuiltins, line 403",0,null,0,null)
set oGa=RJv
set oha=ox[m0v(oGa,"when calling get in ScmdCoreBuiltins, line 404")]
if oha>=$EF1 and oha<=$EF2 then
call mfv(20,ofa,"when calling dispatch_GenericSharedPointer_destroyGenericSharedPointer in ScmdCoreBuiltins, line 405")
set ofa=oGa
exitwhen true
endif
call JRe(m0v(ofa,"when calling get in ScmdCoreBuiltins, line 408"),oGa,"when calling push in ScmdCoreBuiltins, line 408")
call mtv(oFa,"when calling dispatch_Expression_destroyExpression in ScmdCoreBuiltins, line 409")
set oDa=oDa+1
endloop
set oHa=ofa
set EM=EM-1
set RJv=oHa
set oaa=null
set ona=null
set oVa=null
return
elseif xDa==$F then
set ZM[EM]=xha
set EM=EM+1
set oja=wQv("when calling new_Arguments in ScmdDataTypes, line 1307")
set oJa=MRe(xGa,"when calling iterator in ScmdDataTypes, line 1308")
loop
exitwhen not Jgv(oJa,"when calling hasNext in ScmdDataTypes, line 1308")
set oka=jTv(oJa,"when calling next in ScmdDataTypes, line 1308")
call xda(8,xFa,oka,"when calling resolve in ScmdDataTypes, line 1309",0,null,0,null)
set oKa=RJv
set oLa=ox[m0v(oKa,"when calling get in ScmdDataTypes, line 1310")]
if oLa>=$EF1 and oLa<=$EF2 then
call mfv(7,oja,"when calling dispatch_Arguments_destroyArguments in ScmdDataTypes, line 1311")
call Jqv(oJa,"when calling close in ScmdDataTypes, line 1308")
set EM=EM-1
set RJv=oKa
set oaa=null
set ona=null
set oVa=null
return
endif
call gWo(oja,oKa,"when calling add in ScmdDataTypes, line 1313")
endloop
call Jqv(oJa,"when calling close in ScmdDataTypes, line 1308")
call xda(1,xfa,xFa,null,oja,"when calling callImpl in ScmdDataTypes, line 1314",0,null)
set ola=RJv
call mfv(7,oja,"when calling dispatch_Arguments_destroyArguments in ScmdDataTypes, line 1315")
set EM=EM-1
set RJv=ola
set oaa=null
set ona=null
set oVa=null
return
elseif xDa==16 then
set ZM[EM]=xha
set EM=EM+1
set oma=GJo(xfa,xGa,"when calling resolveOverload in ScmdDataTypes, line 1482")
if oma!=0 then
set oMa=0
loop
exitwhen not(oMa!=SNv(xGa,"when calling size in ScmdDataTypes, line 1485")and FMo(G8e(jJ[oma],bUe(hye(jJ[oma],"when calling size in ScmdDataTypes, line 1485")-1,oMa),"when calling get in ScmdDataTypes, line 1485"),M7v(xGa,oMa,"when calling get in ScmdDataTypes, line 1485"),"when calling isInstance in ScmdDataTypes, line 1485"))
set oMa=oMa+1
endloop
if oMa!=SNv(xGa,"when calling size in ScmdDataTypes, line 1487")then
set oPa=B6e(DWe(DSe(M7v(xGa,oMa,"when calling get in ScmdDataTypes, line 1488"),"when calling getTypeToken in ScmdDataTypes, line 1488"),"when calling getName in ScmdDataTypes, line 1488")+" cannot be cast to "+DWe(G8e(jJ[oma],bUe(hye(jJ[oma],"when calling size in ScmdDataTypes, line 1488")-1,oMa),"when calling get in ScmdDataTypes, line 1488"),"when calling getName in ScmdDataTypes, line 1488"),"when calling wrap in ScmdDataTypes, line 1488")
set EM=EM-1
set RJv=oPa
set oaa=null
set ona=null
set oVa=null
return
endif
if oMa==SNv(xGa,"when calling size in ScmdDataTypes, line 1489")then
call xda(4,kJ[oma],xFa,null,xGa,"when calling call in ScmdDataTypes, line 1490",0,null)
set opa=RJv
set EM=EM-1
set RJv=opa
set oaa=null
set ona=null
set oVa=null
return
endif
endif
set oqa=p0v(tJv("No overload found","when calling new_Exception in ScmdDataTypes, line 1491"),"when calling new_SharedPointer in ScmdDataTypes, line 1491")
set EM=EM-1
set RJv=oqa
set oaa=null
set ona=null
set oVa=null
return
elseif xDa==17 then
set ZM[EM]=xha
set EM=EM+1
set oQa=wYv(MJv(Joe(xGa,0,"when calling getPtr in ScmdCoreBuiltins, line 414"),"when calling clone in ScmdCoreBuiltins, line 414"),"when calling new_Expression in ScmdCoreBuiltins, line 414")
set osa=1
loop
exitwhen not(osa<SNv(xGa,"when calling size in ScmdCoreBuiltins, line 416"))
set oSa=Joe(xGa,osa,"when calling getPtr in ScmdCoreBuiltins, line 417")
if ox[iNo(oSa,"when calling get in ScmdCoreBuiltins, line 418")]==$F0D then
set ota=0
loop
exitwhen not(ota<skv(iNo(oSa,"when calling get in ScmdCoreBuiltins, line 420"),"when calling size in ScmdCoreBuiltins, line 420"))
call gWo(UAo(oQa,"when calling getArgs in ScmdCoreBuiltins, line 421"),P_v(sTv(iNo(oSa,"when calling get in ScmdCoreBuiltins, line 421"),ota,"when calling get in ScmdCoreBuiltins, line 421"),"when calling clone in ScmdCoreBuiltins, line 421"),"when calling add in ScmdCoreBuiltins, line 421")
set ota=ota+1
endloop
else
call gWo(UAo(oQa,"when calling getArgs in ScmdCoreBuiltins, line 424"),MJv(oSa,"when calling clone in ScmdCoreBuiltins, line 424"),"when calling add in ScmdCoreBuiltins, line 424")
endif
set osa=osa+1
endloop
call xda(22,oQa,xFa,"when calling evaluate in ScmdCoreBuiltins, line 426",0,null,0,null)
set oTa=RJv
call mtv(oQa,"when calling dispatch_Expression_destroyExpression in ScmdCoreBuiltins, line 427")
set oua=oTa
set EM=EM-1
set RJv=oua
set oaa=null
set ona=null
set oVa=null
return
elseif xDa==18 then
set ZM[EM]=xha
set EM=EM+1
call xda(8,xFa,Joe(xGa,0,"when calling getPtr in ScmdCoreBuiltins, line 350"),"when calling resolve in ScmdCoreBuiltins, line 350",0,null,0,null)
set oUa=RJv
set oya=ox[m0v(oUa,"when calling get in ScmdCoreBuiltins, line 351")]
if not(oya>=$EF1 and oya<=$EF2)then
set oYa=ox[m0v(oUa,"when calling get in ScmdCoreBuiltins, line 352")]
set owa=not((oYa==$EFC or oYa==$F09 and WCv(m0v(oUa,"when calling get in ScmdCoreBuiltins, line 352"),"when calling booleanValue in ScmdCoreBuiltins, line 352")==false)or ox[m0v(oUa,"when calling get in ScmdCoreBuiltins, line 352")]==$F00 or ox[m0v(oUa,"when calling get in ScmdCoreBuiltins, line 352")]==$F0C)
call mfv(20,oUa,"when calling dispatch_GenericSharedPointer_destroyGenericSharedPointer in ScmdCoreBuiltins, line 353")
if owa then
call xda(8,xFa,Joe(xGa,1,"when calling getPtr in ScmdCoreBuiltins, line 354"),"when calling resolve in ScmdCoreBuiltins, line 354",0,null,0,null)
set oWa=RJv
else
set oWa=MLv("when calling nullptr in ScmdCoreBuiltins, line 354")
endif
set oUa=oWa
endif
set oza=oUa
set EM=EM-1
set RJv=oza
set oaa=null
set ona=null
set oVa=null
return
elseif xDa==19 then
set ZM[EM]=xha
set EM=EM+1
call xda($F,xfa,xFa,null,xGa,"when calling call in ScmdDataTypes, line 1527",0,null)
set oZa=RJv
set EM=EM-1
set RJv=oZa
set oaa=null
set ona=null
set oVa=null
return
elseif xDa==20 then
set ZM[EM]=xha
set EM=EM+1
call xda(8,xfa,xFa,"when calling resolve in ScmdCoreBuiltins, line 432",0,null,0,null)
set o_a=RJv
if not(ox[m0v(o_a,"when calling get in ScmdCoreBuiltins, line 433")]==$F0D)then
set o4a=p0v(tJv("Parameter declaration vector should be a vector","when calling new_Exception in ScmdCoreBuiltins, line 434"),"when calling new_SharedPointer in ScmdCoreBuiltins, line 434")
set EM=EM-1
set RJv=o4a
set oaa=null
set ona=null
set oVa=null
return
else
set o0a=jdv(m2e(m0v(o_a,"when calling get in ScmdCoreBuiltins, line 436"),"when calling toHashList in ScmdCoreBuiltins, line 436"),"when calling iterator in ScmdCoreBuiltins, line 436")
loop
exitwhen not Jgv(o0a,"when calling hasNext in ScmdCoreBuiltins, line 436")
set o1a=jTv(o0a,"when calling next in ScmdCoreBuiltins, line 436")
set o3a=ox[m0v(o1a,"when calling get in ScmdCoreBuiltins, line 437")]
if not((o3a>=$EFC and o3a<=$EFF)or(o3a>=$F02 and o3a<=$F03)or(o3a>=$F08 and o3a<=$F09))then
call Jqv(o0a,"when calling close in ScmdCoreBuiltins, line 436")
set o5a=p0v(tJv("Unsupported binding form","when calling new_Exception in ScmdCoreBuiltins, line 438"),"when calling new_SharedPointer in ScmdCoreBuiltins, line 438")
set EM=EM-1
set RJv=o5a
set oaa=null
set ona=null
set oVa=null
return
endif
endloop
call Jqv(o0a,"when calling close in ScmdCoreBuiltins, line 436")
endif
set o2a=p0v(sIo(xfa,m2e(m0v(o_a,"when calling get in ScmdCoreBuiltins, line 439"),"when calling toHashList in ScmdCoreBuiltins, line 439"),MJv(xGa,"when calling clone in ScmdCoreBuiltins, line 439"),"when calling new_RuntimeFunction in ScmdCoreBuiltins, line 439"),"when calling new_SharedPointer in ScmdCoreBuiltins, line 439")
call mfv(20,o_a,"when calling dispatch_GenericSharedPointer_destroyGenericSharedPointer in ScmdCoreBuiltins, line 440")
set EM=EM-1
set RJv=o2a
set oaa=null
set ona=null
set oVa=null
return
elseif xDa==21 then
set ZM[EM]=xha
set EM=EM+1
call xda(8,xFa,Joe(xGa,0,"when calling getPtr in SLangTriggerFunctions, line 34"),"when calling resolve in SLangTriggerFunctions, line 34",0,null,0,null)
set o6a=RJv
if not(ox[m0v(o6a,"when calling get in SLangTriggerFunctions, line 35")]==$F0B)then
call mfv(20,o6a,"when calling dispatch_GenericSharedPointer_destroyGenericSharedPointer in SLangTriggerFunctions, line 36")
set o6a=p0v(tJv("...cannot be cast to Trigger","when calling new_Exception in SLangTriggerFunctions, line 37"),"when calling new_SharedPointer in SLangTriggerFunctions, line 37")
else
call P8v(m0v(o6a,"when calling get in SLangTriggerFunctions, line 39"),Joe(xGa,1,"when calling getPtr in SLangTriggerFunctions, line 39"),"when calling addAction in SLangTriggerFunctions, line 39")
call mfv(20,o6a,"when calling dispatch_GenericSharedPointer_destroyGenericSharedPointer in SLangTriggerFunctions, line 40")
set o6a=MLv("when calling nullptr in SLangTriggerFunctions, line 41")
endif
set o7a=o6a
set EM=EM-1
set RJv=o7a
set oaa=null
set ona=null
set oVa=null
return
elseif xDa==22 then
set ZM[EM]=xga
set EM=EM+1
if ox[xfa]==0 then
if xfa==0 then
call Cdv("Nullpointer exception when calling Expression.evaluate","when calling error in ScmdDataTypes, line 1644")
else
call Cdv("Called Expression.evaluate on invalid object.","when calling error in ScmdDataTypes, line 1644")
endif
endif
call xda(0,xfa,xFa,"when calling evaluate in ScmdDataTypes, line 1644",0,null,0,null)
set o8a=RJv
set EM=EM-1
set RJv=o8a
set oaa=null
set ona=null
set oVa=null
return
elseif xDa==23 then
set ZM[EM]=xha
set EM=EM+1
call xda(16,xfa,xFa,null,xGa,"when calling call in ScmdDataTypes, line 1551",0,null)
set o9a=RJv
set EM=EM-1
set RJv=o9a
set oaa=null
set ona=null
set oVa=null
return
elseif xDa==24 then
set ZM[EM]=xha
set EM=EM+1
call xda(6,xFa,M7v(xGa,0,"when calling get in ScmdCoreBuiltins, line 460"),Mqv(M7v(xGa,1,"when calling get in ScmdCoreBuiltins, line 460"),"when calling getInner in ScmdCoreBuiltins, line 460"),Joe(xGa,2,"when calling getPtr in ScmdCoreBuiltins, line 460"),null,Joe(xGa,3,"when calling getPtr in ScmdCoreBuiltins, line 460"),"when calling defnCmd in ScmdCoreBuiltins, line 460")
set rva=RJv
set EM=EM-1
set RJv=rva
set oaa=null
set ona=null
set oVa=null
return
endif
set oaa=null
set ona=null
set oVa=null
endfunction
function rxa takes integer roa returns string
return wK[roa]
endfunction
function rra takes integer ria,string raa returns string
local string rna
set ZM[EM]=raa
set EM=EM+1
if ox[ria]==0 then
if ria==0 then
call Cdv("Nullpointer exception when calling Exception.getCause","when calling error in ScmdDataTypes, line 204")
else
call Cdv("Called Exception.getCause on invalid object.","when calling error in ScmdDataTypes, line 204")
endif
endif
set rna=rxa(ria)
set EM=EM-1
return rna
endfunction
function rVa takes integer rEa,string rXa returns nothing
set ZM[EM]=rXa
set EM=EM+1
if Oh[rEa]==0 then
if rEa==0 then
call Cdv("Nullpointer exception when calling HashSet.clear","when calling error in HashSet, line 27")
else
call Cdv("Called HashSet.clear on invalid object.","when calling error in HashSet, line 27")
endif
endif
call j_v(rEa)
set EM=EM-1
endfunction
function rOa takes integer rRa,integer rIa,string rAa returns nothing
set ZM[EM]=rAa
set EM=EM+1
if Oh[rRa]==0 then
if rRa==0 then
call Cdv("Nullpointer exception when calling HashSet.add","when calling error in HashSet, line 9")
else
call Cdv("Called HashSet.add on invalid object.","when calling error in HashSet, line 9")
endif
endif
call djv(rRa,rIa,"when calling add in HashSet, line 9")
set EM=EM-1
endfunction
function rNa takes integer rba returns boolean
return QJ[rba]
endfunction
function rBa takes integer rca,string rCa returns boolean
local boolean rda
set ZM[EM]=rCa
set EM=EM+1
if ax[rca]==0 then
if rca==0 then
call Cdv("Nullpointer exception when calling BuiltinData.isProvidingEnumUnit","when calling error in ScmdDataTypes, line 1417")
else
call Cdv("Called BuiltinData.isProvidingEnumUnit on invalid object.","when calling error in ScmdDataTypes, line 1417")
endif
endif
set rda=rNa(rca)
set EM=EM-1
return rda
endfunction
function rDa takes integer rfa,integer rFa,string rga returns boolean
local integer rGa
local boolean rha
local boolean rHa
set ZM[EM]=rga
set EM=EM+1
set rGa=yFo(rfa,rFa,"when calling resolveOverload in ScmdDataTypes, line 1498")
if rGa!=0 then
set rha=rBa(rGa,"when calling isProvidingEnumUnit in ScmdDataTypes, line 1499")
else
set rha=false
endif
set rHa=rha
set EM=EM-1
return rHa
endfunction
function rja takes integer rJa,integer rka,string rKa returns boolean
local boolean rla
set ZM[EM]=rKa
set EM=EM+1
set rla=rDa(rJa,rka,"when calling isProvidingEnumUnit in ScmdDataTypes, line 1536")
set EM=EM-1
return rla
endfunction
function rLa takes integer rma,integer rMa,string rpa returns boolean
local integer rPa
local boolean rqa
local boolean rQa
set ZM[EM]=rpa
set EM=EM+1
set rPa=GJo(rma,rMa,"when calling resolveOverload in ScmdDataTypes, line 1498")
if rPa!=0 then
set rqa=rBa(rPa,"when calling isProvidingEnumUnit in ScmdDataTypes, line 1499")
else
set rqa=false
endif
set rQa=rqa
set EM=EM-1
return rQa
endfunction
function rsa takes integer rSa,integer rta,string rTa returns boolean
local boolean rua
set ZM[EM]=rTa
set EM=EM+1
set rua=rLa(rSa,rta,"when calling isProvidingEnumUnit in ScmdDataTypes, line 1557")
set EM=EM-1
return rua
endfunction
function rUa takes integer rwa,integer rWa,string rya returns boolean
local boolean rYa
set ZM[EM]=rya
set EM=EM+1
if ox[rwa]==0 then
if rwa==0 then
call Cdv("Nullpointer exception when calling Builtin.isProvidingEnumUnit","when calling error in ScmdDataTypes, line 1512")
else
call Cdv("Called Builtin.isProvidingEnumUnit on invalid object.","when calling error in ScmdDataTypes, line 1512")
endif
endif
if ox[rwa]<=$EEC then
set rYa=rja(rwa,rWa,"when calling isProvidingEnumUnit in ScmdDataTypes, line 1512")
else
set rYa=rsa(rwa,rWa,"when calling isProvidingEnumUnit in ScmdDataTypes, line 1512")
endif
set EM=EM-1
return rYa
endfunction
function rza takes integer rZa returns boolean
return mJ[rZa]
endfunction
function r_a takes integer r0a,string r1a returns boolean
local boolean r2a
set ZM[EM]=r1a
set EM=EM+1
if ax[r0a]==0 then
if r0a==0 then
call Cdv("Nullpointer exception when calling BuiltinData.isRequiringEnumUnit","when calling error in ScmdDataTypes, line 1408")
else
call Cdv("Called BuiltinData.isRequiringEnumUnit on invalid object.","when calling error in ScmdDataTypes, line 1408")
endif
endif
set r2a=rza(r0a)
set EM=EM-1
return r2a
endfunction
function r3a takes integer r4a,integer r5a,string r6a returns boolean
local integer r7a
local boolean r8a
local boolean r9a
set ZM[EM]=r6a
set EM=EM+1
set r7a=yFo(r4a,r5a,"when calling resolveOverload in ScmdDataTypes, line 1494")
if r7a!=0 then
set r8a=r_a(r7a,"when calling isRequiringEnumUnit in ScmdDataTypes, line 1495")
else
set r8a=false
endif
set r9a=r8a
set EM=EM-1
return r9a
endfunction
function iva takes integer iea,integer ixa,string ioa returns boolean
local boolean ira
set ZM[EM]=ioa
set EM=EM+1
set ira=r3a(iea,ixa,"when calling isRequiringEnumUnit in ScmdDataTypes, line 1533")
set EM=EM-1
return ira
endfunction
function iia takes integer iaa,integer ina,string iVa returns boolean
local integer iEa
local boolean iXa
local boolean iOa
set ZM[EM]=iVa
set EM=EM+1
set iEa=GJo(iaa,ina,"when calling resolveOverload in ScmdDataTypes, line 1494")
if iEa!=0 then
set iXa=r_a(iEa,"when calling isRequiringEnumUnit in ScmdDataTypes, line 1495")
else
set iXa=false
endif
set iOa=iXa
set EM=EM-1
return iOa
endfunction
function iRa takes integer iIa,integer iAa,string iNa returns boolean
local boolean iba
set ZM[EM]=iNa
set EM=EM+1
set iba=iia(iIa,iAa,"when calling isRequiringEnumUnit in ScmdDataTypes, line 1554")
set EM=EM-1
return iba
endfunction
function iBa takes integer ica,integer iCa,string ida returns boolean
local boolean iDa
set ZM[EM]=ida
set EM=EM+1
if ox[ica]==0 then
if ica==0 then
call Cdv("Nullpointer exception when calling Builtin.isRequiringEnumUnit","when calling error in ScmdDataTypes, line 1510")
else
call Cdv("Called Builtin.isRequiringEnumUnit on invalid object.","when calling error in ScmdDataTypes, line 1510")
endif
endif
if ox[ica]<=$EEC then
set iDa=iva(ica,iCa,"when calling isRequiringEnumUnit in ScmdDataTypes, line 1510")
else
set iDa=iRa(ica,iCa,"when calling isRequiringEnumUnit in ScmdDataTypes, line 1510")
endif
set EM=EM-1
return iDa
endfunction
function ifa takes integer iFa,integer iga,string iGa returns boolean
local integer iha
local integer iHa
local integer ija
local integer iJa
local boolean ika
set ZM[EM]=iGa
set EM=EM+1
if fcv(Ln,iFa,"when calling has in ScmdDataTypes, line 1616")then
set EM=EM-1
return false
endif
call rOa(Ln,iFa,"when calling add in ScmdDataTypes, line 1618")
if ox[m0v(rK[iFa],"when calling get in ScmdDataTypes, line 1619")]==$EF3 then
set ika=ifa(m0v(rK[iFa],"when calling get in ScmdDataTypes, line 1620"),iga,"when calling dfsImpl in ScmdDataTypes, line 1620")
set EM=EM-1
return ika
else
call xda(8,iga,rK[iFa],"when calling resolve in ScmdDataTypes, line 1622",0,null,0,null)
set iha=RJv
set iJa=ox[m0v(iha,"when calling get in ScmdDataTypes, line 1623")]
if iJa>=$EEB and iJa<=$EED then
if iBa(m0v(iha,"when calling get in ScmdDataTypes, line 1624"),sK[iFa],"when calling isRequiringEnumUnit in ScmdDataTypes, line 1624")then
call mfv(20,iha,"when calling dispatch_GenericSharedPointer_destroyGenericSharedPointer in ScmdDataTypes, line 1625")
set EM=EM-1
return true
elseif rUa(m0v(iha,"when calling get in ScmdDataTypes, line 1627"),sK[iFa],"when calling isProvidingEnumUnit in ScmdDataTypes, line 1627")then
call mfv(20,iha,"when calling dispatch_GenericSharedPointer_destroyGenericSharedPointer in ScmdDataTypes, line 1628")
set EM=EM-1
return false
endif
elseif ox[m0v(iha,"when calling get in ScmdDataTypes, line 1630")]==$EEF then
if ox[m0v(nK[m0v(iha,"when calling get in ScmdDataTypes, line 1631")],"when calling get in ScmdDataTypes, line 1631")]==$EF3 and ifa(m0v(nK[m0v(iha,"when calling get in ScmdDataTypes, line 1631")],"when calling get in ScmdDataTypes, line 1631"),iga,"when calling dfsImpl in ScmdDataTypes, line 1631")then
call mfv(20,iha,"when calling dispatch_GenericSharedPointer_destroyGenericSharedPointer in ScmdDataTypes, line 1632")
set EM=EM-1
return true
endif
endif
call mfv(20,iha,"when calling dispatch_GenericSharedPointer_destroyGenericSharedPointer in ScmdDataTypes, line 1634")
set iHa=MRe(sK[iFa],"when calling iterator in ScmdDataTypes, line 1635")
loop
exitwhen not Jgv(iHa,"when calling hasNext in ScmdDataTypes, line 1635")
set ija=jTv(iHa,"when calling next in ScmdDataTypes, line 1635")
if ox[m0v(ija,"when calling get in ScmdDataTypes, line 1636")]==$EF3 and ifa(m0v(ija,"when calling get in ScmdDataTypes, line 1636"),iga,"when calling dfsImpl in ScmdDataTypes, line 1636")then
call Jqv(iHa,"when calling close in ScmdDataTypes, line 1635")
set EM=EM-1
return true
endif
endloop
call Jqv(iHa,"when calling close in ScmdDataTypes, line 1635")
set EM=EM-1
return false
endif
endfunction
function iKa takes integer ila,integer iLa,string ima returns boolean
local boolean iMa
set ZM[EM]=ima
set EM=EM+1
if ox[ila]==0 then
if ila==0 then
call Cdv("Nullpointer exception when calling Expression.dfsImpl","when calling error in ScmdDataTypes, line 1615")
else
call Cdv("Called Expression.dfsImpl on invalid object.","when calling error in ScmdDataTypes, line 1615")
endif
endif
set iMa=ifa(ila,iLa,"when calling dfsImpl in ScmdDataTypes, line 1615")
set EM=EM-1
return iMa
endfunction
function ipa takes integer iPa,integer iqa,string iQa returns boolean
local boolean isa
set ZM[EM]=iQa
set EM=EM+1
call rVa(Ln,"when calling clear in ScmdDataTypes, line 1641")
set isa=iKa(iPa,iqa,"when calling dfsImpl in ScmdDataTypes, line 1642")
set EM=EM-1
return isa
endfunction
function iSa takes integer ita,integer iTa,string iua returns boolean
local boolean iUa
set ZM[EM]=iua
set EM=EM+1
if ox[ita]==0 then
if ita==0 then
call Cdv("Nullpointer exception when calling Expression.dfs","when calling error in ScmdDataTypes, line 1640")
else
call Cdv("Called Expression.dfs on invalid object.","when calling error in ScmdDataTypes, line 1640")
endif
endif
set iUa=ipa(ita,iTa,"when calling dfs in ScmdDataTypes, line 1640")
set EM=EM-1
return iUa
endfunction
function iwa takes string iWa returns integer
local integer iya
set ZM[EM]=iWa
set EM=EM+1
if oF==0 then
if OF<$8000 then
set OF=OF+1
set iya=OF
set lF[iya]=$848
else
call Cdv("Out of memory: Could not create FoldClosure_foldl_send_registerExceptionHandler_SLangChatSystem.","when calling error in SLangChatSystem, line 178")
set iya=0
endif
else
set oF=oF-1
set iya=cF[oF]
set lF[iya]=$848
endif
set EM=EM-1
return iya
endfunction
function iYa takes integer b3s,integer iza,string iZa returns string
return iZa+SMv(iza)+","
endfunction
function i_a takes integer i0a,integer i1a,integer i2a,string i3a returns integer
local integer i4a
set ZM[EM]=i3a
set EM=EM+1
set i4a=KCv(iYa(i0a,i1a,hxv(i2a,"when calling stringFromIndex in LinkedList, line 361")),"when calling stringToIndex in LinkedList, line 361")
set EM=EM-1
return i4a
endfunction
function i5a takes integer lpt,string i6a,string i7a returns string
return i7a+" at |cff5394ec"+i6a+"|r"
endfunction
function i8a takes integer i9a,integer ava,integer aea,string axa returns integer
local integer aoa
set ZM[EM]=axa
set EM=EM+1
set aoa=KCv(i5a(i9a,hxv(ava,"when calling stringFromIndex in SLangChatSystem, line 178"),hxv(aea,"when calling stringFromIndex in SLangChatSystem, line 178")),"when calling stringToIndex in SLangChatSystem, line 178")
set EM=EM-1
return aoa
endfunction
function ara takes integer aia,integer aaa,integer ana,string aVa returns integer
local integer aEa
set ZM[EM]=aVa
set EM=EM+1
if lF[aia]==0 then
if aia==0 then
call Cdv("Nullpointer exception when calling FoldClosure.run","when calling error in LinkedList, line 521")
else
call Cdv("Called FoldClosure.run on invalid object.","when calling error in LinkedList, line 521")
endif
endif
if lF[aia]<=$847 then
set aEa=i_a(aia,aaa,ana,"when calling run_wrapper in LinkedList, line 521")
else
set aEa=i8a(aia,aaa,ana,"when calling run_wrapper in LinkedList, line 521")
endif
set EM=EM-1
return aEa
endfunction
function aXa takes integer aOa,string aRa returns nothing
set ZM[EM]=aRa
set EM=EM+1
if lF[aOa]==0 then
call Cdv("Double free: object of type FoldClosure","when calling error in LinkedList, line 520")
else
set cF[oF]=aOa
set oF=oF+1
set lF[aOa]=0
endif
set EM=EM-1
endfunction
function aIa takes integer aAa,string aNa returns nothing
set ZM[EM]=aNa
set EM=EM+1
call aXa(aAa,"when calling dealloc_FoldClosure in LinkedList, line 520")
set EM=EM-1
endfunction
function aba takes integer aBa,string aca returns nothing
set ZM[EM]=aca
set EM=EM+1
if lF[aBa]==0 then
if aBa==0 then
call Cdv("Nullpointer exception when calling FoldClosure.FoldClosure","when calling error in LinkedList, line 520")
else
call Cdv("Called FoldClosure.FoldClosure on invalid object.","when calling error in LinkedList, line 520")
endif
endif
call aIa(aBa,"when calling destroyFoldClosure in LinkedList, line 520")
set EM=EM-1
endfunction
function aCa takes integer ada,integer aDa,integer afa,string aFa returns integer
local integer aga
local integer aGa
set ZM[EM]=aFa
set EM=EM+1
set aga=aDa
set aGa=sP[oP[ada]]
loop
exitwhen not(aGa!=oP[ada])
set aga=ara(afa,uP[aGa],aga,"when calling run in LinkedList, line 293")
set aGa=sP[aGa]
endloop
call aba(afa,"when calling dispatch_FoldClosure_destroyFoldClosure in LinkedList, line 295")
set EM=EM-1
return aga
endfunction
function aha takes integer aHa,integer aja,integer aJa,string aka returns integer
local integer aKa
set ZM[EM]=aka
set EM=EM+1
if gF[aHa]==0 then
if aHa==0 then
call Cdv("Nullpointer exception when calling LinkedList.foldl","when calling error in LinkedList, line 289")
else
call Cdv("Called LinkedList.foldl on invalid object.","when calling error in LinkedList, line 289")
endif
endif
set aKa=aCa(aHa,aja,aJa,"when calling foldl in LinkedList, line 289")
set EM=EM-1
return aKa
endfunction
function ala takes integer Nyt,integer aLa,string ama,integer aMa,string apa returns nothing
local integer aPa
local string aqa
local integer aQa
local integer asa
local integer aSa
local integer ata
set ZM[EM]=apa
set EM=EM+1
set aSa=Ka[aLa]
set ata=aLa
if aMa!=0 then
set aQa=aMa
set asa=KCv("","when calling stringToIndex in SLangChatSystem, line 178")
set aPa=iwa("when calling alloc_FoldClosure_foldl_send_registerExceptionHandler_SLangChatSystem in SLangChatSystem, line 178")
set aqa=hxv(aha(aQa,asa,aPa,"when calling foldl in SLangChatSystem, line 178"),"when calling stringFromIndex in SLangChatSystem, line 178")
else
set aqa=""
endif
call HFe(aSa,ata,"|cFFcc666eException|r"+aqa+": "+ama,sa[aLa],"when calling send in SLangChatSystem, line 178")
set EM=EM-1
endfunction
function aTa takes integer aua,integer aUa,string awa,integer aWa,string aya returns nothing
set ZM[EM]=aya
set EM=EM+1
if fj[aua]==0 then
if aua==0 then
call Cdv("Nullpointer exception when calling IExceptionHandler.call","when calling error in ScmdDataTypes, line 1560")
else
call Cdv("Called IExceptionHandler.call on invalid object.","when calling error in ScmdDataTypes, line 1560")
endif
endif
call ala(aua,aUa,awa,aWa,"when calling call_registerExceptionHandler_SLangChatSystem in ScmdDataTypes, line 1560")
set EM=EM-1
endfunction
function aYa takes integer aza,string aZa,integer a_a,string a0a returns nothing
local integer a1a
local integer a2a
set ZM[EM]=a0a
set EM=EM+1
set a1a=0
set a2a=Wn-1
loop
exitwhen a1a>a2a
call aTa(Qn[a1a],aza,aZa,a_a,"when calling call in ScmdDataTypes, line 1567")
set a1a=a1a+1
endloop
set EM=EM-1
endfunction
function a3a takes integer a4a,integer a5a,string a6a returns nothing
local integer a7a
local group a8a
local unit a9a
local group nva
local integer nea
local integer nxa
local integer noa
local integer nra
set ZM[EM]=a6a
set EM=EM+1
set a7a=P2e("when calling new_Context in ScmdDataTypes, line 1661")
call p7e(a7a,a5a,"when calling setPlayerId in ScmdDataTypes, line 1662")
if iSa(a4a,a7a,"when calling dfs in ScmdDataTypes, line 1663")then
set a8a=CreateGroup()
set Xn=a5a
call GroupEnumUnitsSelected(a8a,sa[a5a],Filter(RDv))
set nva=a8a
loop
exitwhen not F9e(nva)
set a9a=F6e(nva)
call m7v(a7a,a9a,"when calling setEnumUnit in ScmdDataTypes, line 1668")
call xda(22,a4a,a7a,"when calling evaluate in ScmdDataTypes, line 1669",0,null,0,null)
set nea=RJv
set noa=ox[m0v(nea,"when calling get in ScmdDataTypes, line 1670")]
if noa>=$EF1 and noa<=$EF2 then
call aYa(a5a,rra(m0v(nea,"when calling get in ScmdDataTypes, line 1671"),"when calling getCause in ScmdDataTypes, line 1671"),mWv(m0v(nea,"when calling get in ScmdDataTypes, line 1671"),"when calling getStackTrace in ScmdDataTypes, line 1671"),"when calling handleException in ScmdDataTypes, line 1671")
call mfv(20,nea,"when calling dispatch_GenericSharedPointer_destroyGenericSharedPointer in ScmdDataTypes, line 1672")
exitwhen true
endif
call mfv(20,nea,"when calling dispatch_GenericSharedPointer_destroyGenericSharedPointer in ScmdDataTypes, line 1674")
endloop
call kcv(a8a)
else
call xda(22,a4a,a7a,"when calling evaluate in ScmdDataTypes, line 1677",0,null,0,null)
set nxa=RJv
set nra=ox[m0v(nxa,"when calling get in ScmdDataTypes, line 1678")]
if nra>=$EF1 and nra<=$EF2 then
call aYa(a5a,rra(m0v(nxa,"when calling get in ScmdDataTypes, line 1679"),"when calling getCause in ScmdDataTypes, line 1679"),mWv(m0v(nxa,"when calling get in ScmdDataTypes, line 1679"),"when calling getStackTrace in ScmdDataTypes, line 1679"),"when calling handleException in ScmdDataTypes, line 1679")
endif
call mfv(20,nxa,"when calling dispatch_GenericSharedPointer_destroyGenericSharedPointer in ScmdDataTypes, line 1680")
endif
call mfv(4,a7a,"when calling dispatch_Context_destroyContext in ScmdDataTypes, line 1681")
set EM=EM-1
set a8a=null
set a9a=null
set nva=null
endfunction
function nia takes integer naa,integer nna,string nVa returns nothing
set ZM[EM]=nVa
set EM=EM+1
if ox[naa]==0 then
if naa==0 then
call Cdv("Nullpointer exception when calling Expression.startEvaluationChain","when calling error in ScmdDataTypes, line 1660")
else
call Cdv("Called Expression.startEvaluationChain on invalid object.","when calling error in ScmdDataTypes, line 1660")
endif
endif
call a3a(naa,nna,"when calling startEvaluationChain in ScmdDataTypes, line 1660")
set EM=EM-1
endfunction
function nEa takes integer nXa,string nOa returns integer
local integer nRa
local integer nIa
set ZM[EM]=nOa
set EM=EM+1
set nRa=rP[oP[nXa]]
set nIa=0
if nRa!=oP[nXa]then
set nIa=uP[nRa]
call GJe(nXa,nRa,"when calling removeEntry in LinkedList, line 103")
endif
set EM=EM-1
return nIa
endfunction
function nAa takes integer nNa,string nba returns integer
local integer nBa
set ZM[EM]=nba
set EM=EM+1
if gF[nNa]==0 then
if nNa==0 then
call Cdv("Nullpointer exception when calling LinkedList.pop","when calling error in LinkedList, line 98")
else
call Cdv("Called LinkedList.pop on invalid object.","when calling error in LinkedList, line 98")
endif
endif
set nBa=nEa(nNa,"when calling pop in LinkedList, line 98")
set EM=EM-1
return nBa
endfunction
function nca takes integer nCa returns integer
return uP[rP[oP[nCa]]]
endfunction
function nda takes integer nDa,string nfa returns integer
local integer nFa
set ZM[EM]=nfa
set EM=EM+1
if gF[nDa]==0 then
if nDa==0 then
call Cdv("Nullpointer exception when calling LinkedList.peek","when calling error in LinkedList, line 107")
else
call Cdv("Called LinkedList.peek on invalid object.","when calling error in LinkedList, line 107")
endif
endif
set nFa=nca(nDa)
set EM=EM-1
return nFa
endfunction
function nga takes integer nGa returns integer
return rK[nGa]
endfunction
function nha takes integer nHa,string nja returns integer
local integer nJa
set ZM[EM]=nja
set EM=EM+1
if ox[nHa]==0 then
if nHa==0 then
call Cdv("Nullpointer exception when calling Expression.getCallee","when calling error in ScmdDataTypes, line 1607")
else
call Cdv("Called Expression.getCallee on invalid object.","when calling error in ScmdDataTypes, line 1607")
endif
endif
set nJa=nga(nHa)
set EM=EM-1
return nJa
endfunction
function nka takes integer nKa,integer nla,string nLa returns nothing
set ZM[EM]=nLa
set EM=EM+1
if rK[nKa]!=0 then
call mfv(20,rK[nKa],"when calling dispatch_GenericSharedPointer_destroyGenericSharedPointer in ScmdDataTypes, line 1604")
endif
set rK[nKa]=nla
set EM=EM-1
endfunction
function nma takes integer nMa,integer npa,string nPa returns nothing
set ZM[EM]=nPa
set EM=EM+1
if ox[nMa]==0 then
if nMa==0 then
call Cdv("Nullpointer exception when calling Expression.setCallee","when calling error in ScmdDataTypes, line 1602")
else
call Cdv("Called Expression.setCallee on invalid object.","when calling error in ScmdDataTypes, line 1602")
endif
endif
call nka(nMa,npa,"when calling setCallee in ScmdDataTypes, line 1602")
set EM=EM-1
endfunction
function nqa takes integer nQa,integer nsa,string nSa returns integer
local integer nta
set ZM[EM]=nSa
set EM=EM+1
set nta=nda(nQa,"when calling peek in ScmdParser, line 158")
call nAa(nQa,"when calling pop in ScmdParser, line 159")
if nha(nta,"when calling getCallee in ScmdParser, line 160")==0 then
call nma(nta,p0v(nsa,"when calling new_SharedPointer in ScmdParser, line 161"),"when calling setCallee in ScmdParser, line 161")
else
call gWo(UAo(nta,"when calling getArgs in ScmdParser, line 163"),p0v(nsa,"when calling new_SharedPointer in ScmdParser, line 163"),"when calling add in ScmdParser, line 163")
endif
set EM=EM-1
return nta
endfunction
function nTa takes integer nua returns string
return JK[nua]
endfunction
function nUa takes integer nwa,string nWa returns string
local string nya
set ZM[EM]=nWa
set EM=EM+1
if Dx[nwa]==0 then
if nwa==0 then
call Cdv("Nullpointer exception when calling Tokenizer.getSkipped","when calling error in ScmdParser, line 144")
else
call Cdv("Called Tokenizer.getSkipped on invalid object.","when calling error in ScmdParser, line 144")
endif
endif
set nya=nTa(nwa)
set EM=EM-1
return nya
endfunction
function nYa takes integer nza returns nothing
set HK[nza]=HK[nza]-1
endfunction
function nZa takes integer n_a,string n0a returns nothing
set ZM[EM]=n0a
set EM=EM+1
if Dx[n_a]==0 then
if n_a==0 then
call Cdv("Nullpointer exception when calling Tokenizer.prev","when calling error in ScmdParser, line 57")
else
call Cdv("Called Tokenizer.prev on invalid object.","when calling error in ScmdParser, line 57")
endif
endif
call nYa(n_a)
set EM=EM-1
endfunction
function n1a takes integer n2a,integer n3a returns string
return duv(AK[n2a],n3a)
endfunction
function n4a takes integer n5a,integer n6a,string n7a returns string
local string n8a
set ZM[EM]=n7a
set EM=EM+1
if Dx[n5a]==0 then
if n5a==0 then
call Cdv("Nullpointer exception when calling Tokenizer.charAt","when calling error in ScmdParser, line 48")
else
call Cdv("Called Tokenizer.charAt on invalid object.","when calling error in ScmdParser, line 48")
endif
endif
set n8a=n1a(n5a,n6a)
set EM=EM-1
return n8a
endfunction
function n9a takes integer Vva,string Vea returns string
local string Vxa
set ZM[EM]=Vea
set EM=EM+1
set Vxa=n4a(Vva,HK[Vva],"when calling charAt in ScmdParser, line 52")
set EM=EM-1
return Vxa
endfunction
function Voa takes integer Vra,string Via returns string
local string Vaa
set ZM[EM]=Via
set EM=EM+1
if Dx[Vra]==0 then
if Vra==0 then
call Cdv("Nullpointer exception when calling Tokenizer.current","when calling error in ScmdParser, line 51")
else
call Cdv("Called Tokenizer.current on invalid object.","when calling error in ScmdParser, line 51")
endif
endif
set Vaa=n9a(Vra,"when calling current in ScmdParser, line 51")
set EM=EM-1
return Vaa
endfunction
function Vna takes integer VVa returns nothing
set HK[VVa]=HK[VVa]+1
endfunction
function VEa takes integer VXa,string VOa returns nothing
set ZM[EM]=VOa
set EM=EM+1
if Dx[VXa]==0 then
if VXa==0 then
call Cdv("Nullpointer exception when calling Tokenizer.next","when calling error in ScmdParser, line 54")
else
call Cdv("Called Tokenizer.next on invalid object.","when calling error in ScmdParser, line 54")
endif
endif
call Vna(VXa)
set EM=EM-1
endfunction
function VRa takes integer VIa returns boolean
return HK[VIa]<DK[VIa]
endfunction
function VAa takes integer VNa,string Vba returns boolean
local boolean VBa
set ZM[EM]=Vba
set EM=EM+1
if Dx[VNa]==0 then
if VNa==0 then
call Cdv("Nullpointer exception when calling Tokenizer.hasMore","when calling error in ScmdParser, line 60")
else
call Cdv("Called Tokenizer.hasMore on invalid object.","when calling error in ScmdParser, line 60")
endif
endif
set VBa=VRa(VNa)
set EM=EM-1
return VBa
endfunction
function Vca takes string VCa returns boolean
return VCa==" "
endfunction
function Vda takes string VDa returns boolean
return VDa=="0" or VDa=="1" or VDa=="2" or VDa=="3" or VDa=="4" or VDa=="5" or VDa=="6" or VDa=="7" or VDa=="8" or VDa=="9"
endfunction
function Vfa takes string VFa returns boolean
local string Vga=tYv(VFa)
return Vda(Vga)or Vga=="a" or Vga=="b" or Vga=="c" or Vga=="d" or Vga=="e" or Vga=="f"
endfunction
function VGa takes integer Vha,integer VHa,integer Vja returns string
return Psv(AK[Vha],VHa,Vja)
endfunction
function VJa takes integer Vka,integer VKa,integer Vla,string VLa returns string
local string Vma
set ZM[EM]=VLa
set EM=EM+1
if Dx[Vka]==0 then
if Vka==0 then
call Cdv("Nullpointer exception when calling Tokenizer.substring","when calling error in ScmdParser, line 45")
else
call Cdv("Called Tokenizer.substring on invalid object.","when calling error in ScmdParser, line 45")
endif
endif
set Vma=VGa(Vka,VKa,Vla)
set EM=EM-1
return Vma
endfunction
function VMa takes integer Vpa,string VPa returns boolean
local string Vqa
local integer VQa
local boolean Vsa
local string VSa
local boolean Vta
local string VTa
set ZM[EM]=VPa
set EM=EM+1
set Vqa=tYv(Voa(Vpa,"when calling current in ScmdParser, line 70"))
call VEa(Vpa,"when calling next in ScmdParser, line 71")
if Vqa=="\\" or Vqa=="$" or Vqa=="[" or Vqa=="]" then
set EM=EM-1
set B9=true
set N9=Vqa
return B9
elseif Vqa=="c" then
set VQa=0
loop
exitwhen not(Vfa(Voa(Vpa,"when calling current in ScmdParser, line 76"))and VQa!=6)
call VEa(Vpa,"when calling next in ScmdParser, line 77")
set VQa=VQa+1
endloop
if VQa!=6 then
set EM=EM-1
set B9=false
set N9="Некорректная управляющая последовательность (некорректный код цвета)."
return B9
endif
set Vta=true
set VTa="|cFF"+VJa(Vpa,HK[Vpa]-6,HK[Vpa],"when calling substring in ScmdParser, line 81")
set Vsa=Vta
set VSa=VTa
set EM=EM-1
set B9=Vsa
set N9=VSa
return B9
elseif Vqa=="r" then
set EM=EM-1
set B9=true
set N9="|r"
return B9
elseif Vqa=="n" then
set EM=EM-1
set B9=true
set N9="|n"
return B9
elseif Vqa=="s" then
set EM=EM-1
set B9=true
set N9=" "
return B9
endif
set EM=EM-1
set B9=false
set N9="Некорректная управляющая последовательность."
return B9
endfunction
function Vua takes integer VUa,string Vwa returns boolean
local boolean VWa
local string Vya
local boolean VYa
local string Vza
set ZM[EM]=Vwa
set EM=EM+1
if Dx[VUa]==0 then
if VUa==0 then
call Cdv("Nullpointer exception when calling Tokenizer.getEscapeSequence","when calling error in ScmdParser, line 69")
else
call Cdv("Called Tokenizer.getEscapeSequence on invalid object.","when calling error in ScmdParser, line 69")
endif
endif
set VYa=VMa(VUa,"when calling getEscapeSequence in ScmdParser, line 69")
set Vza=N9
set VWa=VYa
set Vya=Vza
set EM=EM-1
set M9=VWa
set z=Vya
return M9
endfunction
function VZa takes integer V_a,string V0a returns boolean
local string V1a
local boolean V2a
local string V3a
local boolean V4a
local string V5a
set ZM[EM]=V0a
set EM=EM+1
set V1a=Voa(V_a,"when calling current in ScmdParser, line 91")
if(not VAa(V_a,"when calling hasMore in ScmdParser, line 92"))or V1a==" " or V1a=="]" or V1a=="[" or V1a=="$" then
set EM=EM-1
set zv=true
set ze=null
return zv
endif
call VEa(V_a,"when calling next in ScmdParser, line 94")
if V1a=="\\" then
set V4a=Vua(V_a,"when calling getEscapeSequence in ScmdParser, line 96")
set V5a=z
set V2a=V4a
set V3a=V5a
set EM=EM-1
set zv=V2a
set ze=V3a
return zv
endif
set EM=EM-1
set zv=true
set ze=V1a
return zv
endfunction
function V6a takes integer V7a,string V8a returns boolean
local boolean V9a
local string Eva
local boolean Eea
local string Exa
set ZM[EM]=V8a
set EM=EM+1
if Dx[V7a]==0 then
if V7a==0 then
call Cdv("Nullpointer exception when calling Tokenizer.nextStringChunk","when calling error in ScmdParser, line 90")
else
call Cdv("Called Tokenizer.nextStringChunk on invalid object.","when calling error in ScmdParser, line 90")
endif
endif
set Eea=VZa(V7a,"when calling nextStringChunk in ScmdParser, line 90")
set Exa=ze
set V9a=Eea
set Eva=Exa
set EM=EM-1
set zx=V9a
set to=Eva
return zx
endfunction
function Eoa takes integer Era,string Eia returns boolean
local boolean Eaa
local string Ena
local string EVa
local boolean EEa
local string EXa
local boolean EOa
local string ERa
set ZM[EM]=Eia
set EM=EM+1
set EEa=V6a(Era,"when calling nextStringChunk in ScmdParser, line 100")
set EXa=to
set Eaa=EEa
set Ena=EXa
set EVa=""
loop
exitwhen not(Eaa and Ena!=null)
set EVa=EVa+Ena
set EOa=V6a(Era,"when calling nextStringChunk in ScmdParser, line 104")
set ERa=to
set Eaa=EOa
set Ena=ERa
endloop
if not Eaa then
set EM=EM-1
set zo=Eaa
set zr=Ena
return zo
endif
set Ena=EVa
set EM=EM-1
set zo=Eaa
set zr=Ena
return zo
endfunction
function EIa takes integer EAa,string ENa returns boolean
local boolean Eba
local string EBa
local boolean Eca
local string ECa
set ZM[EM]=ENa
set EM=EM+1
if Dx[EAa]==0 then
if EAa==0 then
call Cdv("Nullpointer exception when calling Tokenizer.getString","when calling error in ScmdParser, line 99")
else
call Cdv("Called Tokenizer.getString on invalid object.","when calling error in ScmdParser, line 99")
endif
endif
set Eca=Eoa(EAa,"when calling getString in ScmdParser, line 99")
set ECa=zr
set Eba=Eca
set EBa=ECa
set EM=EM-1
set zV=Eba
set zE=EBa
return zV
endfunction
function Eda takes integer EDa,string Efa returns integer
local integer EFa
local string Ega
local integer EGa
local string Eha
local integer EHa
local string Eja
set ZM[EM]=Efa
set EM=EM+1
set EFa=HK[EDa]
set Ega=Voa(EDa,"when calling current in ScmdParser, line 112")
loop
exitwhen not(VAa(EDa,"when calling hasMore in ScmdParser, line 113")and(not Vca(Ega))and Ega!="[" and Ega!="]" and Ega!="$" and Ega!="\\")
call VEa(EDa,"when calling next in ScmdParser, line 114")
set Ega=Voa(EDa,"when calling current in ScmdParser, line 115")
endloop
if Ega=="\\" or HK[EDa]==EFa then
set EM=EM-1
set zi=1
set za="Некорректное название переменной."
return zi
endif
set EHa=3
set Eja=VJa(EDa,EFa,HK[EDa],"when calling substring in ScmdParser, line 118")
set EGa=EHa
set Eha=Eja
set EM=EM-1
set zi=EGa
set za=Eha
return zi
endfunction
function EJa takes integer Eka,string EKa returns integer
local integer Ela
local string ELa
local integer Ema
local string EMa
set ZM[EM]=EKa
set EM=EM+1
if Dx[Eka]==0 then
if Eka==0 then
call Cdv("Nullpointer exception when calling Tokenizer.getSymbol","when calling error in ScmdParser, line 110")
else
call Cdv("Called Tokenizer.getSymbol on invalid object.","when calling error in ScmdParser, line 110")
endif
endif
set Ema=Eda(Eka,"when calling getSymbol in ScmdParser, line 110")
set EMa=za
set Ela=Ema
set ELa=EMa
set EM=EM-1
set in=Ela
set zn=ELa
return in
endfunction
function Epa takes integer EPa,string Eqa returns string
local integer EQa
local string Esa
set ZM[EM]=Eqa
set EM=EM+1
set EQa=HK[EPa]
loop
exitwhen not Vca(Voa(EPa,"when calling current in ScmdParser, line 65"))
call VEa(EPa,"when calling next in ScmdParser, line 66")
endloop
set Esa=VJa(EPa,EQa,HK[EPa],"when calling substring in ScmdParser, line 67")
set EM=EM-1
return Esa
endfunction
function ESa takes integer Eta,string ETa returns string
local string Eua
set ZM[EM]=ETa
set EM=EM+1
if Dx[Eta]==0 then
if Eta==0 then
call Cdv("Nullpointer exception when calling Tokenizer.skipWhitespaces","when calling error in ScmdParser, line 63")
else
call Cdv("Called Tokenizer.skipWhitespaces on invalid object.","when calling error in ScmdParser, line 63")
endif
endif
set Eua=Epa(Eta,"when calling skipWhitespaces in ScmdParser, line 63")
set EM=EM-1
return Eua
endfunction
function EUa takes integer Ewa,string EWa returns integer
local string Eya
local boolean EYa
local string Eza
local integer EZa
local string E_a
local integer E0a
local string E1a
local boolean E2a
local string E3a
set ZM[EM]=EWa
set EM=EM+1
set JK[Ewa]=ESa(Ewa,"when calling skipWhitespaces in ScmdParser, line 121")
if not VAa(Ewa,"when calling hasMore in ScmdParser, line 122")then
set EM=EM-1
set zX=0
set zO=null
return zX
endif
set Eya=Voa(Ewa,"when calling current in ScmdParser, line 124")
call VEa(Ewa,"when calling next in ScmdParser, line 125")
if Eya=="[" then
set EM=EM-1
set zX=4
set zO=null
return zX
elseif Eya=="]" then
set EM=EM-1
set zX=6
set zO=null
return zX
elseif Eya=="$" then
if Voa(Ewa,"when calling current in ScmdParser, line 131")=="[" then
call VEa(Ewa,"when calling next in ScmdParser, line 132")
set EM=EM-1
set zX=5
set zO=null
return zX
endif
if Vca(Voa(Ewa,"when calling current in ScmdParser, line 134"))then
call VEa(Ewa,"when calling next in ScmdParser, line 135")
set EM=EM-1
set zX=7
set zO=null
return zX
endif
set E0a=EJa(Ewa,"when calling getSymbol in ScmdParser, line 137")
set E1a=zn
set EZa=E0a
set E_a=E1a
set EM=EM-1
set zX=EZa
set zO=E_a
return zX
endif
call nZa(Ewa,"when calling prev in ScmdParser, line 138")
set E2a=EIa(Ewa,"when calling getString in ScmdParser, line 139")
set E3a=zE
set EYa=E2a
set Eza=E3a
if not EYa then
set EM=EM-1
set zX=1
set zO=Eza
return zX
endif
set EM=EM-1
set zX=2
set zO=Eza
return zX
endfunction
function E4a takes integer E5a,string E6a returns integer
local integer E7a
local string E8a
local integer E9a
local string Xva
set ZM[EM]=E6a
set EM=EM+1
if Dx[E5a]==0 then
if E5a==0 then
call Cdv("Nullpointer exception when calling Tokenizer.nextToken","when calling error in ScmdParser, line 120")
else
call Cdv("Called Tokenizer.nextToken on invalid object.","when calling error in ScmdParser, line 120")
endif
endif
set E9a=EUa(E5a,"when calling nextToken in ScmdParser, line 120")
set Xva=zO
set E7a=E9a
set E8a=Xva
set EM=EM-1
set D1=E7a
set H1=E8a
return D1
endfunction
function Xea takes integer kwi returns nothing
endfunction
function Xxa takes integer Xoa,string Xra returns nothing
call Xea(Xoa)
set AK[Xoa]=Xra
set DK[Xoa]=GZv(Xra)
set HK[Xoa]=0
endfunction
function Xia takes string Xaa returns integer
local integer Xna
set ZM[EM]=Xaa
set EM=EM+1
if Px==0 then
if Ax<$8000 then
set Ax=Ax+1
set Xna=Ax
set Dx[Xna]=4972
else
call Cdv("Out of memory: Could not create Tokenizer.","when calling error in ScmdParser, line 22")
set Xna=0
endif
else
set Px=Px-1
set Xna=Ix[Px]
set Dx[Xna]=4972
endif
set EM=EM-1
return Xna
endfunction
function XVa takes string XEa,string XXa returns integer
local integer XOa
set ZM[EM]=XXa
set EM=EM+1
set XOa=Xia("when calling alloc_Tokenizer in ScmdParser, line 30")
call Xxa(XOa,XEa)
set EM=EM-1
return XOa
endfunction
function XRa takes integer XIa,string XAa returns nothing
set ZM[EM]=XAa
set EM=EM+1
call wtv(XIa,"when calling Expression_init in ScmdDataTypes, line 1588")
set rK[XIa]=0
set EM=EM-1
endfunction
function XNa takes string Xba returns integer
local integer XBa
set ZM[EM]=Xba
set EM=EM+1
set XBa=wHv("when calling alloc_Expression in ScmdDataTypes, line 1588")
call XRa(XBa,"when calling construct_Expression in ScmdDataTypes, line 1588")
set EM=EM-1
return XBa
endfunction
function Xca takes integer Uwi returns nothing
endfunction
function XCa takes integer Xda,string XDa returns nothing
set ZM[EM]=XDa
set EM=EM+1
if Dx[Xda]==0 then
call Cdv("Double free: object of type Tokenizer","when calling error in ScmdParser, line 22")
else
set Ix[Px]=Xda
set Px=Px+1
set Dx[Xda]=0
endif
set EM=EM-1
endfunction
function Xfa takes integer XFa,string Xga returns nothing
set ZM[EM]=Xga
set EM=EM+1
call Xca(XFa)
call XCa(XFa,"when calling dealloc_Tokenizer in ScmdParser, line 22")
set EM=EM-1
endfunction
function XGa takes integer Xha,string XHa returns nothing
set ZM[EM]=XHa
set EM=EM+1
if Dx[Xha]==0 then
if Xha==0 then
call Cdv("Nullpointer exception when calling Tokenizer.Tokenizer","when calling error in ScmdParser, line 22")
else
call Cdv("Called Tokenizer.Tokenizer on invalid object.","when calling error in ScmdParser, line 22")
endif
endif
call Xfa(Xha,"when calling destroyTokenizer in ScmdParser, line 22")
set EM=EM-1
endfunction
function Xja takes integer XJa,string Xka,string XKa returns integer
local integer Xla
local integer XLa
local string Xma
local integer XMa
local integer Xpa
local integer XPa
local integer Xqa
local integer XQa
local integer Xsa
local string XSa
local integer Xta
local string XTa
local integer Xua
local string XUa
local integer Xwa
local string XWa
local integer Xya
local string XYa
set ZM[EM]=XKa
set EM=EM+1
set Xla=XVa(Xka,"when calling new_Tokenizer in ScmdParser, line 167")
set Xsa=E4a(Xla,"when calling nextToken in ScmdParser, line 168")
set XSa=H1
set XLa=Xsa
set Xma=XSa
set XMa=yTv("when calling new_LinkedList in ScmdParser, line 169")
set Xpa=yTv("when calling new_LinkedList in ScmdParser, line 170")
set XPa=XNa("when calling new_Expression in ScmdParser, line 171")
loop
exitwhen not true
loop
exitwhen not(XLa==2 or XLa==3)
if XLa==2 then
if nha(XPa,"when calling getCallee in ScmdParser, line 175")==0 then
call nma(XPa,p0v(cne(Xma,"when calling new_Symbol in ScmdParser, line 176"),"when calling new_SharedPointer in ScmdParser, line 176"),"when calling setCallee in ScmdParser, line 176")
else
call gWo(UAo(XPa,"when calling getArgs in ScmdParser, line 178"),p0v(cCo(Xma,nUa(Xla,"when calling getSkipped in ScmdParser, line 178"),"when calling forStrings in ScmdParser, line 178"),"when calling new_SharedPointer in ScmdParser, line 178"),"when calling add in ScmdParser, line 178")
endif
elseif nha(XPa,"when calling getCallee in ScmdParser, line 179")!=0 then
call gWo(UAo(XPa,"when calling getArgs in ScmdParser, line 180"),p0v(cne(Xma,"when calling new_Symbol in ScmdParser, line 180"),"when calling new_SharedPointer in ScmdParser, line 180"),"when calling add in ScmdParser, line 180")
else
call nma(XPa,p0v(cne(Xma,"when calling new_Symbol in ScmdParser, line 182"),"when calling new_SharedPointer in ScmdParser, line 182"),"when calling setCallee in ScmdParser, line 182")
endif
set Xta=E4a(Xla,"when calling nextToken in ScmdParser, line 183")
set XTa=H1
set XLa=Xta
set Xma=XTa
endloop
if XLa==0 then
if nha(XPa,"when calling getCallee in ScmdParser, line 185")!=0 then
loop
exitwhen not(hye(Xpa,"when calling size in ScmdParser, line 186")>0 and nda(Xpa,"when calling peek in ScmdParser, line 186")==7)
set XPa=nqa(XMa,XPa,"when calling pop in ScmdParser, line 187")
call nAa(Xpa,"when calling pop in ScmdParser, line 188")
endloop
endif
if nha(XPa,"when calling getCallee in ScmdParser, line 189")==0 or hye(Xpa,"when calling size in ScmdParser, line 189")!=0 then
set Xua=1
set XUa="No callee"
set XLa=Xua
set Xma=XUa
endif
exitwhen true
elseif XLa==4 or XLa==5 or XLa==7 then
call lIe(XMa,XPa,"when calling push in ScmdParser, line 193")
call lIe(Xpa,XLa,"when calling push in ScmdParser, line 194")
set XPa=XNa("when calling new_Expression in ScmdParser, line 195")
if XLa==4 then
call nma(XPa,MJv(Yd,"when calling clone in ScmdParser, line 197"),"when calling setCallee in ScmdParser, line 197")
endif
elseif XLa==6 then
if nha(XPa,"when calling getCallee in ScmdParser, line 199")!=0 then
loop
exitwhen not(hye(Xpa,"when calling size in ScmdParser, line 200")>0 and nda(Xpa,"when calling peek in ScmdParser, line 200")==7)
set XPa=nqa(XMa,XPa,"when calling pop in ScmdParser, line 201")
call nAa(Xpa,"when calling pop in ScmdParser, line 202")
endloop
endif
if nha(XPa,"when calling getCallee in ScmdParser, line 203")==0 or hye(Xpa,"when calling size in ScmdParser, line 203")==0 then
set Xwa=1
set XWa="Brackets do not match"
set XLa=Xwa
set Xma=XWa
else
call nAa(Xpa,"when calling pop in ScmdParser, line 206")
set XPa=nqa(XMa,XPa,"when calling pop in ScmdParser, line 207")
endif
endif
if XLa==1 then
exitwhen true
endif
set Xya=E4a(Xla,"when calling nextToken in ScmdParser, line 210")
set XYa=H1
set XLa=Xya
set Xma=XYa
endloop
if XLa==1 then
call I4x(XJa,"|cFFcc666eParse error|r: "+Xma,"when calling sendSystemMessage in ScmdParser, line 212")
call mtv(XPa,"when calling dispatch_Expression_destroyExpression in ScmdParser, line 213")
set XPa=0
set Xqa=Xle(XMa,"when calling iterator in ScmdParser, line 215")
loop
exitwhen not Xie(Xqa)
set XQa=E3e(Xqa)
call mtv(XQa,"when calling dispatch_Expression_destroyExpression in ScmdParser, line 216")
endloop
call Xpe(Xqa,"when calling close in ScmdParser, line 215")
endif
call Hcv(Xpa,"when calling dispatch_LinkedList_destroyLinkedList in ScmdParser, line 217")
call Hcv(XMa,"when calling dispatch_LinkedList_destroyLinkedList in ScmdParser, line 218")
call XGa(Xla,"when calling dispatch_Tokenizer_destroyTokenizer in ScmdParser, line 219")
set EM=EM-1
return XPa
endfunction
function Xza takes integer XZa,string X_a,string X0a returns nothing
local integer X1a
set ZM[EM]=X0a
set EM=EM+1
set X1a=Xja(XZa,X_a,"when calling parse in ScmdInterpreter, line 7")
if X1a!=0 then
call nia(X1a,XZa,"when calling startEvaluationChain in ScmdInterpreter, line 9")
call mtv(X1a,"when calling dispatch_Expression_destroyExpression in ScmdInterpreter, line 10")
endif
set EM=EM-1
endfunction
function X2a takes integer X3a returns string
local integer X4a=hM[X3a]
local string X5a=""
loop
exitwhen not(X5a!=GM[X3a]and hM[X3a]<=YM[X3a])
set X5a=Psv(TM[X3a],hM[X3a],hM[X3a]+gM[X3a])
if X5a==GM[X3a]then
set hM[X3a]=hM[X3a]+gM[X3a]
else
set hM[X3a]=hM[X3a]+1
endif
endloop
return Psv(TM[X3a],X4a,hM[X3a]-1)
endfunction
function X6a takes integer X7a,string X8a returns string
local string X9a
set ZM[EM]=X8a
set EM=EM+1
if Wm[X7a]==0 then
if X7a==0 then
call Cdv("Nullpointer exception when calling StringTokenizer.nextToken","when calling error in Utility, line 67")
else
call Cdv("Called StringTokenizer.nextToken on invalid object.","when calling error in Utility, line 67")
endif
endif
set X9a=X2a(X7a)
set EM=EM-1
return X9a
endfunction
function Ova takes string Oea returns integer
local integer Oxa
set ZM[EM]=Oea
set EM=EM+1
if mm==0 then
if Qm<$8000 then
set Qm=Qm+1
set Oxa=Qm
set Wm[Oxa]=4866
else
call Cdv("Out of memory: Could not create StringTokenizer.","when calling error in Utility, line 38")
set Oxa=0
endif
else
set mm=mm-1
set Oxa=vm[mm]
set Wm[Oxa]=4866
endif
set EM=EM-1
return Oxa
endfunction
function Ooa takes integer AaS returns nothing
endfunction
function Ora takes integer Oia,string Oaa,string Ona returns nothing
call Ooa(Oia)
set TM[Oia]=Oaa
set YM[Oia]=GZv(Oaa)
set GM[Oia]=Ona
set gM[Oia]=GZv(Ona)
set hM[Oia]=0
endfunction
function OVa takes string OEa,string OXa,string OOa returns integer
local integer ORa
set ZM[EM]=OOa
set EM=EM+1
set ORa=Ova("when calling alloc_StringTokenizer in Utility, line 46")
call Ora(ORa,OEa,OXa)
set EM=EM-1
return ORa
endfunction
function OIa takes string OAa returns integer
local integer ONa=0
loop
exitwhen not(duv(Nd,ONa)!=OAa)
set ONa=ONa+1
endloop
return ONa
endfunction
function Oba takes string OBa returns integer
local boolean Oca=duv(OBa,0)=="-"
local integer OCa=GZv(OBa)
local integer Oda=0
local integer ODa=1
local integer Ofa
local integer OFa
local integer Oga
local integer OGa
if Oca then
set OFa=1
else
set OFa=0
endif
set Ofa=OFa
set Oga=OCa-1
loop
exitwhen Ofa>Oga
set Oda=Oda+OIa(duv(OBa,Ofa))*ODa
set ODa=ODa*Md
set Ofa=Ofa+1
endloop
if Oca then
set OGa=-Oda
else
set OGa=Oda
endif
return OGa
endfunction
function Oha takes integer OHa,string Oja returns nothing
set ZM[EM]=Oja
set EM=EM+1
if Wm[OHa]==0 then
call Cdv("Double free: object of type StringTokenizer","when calling error in Utility, line 38")
else
set vm[mm]=OHa
set mm=mm+1
set Wm[OHa]=0
endif
set EM=EM-1
endfunction
function OJa takes integer MaS returns nothing
endfunction
function Oka takes integer OKa,string Ola returns nothing
set ZM[EM]=Ola
set EM=EM+1
call OJa(OKa)
call Oha(OKa,"when calling dealloc_StringTokenizer in Utility, line 38")
set EM=EM-1
endfunction
function OLa takes integer Oma,string OMa returns nothing
set ZM[EM]=OMa
set EM=EM+1
if Wm[Oma]==0 then
if Oma==0 then
call Cdv("Nullpointer exception when calling StringTokenizer.StringTokenizer","when calling error in Utility, line 38")
else
call Cdv("Called StringTokenizer.StringTokenizer on invalid object.","when calling error in Utility, line 38")
endif
endif
call Oka(Oma,"when calling destroyStringTokenizer in Utility, line 38")
set EM=EM-1
endfunction
function Opa takes string OPa,string Oqa returns real
local boolean OQa
local integer Osa
local integer OSa
local real Ota
local real OTa
local string Oua
set ZM[EM]=Oqa
set EM=EM+1
set OQa=duv(OPa,0)=="-"
set Oua=OPa
if OQa then
set OSa=1
else
set OSa=0
endif
set Osa=OVa(Tgv(Oua,OSa),".","when calling new_StringTokenizer in SotFRP_LegacyLoad, line 53")
set Ota=DQv(Oba(X6a(Osa,"when calling nextToken in SotFRP_LegacyLoad, line 54")))+DQv(Oba(X6a(Osa,"when calling nextToken in SotFRP_LegacyLoad, line 54")))/1000.
call OLa(Osa,"when calling dispatch_StringTokenizer_destroyStringTokenizer in SotFRP_LegacyLoad, line 55")
set EM=EM-1
if OQa then
set OTa=-Ota
else
set OTa=Ota
endif
return OTa
endfunction
function OUa takes real Owa,real OWa,real Zws returns real
call MoveLocation(wY,Owa,OWa)
return GetLocationZ(wY)
endfunction
function Oya takes hashtable OYa,integer Oza,integer OZa,player O_a returns nothing
call SavePlayerHandle(OYa,Oza,OZa,O_a)
endfunction
function O0a takes player O1a,integer O2a,real O3a,real O4a,real O5a,real O6a,real O7a,integer O8a returns destructable
local destructable O9a=CreateDestructableZ(O2a,O3a,O4a,OUa(O3a,O4a,O5a)+O5a,O6a,O7a,O8a)
local integer Rva=C0v(O9a)
call Oya(Va,Rva,Na,O1a)
call Ake(Va,Rva,Ma,O5a)
call Ake(Va,Rva,wn,O6a)
call Ake(Va,Rva,un,O7a)
call Cxv(Va,Rva,rn,O8a)
set RQv=O9a
set O9a=null
return RQv
endfunction
function Rea takes destructable Rxa,boolean Roa returns nothing
call SetDestructableInvulnerable(Rxa,Roa)
endfunction
function Rra takes string Ria,real Raa,real Rna,player RVa,string REa returns destructable
local integer RXa
local integer ROa
local integer RRa
local real RIa
local real RAa
local real RNa
local real Rba
local real RBa
local integer Rca
local destructable RCa
set ZM[EM]=REa
set EM=EM+1
set RXa=Oba(duv(Ria,0))
set ROa=OVa(Tgv(Ria,1),"&","when calling new_StringTokenizer in SotFRP_LegacyLoad, line 60")
set RRa=Oba(X6a(ROa,"when calling nextToken in SotFRP_LegacyLoad, line 61"))
set RIa=Opa(X6a(ROa,"when calling nextToken in SotFRP_LegacyLoad, line 62"),"when calling decodeReal in SotFRP_LegacyLoad, line 62")+Raa
set RAa=Opa(X6a(ROa,"when calling nextToken in SotFRP_LegacyLoad, line 63"),"when calling decodeReal in SotFRP_LegacyLoad, line 63")+Rna
set RNa=Opa(X6a(ROa,"when calling nextToken in SotFRP_LegacyLoad, line 64"),"when calling decodeReal in SotFRP_LegacyLoad, line 64")
set Rba=Opa(X6a(ROa,"when calling nextToken in SotFRP_LegacyLoad, line 65"),"when calling decodeReal in SotFRP_LegacyLoad, line 65")
set RBa=Opa(X6a(ROa,"when calling nextToken in SotFRP_LegacyLoad, line 66"),"when calling decodeReal in SotFRP_LegacyLoad, line 66")
set Rca=Oba(X6a(ROa,"when calling nextToken in SotFRP_LegacyLoad, line 67"))
call OLa(ROa,"when calling dispatch_StringTokenizer_destroyStringTokenizer in SotFRP_LegacyLoad, line 68")
set RCa=O0a(RVa,RRa,RIa,RAa,RNa,Rba,RBa,Rca)
if RXa==uf then
call Rea(RCa,true)
endif
set EM=EM-1
set RUv=RCa
set RCa=null
return RUv
endfunction
function Rda takes integer RDa returns boolean
return hM[RDa]<=YM[RDa]
endfunction
function Rfa takes integer RFa,string Rga returns boolean
local boolean RGa
set ZM[EM]=Rga
set EM=EM+1
if Wm[RFa]==0 then
if RFa==0 then
call Cdv("Nullpointer exception when calling StringTokenizer.hasMoreTokens","when calling error in Utility, line 64")
else
call Cdv("Called StringTokenizer.hasMoreTokens on invalid object.","when calling error in Utility, line 64")
endif
endif
set RGa=Rda(RFa)
set EM=EM-1
return RGa
endfunction
function Rha takes unit RHa,string Rja,string RJa returns nothing
local integer Rka
local integer RKa
local integer Rla
local integer RLa
local integer Rma
local real RMa
set ZM[EM]=RJa
set EM=EM+1
set Rka=OVa(Tgv(Rja,1),"&","when calling new_StringTokenizer in SotFRP_LegacyLoad, line 157")
set RKa=c6v(b7e(RHa))
set Rla=c6v(bOe(RHa))
set RLa=Ufv(RHa,1)
set Rma=Ufv(RHa,2)
set RMa=bme(RHa)
call SetHeroXP(RHa,Oba(X6a(Rka,"when calling nextToken in SotFRP_LegacyLoad, line 163")),false)
call O8e(RHa,Oba(X6a(Rka,"when calling nextToken in SotFRP_LegacyLoad, line 164")))
call QMe(RHa,Oba(X6a(Rka,"when calling nextToken in SotFRP_LegacyLoad, line 165")))
call LEe(RHa,Oba(X6a(Rka,"when calling nextToken in SotFRP_LegacyLoad, line 166")))
call bVe(RHa,RKa)
call uBv(RHa,Rla)
call N6e(RHa,RLa,1)
call N6e(RHa,Rma,2)
call bKe(RHa,RMa)
call OLa(Rka,"when calling dispatch_StringTokenizer_destroyStringTokenizer in SotFRP_LegacyLoad, line 172")
set EM=EM-1
endfunction
function Rpa takes unit RPa returns real
return GetUnitFlyHeight(RPa)
endfunction
function Rqa takes string RQa,real Rsa,real RSa,player Rta,string RTa returns unit
local integer Rua
local integer RUa
local integer Rwa
local real RWa
local real Rya
local real RYa
local unit Rza
local string RZa
local string R_a
local string R0a
local integer R1a
local real R2a
local string R3a
local integer R4a
set ZM[EM]=RTa
set EM=EM+1
set Rua=Oba(duv(RQa,0))
set RUa=OVa(Tgv(RQa,1),"&","when calling new_StringTokenizer in SotFRP_LegacyLoad, line 79")
set Rwa=Oba(X6a(RUa,"when calling nextToken in SotFRP_LegacyLoad, line 80"))
set RWa=Opa(X6a(RUa,"when calling nextToken in SotFRP_LegacyLoad, line 81"),"when calling decodeReal in SotFRP_LegacyLoad, line 81")+Rsa
set Rya=Opa(X6a(RUa,"when calling nextToken in SotFRP_LegacyLoad, line 82"),"when calling decodeReal in SotFRP_LegacyLoad, line 82")+RSa
set RYa=Opa(X6a(RUa,"when calling nextToken in SotFRP_LegacyLoad, line 83"),"when calling decodeReal in SotFRP_LegacyLoad, line 83")
set Rza=vAe(Rta,Rwa,RWa,Rya,vde(RYa))
set RZa=X6a(RUa,"when calling nextToken in SotFRP_LegacyLoad, line 85")
if RZa!="*" then
call tuv(Rza,tWv(Oba(RZa)))
endif
set R_a=X6a(RUa,"when calling nextToken in SotFRP_LegacyLoad, line 88")
if R_a!="*" then
call NIe(Rza,Opa(R_a,"when calling decodeReal in SotFRP_LegacyLoad, line 90"))
endif
set R0a=X6a(RUa,"when calling nextToken in SotFRP_LegacyLoad, line 91")
if R0a!="*" then
set R1a=OVa(R0a,":","when calling new_StringTokenizer in SotFRP_LegacyLoad, line 93")
call w6v(Rza,Oba(X6a(R1a,"when calling nextToken in SotFRP_LegacyLoad, line 94")),Oba(X6a(R1a,"when calling nextToken in SotFRP_LegacyLoad, line 94")),Oba(X6a(R1a,"when calling nextToken in SotFRP_LegacyLoad, line 94")),Oba(X6a(R1a,"when calling nextToken in SotFRP_LegacyLoad, line 94")))
call OLa(R1a,"when calling dispatch_StringTokenizer_destroyStringTokenizer in SotFRP_LegacyLoad, line 95")
endif
set R2a=Opa(X6a(RUa,"when calling nextToken in SotFRP_LegacyLoad, line 96"),"when calling decodeReal in SotFRP_LegacyLoad, line 96")
if R2a!=Rpa(Rza)then
call Nde(Rza,R2a)
endif
set R3a=X6a(RUa,"when calling nextToken in SotFRP_LegacyLoad, line 99")
if R3a!="*" then
call AWe(Rza,Opa(R3a,"when calling decodeReal in SotFRP_LegacyLoad, line 101"))
endif
call ASe(Rza,Opa(X6a(RUa,"when calling nextToken in SotFRP_LegacyLoad, line 102"),"when calling decodeReal in SotFRP_LegacyLoad, line 102"))
call AMe(Rza,Opa(X6a(RUa,"when calling nextToken in SotFRP_LegacyLoad, line 103"),"when calling decodeReal in SotFRP_LegacyLoad, line 103"))
call bVe(Rza,Oba(X6a(RUa,"when calling nextToken in SotFRP_LegacyLoad, line 104")))
call O0e(Rza,b7e(Rza))
call uBv(Rza,Oba(X6a(RUa,"when calling nextToken in SotFRP_LegacyLoad, line 106")))
call Rqe(Rza,bOe(Rza))
set R4a=Oba(X6a(RUa,"when calling nextToken in SotFRP_LegacyLoad, line 108"))
call N6e(Rza,R4a,1)
call N6e(Rza,R4a,2)
call bKe(Rza,Opa(X6a(RUa,"when calling nextToken in SotFRP_LegacyLoad, line 111"),"when calling decodeReal in SotFRP_LegacyLoad, line 111"))
call OLa(RUa,"when calling dispatch_StringTokenizer_destroyStringTokenizer in SotFRP_LegacyLoad, line 112")
if Rua==sf or Rua==Sf then
call wrv(Rza,Sy)
call wvv(Rza,Sy,true)
else
call Tlv(Rza,Sy)
endif
if Rua==tf or Rua==Sf then
call O3e(Rza)
endif
call Rze(Rza,RWa,Rya)
set EM=EM-1
set Rwv=Rza
set Rza=null
return Rwv
endfunction
function R5a takes unit R6a,string R7a,string R8a returns nothing
local integer R9a
local integer Iva
local string Iea
local integer Ixa
local integer Ioa
local integer Ira
set ZM[EM]=R8a
set EM=EM+1
set R9a=OVa(R7a,"|","when calling new_StringTokenizer in SotFRP_LegacyLoad, line 124")
loop
exitwhen not Rfa(R9a,"when calling hasMoreTokens in SotFRP_LegacyLoad, line 125")
set Iea=X6a(R9a,"when calling nextToken in SotFRP_LegacyLoad, line 127")
set Ixa=Oba(duv(Iea,0))
if Ixa==cf then
set Iva=0
elseif Ixa==of then
set Iva=1
elseif Ixa==Of then
set Iva=2
elseif Ixa==lf then
set Iva=3
elseif Ixa==bf then
set Iva=4
else
set Iva=-1
endif
if Iva==-1 then
set Ira=OVa(Tgv(Iea,1),":","when calling new_StringTokenizer in SotFRP_LegacyLoad, line 143")
set Ioa=Oba(X6a(Ira,"when calling nextToken in SotFRP_LegacyLoad, line 144"))
set Iva=Oba(X6a(Ira,"when calling nextToken in SotFRP_LegacyLoad, line 145"))
call OLa(Ira,"when calling dispatch_StringTokenizer_destroyStringTokenizer in SotFRP_LegacyLoad, line 146")
else
set Ioa=Oba(Tgv(Iea,1))
endif
if Iva==0 then
call TMv(R6a,Iva)
else
call wnv(R6a,Ioa)
call Uuv(R6a,Ioa,Iva)
endif
endloop
call OLa(R9a,"when calling dispatch_StringTokenizer_destroyStringTokenizer in SotFRP_LegacyLoad, line 154")
set EM=EM-1
endfunction
function Iia takes integer Iaa,string Ina,string IVa returns nothing
local real IEa
local real IXa
local integer IOa
local string IRa
local integer IIa
local real IAa
local real INa
set ZM[EM]=IVa
set EM=EM+1
set IAa=zAx(Iaa,"when calling getSelectedOrigin in SotFRP_LegacyLoad, line 193")
set INa=X1
set IEa=IAa
set IXa=INa
set Vd[Iaa]=IEa
set Bd[Iaa]=IXa
set IOa=OVa(Ina,"|","when calling new_StringTokenizer in SotFRP_LegacyLoad, line 196")
loop
exitwhen not Rfa(IOa,"when calling hasMoreTokens in SotFRP_LegacyLoad, line 197")
set IRa=X6a(IOa,"when calling nextToken in SotFRP_LegacyLoad, line 198")
set IIa=Oba(duv(IRa,0))
if IIa==wf or IIa==uf then
call Rra(IRa,Vd[Iaa],Bd[Iaa],sa[Iaa],"when calling decodeDestructable in SotFRP_LegacyLoad, line 201")
elseif IIa==rf or IIa==sf or IIa==Sf or IIa==tf then
set Cd[Iaa]=Rqa(IRa,Vd[Iaa],Bd[Iaa],sa[Iaa],"when calling decodeUnit in SotFRP_LegacyLoad, line 203")
elseif IIa>=cf and IIa<=yf then
call R5a(Cd[Iaa],IRa,"when calling decodeUnitAbilities in SotFRP_LegacyLoad, line 205")
elseif IIa==pf then
call Rha(Cd[Iaa],IRa,"when calling decodeUnitHeroData in SotFRP_LegacyLoad, line 207")
endif
endloop
call OLa(IOa,"when calling dispatch_StringTokenizer_destroyStringTokenizer in SotFRP_LegacyLoad, line 208")
set EM=EM-1
endfunction
function Iba takes integer Zmi,integer IBa,string Ica,string ICa returns nothing
set ZM[EM]=ICa
set EM=EM+1
call Iia(IBa,Ica,"when calling processHandles in SotFRP_LegacyLoad, line 227")
set EM=EM-1
endfunction
function Ida takes string IDa returns integer
local integer Ifa=0
loop
exitwhen not(duv(gn,Ifa)!=IDa)
set Ifa=Ifa+1
endloop
return Ifa
endfunction
function IFa takes string Iga returns integer
local boolean IGa=duv(Iga,0)=="-"
local integer Iha=GZv(Iga)
local integer IHa=0
local integer Ija=1
local integer IJa
local integer Ika
local integer IKa
local integer Ila
if IGa then
set Ika=1
else
set Ika=0
endif
set IJa=Ika
set IKa=Iha-1
loop
exitwhen IJa>IKa
set IHa=IHa+Ida(duv(Iga,IJa))*Ija
set Ija=Ija*hn
set IJa=IJa+1
endloop
if IGa then
set Ila=-IHa
else
set Ila=IHa
endif
return Ila
endfunction
function ILa takes string Ima,string IMa returns real
local boolean Ipa
local integer IPa
local integer Iqa
local real IQa
local real Isa
local string ISa
set ZM[EM]=IMa
set EM=EM+1
set Ipa=duv(Ima,0)=="-"
set ISa=Ima
if Ipa then
set Iqa=1
else
set Iqa=0
endif
set IPa=OVa(Tgv(ISa,Iqa),".","when calling new_StringTokenizer in SaveableHandles, line 414")
set IQa=DQv(IFa(X6a(IPa,"when calling nextToken in SaveableHandles, line 415")))+DQv(IFa(X6a(IPa,"when calling nextToken in SaveableHandles, line 415")))/1000.
call OLa(IPa,"when calling dispatch_StringTokenizer_destroyStringTokenizer in SaveableHandles, line 416")
set EM=EM-1
if Ipa then
set Isa=-IQa
else
set Isa=IQa
endif
return Isa
endfunction
function Ita takes integer ITa,integer Iua returns integer
local integer IUa=ITa
local integer Iwa=0
if IUa<0 then
set IUa=--$80000000+IUa
set Iwa=1
endif
return Iwa*xy[31-Iua]+IUa/xy[Iua]
endfunction
function IWa takes integer Iya returns string
local string IYa=""
local integer Iza=Iya
loop
exitwhen not(Iza!=0)
set IYa=SMv(ModuloInteger(Iza,2))+IYa
set Iza=Ita(Iza,1)
endloop
return IYa
endfunction
function IZa takes integer I_a returns string
set P1=IWa(I_a)
return P1
endfunction
function I0a takes string I1a returns string
return HXe(HXe(HXe(HXe(HXe(HXe(HXe(HXe(I1a,"/v","|"),"/p",":"),"/c","|c"),"/r","|r"),"/n","|n"),"/a","&"),"/b","\\"),"/s","/")
endfunction
function I2a takes string I3a returns boolean
local boolean I4a
if I3a=="1" or I3a=="true" then
set I4a=true
else
set I4a=false
endif
return I4a
endfunction
function I5a takes string I6a,integer I7a returns boolean
local integer I8a=GZv(I6a)
local boolean I9a
if I7a<I8a then
set I9a=I2a(duv(I6a,I8a-I7a-1))
else
set I9a=false
endif
return I9a
endfunction
function Ava takes string Aea returns boolean
return I5a(Aea,0)
endfunction
function Axa takes string Aoa returns boolean
return I5a(Aoa,1)
endfunction
function Ara takes string Aia returns boolean
return I5a(Aia,2)
endfunction
function Aaa takes string Ana,real AVa,real AEa,boolean AXa,string AOa,string ARa returns item
local integer AIa
local string AAa
local integer ANa
local real Aba
local real ABa
local real Aca
local real ACa
local item Ada
local string ADa
set ZM[EM]=ARa
set EM=EM+1
set AIa=OVa(Ana,AOa,"when calling new_StringTokenizer in SaveableHandles, line 776")
set ADa=IZa(IFa(X6a(AIa,"when calling nextToken in SaveableHandles, line 777")))
set AAa=ADa
set ANa=pEe(X6a(AIa,"when calling nextToken in SaveableHandles, line 778"),"when calling fromRawCode in SaveableHandles, line 778")
if AXa then
set ABa=ILa(X6a(AIa,"when calling nextToken in SaveableHandles, line 779"),"when calling decodeReal in SaveableHandles, line 779")+AVa
else
set ABa=.0
endif
set Aba=ABa
if AXa then
set ACa=ILa(X6a(AIa,"when calling nextToken in SaveableHandles, line 780"),"when calling decodeReal in SaveableHandles, line 780")+AEa
else
set ACa=.0
endif
set Aca=ACa
set Ada=CreateItem(ANa,Aba,Aca)
call Ile(Ada,Ava(AAa))
call R9e(Ada,Axa(AAa))
call Iie(Ada,Ara(AAa))
call IJe(Ada,IFa(X6a(AIa,"when calling nextToken in SaveableHandles, line 785")))
call IBe(Ada,ILa(X6a(AIa,"when calling nextToken in SaveableHandles, line 786"),"when calling decodeReal in SaveableHandles, line 786"))
call Ihe(Ada,I0a(X6a(AIa,"when calling nextToken in SaveableHandles, line 787")))
call IOe(Ada,I0a(X6a(AIa,"when calling nextToken in SaveableHandles, line 788")))
call Wpv(Ada,I0a(X6a(AIa,"when calling nextToken in SaveableHandles, line 789")))
call IFe(Ada,I0a(X6a(AIa,"when calling nextToken in SaveableHandles, line 790")))
call IAe(Ada,I0a(X6a(AIa,"when calling nextToken in SaveableHandles, line 791")))
call OLa(AIa,"when calling dispatch_StringTokenizer_destroyStringTokenizer in SaveableHandles, line 792")
set EM=EM-1
set RTv=Ada
set Ada=null
return RTv
endfunction
function Afa takes string AFa,real Aga,real AGa,string Aha returns item
local item AHa
set ZM[EM]=Aha
set EM=EM+1
set AHa=Aaa(AFa,Aga,AGa,true,Fn,"when calling decodeItem in SaveableHandles, line 797")
set EM=EM-1
set Ruv=AHa
set AHa=null
return Ruv
endfunction
function Aja takes integer AJa,string Aka,string AKa returns nothing
local real Ala
local real ALa
local real Ama
local real AMa
set ZM[EM]=AKa
set EM=EM+1
set Ama=zAx(AJa,"when calling getSelectedOrigin in SotFRP_SaveLoad, line 37")
set AMa=X1
set Ala=Ama
set ALa=AMa
set af[AJa]=Ala
set nf[AJa]=ALa
call Afa(Aka,af[AJa],nf[AJa],"when calling decodeItem in SotFRP_SaveLoad, line 40")
set EM=EM-1
endfunction
function Apa takes integer fQi,integer APa,string Aqa,string AQa returns nothing
set ZM[EM]=AQa
set EM=EM+1
call Aja(APa,Aqa,"when calling processItems in SotFRP_SaveLoad, line 123")
set EM=EM-1
endfunction
function Asa takes string ASa returns integer
local integer Ata
set ZM[EM]=ASa
set EM=EM+1
if jG==0 then
if xG<$8000 then
set xG=xG+1
set Ata=xG
set vG[Ata]=$476
else
call Cdv("Out of memory: Could not create CallbackSingle_nullTimer_SotFRP_LegacyLoad.","when calling error in SotFRP_LegacyLoad, line 221")
set Ata=0
endif
else
set jG=jG-1
set Ata=kG[jG]
set vG[Ata]=$476
endif
set EM=EM-1
return Ata
endfunction
function ATa takes integer Aua,string AUa,string Awa returns nothing
local real AWa
local real Aya
local integer AYa
local integer Aza
local integer AZa
local real A_a
local real A0a
set ZM[EM]=Awa
set EM=EM+1
set A_a=zAx(Aua,"when calling getSelectedOrigin in SotFRP_LegacyLoad, line 211")
set A0a=X1
set AWa=A_a
set Aya=A0a
set Vd[Aua]=AWa
set Bd[Aua]=Aya
if AUa=="TlRFMllqRmlPVGN4WkRrd1ptUTRNVFZtT0RnNVptUTFNR0ZqTkdVellUSmhPR1F3WkdNMVlqSTROek0yWTJVd056UTBNV0ZsWmpNNE4yTmtZalUwT1RZNFlUZzJOalp" then
set EM=EM-1
return
endif
if duv(AUa,0)!="t" then
set EM=EM-1
return
endif
set AYa=OVa(Tgv(AUa,1),":","when calling new_StringTokenizer in SotFRP_LegacyLoad, line 218")
loop
exitwhen not Rfa(AYa,"when calling hasMoreTokens in SotFRP_LegacyLoad, line 219")
set Aza=OVa(X6a(AYa,"when calling nextToken in SotFRP_LegacyLoad, line 220"),"&","when calling new_StringTokenizer in SotFRP_LegacyLoad, line 220")
set AZa=Asa("when calling alloc_CallbackSingle_nullTimer_SotFRP_LegacyLoad in SotFRP_LegacyLoad, line 221")
call EUx(AZa)
set nL[AZa]=Aua
set dL[AZa]=Aza
call Lsx(AZa,"when calling nullTimer in SotFRP_LegacyLoad, line 221")
endloop
call OLa(AYa,"when calling dispatch_StringTokenizer_destroyStringTokenizer in SotFRP_LegacyLoad, line 224")
set EM=EM-1
endfunction
function A1a takes integer Dmi,integer A2a,string A3a,string A4a returns nothing
set ZM[EM]=A4a
set EM=EM+1
call ATa(A2a,A3a,"when calling processTerrain in SotFRP_LegacyLoad, line 228")
set EM=EM-1
endfunction
function A5a takes destructable A6a,real A7a returns nothing
call SetDestructableOccluderHeight(A6a,A7a)
endfunction
function A8a takes destructable A9a,real Nva returns nothing
call SetDestructableLife(A9a,Nva)
endfunction
function Nea takes integer Nxa returns string
set Z1=IWa(Nxa)
return Z1
endfunction
function Noa takes destructable Nra,real Nia returns nothing
call SetDestructableMaxLife(Nra,Nia)
endfunction
function Naa takes string Nna returns boolean
return I5a(Nna,0)
endfunction
function NVa takes string NEa,real NXa,real NOa,string NRa returns destructable
local integer NIa
local string NAa
local destructable NNa
local string Nba
set ZM[EM]=NRa
set EM=EM+1
set NIa=OVa(NEa,Fn,"when calling new_StringTokenizer in SaveableHandles, line 485")
set Nba=Nea(IFa(X6a(NIa,"when calling nextToken in SaveableHandles, line 486")))
set NAa=Nba
set NNa=O0a(null,pEe(X6a(NIa,"when calling nextToken in SaveableHandles, line 487"),"when calling fromRawCode in SaveableHandles, line 487"),ILa(X6a(NIa,"when calling nextToken in SaveableHandles, line 487"),"when calling decodeReal in SaveableHandles, line 487")+NXa,ILa(X6a(NIa,"when calling nextToken in SaveableHandles, line 487"),"when calling decodeReal in SaveableHandles, line 487")+NOa,ILa(X6a(NIa,"when calling nextToken in SaveableHandles, line 487"),"when calling decodeReal in SaveableHandles, line 487"),ILa(X6a(NIa,"when calling nextToken in SaveableHandles, line 487"),"when calling decodeReal in SaveableHandles, line 487"),ILa(X6a(NIa,"when calling nextToken in SaveableHandles, line 487"),"when calling decodeReal in SaveableHandles, line 487"),IFa(X6a(NIa,"when calling nextToken in SaveableHandles, line 487")))
call A5a(NNa,ILa(X6a(NIa,"when calling nextToken in SaveableHandles, line 488"),"when calling decodeReal in SaveableHandles, line 488"))
call Noa(NNa,ILa(X6a(NIa,"when calling nextToken in SaveableHandles, line 489"),"when calling decodeReal in SaveableHandles, line 489"))
call A8a(NNa,ILa(X6a(NIa,"when calling nextToken in SaveableHandles, line 490"),"when calling decodeReal in SaveableHandles, line 490"))
call Rea(NNa,Naa(NAa))
call OLa(NIa,"when calling dispatch_StringTokenizer_destroyStringTokenizer in SaveableHandles, line 492")
set EM=EM-1
set Rsv=NNa
set NNa=null
return Rsv
endfunction
function NBa takes integer Nca,string NCa,string Nda returns nothing
local real NDa
local real Nfa
local real NFa
local real Nga
set ZM[EM]=Nda
set EM=EM+1
set NFa=zAx(Nca,"when calling getSelectedOrigin in SotFRP_SaveLoad, line 31")
set Nga=X1
set NDa=NFa
set Nfa=Nga
set af[Nca]=NDa
set nf[Nca]=Nfa
call NVa(NCa,af[Nca],nf[Nca],"when calling decodeDestructable in SotFRP_SaveLoad, line 34")
set EM=EM-1
endfunction
function NGa takes integer eQi,integer Nha,string NHa,string Nja returns nothing
set ZM[EM]=Nja
set EM=EM+1
call NBa(Nha,NHa,"when calling processDestructables in SotFRP_SaveLoad, line 122")
set EM=EM-1
endfunction
function NJa takes string Nka,integer NKa returns boolean
return I5a(Nka,4+NKa)
endfunction
function Nla takes string NLa returns boolean
return I5a(NLa,2)
endfunction
function Nma takes string NMa returns boolean
return I5a(NMa,1)
endfunction
function Npa takes string NPa returns boolean
return I5a(NPa,3)
endfunction
function Nqa takes integer NQa returns string
set I1=IWa(NQa)
return I1
endfunction
function Nsa takes string NSa,string Nta returns item
local item NTa
set ZM[EM]=Nta
set EM=EM+1
set NTa=Aaa(NSa,.0,.0,false,kn,"when calling decodeItem in SaveableHandles, line 801")
set EM=EM-1
set Rtv=NTa
set NTa=null
return Rtv
endfunction
function Nua takes string NUa returns boolean
return I5a(NUa,0)
endfunction
function Nwa takes string NWa,real Nya,real NYa,player Nza,string NZa returns unit
local integer N_a
local string N0a
local integer N1a
local real N2a
local real N3a
local unit N4a
local string N5a
local string N6a
local string N7a
local integer N8a
local string N9a
local string bva
local string bea
local string bxa
local string boa
local integer bra
local integer bia
local string baa
local item bna
local string bVa
local integer bEa
local integer bXa
local integer bOa
local integer bRa
local integer bIa
local integer bAa
local integer bNa
local string bba
local string bBa
local integer bca
local integer bCa
local integer bda
local integer bDa
local integer bfa
local string bFa
local string bga
local string bGa
set ZM[EM]=NZa
set EM=EM+1
set N_a=OVa(NWa,Fn,"when calling new_StringTokenizer in SaveableHandles, line 614")
set bGa=Nqa(IFa(X6a(N_a,"when calling nextToken in SaveableHandles, line 615")))
set N0a=bGa
set N1a=pEe(X6a(N_a,"when calling nextToken in SaveableHandles, line 616"),"when calling fromRawCode in SaveableHandles, line 616")
if Npa(N0a)!=IsHeroUnitId(N1a)then
call OLa(N_a,"when calling dispatch_StringTokenizer_destroyStringTokenizer in SaveableHandles, line 618")
set EM=EM-1
set N4a=null
set bna=null
return null
endif
set N2a=ILa(X6a(N_a,"when calling nextToken in SaveableHandles, line 620"),"when calling decodeReal in SaveableHandles, line 620")+Nya
set N3a=ILa(X6a(N_a,"when calling nextToken in SaveableHandles, line 621"),"when calling decodeReal in SaveableHandles, line 621")+NYa
set N4a=CreateUnit(Nza,N1a,N2a,N3a,ILa(X6a(N_a,"when calling nextToken in SaveableHandles, line 622"),"when calling decodeReal in SaveableHandles, line 622"))
if Nua(N0a)then
call wrv(N4a,Sy)
call wvv(N4a,Sy,true)
endif
if NJa(N0a,0)then
call bFe(N4a,1,false)
elseif NJa(N0a,1)then
call bFe(N4a,1,true)
endif
call bFe(N4a,2,NJa(N0a,2))
set N5a=X6a(N_a,"when calling nextToken in SaveableHandles, line 631")
if N5a!=jn then
call Nde(N4a,1.)
call Nde(N4a,.0)
call Nde(N4a,ILa(N5a,"when calling decodeReal in SaveableHandles, line 635"))
endif
set N6a=X6a(N_a,"when calling nextToken in SaveableHandles, line 636")
if N6a!=jn then
call tuv(N4a,tWv(IFa(N6a)))
endif
set N7a=X6a(N_a,"when calling nextToken in SaveableHandles, line 639")
if N7a!=jn then
set N8a=OVa(N7a,kn,"when calling new_StringTokenizer in SaveableHandles, line 641")
call w6v(N4a,IFa(X6a(N8a,"when calling nextToken in SaveableHandles, line 642")),IFa(X6a(N8a,"when calling nextToken in SaveableHandles, line 642")),IFa(X6a(N8a,"when calling nextToken in SaveableHandles, line 642")),IFa(X6a(N8a,"when calling nextToken in SaveableHandles, line 642")))
call OLa(N8a,"when calling dispatch_StringTokenizer_destroyStringTokenizer in SaveableHandles, line 643")
endif
set N9a=X6a(N_a,"when calling nextToken in SaveableHandles, line 644")
if N9a!=jn then
call NIe(N4a,ILa(N9a,"when calling decodeReal in SaveableHandles, line 646"))
endif
call AMe(N4a,ILa(X6a(N_a,"when calling nextToken in SaveableHandles, line 647"),"when calling decodeReal in SaveableHandles, line 647"))
call ASe(N4a,ILa(X6a(N_a,"when calling nextToken in SaveableHandles, line 648"),"when calling decodeReal in SaveableHandles, line 648"))
set bva=X6a(N_a,"when calling nextToken in SaveableHandles, line 649")
if bva!=jn then
call AWe(N4a,ILa(bva,"when calling decodeReal in SaveableHandles, line 651"))
endif
set bea=X6a(N_a,"when calling nextToken in SaveableHandles, line 652")
if bea!=jn then
call AWe(N4a,ILa(bea,"when calling decodeReal in SaveableHandles, line 654"))
endif
set bxa=X6a(N_a,"when calling nextToken in SaveableHandles, line 655")
if bxa!=null then
call Age(N4a,uiv(ILa(bxa,"when calling decodeReal in SaveableHandles, line 657")))
if Npa(N0a)then
call SetHeroXP(N4a,IFa(X6a(N_a,"when calling nextToken in SaveableHandles, line 659")),false)
call O8e(N4a,IFa(X6a(N_a,"when calling nextToken in SaveableHandles, line 660")))
call QMe(N4a,IFa(X6a(N_a,"when calling nextToken in SaveableHandles, line 661")))
call LEe(N4a,IFa(X6a(N_a,"when calling nextToken in SaveableHandles, line 662")))
endif
set boa=X6a(N_a,"when calling nextToken in SaveableHandles, line 663")
if boa!=null then
call bze(N4a,IFa(boa))
set bra=0
set bia=rde(N4a)-1
loop
exitwhen bra>bia
set baa=X6a(N_a,"when calling nextToken in SaveableHandles, line 667")
if baa!=jn then
set bna=Nsa(baa,"when calling decodeItem in SaveableHandles, line 669")
call A8e(N4a,bna)
call AAe(N4a,bna,bra)
endif
set bra=bra+1
endloop
set bVa=X6a(N_a,"when calling nextToken in SaveableHandles, line 672")
if bVa!=null then
set bEa=0
set bXa=IFa(bVa)-1
loop
exitwhen bEa>bXa
call TMv(N4a,pEe(X6a(N_a,"when calling nextToken in SaveableHandles, line 675"),"when calling fromRawCode in SaveableHandles, line 675"))
set bEa=bEa+1
endloop
set bOa=0
set bRa=IFa(X6a(N_a,"when calling nextToken in SaveableHandles, line 676"))-1
loop
exitwhen bOa>bRa
set bIa=OVa(X6a(N_a,"when calling nextToken in SaveableHandles, line 677"),kn,"when calling new_StringTokenizer in SaveableHandles, line 677")
set bAa=pEe(X6a(bIa,"when calling nextToken in SaveableHandles, line 678"),"when calling fromRawCode in SaveableHandles, line 678")
set bNa=IFa(X6a(bIa,"when calling nextToken in SaveableHandles, line 679"))
call Uuv(N4a,bAa,bNa)
set bba=X6a(bIa,"when calling nextToken in SaveableHandles, line 681")
if bba!=jn then
call BlzSetUnitAbilityManaCost(N4a,bAa,bNa,IFa(bba))
endif
set bBa=X6a(bIa,"when calling nextToken in SaveableHandles, line 684")
if bBa!=jn then
call Ole(N4a,bAa,bNa,ILa(bBa,"when calling decodeReal in SaveableHandles, line 686"))
endif
call OLa(bIa,"when calling dispatch_StringTokenizer_destroyStringTokenizer in SaveableHandles, line 687")
set bOa=bOa+1
endloop
set bca=0
set bCa=IFa(X6a(N_a,"when calling nextToken in SaveableHandles, line 688"))-1
loop
exitwhen bca>bCa
set bda=OVa(X6a(N_a,"when calling nextToken in SaveableHandles, line 689"),kn,"when calling new_StringTokenizer in SaveableHandles, line 689")
set bDa=pEe(X6a(bda,"when calling nextToken in SaveableHandles, line 690"),"when calling fromRawCode in SaveableHandles, line 690")
call wnv(N4a,bDa)
set bfa=IFa(X6a(bda,"when calling nextToken in SaveableHandles, line 692"))
call Uuv(N4a,bDa,bfa)
set bFa=X6a(bda,"when calling nextToken in SaveableHandles, line 694")
if bFa!=jn then
call BlzSetUnitAbilityManaCost(N4a,bDa,bfa,IFa(bFa))
endif
set bga=X6a(bda,"when calling nextToken in SaveableHandles, line 697")
if bga!=jn then
call Ole(N4a,bDa,bfa,ILa(bga,"when calling decodeReal in SaveableHandles, line 699"))
endif
call OLa(bda,"when calling dispatch_StringTokenizer_destroyStringTokenizer in SaveableHandles, line 700")
set bca=bca+1
endloop
call bVe(N4a,IFa(X6a(N_a,"when calling nextToken in SaveableHandles, line 701")))
call X6a(N_a,"when calling nextToken in SaveableHandles, line 702")
call O0e(N4a,ILa(X6a(N_a,"when calling nextToken in SaveableHandles, line 703"),"when calling decodeReal in SaveableHandles, line 703"))
call uBv(N4a,IFa(X6a(N_a,"when calling nextToken in SaveableHandles, line 704")))
call X6a(N_a,"when calling nextToken in SaveableHandles, line 705")
call Rqe(N4a,ILa(X6a(N_a,"when calling nextToken in SaveableHandles, line 706"),"when calling decodeReal in SaveableHandles, line 706"))
call N6e(N4a,IFa(X6a(N_a,"when calling nextToken in SaveableHandles, line 707")),1)
call N2e(N4a,IFa(X6a(N_a,"when calling nextToken in SaveableHandles, line 708")),1)
call tev(N4a,IFa(X6a(N_a,"when calling nextToken in SaveableHandles, line 709")),1)
call tEv(N4a,ILa(X6a(N_a,"when calling nextToken in SaveableHandles, line 710"),"when calling decodeReal in SaveableHandles, line 710"),1)
call N6e(N4a,IFa(X6a(N_a,"when calling nextToken in SaveableHandles, line 711")),2)
call N2e(N4a,IFa(X6a(N_a,"when calling nextToken in SaveableHandles, line 712")),2)
call tev(N4a,IFa(X6a(N_a,"when calling nextToken in SaveableHandles, line 713")),2)
call tEv(N4a,ILa(X6a(N_a,"when calling nextToken in SaveableHandles, line 714"),"when calling decodeReal in SaveableHandles, line 714"),2)
call bKe(N4a,ILa(X6a(N_a,"when calling nextToken in SaveableHandles, line 715"),"when calling decodeReal in SaveableHandles, line 715"))
if Npa(N0a)then
call Rfe(N4a,I0a(X6a(N_a,"when calling nextToken in SaveableHandles, line 717")))
endif
call Nee(N4a,I0a(X6a(N_a,"when calling nextToken in SaveableHandles, line 718")))
endif
endif
endif
call OLa(N_a,"when calling dispatch_StringTokenizer_destroyStringTokenizer in SaveableHandles, line 719")
call NQe(N4a,Nla(N0a))
if Nma(N0a)then
call O3e(N4a)
endif
call Rze(N4a,N2a,N3a)
set EM=EM-1
set RSv=N4a
set N4a=null
set bna=null
return RSv
endfunction
function bha takes integer bHa,string bja,string bJa returns nothing
local real bka
local real bKa
local real bla
local real bLa
set ZM[EM]=bJa
set EM=EM+1
set bla=zAx(bHa,"when calling getSelectedOrigin in SotFRP_SaveLoad, line 25")
set bLa=X1
set bka=bla
set bKa=bLa
set af[bHa]=bka
set nf[bHa]=bKa
call Nwa(bja,af[bHa],nf[bHa],sa[bHa],"when calling decodeUnit in SotFRP_SaveLoad, line 28")
set EM=EM-1
endfunction
function bma takes integer OQi,integer bMa,string bpa,string bPa returns nothing
set ZM[EM]=bPa
set EM=EM+1
call bha(bMa,bpa,"when calling processUnits in SotFRP_SaveLoad, line 121")
set EM=EM-1
endfunction
function bqa takes integer bQa,integer bsa,string bSa,string bta returns nothing
set ZM[EM]=bta
set EM=EM+1
if Lx[bQa]==0 then
if bQa==0 then
call Cdv("Nullpointer exception when calling InputStreamProcessor.call","when calling error in ScmdReader, line 13")
else
call Cdv("Called InputStreamProcessor.call on invalid object.","when calling error in ScmdReader, line 13")
endif
endif
if Lx[bQa]<=$C40 then
if Lx[bQa]<=$C3F then
if Lx[bQa]<=$C3E then
call Iba(bQa,bsa,bSa,"when calling call_registerInputStreamProcessor_SotFRP_LegacyLoad in ScmdReader, line 13")
else
call A1a(bQa,bsa,bSa,"when calling call_registerInputStreamProcessor_SotFRP_LegacyLoad in ScmdReader, line 13")
endif
else
call bma(bQa,bsa,bSa,"when calling call_registerInputStreamProcessor_SotFRP_SaveLoad in ScmdReader, line 13")
endif
elseif Lx[bQa]<=$C41 then
call NGa(bQa,bsa,bSa,"when calling call_registerInputStreamProcessor_SotFRP_SaveLoad in ScmdReader, line 13")
else
call Apa(bQa,bsa,bSa,"when calling call_registerInputStreamProcessor_SotFRP_SaveLoad in ScmdReader, line 13")
endif
set EM=EM-1
endfunction
function bTa takes string bua returns nothing
local string bUa
local integer bwa
local integer bWa
local integer bya
set ZM[EM]=bua
set EM=EM+1
set bUa=GetEventPlayerChatString()
set bwa=GZv(bUa)
set bWa=Hme(GetTriggerPlayer())
if duv(bUa,bwa-1)=="^" then
set Fd[bWa]=Fd[bWa]+Psv(bUa,0,bwa-1)
else
set bUa=Fd[bWa]+bUa
set Fd[bWa]=""
if xd[bWa]!=0 then
if bUa!=hxv(f3v(jd,xd[bWa],"when calling get in ScmdReader, line 30"),"when calling stringFromIndex in ScmdReader, line 30")then
call bqa(xd[bWa],bWa,bUa,"when calling call in ScmdReader, line 31")
else
set xd[bWa]=0
endif
else
set bya=hIv(kd,bUa,"when calling get in ScmdReader, line 35")
if bya==0 then
call Xza(bWa,bUa,"when calling interpret in ScmdReader, line 37")
else
set xd[bWa]=bya
endif
endif
endif
set EM=EM-1
endfunction
function bYa takes nothing returns nothing
set EM=0
call bTa("ScmdReader, line 53")
endfunction
function bza takes nothing returns nothing
local unit bZa=GetSpellAbilityUnit()
call SetUnitAnimation(bZa,"stand")
call UnitRemoveAbility(bZa,'ARal')
call PolledWait(2.8)
call SetUnitAnimation(bZa,"stand")
call PolledWait(.1)
call SetUnitAnimation(bZa,"stand")
call PolledWait(.1)
call SetUnitAnimation(bZa,"stand")
call PolledWait(3.01)
call SetUnitAnimation(bZa,"stand")
set bZa=null
endfunction
function b_a takes nothing returns nothing
local unit b0a=CreateUnitAtLoc(Player(PLAYER_NEUTRAL_PASSIVE),'h0JO',GetUnitLoc(GetSpellAbilityUnit()),GetUnitFacing(GetSpellAbilityUnit()))
call UnitAddAbility(b0a,'A084')
call SetUnitAbilityLevel(b0a,'A084',GetUnitAbilityLevel(GetSpellAbilityUnit(),'A06H'))
call IssuePointOrderByIdLoc(b0a,$D0079,GetSpellTargetLoc())
call TriggerSleepAction(12.)
call RemoveUnit(b0a)
set b0a=null
set b0a=null
endfunction
function b1a takes nothing returns boolean
return(BlzIsUnitInvulnerable(GetFilterUnit())==false and IsUnitType(GetFilterUnit(),UNIT_TYPE_UNDEAD)==false and IsUnitType(GetFilterUnit(),UNIT_TYPE_MECHANICAL)==false and IsUnitType(GetFilterUnit(),UNIT_TYPE_MAGIC_IMMUNE)==false and IsUnitType(GetFilterUnit(),UNIT_TYPE_STRUCTURE)==false)!=null
endfunction
function b2a takes nothing returns nothing
local timer b3a=null
local unit b4a=GetSpellAbilityUnit()
local location b5a=GetSpellTargetLoc()
call DestroyEffect(AddSpecialEffectLoc("Abilities\\Spells\\Other\\Meteor\\Meteor.mdx",b5a))
set b3a=CreateTimer()
call SaveUnitHandle(nr,GetHandleId(b3a),StringHash("u"),b4a)
call SaveLocationHandle(nr,GetHandleId(b3a),StringHash("l"),b5a)
call TimerStart(b3a,.55,false,VPv)
set b3a=CreateTimer()
call SaveUnitHandle(nr,GetHandleId(b3a),StringHash("u"),b4a)
call SaveLocationHandle(nr,GetHandleId(b3a),StringHash("l"),b5a)
call TimerStart(b3a,.875,false,Vqv)
set b5a=null
set b4a=null
set b3a=null
set b3a=null
set b4a=null
set b5a=null
endfunction
function b6a takes nothing returns nothing
set Qw[1]="war3mapImported\\Advanced Rod.mdx"
set Qw[2]="war3mapImported\\Akamas_weapon.mdx"
set Qw[3]="war3mapImported\\Axe.mdx"
set Qw[4]="war3mapImported\\Bandit's_axe.mdx"
set Qw[5]="war3mapImported\\Beastmaster_axe.mdx"
set Qw[6]="war3mapImported\\Blade.mdx"
set Qw[7]="war3mapImported\\Blademaster_sword.mdx"
set Qw[8]="war3mapImported\\Buckler.mdx"
set Qw[9]="war3mapImported\\Chaos_claw.mdx"
set Qw[$A]="war3mapImported\\Chaos_claw.mdx"
set Qw[$B]="war3mapImported\\Doomguard_sword.mdx"
set Qw[$C]="war3mapImported\\FelGuard_weapon.mdx"
set Qw[$D]="war3mapImported\\ForestTroll_weapon.mdx"
set Qw[$E]="war3mapImported\\FurionStaff.mdx"
set Qw[$F]="war3mapImported\\GryphonRider_hammer.mdx"
set Qw[16]="war3mapImported\\Hellscream_axe.mdx"
set Qw[17]="war3mapImported\\Illidian_weapon.mdx"
set Qw[18]="war3mapImported\\IronRaven.mdx"
set Qw[19]="war3mapImported\\IronRaven[half].MDX"
set Qw[20]="war3mapImported\\JainaStaff.mdx"
set Qw[21]="war3mapImported\\Knight_sword.mdx"
set Qw[22]="war3mapImported\\Kobold_hammer.mdx"
set Qw[23]="war3mapImported\\Leonite_Aegis.MDX"
set Qw[24]="war3mapImported\\Magnatur_weapon.mdx"
set Qw[25]="war3mapImported\\Maul.mdx"
set Qw[26]="war3mapImported\\Militia_axe.mdx"
set Qw[27]="war3mapImported\\NE_Shield.MDX"
set Qw[28]="war3mapImported\\Ogre's_clubb.mdx"
set Qw[29]="war3mapImported\\OrcWarlord_clubb.mdx"
set Qw[30]="war3mapImported\\Orc_rampager.MDX"
set Qw[31]="war3mapImported\\Peasant_axe.mdx"
set Qw[32]="war3mapImported\\Pickle.mdx"
set Qw[33]="war3mapImported\\PitLord_wepaon.mdx"
set Qw[34]="war3mapImported\\Proudmoore_sword.mdx"
set Qw[35]="war3mapImported\\RevenantOfTheWaves_Clubb.mdx"
set Qw[36]="war3mapImported\\Satyr_weapon.mdx"
set Qw[37]="war3mapImported\\ShadowHUnter_weapon.mdx"
set Qw[38]="war3mapImported\\Shaman_claw.mdx"
set Qw[39]="war3mapImported\\Sickle.mdx"
set Qw[40]="war3mapImported\\SkeletonOrc_axe.mdx"
set Qw[41]="war3mapImported\\Skeleton_sword.mdx"
set Qw[42]="war3mapImported\\SpellShield.mdx"
set Qw[43]="war3mapImported\\SpiritWalker_axe.mdx"
set Qw[44]="war3mapImported\\Sword.mdx"
set Qw[45]="war3mapImported\\TaurenChieftain_axe.mdx"
set Qw[46]="war3mapImported\\Thunderbolt_hammer.mdx"
set Qw[47]="war3mapImported\\Undead_Tower.MDX"
set Qw[48]="war3mapImported\\Walkingstick.mdx"
set Qw[49]="war3mapImported\\Warlock_weapon.mdx"
set Qw[50]="war3mapImported\\Wolfrider_sword.mdx"
set Qw[51]="war3mapImported\\bloodelf_sword.mdx"
set Qw[52]="war3mapImported\\bloodelfspellthief_sword.mdx"
set Qw[53]="war3mapImported\\bottle.mdx"
set Qw[54]="war3mapImported\\bottle2.mdx"
set Qw[55]="war3mapImported\\centaur_axe.mdx"
set Qw[56]="war3mapImported\\claw.mdx"
set Qw[57]="war3mapImported\\dagger.mdx"
set Qw[58]="war3mapImported\\dragons_weapon.mdx"
set Qw[59]="war3mapImported\\elvenbow.mdx"
set Qw[60]="war3mapImported\\faceless'_clubb.mdx"
set Qw[61]="war3mapImported\\frostmourne.mdx"
set Qw[62]="war3mapImported\\fullhelm.mdx"
set Qw[63]="war3mapImported\\hammer.mdx"
set Qw[64]="war3mapImported\\reversedagger.mdx"
set Qw[65]="war3mapImported\\runeblade.mdx"
set Qw[66]="war3mapImported\\spear.mdx"
set Qw[67]="war3mapImported\\spear2.mdx"
set Qw[68]="war3mapImported\\stonesword.mdx"
set Qw[69]="war3mapImported\\towershield.mdx"
set Qw[70]="war3mapImported\\wand.mdx"
set Qw[71]="war3mapImported\\wizardcone.mdx"
set Qw[72]="war3mapImported\\Pirate Saber.mdx"
set Qw[73]="war3mapImported\\Kitablade.mdx"
set Qw[74]="war3mapImported\\Flintlock Rifle.mdx"
set Qw[75]="war3mapImported\\Longsword.mdx"
set Qw[76]="war3mapImported\\Pistol.MDX"
set Qw[77]="war3mapImported\\Halberd.mdx"
set Qw[78]="war3mapImported\\Quiver.mdx"
set Qw[79]="war3mapImported\\BackPack.mdx"
set Qw[80]="war3mapImported\\BlackWingVR.mdx"
set Qw[81]="war3mapImported\\DragonBlade.mdx"
set Qw[82]="war3mapImported\\PirateHat.MDX"
set Qw[83]="war3mapImported\\sign.mdx"
set Qw[84]="war3mapImported\\HolyShield Seal_Portrait.mdl"
set Qw[85]="Abilities\\Spells\\Undead\\RegenerationAura\\ObsidianRegenAura.mdl"
set Qw[86]="Abilities\\Weapons\\BloodElfSpellThiefMISSILE\\BloodElfSpellThiefMISSILE.mdl"
set Qw[87]="Abilities\\Weapons\\ShadowHunterMissile\\ShadowHunterMissile.mdl"
set Qw[88]="abilities\\Weapons\\FelFireBallMissile\\FelFireBallMissile.mdx"
set Qw[89]="Abilities\\Weapons\\Mortar\\MortarMissile.mdl"
set Qw[90]="war3mapImported\\TwilightSparkle.mdx"
set Qw[91]="war3mapImported\\PrismaticWave.mdx"
set Qw[92]="war3mapImported\\HolyAwakening.mdx"
set Qw[93]="war3mapImported\\EMPBubble.mdx"
call DestroyTrigger(GetTriggeringTrigger())
endfunction
function b7a takes nothing returns nothing
call BlzEndUnitAbilityCooldown(LoadUnitHandle(i,y,GetHandleId(GetExpiredTimer())),'AOex')
call Gmv(GetExpiredTimer())
endfunction
function b8a takes nothing returns nothing
set G=GetUnitLoc(GetEnumUnit())
call SetUnitPositionLoc(GetSoldUnit(),G)
call RemoveLocation(G)
endfunction
function b9a takes nothing returns nothing
set G=GetSpellTargetLoc()
call EnumDestructablesInCircleBJ(256.,G,ofv)
endfunction
function Bva takes nothing returns boolean
return(GetUnitTypeId(GetEnumUnit())!='h000')and(GetUnitTypeId(GetEnumUnit())!='h0KW')and(IsUnitSelected(GetEnumUnit(),GetTriggerPlayer()))
endfunction
function Bea takes nothing returns nothing
if Bva()then
call UnitRemoveTypeBJ(UNIT_TYPE_MECHANICAL,GetEnumUnit())
endif
endfunction
function Bxa takes nothing returns boolean
if GetSpellAbilityId()=='A0JW' then
return true
else
return false
endif
endfunction
function Boa takes nothing returns nothing
call ForGroup(Xs,iwv)
call ForGroup(Yt,iWv)
endfunction
function Bra takes nothing returns nothing
local unit Bia=GetSpellAbilityUnit()
local location Baa=GetSpellTargetLoc()
local effect Bna=AddSpecialEffectLoc("Abilities\\Spells\\Undead\\Darksummoning\\DarkSummonTarget.mdl",GetUnitLoc(Bia))
call PauseUnit(Bia,true)
call SetUnitInvulnerable(Bia,true)
call SetUnitVertexColorBJ(Bia,100.,100.,100.,2.5)
call TriggerSleepAction(.01)
call SetUnitVertexColorBJ(Bia,100.,100.,100.,5.)
call TriggerSleepAction(.01)
call SetUnitVertexColorBJ(Bia,100.,100.,100.,7.5)
call TriggerSleepAction(.01)
call SetUnitVertexColorBJ(Bia,100.,100.,100.,10.)
call TriggerSleepAction(.01)
call SetUnitVertexColorBJ(Bia,100.,100.,100.,12.5)
call TriggerSleepAction(.01)
call SetUnitVertexColorBJ(Bia,100.,100.,100.,15.)
call TriggerSleepAction(.01)
call SetUnitVertexColorBJ(Bia,100.,100.,100.,17.5)
call TriggerSleepAction(.01)
call SetUnitVertexColorBJ(Bia,100.,100.,100.,20.)
call TriggerSleepAction(.01)
call SetUnitVertexColorBJ(Bia,100.,100.,100.,22.5)
call TriggerSleepAction(.01)
call SetUnitVertexColorBJ(Bia,100.,100.,100.,25.)
call TriggerSleepAction(.01)
call SetUnitVertexColorBJ(Bia,100.,100.,100.,27.5)
call TriggerSleepAction(.01)
call SetUnitVertexColorBJ(Bia,100.,100.,100.,30.)
call TriggerSleepAction(.01)
call SetUnitVertexColorBJ(Bia,100.,100.,100.,32.5)
call TriggerSleepAction(.01)
call SetUnitVertexColorBJ(Bia,100.,100.,100.,35.)
call TriggerSleepAction(.01)
call SetUnitVertexColorBJ(Bia,100.,100.,100.,37.5)
call TriggerSleepAction(.01)
call SetUnitVertexColorBJ(Bia,100.,100.,100.,40.)
call TriggerSleepAction(.01)
call SetUnitVertexColorBJ(Bia,100.,100.,100.,42.5)
call TriggerSleepAction(.01)
call SetUnitVertexColorBJ(Bia,100.,100.,100.,45.)
call TriggerSleepAction(.01)
call SetUnitVertexColorBJ(Bia,100.,100.,100.,47.5)
call TriggerSleepAction(.01)
call SetUnitVertexColorBJ(Bia,100.,100.,100.,50.)
call TriggerSleepAction(.01)
call SetUnitVertexColorBJ(Bia,100.,100.,100.,52.5)
call TriggerSleepAction(.01)
call SetUnitVertexColorBJ(Bia,100.,100.,100.,55.)
call TriggerSleepAction(.01)
call SetUnitVertexColorBJ(Bia,100.,100.,100.,57.5)
call TriggerSleepAction(.01)
call SetUnitVertexColorBJ(Bia,100.,100.,100.,60.)
call TriggerSleepAction(.01)
call SetUnitVertexColorBJ(Bia,100.,100.,100.,62.5)
call TriggerSleepAction(.01)
call SetUnitVertexColorBJ(Bia,100.,100.,100.,65.)
call TriggerSleepAction(.01)
call SetUnitVertexColorBJ(Bia,100.,100.,100.,67.5)
call TriggerSleepAction(.01)
call SetUnitVertexColorBJ(Bia,100.,100.,100.,70.)
call TriggerSleepAction(.01)
call SetUnitVertexColorBJ(Bia,100.,100.,100.,72.5)
call TriggerSleepAction(.01)
call SetUnitVertexColorBJ(Bia,100.,100.,100.,75.)
call TriggerSleepAction(.01)
call SetUnitVertexColorBJ(Bia,100.,100.,100.,77.5)
call TriggerSleepAction(.01)
call SetUnitVertexColorBJ(Bia,100.,100.,100.,80.)
call TriggerSleepAction(.01)
call SetUnitVertexColorBJ(Bia,100.,100.,100.,82.5)
call TriggerSleepAction(.01)
call SetUnitVertexColorBJ(Bia,100.,100.,100.,85.)
call TriggerSleepAction(.01)
call SetUnitVertexColorBJ(Bia,100.,100.,100.,87.5)
call TriggerSleepAction(.01)
call SetUnitVertexColorBJ(Bia,100.,100.,100.,90.)
call TriggerSleepAction(.01)
call SetUnitVertexColorBJ(Bia,100.,100.,100.,92.5)
call TriggerSleepAction(.01)
call SetUnitVertexColorBJ(Bia,100.,100.,100.,95.)
call TriggerSleepAction(.01)
call SetUnitVertexColorBJ(Bia,100.,100.,100.,97.5)
call TriggerSleepAction(.01)
call SetUnitVertexColorBJ(Bia,100.,100.,100.,100.)
call TriggerSleepAction(.01)
call SetUnitPositionLoc(Bia,Baa)
set Baa=null
call DestroyEffectBJ(Bna)
set Bna=AddSpecialEffectLocBJ(GetUnitLoc(Bia),"Abilities\\Spells\\Undead\\Darksummoning\\DarkSummonTarget.mdl")
call TriggerSleepAction(.01)
call SetUnitVertexColorBJ(Bia,100.,100.,100.,97.5)
call TriggerSleepAction(.01)
call SetUnitVertexColorBJ(Bia,100.,100.,100.,95.)
call TriggerSleepAction(.01)
call SetUnitVertexColorBJ(Bia,100.,100.,100.,92.5)
call TriggerSleepAction(.01)
call SetUnitVertexColorBJ(Bia,100.,100.,100.,90.)
call TriggerSleepAction(.01)
call SetUnitVertexColorBJ(Bia,100.,100.,100.,87.5)
call TriggerSleepAction(.01)
call SetUnitVertexColorBJ(Bia,100.,100.,100.,85.)
call TriggerSleepAction(.01)
call SetUnitVertexColorBJ(Bia,100.,100.,100.,82.5)
call TriggerSleepAction(.01)
call SetUnitVertexColorBJ(Bia,100.,100.,100.,80.)
call TriggerSleepAction(.01)
call SetUnitVertexColorBJ(Bia,100.,100.,100.,77.5)
call TriggerSleepAction(.01)
call SetUnitVertexColorBJ(Bia,100.,100.,100.,75.)
call TriggerSleepAction(.01)
call SetUnitVertexColorBJ(Bia,100.,100.,100.,72.5)
call TriggerSleepAction(.01)
call SetUnitVertexColorBJ(Bia,100.,100.,100.,70.)
call TriggerSleepAction(.01)
call SetUnitVertexColorBJ(Bia,100.,100.,100.,67.5)
call TriggerSleepAction(.01)
call SetUnitVertexColorBJ(Bia,100.,100.,100.,65.)
call TriggerSleepAction(.01)
call SetUnitVertexColorBJ(Bia,100.,100.,100.,62.5)
call TriggerSleepAction(.01)
call SetUnitVertexColorBJ(Bia,100.,100.,100.,60.)
call TriggerSleepAction(.01)
call SetUnitVertexColorBJ(Bia,100.,100.,100.,57.5)
call TriggerSleepAction(.01)
call SetUnitVertexColorBJ(Bia,100.,100.,100.,55.)
call TriggerSleepAction(.01)
call SetUnitVertexColorBJ(Bia,100.,100.,100.,52.5)
call TriggerSleepAction(.01)
call SetUnitVertexColorBJ(Bia,100.,100.,100.,50.)
call TriggerSleepAction(.01)
call SetUnitVertexColorBJ(Bia,100.,100.,100.,47.5)
call TriggerSleepAction(.01)
call SetUnitVertexColorBJ(Bia,100.,100.,100.,45.)
call TriggerSleepAction(.01)
call SetUnitVertexColorBJ(Bia,100.,100.,100.,42.5)
call TriggerSleepAction(.01)
call SetUnitVertexColorBJ(Bia,100.,100.,100.,40.)
call TriggerSleepAction(.01)
call SetUnitVertexColorBJ(Bia,100.,100.,100.,37.5)
call TriggerSleepAction(.01)
call SetUnitVertexColorBJ(Bia,100.,100.,100.,35.)
call TriggerSleepAction(.01)
call SetUnitVertexColorBJ(Bia,100.,100.,100.,32.5)
call TriggerSleepAction(.01)
call SetUnitVertexColorBJ(Bia,100.,100.,100.,30.)
call TriggerSleepAction(.01)
call SetUnitVertexColorBJ(Bia,100.,100.,100.,27.5)
call TriggerSleepAction(.01)
call SetUnitVertexColorBJ(Bia,100.,100.,100.,25.)
call TriggerSleepAction(.01)
call SetUnitVertexColorBJ(Bia,100.,100.,100.,22.5)
call TriggerSleepAction(.01)
call SetUnitVertexColorBJ(Bia,100.,100.,100.,20.)
call TriggerSleepAction(.01)
call SetUnitVertexColorBJ(Bia,100.,100.,100.,17.5)
call TriggerSleepAction(.01)
call SetUnitVertexColorBJ(Bia,100.,100.,100.,15.)
call TriggerSleepAction(.01)
call SetUnitVertexColorBJ(Bia,100.,100.,100.,12.5)
call TriggerSleepAction(.01)
call SetUnitVertexColorBJ(Bia,100.,100.,100.,10.)
call TriggerSleepAction(.01)
call SetUnitVertexColorBJ(Bia,100.,100.,100.,7.5)
call TriggerSleepAction(.01)
call SetUnitVertexColorBJ(Bia,100.,100.,100.,5.)
call TriggerSleepAction(.01)
call SetUnitVertexColorBJ(Bia,100.,100.,100.,2.5)
call TriggerSleepAction(.01)
call SetUnitVertexColorBJ(Bia,100.,100.,100.,.0)
call TriggerSleepAction(.01)
call SetUnitAnimation(Bia,"stand")
call DestroyEffect(Bna)
call PauseUnit(Bia,false)
call SetUnitInvulnerable(Bia,false)
set Bia=null
set Bna=null
set Bia=null
set Baa=null
set Bna=null
endfunction
function BVa takes nothing returns nothing
local unit BEa
set Ru[GetConvertedPlayerId(GetOwningPlayer(GetSpellAbilityUnit()))]=GetSpellAbilityUnit()
call UnitAddAbilityBJ('A07J',Ru[GetConvertedPlayerId(GetOwningPlayer(GetSpellAbilityUnit()))])
call UnitAddAbilityBJ('A07L',Ru[GetConvertedPlayerId(GetOwningPlayer(GetSpellAbilityUnit()))])
call UnitAddAbilityBJ('A07K',Ru[GetConvertedPlayerId(GetOwningPlayer(GetSpellAbilityUnit()))])
set BEa=Ru[GetConvertedPlayerId(GetOwningPlayer(GetSpellAbilityUnit()))]
call TriggerSleepAction(20.)
set Ru[GetConvertedPlayerId(GetOwningPlayer(GetSpellAbilityUnit()))]=BEa
call UnitRemoveAbilityBJ('A07J',Ru[GetConvertedPlayerId(GetOwningPlayer(GetSpellAbilityUnit()))])
call UnitRemoveAbilityBJ('A07L',Ru[GetConvertedPlayerId(GetOwningPlayer(GetSpellAbilityUnit()))])
call UnitRemoveAbilityBJ('A07K',Ru[GetConvertedPlayerId(GetOwningPlayer(GetSpellAbilityUnit()))])
set BEa=null
set BEa=null
endfunction
function BXa takes nothing returns boolean
return(Ww[GetConvertedPlayerId(GetTriggerPlayer())]<0)
endfunction
function BOa takes nothing returns boolean
return(GetUnitTypeId(GetEnumUnit())!='h000')and(IsUnitSelected(GetEnumUnit(),GetTriggerPlayer()))
endfunction
function BRa takes nothing returns boolean
return(BOa())
endfunction
function BIa takes nothing returns nothing
if BRa()then
if GetTriggerPlayer()==Player(0)then
call DestroyEffectBJ(Ew[Ww[GetConvertedPlayerId(GetTriggerPlayer())]])
endif
if GetTriggerPlayer()==Player(1)then
call DestroyEffectBJ(Zw[Ww[GetConvertedPlayerId(GetTriggerPlayer())]])
endif
if GetTriggerPlayer()==Player(2)then
call DestroyEffectBJ(Kw[Ww[GetConvertedPlayerId(GetTriggerPlayer())]])
endif
if GetTriggerPlayer()==Player(3)then
call DestroyEffectBJ(Jw[Ww[GetConvertedPlayerId(GetTriggerPlayer())]])
endif
if GetTriggerPlayer()==Player(4)then
call DestroyEffectBJ(Hw[Ww[GetConvertedPlayerId(GetTriggerPlayer())]])
endif
if GetTriggerPlayer()==Player(5)then
call DestroyEffectBJ(Dw[Ww[GetConvertedPlayerId(GetTriggerPlayer())]])
endif
if GetTriggerPlayer()==Player(6)then
call DestroyEffectBJ(Aw[Ww[GetConvertedPlayerId(GetTriggerPlayer())]])
endif
if GetTriggerPlayer()==Player(7)then
call DestroyEffectBJ(Pw[Ww[GetConvertedPlayerId(GetTriggerPlayer())]])
endif
if GetTriggerPlayer()==Player(8)then
call DestroyEffectBJ(Iw[Ww[GetConvertedPlayerId(GetTriggerPlayer())]])
endif
if GetTriggerPlayer()==Player(9)then
call DestroyEffectBJ(Uw[Ww[GetConvertedPlayerId(GetTriggerPlayer())]])
endif
if GetTriggerPlayer()==Player($A)then
call DestroyEffectBJ(Xw[Ww[GetConvertedPlayerId(GetTriggerPlayer())]])
endif
if GetTriggerPlayer()==Player($B)then
call DestroyEffectBJ(Lw[Ww[GetConvertedPlayerId(GetTriggerPlayer())]])
endif
set Ww[GetConvertedPlayerId(GetTriggerPlayer())]=Ww[GetConvertedPlayerId(GetTriggerPlayer())]-1
if BXa()then
set Ww[GetConvertedPlayerId(GetTriggerPlayer())]=0
endif
endif
endfunction
function BAa takes nothing returns boolean
set Yy=4096
return true
endfunction
function BNa takes string Bba returns integer
local integer BBa
set ZM[EM]=Bba
set EM=EM+1
if rx==0 then
if sx<$8000 then
set sx=sx+1
set BBa=sx
set tx[BBa]=$C78
else
call Cdv("Out of memory: Could not create IsInstanceChecker_initialize_ScmdDataTypes.","when calling error in ScmdDataTypes, line 414")
set BBa=0
endif
else
set rx=rx-1
set BBa=ux[rx]
set tx[BBa]=$C78
endif
set EM=EM-1
return BBa
endfunction
function Bca takes string BCa returns integer
local integer Bda
set ZM[EM]=BCa
set EM=EM+1
if rx==0 then
if sx<$8000 then
set sx=sx+1
set Bda=sx
set tx[Bda]=$C6C
else
call Cdv("Out of memory: Could not create IsInstanceChecker_initialize_Expression_ScmdDataTypes.","when calling error in ScmdDataTypes, line 1575")
set Bda=0
endif
else
set rx=rx-1
set Bda=ux[rx]
set tx[Bda]=$C6C
endif
set EM=EM-1
return Bda
endfunction
function BDa takes string Bfa returns integer
local integer BFa
set ZM[EM]=Bfa
set EM=EM+1
if rx==0 then
if sx<$8000 then
set sx=sx+1
set BFa=sx
set tx[BFa]=$C75
else
call Cdv("Out of memory: Could not create IsInstanceChecker_initialize_Region_ScmdDataTypes.","when calling error in ScmdDataTypes, line 710")
set BFa=0
endif
else
set rx=rx-1
set BFa=ux[rx]
set tx[BFa]=$C75
endif
set EM=EM-1
return BFa
endfunction
function Bga takes string BGa returns integer
local integer Bha
set ZM[EM]=BGa
set EM=EM+1
if rx==0 then
if sx<$8000 then
set sx=sx+1
set Bha=sx
set tx[Bha]=$C66
else
call Cdv("Out of memory: Could not create IsInstanceChecker_initialize_BuiltinFunction_ScmdDataTypes.","when calling error in ScmdDataTypes, line 1516")
set Bha=0
endif
else
set rx=rx-1
set Bha=ux[rx]
set tx[Bha]=$C66
endif
set EM=EM-1
return Bha
endfunction
function BHa takes string Bja returns integer
local integer BJa
set ZM[EM]=Bja
set EM=EM+1
if rx==0 then
if sx<$8000 then
set sx=sx+1
set BJa=sx
set tx[BJa]=$C7C
else
call Cdv("Out of memory: Could not create IsInstanceChecker_initialize_String_ScmdDataTypes.","when calling error in ScmdDataTypes, line 301")
set BJa=0
endif
else
set rx=rx-1
set BJa=ux[rx]
set tx[BJa]=$C7C
endif
set EM=EM-1
return BJa
endfunction
function Bka takes string BKa returns integer
local integer Bla
set ZM[EM]=BKa
set EM=EM+1
if rx==0 then
if sx<$8000 then
set sx=sx+1
set Bla=sx
set tx[Bla]=$C80
else
call Cdv("Out of memory: Could not create IsInstanceChecker_initialize_Unit_ScmdDataTypes.","when calling error in ScmdDataTypes, line 784")
set Bla=0
endif
else
set rx=rx-1
set Bla=ux[rx]
set tx[Bla]=$C80
endif
set EM=EM-1
return Bla
endfunction
function BLa takes string Bma returns integer
local integer BMa
set ZM[EM]=Bma
set EM=EM+1
if ch==0 then
if oh<$8000 then
set oh=oh+1
set BMa=oh
set Oh[BMa]=$967
else
call Cdv("Out of memory: Could not create HashSet.","when calling error in HashSet, line 5")
set BMa=0
endif
else
set ch=ch-1
set BMa=Sh[ch]
set Oh[BMa]=$967
endif
set EM=EM-1
return BMa
endfunction
function Bpa takes integer fAs returns nothing
endfunction
function BPa takes integer Bqa returns nothing
call Tnv(Bqa)
call Bpa(Bqa)
endfunction
function BQa takes string Bsa returns integer
local integer BSa
set ZM[EM]=Bsa
set EM=EM+1
set BSa=BLa("when calling alloc_HashSet in HashSet, line 4")
call BPa(BSa)
set EM=EM-1
return BSa
endfunction
function Bta takes string BTa returns integer
local integer Bua
set ZM[EM]=BTa
set EM=EM+1
if vx==0 then
if mx<$8000 then
set mx=mx+1
set Bua=mx
set Qx[Bua]=$8E9
else
call Cdv("Out of memory: Could not create TypeToken.","when calling error in ScmdDataTypes, line 23")
set Bua=0
endif
else
set vx=vx-1
set Bua=xx[vx]
set Qx[Bua]=$8E9
endif
set EM=EM-1
return Bua
endfunction
function BUa takes integer p6i returns nothing
endfunction
function Bwa takes integer BWa,string Bya,integer BYa returns nothing
call BUa(BWa)
set WK[BWa]=Bya
set EK[BWa]=BYa
endfunction
function Bza takes string BZa,integer B_a,string B0a returns integer
local integer B1a
set ZM[EM]=B0a
set EM=EM+1
set B1a=Bta("when calling alloc_TypeToken in ScmdDataTypes, line 28")
call Bwa(B1a,BZa,B_a)
set EM=EM-1
return B1a
endfunction
function B2a takes string B3a,integer B4a,string B5a returns integer
local integer B6a
set ZM[EM]=B5a
set EM=EM+1
set B6a=Bza(B3a,B4a,"when calling new_TypeToken in ScmdDataTypes, line 33")
set EM=EM-1
return B6a
endfunction
function B7a takes string B8a returns integer
local integer B9a
set ZM[EM]=B8a
set EM=EM+1
if rx==0 then
if sx<$8000 then
set sx=sx+1
set B9a=sx
set tx[B9a]=$C6B
else
call Cdv("Out of memory: Could not create IsInstanceChecker_initialize_Exception_ScmdDataTypes.","when calling error in ScmdDataTypes, line 185")
set B9a=0
endif
else
set rx=rx-1
set B9a=ux[rx]
set tx[B9a]=$C6B
endif
set EM=EM-1
return B9a
endfunction
function cva takes string cea returns integer
local integer cxa
set ZM[EM]=cea
set EM=EM+1
if rx==0 then
if sx<$8000 then
set sx=sx+1
set cxa=sx
set tx[cxa]=$C70
else
call Cdv("Out of memory: Could not create IsInstanceChecker_initialize_Integer_ScmdDataTypes.","when calling error in ScmdDataTypes, line 478")
set cxa=0
endif
else
set rx=rx-1
set cxa=ux[rx]
set tx[cxa]=$C70
endif
set EM=EM-1
return cxa
endfunction
function coa takes string cra returns integer
local integer cia
set ZM[EM]=cra
set EM=EM+1
if rx==0 then
if sx<$8000 then
set sx=sx+1
set cia=sx
set tx[cia]=$C74
else
call Cdv("Out of memory: Could not create IsInstanceChecker_initialize_Rect_ScmdDataTypes.","when calling error in ScmdDataTypes, line 680")
set cia=0
endif
else
set rx=rx-1
set cia=ux[rx]
set tx[cia]=$C74
endif
set EM=EM-1
return cia
endfunction
function caa takes string cna returns integer
local integer cVa
set ZM[EM]=cna
set EM=EM+1
if rx==0 then
if sx<$8000 then
set sx=sx+1
set cVa=sx
set tx[cVa]=$C77
else
call Cdv("Out of memory: Could not create IsInstanceChecker_initialize_ScmdDataTypes.","when calling error in ScmdDataTypes, line 50")
set cVa=0
endif
else
set rx=rx-1
set cVa=ux[rx]
set tx[cVa]=$C77
endif
set EM=EM-1
return cVa
endfunction
function cEa takes string cXa returns integer
local integer cOa
set ZM[EM]=cXa
set EM=EM+1
if rx==0 then
if sx<$8000 then
set sx=sx+1
set cOa=sx
set tx[cOa]=$C81
else
call Cdv("Out of memory: Could not create IsInstanceChecker_initialize_Vector_ScmdDataTypes.","when calling error in ScmdDataTypes, line 1054")
set cOa=0
endif
else
set rx=rx-1
set cOa=ux[rx]
set tx[cOa]=$C81
endif
set EM=EM-1
return cOa
endfunction
function cRa takes string cIa returns integer
local integer cAa
set ZM[EM]=cIa
set EM=EM+1
if rx==0 then
if sx<$8000 then
set sx=sx+1
set cAa=sx
set tx[cAa]=$C79
else
call Cdv("Out of memory: Could not create IsInstanceChecker_initialize_ScmdDataTypes.","when calling error in ScmdDataTypes, line 1286")
set cAa=0
endif
else
set rx=rx-1
set cAa=ux[rx]
set tx[cAa]=$C79
endif
set EM=EM-1
return cAa
endfunction
function cNa takes string cba returns integer
local integer cBa
set ZM[EM]=cba
set EM=EM+1
if rx==0 then
if sx<$8000 then
set sx=sx+1
set cBa=sx
set tx[cBa]=$C67
else
call Cdv("Out of memory: Could not create IsInstanceChecker_initialize_BuiltinSpecialForm_ScmdDataTypes.","when calling error in ScmdDataTypes, line 1540")
set cBa=0
endif
else
set rx=rx-1
set cBa=ux[rx]
set tx[cBa]=$C67
endif
set EM=EM-1
return cBa
endfunction
function cca takes string cCa returns nothing
local integer cda
local integer cDa
set ZM[EM]=cCa
set EM=EM+1
set cda=0
set cDa=bj_MAX_PLAYER_SLOTS-1
loop
exitwhen cda>cDa
set Od[cda]=g1v("when calling new_StringHashMap in ScmdDataTypes, line 251")
set cda=cda+1
endloop
set EM=EM-1
endfunction
function cfa takes string cFa returns integer
local integer cga
set ZM[EM]=cFa
set EM=EM+1
if rx==0 then
if sx<$8000 then
set sx=sx+1
set cga=sx
set tx[cga]=$C6E
else
call Cdv("Out of memory: Could not create IsInstanceChecker_initialize_Group_ScmdDataTypes.","when calling error in ScmdDataTypes, line 732")
set cga=0
endif
else
set rx=rx-1
set cga=ux[rx]
set tx[cga]=$C6E
endif
set EM=EM-1
return cga
endfunction
function cGa takes string cha returns integer
local integer cHa
set ZM[EM]=cha
set EM=EM+1
if rx==0 then
if sx<$8000 then
set sx=sx+1
set cHa=sx
set tx[cHa]=$C73
else
call Cdv("Out of memory: Could not create IsInstanceChecker_initialize_Real_ScmdDataTypes.","when calling error in ScmdDataTypes, line 423")
set cHa=0
endif
else
set rx=rx-1
set cHa=ux[rx]
set tx[cHa]=$C73
endif
set EM=EM-1
return cHa
endfunction
function cja takes string cJa returns integer
local integer cka
set ZM[EM]=cJa
set EM=EM+1
if rx==0 then
if sx<$8000 then
set sx=sx+1
set cka=sx
set tx[cka]=$C7A
else
call Cdv("Out of memory: Could not create IsInstanceChecker_initialize_Sound_ScmdDataTypes.","when calling error in ScmdDataTypes, line 651")
set cka=0
endif
else
set rx=rx-1
set cka=ux[rx]
set tx[cka]=$C7A
endif
set EM=EM-1
return cka
endfunction
function cKa takes string cla returns integer
local integer cLa
set ZM[EM]=cla
set EM=EM+1
if rx==0 then
if sx<$8000 then
set sx=sx+1
set cLa=sx
set tx[cLa]=$C83
else
call Cdv("Out of memory: Could not create IsInstanceChecker_initialize_Widget_ScmdDataTypes.","when calling error in ScmdDataTypes, line 762")
set cLa=0
endif
else
set rx=rx-1
set cLa=ux[rx]
set tx[cLa]=$C83
endif
set EM=EM-1
return cLa
endfunction
function cma takes string cMa returns integer
local integer cpa
set ZM[EM]=cMa
set EM=EM+1
if rx==0 then
if sx<$8000 then
set sx=sx+1
set cpa=sx
set tx[cpa]=$C68
else
call Cdv("Out of memory: Could not create IsInstanceChecker_initialize_CameraSetup_ScmdDataTypes.","when calling error in ScmdDataTypes, line 856")
set cpa=0
endif
else
set rx=rx-1
set cpa=ux[rx]
set tx[cpa]=$C68
endif
set EM=EM-1
return cpa
endfunction
function cPa takes string cqa returns integer
local integer cQa
set ZM[EM]=cqa
set EM=EM+1
if rx==0 then
if sx<$8000 then
set sx=sx+1
set cQa=sx
set tx[cQa]=$C65
else
call Cdv("Out of memory: Could not create IsInstanceChecker_initialize_Boolean_ScmdDataTypes.","when calling error in ScmdDataTypes, line 354")
set cQa=0
endif
else
set rx=rx-1
set cQa=ux[rx]
set tx[cQa]=$C65
endif
set EM=EM-1
return cQa
endfunction
function csa takes string cSa returns integer
local integer cta
set ZM[EM]=cSa
set EM=EM+1
if rx==0 then
if sx<$8000 then
set sx=sx+1
set cta=sx
set tx[cta]=$C7B
else
call Cdv("Out of memory: Could not create IsInstanceChecker_initialize_SpecialEffect_ScmdDataTypes.","when calling error in ScmdDataTypes, line 594")
set cta=0
endif
else
set rx=rx-1
set cta=ux[rx]
set tx[cta]=$C7B
endif
set EM=EM-1
return cta
endfunction
function cTa takes string cua returns integer
local integer cUa
set ZM[EM]=cua
set EM=EM+1
if rx==0 then
if sx<$8000 then
set sx=sx+1
set cUa=sx
set tx[cUa]=$C7F
else
call Cdv("Out of memory: Could not create IsInstanceChecker_initialize_Undefined_ScmdDataTypes.","when calling error in ScmdDataTypes, line 72")
set cUa=0
endif
else
set rx=rx-1
set cUa=ux[rx]
set tx[cUa]=$C7F
endif
set EM=EM-1
return cUa
endfunction
function cwa takes string cWa returns integer
local integer cya
set ZM[EM]=cWa
set EM=EM+1
if rx==0 then
if sx<$8000 then
set sx=sx+1
set cya=sx
set tx[cya]=$C6A
else
call Cdv("Out of memory: Could not create IsInstanceChecker_initialize_Destructable_ScmdDataTypes.","when calling error in ScmdDataTypes, line 834")
set cya=0
endif
else
set rx=rx-1
set cya=ux[rx]
set tx[cya]=$C6A
endif
set EM=EM-1
return cya
endfunction
function cYa takes string cza returns integer
local integer cZa
set ZM[EM]=cza
set EM=EM+1
if rx==0 then
if sx<$8000 then
set sx=sx+1
set cZa=sx
set tx[cZa]=$C6F
else
call Cdv("Out of memory: Could not create IsInstanceChecker_initialize_Handle_ScmdDataTypes.","when calling error in ScmdDataTypes, line 557")
set cZa=0
endif
else
set rx=rx-1
set cZa=ux[rx]
set tx[cZa]=$C6F
endif
set EM=EM-1
return cZa
endfunction
function c_a takes string c0a returns integer
local integer c1a
set ZM[EM]=c0a
set EM=EM+1
if rx==0 then
if sx<$8000 then
set sx=sx+1
set c1a=sx
set tx[c1a]=$C72
else
call Cdv("Out of memory: Could not create IsInstanceChecker_initialize_Null_ScmdDataTypes.","when calling error in ScmdDataTypes, line 87")
set c1a=0
endif
else
set rx=rx-1
set c1a=ux[rx]
set tx[c1a]=$C72
endif
set EM=EM-1
return c1a
endfunction
function c2a takes string c3a returns integer
local integer c4a
set ZM[EM]=c3a
set EM=EM+1
if rx==0 then
if sx<$8000 then
set sx=sx+1
set c4a=sx
set tx[c4a]=$C69
else
call Cdv("Out of memory: Could not create IsInstanceChecker_initialize_ClassCastException_ScmdDataTypes.","when calling error in ScmdDataTypes, line 218")
set c4a=0
endif
else
set rx=rx-1
set c4a=ux[rx]
set tx[c4a]=$C69
endif
set EM=EM-1
return c4a
endfunction
function c5a takes string c6a returns integer
local integer c7a
set ZM[EM]=c6a
set EM=EM+1
if rx==0 then
if sx<$8000 then
set sx=sx+1
set c7a=sx
set tx[c7a]=$C7E
else
call Cdv("Out of memory: Could not create IsInstanceChecker_initialize_Trigger_ScmdDataTypes.","when calling error in ScmdDataTypes, line 895")
set c7a=0
endif
else
set rx=rx-1
set c7a=ux[rx]
set tx[c7a]=$C7E
endif
set EM=EM-1
return c7a
endfunction
function c8a takes string c9a returns integer
local integer Cva
set ZM[EM]=c9a
set EM=EM+1
if rx==0 then
if sx<$8000 then
set sx=sx+1
set Cva=sx
set tx[Cva]=$C76
else
call Cdv("Out of memory: Could not create IsInstanceChecker_initialize_RuntimeFunction_ScmdDataTypes.","when calling error in ScmdDataTypes, line 1320")
set Cva=0
endif
else
set rx=rx-1
set Cva=ux[rx]
set tx[Cva]=$C76
endif
set EM=EM-1
return Cva
endfunction
function Cea takes string Cxa returns integer
local integer Coa
set ZM[EM]=Cxa
set EM=EM+1
if rx==0 then
if sx<$8000 then
set sx=sx+1
set Coa=sx
set tx[Coa]=$C64
else
call Cdv("Out of memory: Could not create IsInstanceChecker_initialize_Agent_ScmdDataTypes.","when calling error in ScmdDataTypes, line 578")
set Coa=0
endif
else
set rx=rx-1
set Coa=ux[rx]
set tx[Coa]=$C64
endif
set EM=EM-1
return Coa
endfunction
function Cra takes string Cia returns integer
local integer Caa
set ZM[EM]=Cia
set EM=EM+1
if rx==0 then
if sx<$8000 then
set sx=sx+1
set Caa=sx
set tx[Caa]=$C7D
else
call Cdv("Out of memory: Could not create IsInstanceChecker_initialize_Symbol_ScmdDataTypes.","when calling error in ScmdDataTypes, line 244")
set Caa=0
endif
else
set rx=rx-1
set Caa=ux[rx]
set tx[Caa]=$C7D
endif
set EM=EM-1
return Caa
endfunction
function Cna takes string CVa returns integer
local integer CEa
set ZM[EM]=CVa
set EM=EM+1
if rx==0 then
if sx<$8000 then
set sx=sx+1
set CEa=sx
set tx[CEa]=$C82
else
call Cdv("Out of memory: Could not create IsInstanceChecker_initialize_WeatherEffect_ScmdDataTypes.","when calling error in ScmdDataTypes, line 627")
set CEa=0
endif
else
set rx=rx-1
set CEa=ux[rx]
set tx[CEa]=$C82
endif
set EM=EM-1
return CEa
endfunction
function CXa takes string COa returns integer
local integer CRa
set ZM[EM]=COa
set EM=EM+1
if rx==0 then
if sx<$8000 then
set sx=sx+1
set CRa=sx
set tx[CRa]=$C6D
else
call Cdv("Out of memory: Could not create IsInstanceChecker_initialize_Function_ScmdDataTypes.","when calling error in ScmdDataTypes, line 1302")
set CRa=0
endif
else
set rx=rx-1
set CRa=ux[rx]
set tx[CRa]=$C6D
endif
set EM=EM-1
return CRa
endfunction
function CIa takes string CAa returns integer
local integer CNa
set ZM[EM]=CAa
set EM=EM+1
if rx==0 then
if sx<$8000 then
set sx=sx+1
set CNa=sx
set tx[CNa]=$C71
else
call Cdv("Out of memory: Could not create IsInstanceChecker_initialize_Item_ScmdDataTypes.","when calling error in ScmdDataTypes, line 809")
set CNa=0
endif
else
set rx=rx-1
set CNa=ux[rx]
set tx[CNa]=$C71
endif
set EM=EM-1
return CNa
endfunction
function Cba takes string CBa returns boolean
local integer Cca
local integer CCa
local integer Cda
local integer CDa
local integer Cfa
local integer CFa
local integer Cga
local integer CGa
local integer Cha
local integer CHa
local integer Cja
local integer CJa
local integer Cka
local integer CKa
local integer Cla
local integer CLa
local integer Cma
local integer CMa
local integer Cpa
local integer CPa
local integer Cqa
local integer CQa
local integer Csa
local integer CSa
local integer Cta
local integer CTa
local integer Cua
local integer CUa
local integer Cwa
local integer CWa
local integer Cya
local integer CYa
set ZM[EM]=CBa
set EM=EM+1
set Cca=caa("when calling alloc_IsInstanceChecker_initialize_ScmdDataTypes in ScmdDataTypes, line 50")
set xn=B2a("Object",Cca,"when calling initialize in ScmdDataTypes, line 50")
set CCa=cTa("when calling alloc_IsInstanceChecker_initialize_Undefined_ScmdDataTypes in ScmdDataTypes, line 72")
set nd=B2a("Undefined",CCa,"when calling initialize in ScmdDataTypes, line 72")
set Cda=c_a("when calling alloc_IsInstanceChecker_initialize_Null_ScmdDataTypes in ScmdDataTypes, line 87")
set wd=B2a("Null",Cda,"when calling initialize in ScmdDataTypes, line 87")
set Cn=p0v(dpe("when calling new_Null in ScmdDataTypes, line 118"),"when calling new_SharedPointer in ScmdDataTypes, line 118")
set CDa=B7a("when calling alloc_IsInstanceChecker_initialize_Exception_ScmdDataTypes in ScmdDataTypes, line 185")
set Jn=B2a("Exception",CDa,"when calling initialize in ScmdDataTypes, line 185")
set Cfa=c2a("when calling alloc_IsInstanceChecker_initialize_ClassCastException_ScmdDataTypes in ScmdDataTypes, line 218")
call B2a("ClassCastException",Cfa,"when calling initialize in ScmdDataTypes, line 218")
set CFa=Cra("when calling alloc_IsInstanceChecker_initialize_Symbol_ScmdDataTypes in ScmdDataTypes, line 244")
set od=B2a("Symbol",CFa,"when calling initialize in ScmdDataTypes, line 244")
call cca("when calling onInit in ScmdDataTypes, line 293")
set Cga=BHa("when calling alloc_IsInstanceChecker_initialize_String_ScmdDataTypes in ScmdDataTypes, line 301")
set cd=B2a("String",Cga,"when calling initialize in ScmdDataTypes, line 301")
set CGa=cPa("when calling alloc_IsInstanceChecker_initialize_Boolean_ScmdDataTypes in ScmdDataTypes, line 354")
set Zn=B2a("Boolean",CGa,"when calling initialize in ScmdDataTypes, line 354")
set Cha=BNa("when calling alloc_IsInstanceChecker_initialize_ScmdDataTypes in ScmdDataTypes, line 414")
set vn=B2a("Number",Cha,"when calling initialize in ScmdDataTypes, line 414")
set CHa=cGa("when calling alloc_IsInstanceChecker_initialize_Real_ScmdDataTypes in ScmdDataTypes, line 423")
set ud=B2a("Real",CHa,"when calling initialize in ScmdDataTypes, line 423")
set Cja=cva("when calling alloc_IsInstanceChecker_initialize_Integer_ScmdDataTypes in ScmdDataTypes, line 478")
set Nn=B2a("Integer",Cja,"when calling initialize in ScmdDataTypes, line 478")
set CJa=cYa("when calling alloc_IsInstanceChecker_initialize_Handle_ScmdDataTypes in ScmdDataTypes, line 557")
set Bn=B2a("Handle",CJa,"when calling initialize in ScmdDataTypes, line 557")
set Cka=Cea("when calling alloc_IsInstanceChecker_initialize_Agent_ScmdDataTypes in ScmdDataTypes, line 578")
set En=B2a("Agent",Cka,"when calling initialize in ScmdDataTypes, line 578")
set CKa=csa("when calling alloc_IsInstanceChecker_initialize_SpecialEffect_ScmdDataTypes in ScmdDataTypes, line 594")
set Sd=B2a("SpecialEffect",CKa,"when calling initialize in ScmdDataTypes, line 594")
set Cla=Cna("when calling alloc_IsInstanceChecker_initialize_WeatherEffect_ScmdDataTypes in ScmdDataTypes, line 627")
set Rd=B2a("WeatherEffect",Cla,"when calling initialize in ScmdDataTypes, line 627")
set CLa=cja("when calling alloc_IsInstanceChecker_initialize_Sound_ScmdDataTypes in ScmdDataTypes, line 651")
set id=B2a("Sound",CLa,"when calling initialize in ScmdDataTypes, line 651")
set Cma=coa("when calling alloc_IsInstanceChecker_initialize_Rect_ScmdDataTypes in ScmdDataTypes, line 680")
set rd=B2a("Rect",Cma,"when calling initialize in ScmdDataTypes, line 680")
set CMa=BDa("when calling alloc_IsInstanceChecker_initialize_Region_ScmdDataTypes in ScmdDataTypes, line 710")
set sd=B2a("Region",CMa,"when calling initialize in ScmdDataTypes, line 710")
set Cpa=cfa("when calling alloc_IsInstanceChecker_initialize_Group_ScmdDataTypes in ScmdDataTypes, line 732")
set Vn=B2a("Group",Cpa,"when calling initialize in ScmdDataTypes, line 732")
set CPa=cKa("when calling alloc_IsInstanceChecker_initialize_Widget_ScmdDataTypes in ScmdDataTypes, line 762")
set Td=B2a("Widget",CPa,"when calling initialize in ScmdDataTypes, line 762")
set Cqa=Bka("when calling alloc_IsInstanceChecker_initialize_Unit_ScmdDataTypes in ScmdDataTypes, line 784")
set dd=B2a("Unit",Cqa,"when calling initialize in ScmdDataTypes, line 784")
set CQa=CIa("when calling alloc_IsInstanceChecker_initialize_Item_ScmdDataTypes in ScmdDataTypes, line 809")
set Mn=B2a("Item",CQa,"when calling initialize in ScmdDataTypes, line 809")
set Csa=cwa("when calling alloc_IsInstanceChecker_initialize_Destructable_ScmdDataTypes in ScmdDataTypes, line 834")
set Hn=B2a("Destructable",Csa,"when calling initialize in ScmdDataTypes, line 834")
set CSa=cma("when calling alloc_IsInstanceChecker_initialize_CameraSetup_ScmdDataTypes in ScmdDataTypes, line 856")
set Pn=B2a("CameraSetup",CSa,"when calling initialize in ScmdDataTypes, line 856")
set Dn=0
set Cta=c5a("when calling alloc_IsInstanceChecker_initialize_Trigger_ScmdDataTypes in ScmdDataTypes, line 895")
set ld=B2a("Trigger",Cta,"when calling initialize in ScmdDataTypes, line 895")
set bd=InitHashtable()
set yd=InitHashtable()
set pd=InitHashtable()
set ed=a6x("when calling new_Table in ScmdDataTypes, line 909")
set qd=Condition(O0v)
set ad=O1v
set CTa=cEa("when calling alloc_IsInstanceChecker_initialize_Vector_ScmdDataTypes in ScmdDataTypes, line 1054")
set fd=B2a("Vector",CTa,"when calling initialize in ScmdDataTypes, line 1054")
set Cua=cRa("when calling alloc_IsInstanceChecker_initialize_ScmdDataTypes in ScmdDataTypes, line 1286")
set mn=B2a("Callable",Cua,"when calling initialize in ScmdDataTypes, line 1286")
set CUa=CXa("when calling alloc_IsInstanceChecker_initialize_Function_ScmdDataTypes in ScmdDataTypes, line 1302")
call B2a("Function",CUa,"when calling initialize in ScmdDataTypes, line 1302")
set Cwa=c8a("when calling alloc_IsInstanceChecker_initialize_RuntimeFunction_ScmdDataTypes in ScmdDataTypes, line 1320")
set td=B2a("RuntimeFunction",Cwa,"when calling initialize in ScmdDataTypes, line 1320")
set CWa=Bga("when calling alloc_IsInstanceChecker_initialize_BuiltinFunction_ScmdDataTypes in ScmdDataTypes, line 1516")
set Un=B2a("BuiltinFunction",CWa,"when calling initialize in ScmdDataTypes, line 1516")
set Cya=cNa("when calling alloc_IsInstanceChecker_initialize_BuiltinSpecialForm_ScmdDataTypes in ScmdDataTypes, line 1540")
set In=B2a("BuiltinSpecialForm",Cya,"when calling initialize in ScmdDataTypes, line 1540")
set Wn=0
set CYa=Bca("when calling alloc_IsInstanceChecker_initialize_Expression_ScmdDataTypes in ScmdDataTypes, line 1575")
set Kn=B2a("Expression",CYa,"when calling initialize in ScmdDataTypes, line 1575")
set Ln=BQa("when calling new_HashSet in ScmdDataTypes, line 1613")
set EM=EM-1
return true
endfunction
function Cza takes nothing returns boolean
set EM=0
return Cba("ScmdDataTypes, line 1")
endfunction
function CZa takes nothing returns nothing
local timer C_a=GetExpiredTimer()
local effect C0a=LoadEffectHandle(c,GetHandleId(C_a),O)
call FlushChildHashtable(c,GetHandleId(C_a))
call DestroyTimer(C_a)
set C_a=null
call DestroyEffect(C0a)
set C0a=null
set C_a=null
set C0a=null
endfunction
function C1a takes nothing returns nothing
set Ju[8]=GetUnitLoc(GetEnumUnit())
call CreateNUnitsAtLoc(1,'h0LE',GetOwningPlayer(Nu),Ju[8],bj_UNIT_FACING)
call UnitAddAbilityBJ('A06N',GetLastCreatedUnit())
call SetUnitAbilityLevelSwapped('A06N',GetLastCreatedUnit(),Mu)
call IssueTargetOrderBJ(GetLastCreatedUnit(),"thunderbolt",GetEnumUnit())
call GroupAddUnitSimple(GetLastCreatedUnit(),Ku)
call SaveIntegerBJ(Du+2,0,GetHandleIdBJ(GetLastCreatedUnit()),Au)
call RemoveLocation(Ju[8])
endfunction
function C2a takes string C3a returns boolean
local integer C4a
local boolean C5a
local integer C6a
local integer C7a
local integer C8a
local integer C9a
local boolean dva
local integer dea
local boolean dxa
set ZM[EM]=C3a
set EM=EM+1
set C4a=C0v(GetTriggeringTrigger())
set C5a=true
set C6a=fwv(ed,C4a,"when calling loadInt in ScmdDataTypes, line 914")
call qJe(C6a,GetTriggerUnit(),"when calling setTriggerUnit in ScmdDataTypes, line 915")
call pwe(C6a,GetSpellAbilityUnit(),"when calling setSpellAbilityUnit in ScmdDataTypes, line 916")
call qXe(C6a,GetSpellTargetUnit(),"when calling setSpellTargetUnit in ScmdDataTypes, line 917")
call Pke(C6a,GetSpellTargetX(),"when calling setSpellTargetX in ScmdDataTypes, line 918")
call Pre(C6a,GetSpellTargetY(),"when calling setSpellTargetY in ScmdDataTypes, line 919")
call phe(C6a,GetSpellTargetDestructable(),"when calling setSpellTargetDestructable in ScmdDataTypes, line 920")
call pQe(C6a,GetSpellTargetItem(),"when calling setSpellTargetItem in ScmdDataTypes, line 921")
call PFe(C6a,GetManipulatedItem(),"when calling setManipulatedItem in ScmdDataTypes, line 922")
call p0e(C6a,GetSpellAbilityId(),"when calling setSpellAbilityId in ScmdDataTypes, line 923")
set C7a=0
set C8a=c8v(bd,C4a,-1)-1
loop
exitwhen C7a>C8a
call xda(8,fwv(ed,C4a,"when calling loadInt in ScmdDataTypes, line 925"),c8v(bd,C4a,C7a),"when calling resolve in ScmdDataTypes, line 925",0,null,0,null)
set C9a=RJv
set dea=ox[m0v(C9a,"when calling get in ScmdDataTypes, line 926")]
if dea==$EFC or dea==$F09 then
set dva=WCv(m0v(C9a,"when calling get in ScmdDataTypes, line 926"),"when calling booleanValue in ScmdDataTypes, line 926")
else
set dva=not(ox[m0v(C9a,"when calling get in ScmdDataTypes, line 926")]==$F00)
endif
set C5a=dva
call mfv(20,C9a,"when calling dispatch_GenericSharedPointer_destroyGenericSharedPointer in ScmdDataTypes, line 927")
if not C5a then
exitwhen true
endif
set C7a=C7a+1
endloop
set dxa=C5a
set EM=EM-1
return dxa
endfunction
function doa takes nothing returns boolean
set EM=0
return C2a("ScmdDataTypes, line 911")
endfunction
function dra takes nothing returns boolean
return GetBooleanAnd(IsUnitAliveBJ(GetFilterUnit()),IsUnitEnemy(GetFilterUnit(),GetOwningPlayer(Nu)))
endfunction
function dia takes nothing returns boolean
return(GetSpellAbilityId()=='A0EG')
endfunction
function daa takes nothing returns boolean
return IsPlayerEnemy(GetOwningPlayer(GetSpellAbilityUnit()),GetOwningPlayer(GetFilterUnit()))
endfunction
function dna takes nothing returns boolean
return(GetSpellAbilityId()=='A085')
endfunction
function dVa takes nothing returns boolean
return(GetUnitTypeId(GetEnumUnit())!='h000')and(IsUnitSelected(GetEnumUnit(),GetTriggerPlayer()))
endfunction
function dEa takes nothing returns boolean
return(dVa())
endfunction
function dXa takes nothing returns boolean
return(GetUnitAbilityLevelSwapped('A0K1',GetEnumUnit())==0)and(GetUnitAbilityLevelSwapped('A0K2',GetEnumUnit())==0)
endfunction
function dOa takes nothing returns boolean
return(dXa())
endfunction
function dRa takes nothing returns nothing
if dEa()then
if dOa()then
call UnitAddAbilityBJ('A0K1',GetEnumUnit())
call UnitMakeAbilityPermanent(GetEnumUnit(),true,'A0K1')
else
call IncUnitAbilityLevelSwapped('A0K1',GetEnumUnit())
call IncUnitAbilityLevelSwapped('A0K2',GetEnumUnit())
endif
endif
endfunction
function dIa takes nothing returns boolean
return true
endfunction
function dAa takes nothing returns nothing
set aw[dw]='A00H'
set nw[dw]="advanceddeathtower"
set dw=dw+1
set aw[dw]='A00I'
set nw[dw]="ancientprotector"
set dw=dw+1
set aw[dw]='A00J'
set nw[dw]="arcanetower"
set dw=dw+1
set aw[dw]='A00K'
set nw[dw]="archer"
set dw=dw+1
set aw[dw]='A00L'
set nw[dw]="archmage"
set dw=dw+1
set aw[dw]='A00M'
set nw[dw]="assassin"
set dw=dw+1
set aw[dw]='A00N'
set nw[dw]="avatarofvengeance"
set dw=dw+1
set aw[dw]='A00O'
set nw[dw]="banshee"
set dw=dw+1
set aw[dw]='A00P'
set nw[dw]="bardarachnathid"
set dw=dw+1
set aw[dw]='A02R'
set nw[dw]="blackarrow"
set dw=dw+1
set aw[dw]='A00Q'
set nw[dw]="blackdragon"
set dw=dw+1
set aw[dw]='A00R'
set nw[dw]="bloodmage"
set dw=dw+1
set aw[dw]='A02S'
set nw[dw]="breathoffire"
set dw=dw+1
set aw[dw]='A02T'
set nw[dw]="breathoffrost"
set dw=dw+1
set aw[dw]='A00T'
set nw[dw]="cannontower"
set dw=dw+1
set aw[dw]='A02U'
set nw[dw]="charm"
set dw=dw+1
set aw[dw]='A00V'
set nw[dw]="chimaera"
set dw=dw+1
set aw[dw]='A02V'
set nw[dw]="clusterrockets"
set dw=dw+1
set aw[dw]='A00W'
set nw[dw]="couatl"
set dw=dw+1
set aw[dw]='A00S'
set nw[dw]="cryptfiend"
set dw=dw+1
set aw[dw]='A09M'
set nw[dw]="chainlightning"
set dw=dw+1
set aw[dw]='A02W'
set nw[dw]="darksummoning"
set dw=dw+1
set aw[dw]='A00X'
set nw[dw]="deathtower"
set dw=dw+1
set aw[dw]='A00Y'
set nw[dw]="demolisher"
set dw=dw+1
set aw[dw]='A00Z'
set nw[dw]="demonhunter"
set dw=dw+1
set aw[dw]='A010'
set nw[dw]="destroyer"
set dw=dw+1
set aw[dw]='A011'
set nw[dw]="draeneidemolisher"
set dw=dw+1
set aw[dw]='A012'
set nw[dw]="dragonhawk"
set dw=dw+1
set aw[dw]='A013'
set nw[dw]="druidofthetalon"
set dw=dw+1
set aw[dw]='A014'
set nw[dw]="dryad"
set dw=dw+1
set aw[dw]='A016'
set nw[dw]="faeriedragon"
set dw=dw+1
set aw[dw]='A036'
set nw[dw]="faeriefire"
set dw=dw+1
set aw[dw]='A017'
set nw[dw]="farseer"
set dw=dw+1
set aw[dw]='A018'
set nw[dw]="firelord"
set dw=dw+1
set aw[dw]='A019'
set nw[dw]="flyingmachine"
set dw=dw+1
set aw[dw]='A01A'
set nw[dw]="flyingmachinebombs"
set dw=dw+1
set aw[dw]='A02Y'
set nw[dw]="frostbolt"
set dw=dw+1
set aw[dw]='A01B'
set nw[dw]="frostwyrm"
set dw=dw+1
set aw[dw]='A01C'
set nw[dw]="gargoyle"
set dw=dw+1
set aw[dw]='A01D'
set nw[dw]="glaivethrower"
set dw=dw+1
set aw[dw]='A01E'
set nw[dw]="gnollassassin"
set dw=dw+1
set aw[dw]='A01F'
set nw[dw]="goblinblaster"
set dw=dw+1
set aw[dw]='A01G'
set nw[dw]="greendrake"
set dw=dw+1
set aw[dw]='A01H'
set nw[dw]="gryphonrider"
set dw=dw+1
set aw[dw]='A00U'
set nw[dw]="guardtower"
set dw=dw+1
set aw[dw]='A01J'
set nw[dw]="humanbattleship"
set dw=dw+1
set aw[dw]='A01K'
set nw[dw]="huntress"
set dw=dw+1
set aw[dw]='A01L'
set nw[dw]="hydralisk"
set dw=dw+1
set aw[dw]='A01M'
set nw[dw]="illidan"
set dw=dw+1
set aw[dw]='A01N'
set nw[dw]="keeperofthegrove"
set dw=dw+1
set aw[dw]='A01O'
set nw[dw]="kodobeast"
set dw=dw+1
set aw[dw]='A01P'
set nw[dw]="lavaspawn"
set dw=dw+1
set aw[dw]='A01Q'
set nw[dw]="lich"
set dw=dw+1
set aw[dw]='A037'
set nw[dw]="lightningshield"
set dw=dw+1
set aw[dw]='A01R'
set nw[dw]="locust"
set dw=dw+1
set aw[dw]='A01S'
set nw[dw]="makruka"
set dw=dw+1
set aw[dw]='A032'
set nw[dw]="massteleport"
set dw=dw+1
set aw[dw]='A01T'
set nw[dw]="meatwagon"
set dw=dw+1
set aw[dw]='A01U'
set nw[dw]="mortarteam"
set dw=dw+1
set aw[dw]='A01V'
set nw[dw]="mur'gul"
set dw=dw+1
set aw[dw]='A01W'
set nw[dw]="nagaseawitch"
set dw=dw+1
set aw[dw]='A01X'
set nw[dw]="necromancer"
set dw=dw+1
set aw[dw]='A01I'
set nw[dw]="nerubiantower"
set dw=dw+1
set aw[dw]='A030'
set nw[dw]="orbofcorruption"
set dw=dw+1
set aw[dw]='A02Z'
set nw[dw]="orbofdarkness"
set dw=dw+1
set aw[dw]='A031'
set nw[dw]="orboffrost"
set dw=dw+1
set aw[dw]='A01Z'
set nw[dw]="pandarenbrewmaster"
set dw=dw+1
set aw[dw]='A020'
set nw[dw]="phoenix"
set dw=dw+1
set aw[dw]='A021'
set nw[dw]="priest"
set dw=dw+1
set aw[dw]='A022'
set nw[dw]="priestessofthemoon"
set dw=dw+1
set aw[dw]='A023'
set nw[dw]="quilbeast"
set dw=dw+1
set aw[dw]='A025'
set nw[dw]="reefelemental"
set dw=dw+1
set aw[dw]='A033'
set nw[dw]="resurrection"
set dw=dw+1
set aw[dw]='A024'
set nw[dw]="rexxar"
set dw=dw+1
set aw[dw]='A026'
set nw[dw]="rifleman"
set dw=dw+1
set aw[dw]='A027'
set nw[dw]="satyr"
set dw=dw+1
set aw[dw]='A028'
set nw[dw]="serpentward"
set dw=dw+1
set aw[dw]='A029'
set nw[dw]="shadowhunter"
set dw=dw+1
set aw[dw]='A02B'
set nw[dw]="shockwave"
set dw=dw+1
set aw[dw]='A02A'
set nw[dw]="siegeenginebarrage"
set dw=dw+1
set aw[dw]='A02C'
set nw[dw]="skeletalmage"
set dw=dw+1
set aw[dw]='A02D'
set nw[dw]="skyfurytower"
set dw=dw+1
set aw[dw]='A02E'
set nw[dw]="sludgeflinger"
set dw=dw+1
set aw[dw]='A02I'
set nw[dw]="snapdragon"
set dw=dw+1
set aw[dw]='A02F'
set nw[dw]="sorceress"
set dw=dw+1
set aw[dw]='A02G'
set nw[dw]="spellbreaker"
set dw=dw+1
set aw[dw]='A01Y'
set nw[dw]="spirittower"
set dw=dw+1
set aw[dw]='A02H'
set nw[dw]="spiritofvengeance"
set dw=dw+1
set aw[dw]='A034'
set nw[dw]="tomeofretraining"
set dw=dw+1
set aw[dw]='A02J'
set nw[dw]="trollbatrider"
set dw=dw+1
set aw[dw]='A02K'
set nw[dw]="trollheadhunter"
set dw=dw+1
set aw[dw]='A02L'
set nw[dw]="trollwitchdoctor"
set dw=dw+1
set aw[dw]='A02M'
set nw[dw]="tuskarr"
set dw=dw+1
set aw[dw]='A015'
set nw[dw]="voidwalker"
set dw=dw+1
set aw[dw]='A035'
set nw[dw]="warstomp"
set dw=dw+1
set aw[dw]='A02N'
set nw[dw]="warden"
set dw=dw+1
set aw[dw]='A02O'
set nw[dw]="waterelemental"
set dw=dw+1
set aw[dw]='A02P'
set nw[dw]="windrider"
set dw=dw+1
set aw[dw]='A02Q'
set nw[dw]="wisp"
set dw=dw+1
set aw[dw]='A02X'
set nw[dw]="wispexplode"
set dw=dw+1
set aw[dw]='A0IV'
set nw[dw]="cyclone"
set dw=dw+1
set aw[dw]='A0IW'
set nw[dw]="tornado"
set dw=dw+1
set aw[dw]='A09N'
set nw[dw]="arcanemissile"
set dw=dw+1
set aw[dw]='A09L'
set nw[dw]="holybolt"
set dw=dw+1
set aw[dw]='A09O'
set nw[dw]="icebolt"
set dw=dw+1
set aw[dw]='A0HM'
set nw[dw]="laserray"
set dw=dw+1
set aw[dw]='A0GD'
set nw[dw]="fingerofdeath"
set dw=dw+1
set aw[dw]='A0I6'
set nw[dw]="forkedlightning"
set dw=dw+1
set aw[dw]='A0I7'
set nw[dw]="aerialshackles"
set dw=dw+1
set aw[dw]='A0I8'
set nw[dw]="manaburn"
set dw=dw+1
set aw[dw]='A0I9'
set nw[dw]="lifedrain"
set dw=dw+1
set aw[dw]='A0IA'
set nw[dw]="siphonmana"
set dw=dw+1
set aw[dw]='A0IB'
set nw[dw]="healingwave"
set dw=dw+1
set aw[dw]='A0JI'
set nw[dw]="nagadeath"
set dw=dw+1
set aw[dw]='A0JJ'
set nw[dw]="ucanceldeath"
set dw=dw+1
set aw[dw]='A0JK'
set nw[dw]="humanlargedeathexplode"
set dw=dw+1
set aw[dw]='A0JL'
set nw[dw]="undeaddissipate"
set dw=dw+1
set aw[dw]='A09K'
set nw[dw]="spinningburninghead"
set dw=dw+1
set aw[dw]='A0L7'
set nw[dw]="lightningmissile"
set dw=dw+1
set aw[dw]='A0IF'
set nw[dw]="magefirebolt"
set dw=dw+1
set aw[dw]='A0GU'
set nw[dw]="felfirebolt"
set dw=dw+1
set aw[dw]='A0GZ'
set nw[dw]="felbreathoffire"
set dw=dw+1
set aw[dw]='A0GV'
set nw[dw]="felincinerate"
set dw=dw+1
set aw[dw]='A0H2'
set nw[dw]="felliquidfire"
set dw=dw+1
call DestroyTrigger(GetTriggeringTrigger())
endfunction
function dNa takes nothing returns boolean
set CR="air"
set VR="ground"
set BR="invulnerable"
set NR="mechanical"
set MR="organic"
set wT="structure"
set uT="vulnerable"
return true
endfunction
function dba takes nothing returns nothing
if IsUnitEnemy(GetFilterUnit(),Rl)then
call UnitDamageTarget(fl,GetFilterUnit(),Tl,true,true,ATTACK_TYPE_NORMAL,DAMAGE_TYPE_MAGIC,WEAPON_TYPE_WHOKNOWS)
endif
endfunction
function dBa takes nothing returns boolean
return IsUnitSelected(GetFilterUnit(),GetTriggerPlayer())
endfunction
function dca takes nothing returns boolean
return(GetEventPlayerChatString()=="~tauren")
endfunction
function dCa takes nothing returns boolean
return(GetEventPlayerChatString()=="@tauren")
endfunction
function dda takes nothing returns nothing
set g[GetConvertedPlayerId(GetTriggerPlayer())]=GetUnitsOfPlayerMatching(GetTriggerPlayer(),Condition(o9v))
if dca()then
call ForGroupBJ(g[GetConvertedPlayerId(GetTriggerPlayer())],rvv)
elseif dCa()then
call ForGroupBJ(g[GetConvertedPlayerId(GetTriggerPlayer())],rev)
endif
call DestroyGroup(g[GetPlayerId(GetTriggerPlayer())+1])
endfunction
function dDa takes nothing returns boolean
return(GetUnitAbilityLevel(GetTriggerUnit(),'A0IR')>0)
endfunction
function dfa takes nothing returns nothing
set g[GetConvertedPlayerId(GetTriggerPlayer())]=GetUnitsOfPlayerMatching(GetTriggerPlayer(),Condition(xIv))
call ForGroupBJ(g[GetConvertedPlayerId(GetTriggerPlayer())],xAv)
call DestroyGroup(g[GetPlayerId(GetTriggerPlayer())+1])
endfunction
function dFa takes nothing returns nothing
local group dga=GetUnitsOfPlayerMatching(GetTriggerPlayer(),Condition(inv))
if GetEventPlayerChatString()=="'heromagearmor" then
call ForGroup(dga,iVv)
elseif GetEventPlayerChatString()=="@heromagearmor" then
call ForGroup(dga,iEv)
endif
call DestroyGroup(dga)
set dga=null
set dga=null
endfunction
function dGa takes nothing returns nothing
call SetBlightRadiusLocBJ(false,GetEnumPlayer(),G,92.)
endfunction
function dha takes nothing returns boolean
return(GetUnitTypeId(GetEnumUnit())!='h000')and(IsUnitSelected(GetEnumUnit(),GetTriggerPlayer()))
endfunction
function dHa takes nothing returns boolean
return(dha())
endfunction
function dja takes nothing returns boolean
return(X[GetConvertedPlayerId(GetTriggerPlayer())]<0)
endfunction
function dJa takes nothing returns nothing
if dHa()then
if GetTriggerPlayer()==Player(0)then
call DestroyEffectBJ(W[X[GetConvertedPlayerId(GetTriggerPlayer())]])
endif
if GetTriggerPlayer()==Player(1)then
call DestroyEffectBJ(E[X[GetConvertedPlayerId(GetTriggerPlayer())]])
endif
if GetTriggerPlayer()==Player(2)then
call DestroyEffectBJ(J[X[GetConvertedPlayerId(GetTriggerPlayer())]])
endif
if GetTriggerPlayer()==Player(3)then
call DestroyEffectBJ(H[X[GetConvertedPlayerId(GetTriggerPlayer())]])
endif
if GetTriggerPlayer()==Player(4)then
call DestroyEffectBJ(D[X[GetConvertedPlayerId(GetTriggerPlayer())]])
endif
if GetTriggerPlayer()==Player(5)then
call DestroyEffectBJ(A[X[GetConvertedPlayerId(GetTriggerPlayer())]])
endif
if GetTriggerPlayer()==Player(6)then
call DestroyEffectBJ(P[X[GetConvertedPlayerId(GetTriggerPlayer())]])
endif
if GetTriggerPlayer()==Player(7)then
call DestroyEffectBJ(I[X[GetConvertedPlayerId(GetTriggerPlayer())]])
endif
if GetTriggerPlayer()==Player(8)then
call DestroyEffectBJ(U[X[GetConvertedPlayerId(GetTriggerPlayer())]])
endif
if GetTriggerPlayer()==Player(9)then
call DestroyEffectBJ(Z[X[GetConvertedPlayerId(GetTriggerPlayer())]])
endif
if GetTriggerPlayer()==Player($A)then
call DestroyEffectBJ(L[X[GetConvertedPlayerId(GetTriggerPlayer())]])
endif
if GetTriggerPlayer()==Player($B)then
call DestroyEffectBJ(K[X[GetConvertedPlayerId(GetTriggerPlayer())]])
endif
set X[GetConvertedPlayerId(GetTriggerPlayer())]=X[GetConvertedPlayerId(GetTriggerPlayer())]-1
if dja()then
set X[GetConvertedPlayerId(GetTriggerPlayer())]=0
endif
endif
endfunction
function dka takes integer Pks returns nothing
endfunction
function dKa takes integer dla returns nothing
call dka(dla)
endfunction
function dLa takes string dma returns integer
local integer dMa
set ZM[EM]=dma
set EM=EM+1
if RG==0 then
if TG<$8000 then
set TG=TG+1
set dMa=TG
set YG[dMa]=5104
else
call Cdv("Out of memory: Could not create OnBuffApplicationStruct.","when calling error in EmergencyEvade, line 30")
set dMa=0
endif
else
set RG=RG-1
set dMa=fG[RG]
set YG[dMa]=5104
endif
set EM=EM-1
return dMa
endfunction
function dpa takes string dPa returns integer
local integer dqa
set ZM[EM]=dPa
set EM=EM+1
set dqa=dLa("when calling alloc_OnBuffApplicationStruct in EmergencyEvade, line 30")
call dKa(dqa)
set EM=EM-1
return dqa
endfunction
function dQa takes integer dsa,integer dSa returns nothing
set MQ[dsa]=dSa
endfunction
function dta takes integer dTa,integer dua,string dUa returns nothing
set ZM[EM]=dUa
set EM=EM+1
if dG[dTa]==0 then
if dTa==0 then
call Cdv("Nullpointer exception when calling BuffType.setOnRemovalHandler","when calling error in BuffsJurst, line 62")
else
call Cdv("Called BuffType.setOnRemovalHandler on invalid object.","when calling error in BuffsJurst, line 62")
endif
endif
call dQa(dTa,dua)
set EM=EM-1
endfunction
function dwa takes integer dWa,integer dya returns nothing
set CQ[dWa]=dya
endfunction
function dYa takes integer dza,integer dZa,string d_a returns nothing
set ZM[EM]=d_a
set EM=EM+1
if dG[dza]==0 then
if dza==0 then
call Cdv("Nullpointer exception when calling BuffType.setOnApplicationHandler","when calling error in BuffsJurst, line 42")
else
call Cdv("Called BuffType.setOnApplicationHandler on invalid object.","when calling error in BuffsJurst, line 42")
endif
endif
call dwa(dza,dZa)
set EM=EM-1
endfunction
function d0a takes integer Bks returns nothing
endfunction
function d1a takes integer d2a returns nothing
call d0a(d2a)
endfunction
function d3a takes string d4a returns integer
local integer d5a
set ZM[EM]=d4a
set EM=EM+1
if RG==0 then
if TG<$8000 then
set TG=TG+1
set d5a=TG
set YG[d5a]=5107
else
call Cdv("Out of memory: Could not create OnBuffRemovalStruct.","when calling error in EmergencyEvade, line 36")
set d5a=0
endif
else
set RG=RG-1
set d5a=fG[RG]
set YG[d5a]=5107
endif
set EM=EM-1
return d5a
endfunction
function d6a takes string d7a returns integer
local integer d8a
set ZM[EM]=d7a
set EM=EM+1
set d8a=d3a("when calling alloc_OnBuffRemovalStruct in EmergencyEvade, line 36")
call d1a(d8a)
set EM=EM-1
return d8a
endfunction
function d9a takes string Dva returns nothing
local trigger Dea
set ZM[EM]=Dva
set EM=EM+1
set Dea=CreateTrigger()
call dYa(Lp,dpa("when calling new_OnBuffApplicationStruct in EmergencyEvade, line 44"),"when calling setOnApplicationHandler in EmergencyEvade, line 44")
call dta(Lp,d6a("when calling new_OnBuffRemovalStruct in EmergencyEvade, line 45"),"when calling setOnRemovalHandler in EmergencyEvade, line 45")
call Avv(Dea,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(Dea,Filter(OSv))
set EM=EM-1
set Dea=null
endfunction
function Dxa takes string Doa returns integer
local integer Dra
set ZM[EM]=Doa
set EM=EM+1
if Fv==0 then
if kv<$8000 then
set kv=kv+1
set Dra=kv
set jv[Dra]=4900
else
call Cdv("Out of memory: Could not create Table.","when calling error in TableJurst, line 3")
set Dra=0
endif
else
set Fv=Fv-1
set Dra=hv[Fv]
set jv[Dra]=4900
endif
set EM=EM-1
return Dra
endfunction
function Dia takes integer M3i returns nothing
endfunction
function Daa takes integer Dna returns nothing
call Dia(Dna)
endfunction
function DVa takes string DEa returns integer
local integer DXa
set ZM[EM]=DEa
set EM=EM+1
set DXa=Dxa("when calling alloc_Table in TableJurst, line 3")
call Daa(DXa)
set EM=EM-1
return DXa
endfunction
function DOa takes string DRa returns integer
local integer DIa
set ZM[EM]=DRa
set EM=EM+1
set DIa=DVa("when calling new_Table in TableJurst, line 8")
set EM=EM-1
return DIa
endfunction
function DAa takes integer DNa,string Dba returns nothing
set ZM[EM]=Dba
set EM=EM+1
set XQ[DNa]=DOa("when calling create in BuffsJurst, line 29")
set CQ[DNa]=0
set VQ[DNa]=0
set BQ[DNa]=0
set NQ[DNa]=0
set MQ[DNa]=0
set wW[DNa]=0
set EM=EM-1
endfunction
function DBa takes integer Dca,string DCa returns nothing
set ZM[EM]=DCa
set EM=EM+1
call DAa(Dca,"when calling BuffType_init in BuffsJurst, line 27")
set EM=EM-1
endfunction
function Dda takes string DDa returns integer
local integer Dfa
set ZM[EM]=DDa
set EM=EM+1
if aG==0 then
if nG<$8000 then
set nG=nG+1
set Dfa=nG
set dG[Dfa]=$43D
else
call Cdv("Out of memory: Could not create BuffType.","when calling error in BuffsJurst, line 27")
set Dfa=0
endif
else
set aG=aG-1
set Dfa=qG[aG]
set dG[Dfa]=$43D
endif
set EM=EM-1
return Dfa
endfunction
function DFa takes string Dga returns integer
local integer DGa
set ZM[EM]=Dga
set EM=EM+1
set DGa=Dda("when calling alloc_BuffType in BuffsJurst, line 27")
call DBa(DGa,"when calling construct_BuffType in BuffsJurst, line 27")
set EM=EM-1
return DGa
endfunction
function Dha takes string DHa returns integer
local integer Dja
set ZM[EM]=DHa
set EM=EM+1
set Dja=DFa("when calling new_BuffType in BuffsJurst, line 39")
set EM=EM-1
return Dja
endfunction
function DJa takes string Dka returns boolean
set ZM[EM]=Dka
set EM=EM+1
set Hp='A00F'
set Jp='A03T'
set Kp='A0JM'
set Lp=Dha("when calling create in EmergencyEvade, line 9")
call d9a("when calling Init in EmergencyEvade, line 1")
set EM=EM-1
return true
endfunction
function DKa takes nothing returns boolean
set EM=0
return DJa("EmergencyEvade, line 1")
endfunction
function Dla takes nothing returns nothing
if GetSpellAbilityId()!=ZO then
return
endif
call GBv(IO,GetUnitAbilityLevel(GetSpellAbilityUnit(),ZO),"attackonce",GetSpellTargetUnit())
call SaveUnitHandle(i,PO,GetHandleId(GetSpellTargetUnit()),GetSpellAbilityUnit())
endfunction
function DLa takes nothing returns nothing
call CameraClearNoiseForPlayer(GetEnumPlayer())
endfunction
function Dma takes framehandle DMa,player Dpa,boolean DPa returns nothing
if ta==Dpa then
call BlzFrameSetVisible(DMa,DPa)
endif
endfunction
function Dqa takes framehandle DQa returns nothing
call BlzFrameSetVisible(DQa,true)
endfunction
function Dsa takes nothing returns player
return GetTriggerPlayer()
endfunction
function DSa takes framehandle Dta returns boolean
return BlzFrameIsVisible(Dta)
endfunction
function DTa takes framehandle Dua returns nothing
call BlzFrameSetVisible(Dua,false)
endfunction
function DUa takes integer Dwa returns nothing
local string DWa
local framehandle Dya
local framehandle DYa
local framehandle Dza
call Dma(OJ[qJ[Dwa]],Dsa(),not DSa(OJ[qJ[Dwa]]))
set Dza=oJ[qJ[Dwa]]
if DSa(OJ[qJ[Dwa]])then
set DWa="Hide Log"
else
set DWa="Show Log"
endif
call Gte(Dza,DWa)
set Dya=cJ[qJ[Dwa]]
call DTa(Dya)
set DYa=Dya
call Dqa(DYa)
set Dya=null
set DYa=null
set Dza=null
endfunction
function DZa takes integer D_a,string D0a returns nothing
set ZM[EM]=D0a
set EM=EM+1
if bg[D_a]==0 then
if D_a==0 then
call Cdv("Nullpointer exception when calling FrameHandleListener.onEvent","when calling error in ClosureFrames, line 110")
else
call Cdv("Called FrameHandleListener.onEvent on invalid object.","when calling error in ClosureFrames, line 110")
endif
endif
call DUa(D_a)
set EM=EM-1
endfunction
function D1a takes string D2a returns nothing
local integer D3a
local frameeventtype D4a
local integer D5a
set ZM[EM]=D2a
set EM=EM+1
set D3a=f3v(yp,C0v(BlzGetTriggerFrame()),"when calling get in ClosureFrames, line 93")
set D4a=BlzGetTriggerFrameEvent()
loop
exitwhen not(D3a!=0)
set D5a=vW[D3a]
if xW[D3a]==D4a then
call DZa(D3a,"when calling onEvent in ClosureFrames, line 98")
endif
set D3a=D5a
endloop
set EM=EM-1
set D4a=null
endfunction
function D6a takes nothing returns nothing
set EM=0
call D1a("ClosureFrames, line 23")
endfunction
function D7a takes nothing returns boolean
return true
endfunction
function D8a takes nothing returns nothing
call CameraSetEQNoiseForPlayer(GetEnumPlayer(),4.)
endfunction
function D9a takes nothing returns boolean
if GetSpellAbilityId()=='A0K1' or GetSpellAbilityId()=='A0K2' then
return true
else
return false
endif
endfunction
function fva takes nothing returns nothing
local unit fea=GetSpellAbilityUnit()
local location fxa=GetUnitLoc(fea)
local location foa=GetSpellTargetLoc()
local timer fra=CreateTimer()
call SaveLocationHandle(nr,GetHandleId(fra),StringHash("l1"),fxa)
call SaveLocationHandle(nr,GetHandleId(fra),StringHash("l2"),foa)
call SaveUnitHandle(nr,GetHandleId(fra),StringHash("u"),fea)
set fea=null
set fxa=null
set foa=null
call SaveInteger(nr,GetHandleId(fra),StringHash("i"),1)
call TimerStart(fra,.1,true,Vwv)
set fra=null
set fea=null
set fxa=null
set foa=null
set fra=null
endfunction
function fia takes nothing returns boolean
return(GetDestructableMaxLife(GetEnumDestructable())<1000000000.)and(GetDestructableMaxLife(GetEnumDestructable())!=777.77)
endfunction
function faa takes nothing returns nothing
if fia()then
call SetDestructableInvulnerableBJ(GetEnumDestructable(),true)
call KillDestructable(GetEnumDestructable())
call RemoveDestructable(GetEnumDestructable())
endif
endfunction
function fna takes nothing returns nothing
set Vs[Cs]='Bmlt'
set Cs=Cs+1
set Vs[Cs]='Bply'
set Cs=Cs+1
set Vs[Cs]='Bena'
set Cs=Cs+1
set Vs[Cs]='Beng'
set Cs=Cs+1
set Vs[Cs]='Bens'
set Cs=Cs+1
set Vs[Cs]='Bwea'
set Cs=Cs+1
set Vs[Cs]='Bweb'
set Cs=Cs+1
set Vs[Cs]='BUim'
set Cs=Cs+1
set Vs[Cs]='BUsl'
set Cs=Cs+1
set Vs[Cs]='BUst'
set Cs=Cs+1
set Vs[Cs]='BUsp'
set Cs=Cs+1
set Vs[Cs]='BEer'
set Cs=Cs+1
set Vs[Cs]='Bcyc'
set Cs=Cs+1
set Vs[Cs]='Bcy2'
set Cs=Cs+1
set Vs[Cs]='BSTN'
set Cs=Cs+1
set Vs[Cs]='BPSE'
set Cs=Cs+1
set Vs[Cs]='BNsi'
set Cs=Cs+1
set Vs[Cs]='BNso'
set Cs=Cs+1
set Vs[Cs]='BNdo'
set Cs=Cs+1
set Vs[Cs]='B027'
set Cs=Cs+1
set Vs[Cs]='B03B'
set Cs=Cs+1
set Vs[Cs]='B028'
set Cs=Cs+1
set Vs[Cs]='B000'
set Cs=Cs+1
set Vs[Cs]='B03O'
set Cs=Cs+1
set Vs[Cs]='B02P'
set Cs=Cs+1
call DestroyTrigger(GetTriggeringTrigger())
endfunction
function fVa takes nothing returns nothing
call RemoveUnit(GetEnumUnit())
endfunction
function fEa takes nothing returns nothing
set G=GetUnitLoc(GetEnumUnit())
call CreateItemLoc(B[GetForLoopIndexA()],G)
call RemoveLocation(G)
endfunction
function fXa takes nothing returns nothing
local location fOa=GetSpellTargetLoc()
local integer fRa=GetPlayerId(GetTriggerPlayer())
local destructable fIa=null
if mw[fRa]then
set vw[fRa]=GetRandomReal(.8,1.2)
endif
if is[fRa]then
set Ss[fRa]=GetRandomReal(.0,360.)
endif
if dt[fRa]then
set nt[fRa]=GetRandomInt(0,ft[fRa])
endif
set fIa=CreateDestructableZ(j[fRa],GetLocationX(fOa),GetLocationY(fOa),Gt[fRa]+GetLocationZ(fOa),Ss[fRa],vw[fRa],nt[fRa])
call FlushChildHashtable(nr,GetHandleId(fIa))
if qt[fRa]==false then
call SetDestructableOccluderHeight(fIa,at[fRa])
endif
if Rt[fRa]then
call SetDestructableInvulnerable(fIa,true)
endif
set fRa=0
call RemoveLocation(fOa)
set fOa=null
set fIa=null
set fOa=null
set fIa=null
endfunction
function fAa takes nothing returns boolean
if IsUnitType(GetFilterUnit(),UNIT_TYPE_FLYING)==false and IsUnitAlly(GetFilterUnit(),GetOwningPlayer(Zr[kr[3]]))==false and GetOwningPlayer(GetFilterUnit())!=GetOwningPlayer(Zr[kr[3]])then
return true
else
return false
endif
endfunction
function fNa takes nothing returns nothing
local integer fba=1
loop
exitwhen fba>$3B9ACA00
if Gr[fba]==null then
set Gr[fba]=GetSpellAbilityUnit()
set gr[fba]=GetSpellTargetLoc()
return
endif
set fba=fba+1
endloop
set fba=0
endfunction
function fBa takes nothing returns boolean
return(GetSpellAbilityId()=='A08Q')
endfunction
function fca takes nothing returns boolean
return(GetUnitTypeId(GetEnumUnit())!='h000')and(GetUnitTypeId(GetEnumUnit())!='h0KW')and(IsUnitSelected(GetEnumUnit(),GetTriggerPlayer()))
endfunction
function fCa takes nothing returns nothing
if fca()then
call UnitRemoveAbilityBJ('Aatk',GetEnumUnit())
endif
endfunction
function fda takes nothing returns nothing
local group fDa=GetUnitsOfPlayerMatching(GetTriggerPlayer(),Condition(iov))
if GetEventPlayerChatString()=="'nocooldown" then
call ForGroup(fDa,irv)
elseif GetEventPlayerChatString()=="@nocooldown" then
call ForGroup(fDa,iiv)
endif
call DestroyGroup(fDa)
set fDa=null
set fDa=null
endfunction
function ffa takes nothing returns boolean
return(GetUnitTypeId(GetEnumUnit())!='h000')and(IsUnitSelected(GetEnumUnit(),GetTriggerPlayer()))
endfunction
function fFa takes nothing returns boolean
return(ffa())
endfunction
function fga takes nothing returns nothing
if fFa()then
call AddSpecialEffectTargetUnitBJ(Q[S2I(SubStringBJ(GetEventPlayerChatString(),7,7))],GetEnumUnit(),Qw[S2I(SubStringBJ(GetEventPlayerChatString(),5,6))])
set Ww[GetConvertedPlayerId(GetTriggerPlayer())]=Ww[GetConvertedPlayerId(GetTriggerPlayer())]+1
if GetTriggerPlayer()==Player(0)then
set Ew[Ww[GetConvertedPlayerId(GetTriggerPlayer())]]=GetLastCreatedEffectBJ()
endif
if GetTriggerPlayer()==Player(1)then
set Zw[Ww[GetConvertedPlayerId(GetTriggerPlayer())]]=GetLastCreatedEffectBJ()
endif
if GetTriggerPlayer()==Player(2)then
set Kw[Ww[GetConvertedPlayerId(GetTriggerPlayer())]]=GetLastCreatedEffectBJ()
endif
if GetTriggerPlayer()==Player(3)then
set Jw[Ww[GetConvertedPlayerId(GetTriggerPlayer())]]=GetLastCreatedEffectBJ()
endif
if GetTriggerPlayer()==Player(4)then
set Hw[Ww[GetConvertedPlayerId(GetTriggerPlayer())]]=GetLastCreatedEffectBJ()
endif
if GetTriggerPlayer()==Player(5)then
set Dw[Ww[GetConvertedPlayerId(GetTriggerPlayer())]]=GetLastCreatedEffectBJ()
endif
if GetTriggerPlayer()==Player(6)then
set Aw[Ww[GetConvertedPlayerId(GetTriggerPlayer())]]=GetLastCreatedEffectBJ()
endif
if GetTriggerPlayer()==Player(7)then
set Pw[Ww[GetConvertedPlayerId(GetTriggerPlayer())]]=GetLastCreatedEffectBJ()
endif
if GetTriggerPlayer()==Player(8)then
set Iw[Ww[GetConvertedPlayerId(GetTriggerPlayer())]]=GetLastCreatedEffectBJ()
endif
if GetTriggerPlayer()==Player(9)then
set Uw[Ww[GetConvertedPlayerId(GetTriggerPlayer())]]=GetLastCreatedEffectBJ()
endif
if GetTriggerPlayer()==Player($A)then
set Xw[Ww[GetConvertedPlayerId(GetTriggerPlayer())]]=GetLastCreatedEffectBJ()
endif
if GetTriggerPlayer()==Player($B)then
set Lw[Ww[GetConvertedPlayerId(GetTriggerPlayer())]]=GetLastCreatedEffectBJ()
endif
endif
endfunction
function fGa takes integer fha returns nothing
set hD[fha]=-1
endfunction
function fHa takes integer fja returns nothing
call fGa(fja)
endfunction
function fJa takes string fka returns integer
local integer fKa
set ZM[EM]=fka
set EM=EM+1
if nk==0 then
if dk<$8000 then
set dk=dk+1
set fKa=dk
set fk[fKa]=$F77
else
call Cdv("Out of memory: Could not create OrderStringFactory.","when calling error in OrderStringFactory, line 6")
set fKa=0
endif
else
set nk=nk-1
set fKa=ak[nk]
set fk[fKa]=$F77
endif
set EM=EM-1
return fKa
endfunction
function fla takes string fLa returns integer
local integer fma
set ZM[EM]=fLa
set EM=EM+1
set fma=fJa("when calling alloc_OrderStringFactory in OrderStringFactory, line 6")
call fHa(fma)
set EM=EM-1
return fma
endfunction
function fMa takes string fpa returns boolean
set ZM[EM]=fpa
set EM=EM+1
set vy=fla("when calling new_OrderStringFactory in ChannelAbilityPreset, line 10")
set EM=EM-1
return true
endfunction
function fPa takes nothing returns boolean
set EM=0
return fMa("ChannelAbilityPreset, line 1")
endfunction
function fqa takes nothing returns boolean
return(Sr)
endfunction
function fQa takes nothing returns boolean
return(Mu==1)or(Mu==3)
endfunction
function fsa takes nothing returns boolean
return(CountUnitsInGroup(lr[rr])==0)and(fQa())
endfunction
function fSa takes nothing returns boolean
return(DistanceBetweenPoints(Ju[7],Ju[5])<=Fu*5.)and(GetUnitFlyHeight(GetEnumUnit())<=10.)
endfunction
function fta takes nothing returns boolean
return(DistanceBetweenPoints(Ju[7],Ju[5])<=Fu+10.)or(fSa())
endfunction
function fTa takes nothing returns boolean
return(fta())
endfunction
function fua takes nothing returns boolean
return(Mu==1)
endfunction
function fUa takes nothing returns boolean
return(Mu==2)
endfunction
function fwa takes nothing returns boolean
return(ModuloReal(ir,3.)==.0)
endfunction
function fWa takes nothing returns boolean
return(ModuloReal(ir,2.)==.0)
endfunction
function fya takes nothing returns boolean
return(Mu==1)
endfunction
function fYa takes nothing returns boolean
return(Mu==1)
endfunction
function fza takes nothing returns boolean
return(Yu)
endfunction
function fZa takes nothing returns boolean
return(CountUnitsInGroup(Lu)==0)
endfunction
function f_a takes nothing returns boolean
return(Yu)
endfunction
function f0a takes nothing returns boolean
return(Mu==2)
endfunction
function f1a takes nothing returns nothing
set Ju[6]=GetUnitLoc(GetEnumUnit())
set Ju[7]=PolarProjectionBJ(Ju[6],Fu,AngleBetweenPoints(Ju[4],Ju[5]))
set yr=DistanceBetweenPoints(Ju[4],Ju[7])
call SetUnitPositionLoc(GetEnumUnit(),Ju[7])
call SetUnitFlyHeightBJ(GetEnumUnit(),4.*(hu/tr)*yr*((-(1.*yr))/tr+1.),.0)
if fTa()then
call KillUnit(GetEnumUnit())
call GroupRemoveUnitSimple(GetEnumUnit(),lr[rr])
call GroupAddUnitSimple(GetEnumUnit(),Ku)
call SaveIntegerBJ(Du+1,0,GetHandleIdBJ(GetEnumUnit()),Au)
if fYa()then
call AddSpecialEffectLocBJ(Ju[7],"Abilities\\Weapons\\FrostWyrmMissile\\FrostWyrmMissile.mdl")
call DestroyEffectBJ(GetLastCreatedEffectBJ())
elseif f0a()then
set ir=ir+1.
call SaveRealBJ(ir,$B,Bu,Au)
if fWa()then
set Ju[$A]=PolarProjectionBJ(Ju[5],GetRandomReal(Gu,Wu),GetRandomDirectionDeg())
call CreateNUnitsAtLocFacingLocBJ(1,'h00A',GetOwningPlayer(Nu),Ju[5],Ju[$A])
call GroupAddUnitSimple(GetLastCreatedUnit(),cr[rr])
call SaveLocationHandleBJ(Ju[$A],1,GetHandleIdBJ(GetLastCreatedUnit()),Au)
call SaveBooleanBJ(false,2,GetHandleIdBJ(GetLastCreatedUnit()),Au)
endif
if fwa()then
call AddSpecialEffectLocBJ(Ju[7],"Abilities\\Spells\\Other\\Doom\\DoomDeath.mdl")
call DestroyEffectBJ(GetLastCreatedEffectBJ())
endif
else
call AddSpecialEffectLocBJ(Ju[7],"Abilities\\Weapons\\ChimaeraLightningMissile\\ChimaeraLightningMissile.mdl")
call DestroyEffectBJ(GetLastCreatedEffectBJ())
endif
if fqa()then
if fza()then
call ForForce(GetPlayersAll(),I0)
endif
call SaveBooleanBJ(false,$C,Bu,Au)
call CreateUbersplatBJ(Ju[7],"DHLB",100.,100.,100.,.0,false,true)
call FinishUbersplat(GetLastCreatedUbersplat())
call SetUbersplatRenderAlways(GetLastCreatedUbersplat(),true)
set br=1
loop
exitwhen br>5
set Ju[8]=PolarProjectionBJ(Ju[7],GetRandomReal(50.,180.),GetRandomDirectionDeg())
if fya()then
call CreateNUnitsAtLoc(1,'h0IE',GetOwningPlayer(Nu),Ju[8],GetRandomDirectionDeg())
call SetUnitTimeScalePercent(GetLastCreatedUnit(),20.)
elseif fUa()then
call CreateNUnitsAtLoc(1,'h006',GetOwningPlayer(Nu),Ju[8],GetRandomDirectionDeg())
else
call CreateNUnitsAtLoc(1,'h0LG',GetOwningPlayer(Nu),Ju[8],GetRandomDirectionDeg())
call SetUnitTimeScalePercent(GetLastCreatedUnit(),20.)
endif
call GroupAddUnitSimple(GetLastCreatedUnit(),Ku)
call UnitApplyTimedLifeBJ(5.,'BTLF',GetLastCreatedUnit())
call SaveIntegerBJ(Du+7,0,GetHandleIdBJ(GetLastCreatedUnit()),Au)
call RemoveLocation(Ju[8])
set br=br+1
endloop
set bj_wantDestroyGroup=true
call ForGroupBJ(GetUnitsInRangeOfLocMatching(Gu,Ju[7],Condition(A0)),N0)
if fua()then
set br=1
loop
exitwhen br>3
call CreateNUnitsAtLoc(1,'h0E1',GetOwningPlayer(Nu),Ju[7],bj_UNIT_FACING)
call KillUnit(GetLastCreatedUnit())
call GroupAddUnitSimple(GetLastCreatedUnit(),Ku)
call SaveIntegerBJ(Du+2,0,GetHandleIdBJ(GetLastCreatedUnit()),Au)
set br=br+1
endloop
set bj_wantDestroyGroup=true
call ForGroupBJ(GetUnitsInRangeOfLocMatching(Qu,Ju[7],Condition(b0)),B0)
endif
endif
set bj_wantDestroyGroup=true
call ForGroupBJ(GetUnitsInRangeOfLocMatching(Gu,Ju[7],Condition(c0)),C0)
if fsa()then
if f_a()then
call ForForce(GetPlayersAll(),d0)
endif
call GroupRemoveUnitSimple(Nu,Lu)
call FlushChildHashtableBJ(Bu,Au)
if fZa()then
call DisableTrigger(GetTriggeringTrigger())
set Vu=0
endif
call RemoveLocation(Ju[4])
call RemoveLocation(Ju[5])
endif
endif
call RemoveLocation(Ju[6])
call RemoveLocation(Ju[7])
endfunction
function f2a takes nothing returns nothing
set g[GetConvertedPlayerId(GetTriggerPlayer())]=GetUnitsOfPlayerMatching(GetTriggerPlayer(),Condition(vGv))
call ForGroupBJ(g[GetConvertedPlayerId(GetTriggerPlayer())],vhv)
call DestroyGroup(g[GetPlayerId(GetTriggerPlayer())+1])
endfunction
function f3a takes nothing returns integer
return Nn
endfunction
function f4a takes integer f5a,string f6a,string f7a,string f8a,string f9a returns nothing
local integer Fva
local integer Fea
local integer Fxa
set ZM[EM]=f9a
set EM=EM+1
set Fva=p0v(f5a,"when calling new_SharedPointer in ScmdBuiltinsRegistrar, line 18")
set Fea=0
set Fxa=bj_MAX_PLAYERS-1
loop
exitwhen Fea>Fxa
call c6e(Fea,f6a,f7a,f8a,Fva,true,"when calling assign in ScmdBuiltinsRegistrar, line 20")
set Fea=Fea+1
endloop
set EM=EM-1
endfunction
function Foa takes integer Fra,string Fia,string Faa returns nothing
set ZM[EM]=Faa
set EM=EM+1
call f4a(Fra,Fia,null,null,"when calling registerProtectedBuiltin in ScmdBuiltinsRegistrar, line 23")
set EM=EM-1
endfunction
function Fna takes integer FVa,integer FEa,integer FXa,string FOa returns nothing
set ZM[EM]=FOa
set EM=EM+1
set xJ[FVa]=0
call zGv(jJ[FVa],FEa,"when calling add in ScmdDataTypes, line 1394")
set xJ[FVa]=xJ[FVa]+1
call zGv(jJ[FVa],FXa,"when calling add in ScmdDataTypes, line 1394")
set xJ[FVa]=xJ[FVa]+1
set EM=EM-1
endfunction
function FRa takes integer FIa,integer FAa,integer FNa,string Fba returns nothing
set ZM[EM]=Fba
set EM=EM+1
if ax[FIa]==0 then
if FIa==0 then
call Cdv("Nullpointer exception when calling BuiltinData.setArgumentsTypes","when calling error in ScmdDataTypes, line 1391")
else
call Cdv("Called BuiltinData.setArgumentsTypes on invalid object.","when calling error in ScmdDataTypes, line 1391")
endif
endif
call Fna(FIa,FAa,FNa,"when calling setArgumentsTypes in ScmdDataTypes, line 1391")
set EM=EM-1
endfunction
function FBa takes string Fca returns integer
local integer FCa
set ZM[EM]=Fca
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set FCa=Yj
set Gj[FCa]=$B1F
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_UnitShopsBuiltins.","when calling error in UnitShopsBuiltins, line 8")
set FCa=0
endif
else
set Tj=Tj-1
set FCa=Rj[Tj]
set Gj[FCa]=$B1F
endif
set EM=EM-1
return FCa
endfunction
function Fda takes string FDa returns integer
local integer Ffa
set ZM[EM]=FDa
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set Ffa=Yj
set Gj[Ffa]=$B20
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_UnitShopsBuiltins.","when calling error in UnitShopsBuiltins, line 12")
set Ffa=0
endif
else
set Tj=Tj-1
set Ffa=Rj[Tj]
set Gj[Ffa]=$B20
endif
set EM=EM-1
return Ffa
endfunction
function FFa takes string Fga returns boolean
local integer FGa
local integer Fha
local integer FHa
local integer Fja
set ZM[EM]=Fga
set EM=EM+1
set FGa=FBa("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_UnitShopsBuiltins in UnitShopsBuiltins, line 8")
set Fha=OPo(FGa,"when calling new_BuiltinData in UnitShopsBuiltins, line 8")
call FRa(Fha,f3a(),f3a(),"when calling setArgumentsTypes in UnitShopsBuiltins, line 11")
call Foa(ILo(Fha,"when calling new_BuiltinFunction in UnitShopsBuiltins, line 8"),"utypesetbaseid","when calling registerProtectedBuiltin in UnitShopsBuiltins, line 8")
set FHa=Fda("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_UnitShopsBuiltins in UnitShopsBuiltins, line 12")
set Fja=OPo(FHa,"when calling new_BuiltinData in UnitShopsBuiltins, line 12")
call Rxo(Fja,f3a(),"when calling setArgumentsTypes in UnitShopsBuiltins, line 15")
call Foa(ILo(Fja,"when calling new_BuiltinFunction in UnitShopsBuiltins, line 12"),"utypeflush","when calling registerProtectedBuiltin in UnitShopsBuiltins, line 12")
set EM=EM-1
return true
endfunction
function FJa takes nothing returns boolean
set EM=0
return FFa("UnitShopsBuiltins, line 1")
endfunction
function Fka takes nothing returns boolean
local real FKa
local real Fla
set ie=BlzGetOriginFrame(ORIGIN_FRAME_GAME_UI,0)
set FKa=.8
set Fla=.6
set Se=FKa
set ce=Fla
return true
endfunction
function FLa takes nothing returns boolean
return(ju<=0)
endfunction
function Fma takes nothing returns boolean
return(IsTriggerEnabled(Bt)==false)
endfunction
function FMa takes nothing returns nothing
call GroupAddUnitSimple(GetTriggerUnit(),Lu)
call GroupRemoveUnitSimple(GetTriggerUnit(),Hu)
call SaveLocationHandleBJ(GetSpellTargetLoc(),1,GetHandleIdBJ(GetTriggerUnit()),Au)
call SaveIntegerBJ(GetUnitAbilityLevelSwapped('A07X',GetTriggerUnit()),5,GetHandleIdBJ(GetTriggerUnit()),Au)
call SaveIntegerBJ(0,6,GetHandleIdBJ(GetTriggerUnit()),Au)
if FLa()then
call SaveIntegerBJ(3,7,GetHandleIdBJ(GetTriggerUnit()),Au)
else
call SaveIntegerBJ(1,7,GetHandleIdBJ(GetTriggerUnit()),Au)
endif
call SaveIntegerBJ(Vu,8,GetHandleIdBJ(GetTriggerUnit()),Au)
call SaveRealBJ(DistanceBetweenPoints(LoadLocationHandleBJ(0,GetHandleIdBJ(GetTriggerUnit()),Au),LoadLocationHandleBJ(1,GetHandleIdBJ(GetTriggerUnit()),Au)),9,GetHandleIdBJ(GetTriggerUnit()),Au)
call SaveIntegerBJ(0,$A,GetHandleIdBJ(GetTriggerUnit()),Au)
call SaveRealBJ(.0,$B,GetHandleIdBJ(GetTriggerUnit()),Au)
call SaveBooleanBJ(true,$C,GetHandleIdBJ(GetTriggerUnit()),Au)
set Vu=Vu+1
call UnitRemoveAbilityBJ('A07X',GetTriggerUnit())
call SetPlayerAbilityAvailableBJ(true,'A07W',GetOwningPlayer(GetTriggerUnit()))
call RemoveUnit(LoadUnitHandleBJ(2,GetHandleIdBJ(GetTriggerUnit()),Au))
call RemoveUnit(LoadUnitHandleBJ(3,GetHandleIdBJ(GetTriggerUnit()),Au))
call IssueImmediateOrderBJ(GetTriggerUnit(),"stop")
call SetUnitAnimation(GetTriggerUnit(),"spell slam")
if Fma()then
call EnableTrigger(si)
endif
endfunction
function Fpa takes nothing returns nothing
local unit FPa=CreateUnitAtLoc(Player(PLAYER_NEUTRAL_PASSIVE),'h0JO',GetUnitLoc(GetSpellAbilityUnit()),GetUnitFacing(GetSpellAbilityUnit()))
call UnitAddAbility(FPa,'A0GP')
call SetUnitAbilityLevel(FPa,'A0GP',GetUnitAbilityLevel(GetSpellAbilityUnit(),'A0GL'))
call IssuePointOrderByIdLoc(FPa,$D010E,GetSpellTargetLoc())
call TriggerSleepAction(12.)
call RemoveUnit(FPa)
set FPa=null
set FPa=null
endfunction
function Fqa takes nothing returns boolean
return(GetSpellAbilityId()=='A0CW')
endfunction
function FQa takes nothing returns nothing
local timer Fsa=GetExpiredTimer()
local unit FSa=LoadUnitHandle(nr,GetHandleId(Fsa),StringHash("s"))
local effect Fta=LoadEffectHandle(nr,GetHandleId(Fsa),StringHash("e"))
call FlushChildHashtable(nr,GetHandleId(Fsa))
call DestroyTimer(Fsa)
set Fsa=null
call SaveTimerHandle(nr,GetHandleId(FSa),StringHash("daT"),null)
call DestroyEffect(Fta)
set Fta=null
call UnitRemoveAbility(FSa,'AOde')
set FSa=null
set Fsa=null
set FSa=null
set Fta=null
endfunction
function FTa takes nothing returns nothing
local unit Fua=GetSpellTargetUnit()
local player FUa=GetOwningPlayer(GetSpellAbilityUnit())
local player Fwa=GetOwningPlayer(GetSpellTargetUnit())
local effect FWa
local effect Fya
if IsUnitInGroup(GetSpellTargetUnit(),Yr) then
call AddSpecialEffectTargetUnitBJ("origin",Fua,"Abilities\\Spells\\Items\\SpellShieldAmulet\\SpellShieldCaster.mdl")
set Fua=null
set Fwa=null
set FUa=null
set FWa=null
set Fya=null
return
endif
call GroupAddUnitSimple(Fua,Yr)
call SetUnitOwner(Fua,FUa,false)
call AddSpecialEffectTargetUnitBJ("overhead",Fua,"Abilities\\Spells\\Other\\Charm\\CharmTarget.mdl")
set FWa=AddSpecialEffectTargetUnitBJ("left hand",Fua,"Abilities\\Weapons\\BansheeMissile\\BansheeMissile.mdl")
set Fya=AddSpecialEffectTargetUnitBJ("right hand",Fua,"Abilities\\Weapons\\BansheeMissile\\BansheeMissile.mdl")
call UnitAddAbility(Fua,'A0DL')
call UnitMakeAbilityPermanent(Fua,true,'A0DL')
call PolledWait(30.)
call UnitRemoveAbility(Fua,'A0DL')
call UnitRemoveBuffBJ('B02I',Fua)
call DestroyEffectBJ(FWa)
call DestroyEffectBJ(Fya)
call AddSpecialEffectTargetUnitBJ("origin",Fua,"Abilities\\Spells\\Human\\DispelMagic\\DispelMagicTarget.mdl")
call SetUnitOwner(Fua,Fwa,true)
call GroupRemoveUnitSimple(Fua,Yr)
set Fua=null
set FUa=null
set Fwa=null
set FWa=null
set Fya=null
set Fua=null
set Fwa=null
set FUa=null
set FWa=null
set Fya=null
endfunction
function FYa takes nothing returns boolean
return(GetUnitTypeId(GetEnumUnit())!='h000')and(IsUnitSelected(GetEnumUnit(),GetTriggerPlayer()))and(GetUnitAbilityLevelSwapped('A0FD',GetEnumUnit())==0)and(GetUnitAbilityLevelSwapped('A0FC',GetEnumUnit())==0)
endfunction
function Fza takes nothing returns boolean
return(FYa())
endfunction
function FZa takes nothing returns nothing
if Fza()then
call UnitAddAbilityBJ('A0FC',GetEnumUnit())
call UnitMakeAbilityPermanent(GetEnumUnit(),true,'Aetf')
endif
endfunction
function F_a takes nothing returns boolean
return true
endfunction
function F0a takes nothing returns boolean
return(F[GetConvertedPlayerId(GetTriggerPlayer())])and(GetEventPlayerChatString()=="terrain on")
endfunction
function F1a takes nothing returns boolean
return(F[GetConvertedPlayerId(GetTriggerPlayer())])and(GetEventPlayerChatString()=="terrain off")
endfunction
function F2a takes nothing returns nothing
if F0a()then
set gw=true
return
endif
if F1a()then
set gw=false
return
endif
set Tw[GetConvertedPlayerId(GetTriggerPlayer())]=S2I(SubStringBJ(GetEventPlayerChatString(),9,$B))
call GetConvertedPlayerId(GetTriggerPlayer())
endfunction
function F3a takes nothing returns boolean
return true
endfunction
function F4a takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),1,1)=="*")
endfunction
function F5a takes nothing returns boolean
return GetSpellAbilityId()=='AcS7' or GetSpellAbilityId()=='AcS8'
endfunction
function F6a takes nothing returns boolean
return(GetUnitTypeId(GetEnumUnit())!='h000')and(IsUnitSelected(GetEnumUnit(),GetTriggerPlayer()))and(GetUnitTypeId(GetEnumUnit())!='h0KW')
endfunction
function F7a takes nothing returns nothing
if F6a()then
call UnitAddTypeBJ(UNIT_TYPE_UNDEAD,GetEnumUnit())
endif
endfunction
function F8a takes nothing returns nothing
if GetUnitTypeId(GetEnumUnit())!='h000' and IsUnitSelected(GetEnumUnit(),GetTriggerPlayer()) then
call GroupRemoveUnit(Xs,GetEnumUnit())
endif
endfunction
function F9a takes nothing returns nothing
set G=GetUnitLoc(GetEnumUnit())
call CreateItemLoc('I06U',G)
call RemoveLocation(G)
endfunction
function gva takes string gea returns nothing
local integer gxa
set ZM[EM]=gea
set EM=EM+1
set gxa=0
loop
exitwhen gxa>$F
call Dyv(Wp,Ccv(Qp[gxa]),gxa,"when calling saveInt in Colors, line 207")
set gxa=gxa+1
endloop
set EM=EM-1
endfunction
function goa takes string gra returns boolean
local integer gia
local integer gaa
local integer gna
local integer gVa
local integer gEa
local integer gXa
local integer gOa
local integer gRa
local integer gIa
local integer gAa
local integer gNa
local integer gba
local integer gBa
local integer gca
local integer gCa
local integer gda
local integer gDa
local integer gfa
local integer gFa
local integer gga
local integer gGa
local integer gha
local integer gHa
local integer gja
local integer gJa
local integer gka
local integer gKa
local integer gla
local integer gLa
local integer gma
local integer gMa
local integer gpa
local integer gPa
local integer gqa
local integer gQa
local integer gsa
local integer gSa
local integer gta
local integer gTa
local integer gua
local integer gUa
local integer gwa
local integer gWa
local integer gya
local integer gYa
local integer gza
local integer gZa
local integer g_a
local integer g0a
local integer g1a
local integer g2a
local integer g3a
local integer g4a
local integer g5a
local integer g6a
local integer g7a
local integer g8a
local integer g9a
local integer Gva
local integer Gea
local integer Gxa
local integer Goa
local integer Gra
local integer Gia
local integer Gaa
local integer Gna
local integer GVa
local integer GEa
local integer GXa
local integer GOa
local integer GRa
local integer GIa
local integer GAa
local integer GNa
local integer Gba
local integer GBa
local integer Gca
local integer GCa
local integer Gda
local integer GDa
local integer Gfa
local integer GFa
local integer Gga
local integer GGa
set ZM[EM]=gra
set EM=EM+1
set gia=$FF
set gaa=$FF
set gna=$FF
set gVa=$FF
set ep=gia
set qp=gaa
set ap=gna
set np=gVa
set gEa=0
set gXa=0
set gOa=0
set gRa=0
set dp=gEa
set fp=gXa
set Rp=gOa
set Tp=gRa
set gIa=$FF
set gAa=$CC
set gNa=0
set gba=$FF
set Yp=gIa
set Gp=gAa
set gp=gNa
set hp=gba
set Fp="black"
set kp=23
set gBa=$FF
set gca=2
set gCa=2
set jp[0]=gBa
set xp[0]=gca
set vp[0]=gCa
set gda=0
set gDa=65
set gfa=$FF
set jp[1]=gda
set xp[1]=gDa
set vp[1]=gfa
set gFa=27
set gga=$E5
set gGa=$B8
set jp[2]=gFa
set xp[2]=gga
set vp[2]=gGa
set gha=83
set gHa=0
set gja=$80
set jp[3]=gha
set xp[3]=gHa
set vp[3]=gja
set gJa=$FF
set gka=$FC
set gKa=0
set jp[4]=gJa
set xp[4]=gka
set vp[4]=gKa
set gla=$FE
set gLa=$89
set gma=$D
set jp[5]=gla
set xp[5]=gLa
set vp[5]=gma
set gMa=31
set gpa=$BF
set gPa=0
set jp[6]=gMa
set xp[6]=gpa
set vp[6]=gPa
set gqa=$E4
set gQa=90
set gsa=$AF
set jp[7]=gqa
set xp[7]=gQa
set vp[7]=gsa
set gSa=$94
set gta=$95
set gTa=$96
set jp[8]=gSa
set xp[8]=gta
set vp[8]=gTa
set gua='}'
set gUa=$BE
set gwa=$F1
set jp[9]=gua
set xp[9]=gUa
set vp[9]=gwa
set gWa=$F
set gya=97
set gYa=69
set jp[$A]=gWa
set xp[$A]=gya
set vp[$A]=gYa
set gza=77
set gZa=41
set g_a=3
set jp[$B]=gza
set xp[$B]=gZa
set vp[$B]=g_a
set g0a=$9B
set g1a=0
set g2a=0
set jp[$C]=g0a
set xp[$C]=g1a
set vp[$C]=g2a
set g3a=0
set g4a=0
set g5a=$C3
set jp[$D]=g3a
set xp[$D]=g4a
set vp[$D]=g5a
set g6a=0
set g7a=$EA
set g8a=$FF
set jp[$E]=g6a
set xp[$E]=g7a
set vp[$E]=g8a
set g9a=$BE
set Gva=0
set Gea=$FE
set jp[$F]=g9a
set xp[$F]=Gva
set vp[$F]=Gea
set Gxa=$EB
set Goa=$CD
set Gra=$87
set jp[16]=Gxa
set xp[16]=Goa
set vp[16]=Gra
set Gia=$F8
set Gaa=$A4
set Gna=$8B
set jp[17]=Gia
set xp[17]=Gaa
set vp[17]=Gna
set GVa=$BF
set GEa=$FF
set GXa=$80
set jp[18]=GVa
set xp[18]=GEa
set vp[18]=GXa
set GOa=$DC
set GRa=$B9
set GIa=$EB
set jp[19]=GOa
set xp[19]=GRa
set vp[19]=GIa
set GAa=40
set GNa=40
set Gba=40
set jp[20]=GAa
set xp[20]=GNa
set vp[20]=Gba
set GBa=$EB
set Gca=$F0
set GCa=$FF
set jp[21]=GBa
set xp[21]=Gca
set vp[21]=GCa
set Gda=0
set GDa='x'
set Gfa=30
set jp[22]=Gda
set xp[22]=GDa
set vp[22]=Gfa
set GFa=$A4
set Gga=$B
set GGa=51
set jp[23]=GFa
set xp[23]=Gga
set vp[23]=GGa
set mp[0]="red"
set mp[1]="blue"
set mp[2]="teal"
set mp[3]="purple"
set mp[4]="yellow"
set mp[5]="orange"
set mp[6]="green"
set mp[7]="pink"
set mp[8]="gray"
set mp[9]="light blue"
set mp[$A]="dark green"
set mp[$B]="brown"
set mp[$C]="maroon"
set mp[$D]="navy"
set mp[$E]="turquoise"
set mp[$F]="violet"
set mp[16]="wheat"
set mp[17]="peach"
set mp[18]="mint"
set mp[19]="lavender"
set mp[20]="coal"
set mp[21]="snow"
set mp[22]="emerald"
set mp[23]="peanut"
set Qp[0]="0"
set Qp[1]="1"
set Qp[2]="2"
set Qp[3]="3"
set Qp[4]="4"
set Qp[5]="5"
set Qp[6]="6"
set Qp[7]="7"
set Qp[8]="8"
set Qp[9]="9"
set Qp[$A]="A"
set Qp[$B]="B"
set Qp[$C]="C"
set Qp[$D]="D"
set Qp[$E]="E"
set Qp[$F]="F"
set Wp=a6x("when calling new_Table in Colors, line 155")
call gva("when calling initializeTable in Colors, line 210")
set EM=EM-1
return true
endfunction
function Gha takes nothing returns boolean
set EM=0
return goa("Colors, line 1")
endfunction
function GHa takes nothing returns nothing
local unit Gja=LoadUnitHandle(i,NO,GetHandleId(GetExpiredTimer()))
call Gmv(GetExpiredTimer())
call BlzSetUnitAbilityManaCost(Gja,JO,1,BlzGetUnitAbilityManaCost(Gja,JO,1)+30)
call BlzSetUnitAbilityManaCost(Gja,JO,2,BlzGetUnitAbilityManaCost(Gja,JO,2)+30)
call BlzSetUnitAbilityManaCost(Gja,JO,3,BlzGetUnitAbilityManaCost(Gja,JO,3)+30)
set Gja=null
set Gja=null
endfunction
function GJa takes nothing returns boolean
return(GetSpellAbilityId()=='A06X')
endfunction
function Gka takes integer GKa returns nothing
set hW[GKa]=0
set FW[GKa]=0
set jW[GKa]=null
endfunction
function Gla takes integer GLa returns nothing
call Gka(GLa)
endfunction
function Gma takes string GMa returns integer
local integer Gpa
set ZM[EM]=GMa
set EM=EM+1
if Sx==0 then
if cx<$8000 then
set cx=cx+1
set Gpa=cx
set ox[Gpa]=$EED
else
call Cdv("Out of memory: Could not create BuiltinSpecialForm.","when calling error in ScmdDataTypes, line 1538")
set Gpa=0
endif
else
set Sx=Sx-1
set Gpa=ix[Sx]
set ox[Gpa]=$EED
endif
set EM=EM-1
return Gpa
endfunction
function GPa takes integer Gqa,string GQa returns nothing
set ZM[EM]=GQa
set EM=EM+1
set ZJ[Gqa]=TEv("when calling new_HashList in ScmdDataTypes, line 1429")
set UJ[Gqa]=0
set EM=EM-1
endfunction
function Gsa takes integer GSa,string Gta returns nothing
set ZM[EM]=Gta
set EM=EM+1
call GPa(GSa,"when calling construct_BuiltinSpecialForm_BuiltinModule in ScmdDataTypes, line 1428")
set EM=EM-1
endfunction
function GTa takes integer Gua,integer GUa,string Gwa returns nothing
local integer GWa
set ZM[EM]=Gwa
set EM=EM+1
if vJ[GUa]then
if UJ[Gua]!=0 then
call JDv(UJ[Gua],"when calling dispatch_BuiltinData_destroyBuiltinData in ScmdDataTypes, line 1435")
endif
set UJ[Gua]=GUa
else
call dlv(ZJ[Gua],0,"when calling add in ScmdDataTypes, line 1438")
set GWa=dgv(ZJ[Gua],"when calling size in ScmdDataTypes, line 1439")-2
loop
exitwhen not(GWa>=0 and xJ[GUa]<xJ[jqv(ZJ[Gua],GWa,"when calling get in ScmdDataTypes, line 1440")])
call Ixo(ZJ[Gua],GWa+1,jqv(ZJ[Gua],GWa,"when calling get in ScmdDataTypes, line 1441"),"when calling set in ScmdDataTypes, line 1441")
set GWa=GWa-1
endloop
call Ixo(ZJ[Gua],GWa+1,GUa,"when calling set in ScmdDataTypes, line 1443")
endif
set EM=EM-1
endfunction
function Gya takes integer GYa,integer Gza,string GZa returns nothing
set ZM[EM]=GZa
set EM=EM+1
if ox[GYa]==0 then
if GYa==0 then
call Cdv("Nullpointer exception when calling BuiltinSpecialForm.addOverload","when calling error in ScmdDataTypes, line 1432")
else
call Cdv("Called BuiltinSpecialForm.addOverload on invalid object.","when calling error in ScmdDataTypes, line 1432")
endif
endif
call GTa(GYa,Gza,"when calling addOverload in ScmdDataTypes, line 1432")
set EM=EM-1
endfunction
function G_a takes integer G0a,integer G1a,string G2a returns nothing
set ZM[EM]=G2a
set EM=EM+1
call Gsa(G0a,"when calling BuiltinSpecialForm_init in ScmdDataTypes, line 1544")
call Gya(G0a,G1a,"when calling addOverload in ScmdDataTypes, line 1545")
set EM=EM-1
endfunction
function G3a takes integer G4a,string G5a returns integer
local integer G6a
set ZM[EM]=G5a
set EM=EM+1
set G6a=Gma("when calling alloc_BuiltinSpecialForm in ScmdDataTypes, line 1544")
call G_a(G6a,G4a,"when calling construct_BuiltinSpecialForm in ScmdDataTypes, line 1544")
set EM=EM-1
return G6a
endfunction
function G7a takes string G8a returns integer
local integer G9a
set ZM[EM]=G8a
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set G9a=Yj
set Gj[G9a]=$B1E
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_SotfrpGuiRegions.","when calling error in SotfrpGuiRegions, line 180")
set G9a=0
endif
else
set Tj=Tj-1
set G9a=Rj[Tj]
set Gj[G9a]=$B1E
endif
set EM=EM-1
return G9a
endfunction
function hva takes string hea returns integer
local integer hxa
set ZM[EM]=hea
set EM=EM+1
if BG==0 then
if NG<$8000 then
set NG=NG+1
set hxa=NG
set MG[hxa]=$F3E
else
call Cdv("Out of memory: Could not create OnCastListener_onCast_SotfrpGuiRegions.","when calling error in SotfrpGuiRegions, line 249")
set hxa=0
endif
else
set BG=BG-1
set hxa=VG[BG]
set MG[hxa]=$F3E
endif
set EM=EM-1
return hxa
endfunction
function hoa takes string hra returns integer
local integer hia
set ZM[EM]=hra
set EM=EM+1
if BG==0 then
if NG<$8000 then
set NG=NG+1
set hia=NG
set MG[hia]=$F42
else
call Cdv("Out of memory: Could not create OnPointCast_onPointCast_SotfrpGuiRegions.","when calling error in SotfrpGuiRegions, line 236")
set hia=0
endif
else
set BG=BG-1
set hia=VG[BG]
set MG[hia]=$F42
endif
set EM=EM-1
return hia
endfunction
function haa takes unit hna,integer hVa,integer hEa,string hXa returns integer
set ZM[EM]=hXa
set EM=EM+1
set kW[hEa]=hVa
if hna!=null then
set jW[hEa]=hna
if fov(My,Hzo(hna),"when calling has in ClosureEvents, line 156")then
set FW[f3v(My,Hzo(hna),"when calling get in ClosureEvents, line 157")]=hEa
set hW[hEa]=f3v(My,Hzo(hna),"when calling get in ClosureEvents, line 158")
endif
call fqv(My,Hzo(hna),hEa,"when calling put in ClosureEvents, line 159")
else
if fov(Ny,hVa,"when calling has in ClosureEvents, line 161")then
set FW[f3v(Ny,hVa,"when calling get in ClosureEvents, line 162")]=hEa
set hW[hEa]=f3v(Ny,hVa,"when calling get in ClosureEvents, line 163")
endif
call fqv(Ny,hVa,hEa,"when calling put in ClosureEvents, line 165")
endif
set EM=EM-1
return hEa
endfunction
function hOa takes unit hRa,integer hIa,integer hAa,string hNa returns integer
local integer hba
set ZM[EM]=hNa
set EM=EM+1
set hba=haa(hRa,hIa,hAa,"when calling addSpellInternal in ClosureEvents, line 132")
set EM=EM-1
return hba
endfunction
function hBa takes string hca returns integer
local integer hCa
set ZM[EM]=hca
set EM=EM+1
if BG==0 then
if NG<$8000 then
set NG=NG+1
set hCa=NG
set MG[hCa]=$F3D
else
call Cdv("Out of memory: Could not create OnCastListener_onCast_SotfrpGuiRegions.","when calling error in SotfrpGuiRegions, line 245")
set hCa=0
endif
else
set BG=BG-1
set hCa=VG[BG]
set MG[hCa]=$F3D
endif
set EM=EM-1
return hCa
endfunction
function hda takes nothing returns integer
return Kn
endfunction
function hDa takes integer hfa,integer hFa,boolean hga returns nothing
local player hGa=sa[hfa]
local integer hha=hFa
local integer hHa
if hga then
set hHa=1
else
set hHa=0
endif
call SetPlayerTechResearched(hGa,hha,hHa)
set hGa=null
endfunction
function hja takes integer hJa,integer hka returns nothing
call hDa(hJa,hka,true)
endfunction
function hKa takes string hla returns integer
local integer hLa
set ZM[EM]=hla
set EM=EM+1
if BG==0 then
if NG<$8000 then
set NG=NG+1
set hLa=NG
set MG[hLa]=$F39
else
call Cdv("Out of memory: Could not create OnCastListener_onCast_SotfrpGuiRegions.","when calling error in SotfrpGuiRegions, line 219")
set hLa=0
endif
else
set BG=BG-1
set hLa=VG[BG]
set MG[hLa]=$F39
endif
set EM=EM-1
return hLa
endfunction
function hma takes string hMa returns integer
local integer hpa
set ZM[EM]=hMa
set EM=EM+1
if BG==0 then
if NG<$8000 then
set NG=NG+1
set hpa=NG
set MG[hpa]=$F37
else
call Cdv("Out of memory: Could not create OnCastListener_onCast_SotfrpGuiRegions.","when calling error in SotfrpGuiRegions, line 213")
set hpa=0
endif
else
set BG=BG-1
set hpa=VG[BG]
set MG[hpa]=$F37
endif
set EM=EM-1
return hpa
endfunction
function hPa takes string hqa returns integer
local integer hQa
set ZM[EM]=hqa
set EM=EM+1
if BG==0 then
if NG<$8000 then
set NG=NG+1
set hQa=NG
set MG[hQa]=$F38
else
call Cdv("Out of memory: Could not create OnCastListener_onCast_SotfrpGuiRegions.","when calling error in SotfrpGuiRegions, line 216")
set hQa=0
endif
else
set BG=BG-1
set hQa=VG[BG]
set MG[hQa]=$F38
endif
set EM=EM-1
return hQa
endfunction
function hsa takes string hSa returns integer
local integer hta
set ZM[EM]=hSa
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set hta=Yj
set Gj[hta]=$B1C
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_SotfrpGuiRegions.","when calling error in SotfrpGuiRegions, line 122")
set hta=0
endif
else
set Tj=Tj-1
set hta=Rj[Tj]
set Gj[hta]=$B1C
endif
set EM=EM-1
return hta
endfunction
function hTa takes integer hec,string Fec,integer kec returns nothing
endfunction
function hua takes integer hUa,string hwa,integer hWa returns nothing
if tQ[hUa]!=0 and iQ[hUa]then
call hTa(tQ[hUa],hwa,hWa)
endif
endfunction
function hya takes integer hYa,string hza,integer hZa,string h_a returns nothing
set ZM[EM]=h_a
set EM=EM+1
if tY[hYa]==0 then
if hYa==0 then
call Cdv("Nullpointer exception when calling AbilityDefinition.addTooltipProperty","when calling error in AbilityObjEditing, line 69")
else
call Cdv("Called AbilityDefinition.addTooltipProperty on invalid object.","when calling error in AbilityObjEditing, line 69")
endif
endif
call hua(hYa,hza,hZa)
set EM=EM-1
endfunction
function h0a takes integer Eku,string Zku,integer Uku,integer Iku,string Pku returns nothing
endfunction
function h1a takes integer CZi,integer VZi returns string
return"smart"
endfunction
function h2a takes integer h3a,integer Vns returns string
return aW[nW[h3a]]
endfunction
function h4a takes integer gPi,integer hPi returns string
return"auravampiric"
endfunction
function h5a takes integer TPi,integer YPi returns string
return"auraunholy"
endfunction
function h6a takes integer TZi,integer YZi returns string
return"dispelmagic"
endfunction
function h7a takes integer Tbt,integer Ybt returns string
return"Бросок костей судьбы, дающих случайное боевое усиление. Время действия - "+SMv(Qa)+" сек."
endfunction
function h8a takes integer APi,integer DPi returns string
return"berserk"
endfunction
function h9a takes string Hva returns integer
local integer Hea
set ZM[EM]=Hva
set EM=EM+1
if FF==0 then
if kF<$8000 then
set kF=kF+1
set Hea=kF
set jF[Hea]=4968
else
call Cdv("Out of memory: Could not create ToStringClosure_joinBy_ObjectIds.","when calling error in ObjectIds, line 56")
set Hea=0
endif
else
set FF=FF-1
set Hea=hF[FF]
set jF[Hea]=4968
endif
set EM=EM-1
return Hea
endfunction
function Hxa takes integer ESS,integer Hoa returns string
return d0v(Hoa)
endfunction
function Hra takes integer sPi,integer Hia returns string
return d0v(Hia)
endfunction
function Haa takes integer jUi,integer Hna returns string
return d0v(Hna)
endfunction
function HVa takes integer lwt,integer HEa returns string
return d0v(HEa)
endfunction
function HXa takes integer HOa,integer HRa,string HIa returns string
local string HAa
set ZM[EM]=HIa
set EM=EM+1
if jF[HOa]==0 then
if HOa==0 then
call Cdv("Nullpointer exception when calling ToStringClosure.toString","when calling error in LinkedList, line 557")
else
call Cdv("Called ToStringClosure.toString on invalid object.","when calling error in LinkedList, line 557")
endif
endif
if jF[HOa]<=4969 then
if jF[HOa]<=4968 then
set HAa=HVa(HOa,HRa)
else
set HAa=Hxa(HOa,HRa)
endif
elseif jF[HOa]<=4970 then
set HAa=Haa(HOa,HRa)
else
set HAa=Hra(HOa,HRa)
endif
set EM=EM-1
return HAa
endfunction
function HNa takes integer Hba,integer HBa,string Hca,string HCa returns string
local integer Hda
local integer HDa
local integer Hfa
local integer HFa
local string Hga
set ZM[EM]=HCa
set EM=EM+1
set Hda=hNe(Hba,"when calling iterator in LinkedList, line 560")
set HDa=yTv("when calling new_LinkedList in LinkedList, line 561")
set HFa=Hda
loop
exitwhen not Xie(HFa)
set Hfa=E3e(HFa)
call zGv(HDa,KCv(HXa(HBa,Hfa,"when calling toString in LinkedList, line 564"),"when calling stringToIndex in LinkedList, line 564"),"when calling add in LinkedList, line 564")
endloop
call hCe(Hda,"when calling close in LinkedList, line 566")
set Hga=hhe(HDa,Hca,"when calling joinBy in LinkedList, line 567")
call Hcv(HDa,"when calling dispatch_LinkedList_destroyLinkedList in LinkedList, line 568")
set EM=EM-1
return Hga
endfunction
function HGa takes integer Hha,integer HHa,integer Hja,integer HJa,string Hka returns string
local integer HKa
local string Hla
local integer HLa
local integer Hma
set ZM[EM]=Hka
set EM=EM+1
set HKa=yTv("when calling new_LinkedList in ObjectIds, line 53")
call zGv(HKa,Hha,"when calling add in ObjectIds, line 55")
call zGv(HKa,HHa,"when calling add in ObjectIds, line 55")
call zGv(HKa,Hja,"when calling add in ObjectIds, line 55")
call zGv(HKa,HJa,"when calling add in ObjectIds, line 55")
set Hma=HKa
set HLa=h9a("when calling alloc_ToStringClosure_joinBy_ObjectIds in ObjectIds, line 56")
set Hla=HNa(Hma,HLa,",","when calling joinBy in ObjectIds, line 56")
call Hcv(HKa,"when calling dispatch_LinkedList_destroyLinkedList in ObjectIds, line 57")
set EM=EM-1
return Hla
endfunction
function HMa takes integer AEi,integer DEi,string Hpa returns string
local string HPa
set ZM[EM]=Hpa
set EM=EM+1
set HPa=HGa(Wf,Wf,Wf,Wf,"when calling commaList in SotfrpGuiDestructables, line 123")
set EM=EM-1
return HPa
endfunction
function Hqa takes integer JPi,integer KPi returns string
return"defend"
endfunction
function HQa takes integer IKi,integer PKi returns integer
return 0
endfunction
function Hsa takes integer Ids,integer Pds returns integer
return 9
endfunction
function HSa takes integer Phs,integer Ahs returns integer
return 0
endfunction
function Hta takes integer HTa,integer JeS returns integer
return qM[HTa]
endfunction
function Hua takes integer fUi,integer RUi returns integer
return je
endfunction
function HUa takes integer mds,integer Qds returns integer
return 90
endfunction
function Hwa takes integer HWa,integer Tis returns integer
return cQ[oQ[HWa]]
endfunction
function Hya takes integer Wbt,integer HYa returns integer
return $A*HYa
endfunction
function Hza takes integer HZa,integer nds returns integer
return qW[TW[HZa]]
endfunction
function H_a takes integer YKi,integer GKi returns integer
return $87
endfunction
function H0a takes integer YUi,integer GUi returns integer
return je
endfunction
function H1a takes integer SWi,integer cWi returns integer
return $A
endfunction
function H2a takes integer H3a,integer eds returns integer
return RW[H3a]
endfunction
function H4a takes integer H5a,integer Mns returns integer
return dW[H5a]
endfunction
function H6a takes integer kbt,integer jbt returns integer
return 25
endfunction
function H7a takes integer H8a,integer H9a,string jva returns integer
local integer jea
set ZM[EM]=jva
set EM=EM+1
if oY[H8a]==0 then
if H8a==0 then
call Cdv("Nullpointer exception when calling IntLevelClosure.run","when calling error in ObjEditingNatives, line 10")
else
call Cdv("Called IntLevelClosure.run on invalid object.","when calling error in ObjEditingNatives, line 10")
endif
endif
if oY[H8a]<=$C50 then
if oY[H8a]<=$C4C then
if oY[H8a]<=$C4A then
if oY[H8a]<=$C49 then
set jea=Hya(H8a,H9a)
else
set jea=H1a(H8a,H9a)
endif
elseif oY[H8a]<=$C4B then
set jea=Hta(H8a,H9a)
else
set jea=H4a(H8a,H9a)
endif
elseif oY[H8a]<=$C4E then
if oY[H8a]<=$C4D then
set jea=H6a(H8a,H9a)
else
set jea=H_a(H8a,H9a)
endif
elseif oY[H8a]<=$C4F then
set jea=HUa(H8a,H9a)
else
set jea=HQa(H8a,H9a)
endif
elseif oY[H8a]<=$C54 then
if oY[H8a]<=$C52 then
if oY[H8a]<=$C51 then
set jea=H0a(H8a,H9a)
else
set jea=Hua(H8a,H9a)
endif
elseif oY[H8a]<=$C53 then
set jea=Hza(H8a,H9a)
else
set jea=Hwa(H8a,H9a)
endif
elseif oY[H8a]<=$C56 then
if oY[H8a]<=$C55 then
set jea=Hsa(H8a,H9a)
else
set jea=HSa(H8a,H9a)
endif
else
set jea=H2a(H8a,H9a)
endif
set EM=EM-1
return jea
endfunction
function jxa takes integer joa,integer jra,string jia returns string
local string jaa
set ZM[EM]=jia
set EM=EM+1
set jaa=SMv(H7a(OQ[joa],jra,"when calling run in AbilityObjEditing, line 74"))
set EM=EM-1
return jaa
endfunction
function jna takes integer IUi,integer PUi returns real
return DQv(je)
endfunction
function jVa takes integer CKi,integer VKi returns real
return DQv(GR)
endfunction
function jEa takes integer Cds,integer jXa returns real
return DQv(Iy)*jXa
endfunction
function jOa takes integer LEi,integer XEi returns real
return .01
endfunction
function jRa takes integer Lbt,integer jIa returns real
return 10.*jIa
endfunction
function jAa takes integer Lhs,integer Xhs returns integer
return 0
endfunction
function jNa takes integer Pas,integer Aas returns integer
return-1
endfunction
function jba takes integer gbt,integer hbt returns integer
return 5
endfunction
function jBa takes integer TWi,integer YWi returns real
return DQv(je)
endfunction
function jca takes integer DKi,integer HKi returns real
return .75
endfunction
function jCa takes integer Dds,integer Hds returns real
return DQv(Py)
endfunction
function jda takes integer Has,integer Jas returns integer
return-1
endfunction
function jDa takes integer Hbt,integer Jbt returns real
return DQv(Qa)
endfunction
function jfa takes integer Hhs,integer Jhs returns integer
return 0
endfunction
function jFa takes integer BPi,integer NPi returns real
return DQv(je)
endfunction
function jga takes integer VEi,integer BEi returns real
return DQv(je)
endfunction
function jGa takes integer Vhs,integer Bhs returns integer
return 0
endfunction
function jha takes integer cds,integer ods returns real
return .0
endfunction
function jHa takes integer vbt,integer mbt returns real
return DQv(Qa)
endfunction
function jja takes integer dWi,integer fWi returns real
return DQv(je)
endfunction
function jJa takes integer dZi,integer fZi returns integer
return $C8
endfunction
function jka takes integer fKi,integer RKi returns integer
return 30
endfunction
function jKa takes integer fYt,integer RYt returns real
return .01
endfunction
function jla takes integer EKi,integer ZKi returns integer
return 0
endfunction
function jLa takes integer Eds,integer Zds returns real
return .75
endfunction
function jma takes integer Kds,integer Lds returns real
return DQv(Py)
endfunction
function jMa takes integer OWi,integer lWi returns integer
return 0
endfunction
function jpa takes integer Oyt,integer lyt returns real
return DQv(Qa)
endfunction
function jPa takes integer yPi,integer pPi returns real
return DQv(je)
endfunction
function jqa takes integer yWi,integer pWi returns integer
return 0
endfunction
function jQa takes integer yyt,integer jsa returns real
return 10.*jsa
endfunction
function jSa takes integer YYt,integer GYt returns real
return .01
endfunction
function jta takes integer hKi,integer FKi returns real
return .75
endfunction
function jTa takes integer hds,integer Fds returns real
return Dy/2.
endfunction
function jua takes integer qWi,integer aWi returns real
return DQv(je)
endfunction
function jUa takes integer qyt,integer ayt returns integer
return 0
endfunction
function jwa takes integer pks,integer eks returns integer
return-1
endfunction
function jWa takes integer jya,integer rds returns real
return fW[jya]
endfunction
function jYa takes integer ufs,integer rfs returns real
return Ay
endfunction
function jza takes integer jds,integer xds returns integer
return 6
endfunction
function jZa takes integer NZi,integer MZi returns real
return DQv(je)
endfunction
function j_a takes integer Nds,integer Mds returns real
return Ay
endfunction
function j0a takes integer lds,integer bds returns real
return .0
endfunction
function j1a takes integer lks,integer bks returns integer
return-1
endfunction
function j2a takes integer j3a,integer j4a,string j5a returns real
local real j6a
set ZM[EM]=j5a
set EM=EM+1
if JG[j3a]==0 then
if j3a==0 then
call Cdv("Nullpointer exception when calling RealLevelClosure.run","when calling error in ObjEditingNatives, line 13")
else
call Cdv("Called RealLevelClosure.run on invalid object.","when calling error in ObjEditingNatives, line 13")
endif
endif
if JG[j3a]<=4185 then
if JG[j3a]<=4174 then
if JG[j3a]<=4169 then
if JG[j3a]<=4166 then
if JG[j3a]<=4165 then
if JG[j3a]<=4164 then
set j6a=jHa(j3a,j4a)
else
set j6a=jDa(j3a,j4a)
endif
else
set j6a=jpa(j3a,j4a)
endif
elseif JG[j3a]<=4168 then
if JG[j3a]<=4167 then
set j6a=jVa(j3a,j4a)
else
set j6a=jJa(j3a,j4a)
endif
else
set j6a=j0a(j3a,j4a)
endif
elseif JG[j3a]<=4172 then
if JG[j3a]<=4171 then
if JG[j3a]<=4170 then
set j6a=j_a(j3a,j4a)
else
set j6a=jAa(j3a,j4a)
endif
else
set j6a=jRa(j3a,j4a)
endif
elseif JG[j3a]<=4173 then
set j6a=jna(j3a,j4a)
else
set j6a=jPa(j3a,j4a)
endif
elseif JG[j3a]<=4180 then
if JG[j3a]<=4177 then
if JG[j3a]<=4176 then
if JG[j3a]<=4175 then
set j6a=jZa(j3a,j4a)
else
set j6a=jBa(j3a,j4a)
endif
else
set j6a=jja(j3a,j4a)
endif
elseif JG[j3a]<=4179 then
if JG[j3a]<=4178 then
set j6a=jga(j3a,j4a)
else
set j6a=jua(j3a,j4a)
endif
else
set j6a=jTa(j3a,j4a)
endif
elseif JG[j3a]<=4183 then
if JG[j3a]<=4182 then
if JG[j3a]<=4181 then
set j6a=jFa(j3a,j4a)
else
set j6a=jQa(j3a,j4a)
endif
else
set j6a=jUa(j3a,j4a)
endif
elseif JG[j3a]<=4184 then
set j6a=jWa(j3a,j4a)
else
set j6a=jba(j3a,j4a)
endif
elseif JG[j3a]<=4196 then
if JG[j3a]<=4191 then
if JG[j3a]<=4188 then
if JG[j3a]<=4187 then
if JG[j3a]<=4186 then
set j6a=jka(j3a,j4a)
else
set j6a=jza(j3a,j4a)
endif
else
set j6a=jla(j3a,j4a)
endif
elseif JG[j3a]<=4190 then
if JG[j3a]<=4189 then
set j6a=jEa(j3a,j4a)
else
set j6a=jfa(j3a,j4a)
endif
else
set j6a=jda(j3a,j4a)
endif
elseif JG[j3a]<=4194 then
if JG[j3a]<=4193 then
if JG[j3a]<=4192 then
set j6a=jwa(j3a,j4a)
else
set j6a=jSa(j3a,j4a)
endif
else
set j6a=jqa(j3a,j4a)
endif
elseif JG[j3a]<=4195 then
set j6a=jma(j3a,j4a)
else
set j6a=jOa(j3a,j4a)
endif
elseif JG[j3a]<=4202 then
if JG[j3a]<=4199 then
if JG[j3a]<=4198 then
if JG[j3a]<=4197 then
set j6a=jNa(j3a,j4a)
else
set j6a=j1a(j3a,j4a)
endif
else
set j6a=jKa(j3a,j4a)
endif
elseif JG[j3a]<=4201 then
if JG[j3a]<=4200 then
set j6a=jMa(j3a,j4a)
else
set j6a=jCa(j3a,j4a)
endif
else
set j6a=jha(j3a,j4a)
endif
elseif JG[j3a]<=4205 then
if JG[j3a]<=4204 then
if JG[j3a]<=4203 then
set j6a=jLa(j3a,j4a)
else
set j6a=jta(j3a,j4a)
endif
else
set j6a=jca(j3a,j4a)
endif
elseif JG[j3a]<=4206 then
set j6a=jYa(j3a,j4a)
else
set j6a=jGa(j3a,j4a)
endif
set EM=EM-1
return j6a
endfunction
function j7a takes integer j8a,integer j9a,string Jva returns string
local string Jea
set ZM[EM]=Jva
set EM=EM+1
set Jea=qwv(j2a(lQ[j8a],j9a,"when calling run in AbilityObjEditing, line 77"))
set EM=EM-1
return Jea
endfunction
function Jxa takes integer Joa,integer oSs returns string
return pQ[Joa]
endfunction
function Jra takes integer UEi,integer IEi returns string
return"frenzy"
endfunction
function Jia takes integer UPi,integer IPi returns string
return"bearform"
endfunction
function Jaa takes string Jna,string JVa returns string
return Jna+" (|cFFFFCC00"+JVa+"|r)"
endfunction
function JEa takes string JXa,integer JOa returns string
return JXa+", [|cFFFFCC00Уровень "+SMv(JOa)+"|r]"
endfunction
function JRa takes integer JIa,integer JAa returns string
return Jaa(JEa(HC[JC[JIa]],JAa),DC[JC[JIa]])
endfunction
function JNa takes integer vPi,integer mPi returns string
return"avengerform"
endfunction
function Jba takes integer JBa,integer fPi returns string
return IL[JBa]
endfunction
function Jca takes string JCa,string Jda,string JDa,string Jfa,string JFa,string Jga,string JGa,string Jha returns string
local integer JHa
local string Jja
set ZM[EM]=Jha
set EM=EM+1
set JHa=yTv("when calling new_LinkedList in ObjectIds, line 61")
call zGv(JHa,KCv(JCa,"when calling stringToIndex in ObjectIds, line 63"),"when calling add in ObjectIds, line 63")
call zGv(JHa,KCv(Jda,"when calling stringToIndex in ObjectIds, line 63"),"when calling add in ObjectIds, line 63")
call zGv(JHa,KCv(JDa,"when calling stringToIndex in ObjectIds, line 63"),"when calling add in ObjectIds, line 63")
call zGv(JHa,KCv(Jfa,"when calling stringToIndex in ObjectIds, line 63"),"when calling add in ObjectIds, line 63")
call zGv(JHa,KCv(JFa,"when calling stringToIndex in ObjectIds, line 63"),"when calling add in ObjectIds, line 63")
call zGv(JHa,KCv(Jga,"when calling stringToIndex in ObjectIds, line 63"),"when calling add in ObjectIds, line 63")
call zGv(JHa,KCv(JGa,"when calling stringToIndex in ObjectIds, line 63"),"when calling add in ObjectIds, line 63")
set Jja=hhe(JHa,",","when calling joinBy in ObjectIds, line 64")
call Hcv(JHa,"when calling dispatch_LinkedList_destroyLinkedList in ObjectIds, line 65")
set EM=EM-1
return Jja
endfunction
function JJa takes integer rFs,integer sFs,string Jka returns string
local string JKa
set ZM[EM]=Jka
set EM=EM+1
set JKa=Jca(CR,wT,NR,VR,BR,MR,uT,"when calling commaList in DummyBuffs, line 53")
set EM=EM-1
return JKa
endfunction
function Jla takes integer JLa,integer iSs returns string
return yQ[JLa]
endfunction
function Jma takes string JMa,integer Jpa returns string
return JMa+", [|cFFFFCC00Уровень "+SMv(Jpa)+"|r]"
endfunction
function JPa takes string Jqa,string JQa returns string
return Jqa+" (|cFFFFCC00"+JQa+"|r)"
endfunction
function Jsa takes integer fds,integer JSa returns string
return JPa(Jma("Рассекающий удар",JSa),Jy)
endfunction
function Jta takes integer JTa,integer ZUi returns string
return vL[JTa]
endfunction
function Jua takes integer XPi,integer CPi returns string
return"dismount"
endfunction
function JUa takes integer mKi,integer QKi returns string
return"Досрочный взрыв гранаты."
endfunction
function Jwa takes integer mSS,integer QSS returns string
return UT
endfunction
function JWa takes integer Jya,integer JYa returns integer
return JYa*4+Jya
endfunction
function Jza takes integer JZa,integer QUi returns string
return Vgx(kL[JZa],Bf[JWa(jL[JZa],xL[JZa])])
endfunction
function J_a takes integer KKi,integer LKi returns string
return d0v(RR)+","+d0v(TR)
endfunction
function J0a takes integer WPi,integer EPi returns string
return"battleroar"
endfunction
function J1a takes integer J2a,integer lPi returns string
return ZL[J2a]
endfunction
function J3a takes integer aKi,integer nKi returns string
return"Бросок прилипающей к цели гранаты, которая взрывается при повторном использовании способности "+"или по окончанию времени действия, нанося "+SMv(YR)+" ед. осадного урона основной цели и всем войскам вокруг "+"и оглушая их на "+SMv(YR)+" сек.|nВремя действия - "+SMv(GR)+" сек."
endfunction
function J4a takes integer YSS,integer GSS returns string
return ZT
endfunction
function J5a takes integer Yds,integer J6a returns string
return"Воин поражает размашистым ударом всех противников перед собой, нанося им "+SMv(Zy*J6a)+" ед. физического урона. "+"При поражении "+SMv(Uy)+" целей или более, воин наносит им глубокие раны, из-за которых цели получают "+SMv(Iy*J6a)+" ед. урона ежесекундно в течение "+SMv(Py)+" сек., "+"а их скорости боя и передвижения снижаются на "+SMv(c6v(Ay*100.))+"%."
endfunction
function J7a takes integer sAi,integer tAi returns string
return"divineshield"
endfunction
function J8a takes integer hSS,integer FSS returns string
return""
endfunction
function J9a takes integer kva,integer FUi returns string
return FL[kva]
endfunction
function kea takes integer kxa,integer aPi returns string
return UL[kxa]
endfunction
function koa takes integer SAi,integer cAi returns string
return"fanofknives"
endfunction
function kra takes integer kia,integer cPi returns string
return Vgx(QL[kia],Mf[JWa(WL[kia],EL[kia])])
endfunction
function kaa takes integer kna,integer kVa,string kEa returns string
local integer kXa
local string kOa
local integer kRa
local integer kIa
set ZM[EM]=kEa
set EM=EM+1
set kXa=yTv("when calling new_LinkedList in ObjectIds, line 53")
call zGv(kXa,kna,"when calling add in ObjectIds, line 55")
call zGv(kXa,kVa,"when calling add in ObjectIds, line 55")
set kIa=kXa
set kRa=h9a("when calling alloc_ToStringClosure_joinBy_ObjectIds in ObjectIds, line 56")
set kOa=HNa(kIa,kRa,",","when calling joinBy in ObjectIds, line 56")
call Hcv(kXa,"when calling dispatch_LinkedList_destroyLinkedList in ObjectIds, line 57")
set EM=EM-1
return kOa
endfunction
function kAa takes integer tfs,integer ifs,string kNa returns string
local string kba
set ZM[EM]=kNa
set EM=EM+1
set kba=kaa(Wy,Ey,"when calling commaList in Cleave, line 73")
set EM=EM-1
return kba
endfunction
function kBa takes string kca,string kCa returns string
return kca+" (|cFFFFCC00"+kCa+"|r)"
endfunction
function kda takes integer pKi,integer eKi returns string
return kBa("Липкая граната",gR)
endfunction
function kDa takes integer wAi,integer uAi returns string
return"attackground"
endfunction
function kfa takes integer Zas,integer Uas returns boolean
return false
endfunction
function kFa takes integer cks,integer oks returns boolean
return false
endfunction
function kga takes integer tds,integer ids returns boolean
return false
endfunction
function kGa takes integer kha,integer kHa,string kja returns boolean
local boolean kJa
set ZM[EM]=kja
set EM=EM+1
if PG[kha]==0 then
if kha==0 then
call Cdv("Nullpointer exception when calling BooleanLevelClosure.run","when calling error in ObjEditingNatives, line 16")
else
call Cdv("Called BooleanLevelClosure.run on invalid object.","when calling error in ObjEditingNatives, line 16")
endif
endif
if PG[kha]<=$414 then
if PG[kha]<=$413 then
set kJa=kfa(kha,kHa)
else
set kJa=kFa(kha,kHa)
endif
else
set kJa=kga(kha,kHa)
endif
set EM=EM-1
return kJa
endfunction
function kka takes integer kKa,integer kla,string kLa returns string
local string kma
set ZM[EM]=kLa
set EM=EM+1
set kma=qov(kGa(bQ[kKa],kla,"when calling run in AbilityObjEditing, line 80"))
set EM=EM-1
return kma
endfunction
function kMa takes integer kpa,integer wFs returns string
return d0v(WE[kpa])
endfunction
function kPa takes integer jKi,integer xKi returns string
return kBa("Липкая граната",gR)
endfunction
function kqa takes integer kQa,integer xSS returns string
return Vgx(ET,VTx(PT[hB[kQa]],AT[hB[kQa]]))
endfunction
function ksa takes integer kPi,integer jPi returns string
return"avatar"
endfunction
function kSa takes integer kta,integer bSs returns string
return SMv(eQ[kta])
endfunction
function kTa takes integer kua,integer kUa,string kwa returns string
local string kWa
set ZM[EM]=kwa
set EM=EM+1
if yY[kua]==0 then
if kua==0 then
call Cdv("Nullpointer exception when calling StringLevelClosure.run","when calling error in ObjEditingNatives, line 7")
else
call Cdv("Called StringLevelClosure.run on invalid object.","when calling error in ObjEditingNatives, line 7")
endif
endif
if yY[kua]<=4840 then
if yY[kua]<=4829 then
if yY[kua]<=4823 then
if yY[kua]<=4820 then
if yY[kua]<=4819 then
if yY[kua]<=4818 then
set kWa=Jla(kua,kUa)
else
set kWa=Jxa(kua,kUa)
endif
else
set kWa=kSa(kua,kUa)
endif
elseif yY[kua]<=4822 then
if yY[kua]<=4821 then
set kWa=jxa(kua,kUa,"when calling run_addTooltipProperty_AbilityDefinition_AbilityObjEditing in ObjEditingNatives, line 7")
else
set kWa=j7a(kua,kUa,"when calling run_addTooltipProperty_AbilityDefinition_AbilityObjEditing in ObjEditingNatives, line 7")
endif
else
set kWa=kka(kua,kUa,"when calling run_addTooltipProperty_AbilityDefinition_AbilityObjEditing in ObjEditingNatives, line 7")
endif
elseif yY[kua]<=4826 then
if yY[kua]<=4825 then
if yY[kua]<=4824 then
set kWa=J_a(kua,kUa)
else
set kWa=h2a(kua,kUa)
endif
else
set kWa=Jra(kua,kUa)
endif
elseif yY[kua]<=4828 then
if yY[kua]<=4827 then
set kWa=h5a(kua,kUa)
else
set kWa=h6a(kua,kUa)
endif
else
set kWa=h4a(kua,kUa)
endif
elseif yY[kua]<=4835 then
if yY[kua]<=4832 then
if yY[kua]<=4831 then
if yY[kua]<=4830 then
set kWa=ksa(kua,kUa)
else
set kWa=JNa(kua,kUa)
endif
else
set kWa=J0a(kua,kUa)
endif
elseif yY[kua]<=4834 then
if yY[kua]<=4833 then
set kWa=Jia(kua,kUa)
else
set kWa=h8a(kua,kUa)
endif
else
set kWa=Hqa(kua,kUa)
endif
elseif yY[kua]<=4838 then
if yY[kua]<=4837 then
if yY[kua]<=4836 then
set kWa=Jua(kua,kUa)
else
set kWa=kDa(kua,kUa)
endif
else
set kWa=J7a(kua,kUa)
endif
elseif yY[kua]<=4839 then
set kWa=koa(kua,kUa)
else
set kWa=J8a(kua,kUa)
endif
elseif yY[kua]<=4852 then
if yY[kua]<=4846 then
if yY[kua]<=4843 then
if yY[kua]<=4842 then
if yY[kua]<=4841 then
set kWa=h1a(kua,kUa)
else
set kWa=kAa(kua,kUa,"when calling run_presetBuffs_Cleave in ObjEditingNatives, line 7")
endif
else
set kWa=kMa(kua,kUa)
endif
elseif yY[kua]<=4845 then
if yY[kua]<=4844 then
set kWa=kea(kua,kUa)
else
set kWa=Jba(kua,kUa)
endif
else
set kWa=J4a(kua,kUa)
endif
elseif yY[kua]<=4849 then
if yY[kua]<=4848 then
if yY[kua]<=4847 then
set kWa=J9a(kua,kUa)
else
set kWa=JJa(kua,kUa,"when calling run_presetTargetsAllowed_DummyBuffs in ObjEditingNatives, line 7")
endif
else
set kWa=Jta(kua,kUa)
endif
elseif yY[kua]<=4851 then
if yY[kua]<=4850 then
set kWa=J1a(kua,kUa)
else
set kWa=h7a(kua,kUa)
endif
else
set kWa=J3a(kua,kUa)
endif
elseif yY[kua]<=4858 then
if yY[kua]<=4855 then
if yY[kua]<=4854 then
if yY[kua]<=4853 then
set kWa=JUa(kua,kUa)
else
set kWa=J5a(kua,kUa)
endif
else
set kWa=Jwa(kua,kUa)
endif
elseif yY[kua]<=4857 then
if yY[kua]<=4856 then
set kWa=Jza(kua,kUa)
else
set kWa=kra(kua,kUa)
endif
else
set kWa=JRa(kua,kUa)
endif
elseif yY[kua]<=4861 then
if yY[kua]<=4860 then
if yY[kua]<=4859 then
set kWa=kda(kua,kUa)
else
set kWa=kPa(kua,kUa)
endif
else
set kWa=Jsa(kua,kUa)
endif
elseif yY[kua]<=4862 then
set kWa=kqa(kua,kUa)
else
set kWa=HMa(kua,kUa,"when calling run_presetUnitCreatedperplayerrace_presetDurationNormal_presetCastRange_addButton_getNewId_compiletime_SotfrpGuiDestructables in ObjEditingNatives, line 7")
endif
set EM=EM-1
return kWa
endfunction
function kya takes integer kYa,string kza,integer kZa,integer k_a,integer k0a,string k1a returns nothing
local integer k2a
local integer k3a
set ZM[EM]=k1a
set EM=EM+1
set k2a=1
set k3a=kZa
loop
exitwhen k2a>k3a
call h0a(kYa,kza,k2a,k_a,kTa(k0a,k2a,"when calling run in ObjEditingNatives, line 90"))
set k2a=k2a+1
endloop
set EM=EM-1
endfunction
function k4a takes integer k5a,integer k6a,string k7a returns nothing
set ZM[EM]=k7a
set EM=EM+1
call kya(rQ[k5a],"spb5",sQ[k5a],5,k6a,"when calling setLevelsDataString in AbilityObjEditing, line 10548")
call hya(k5a,"BaseOrderID",k6a,"when calling addTooltipProperty in AbilityObjEditing, line 10549")
set EM=EM-1
endfunction
function k8a takes integer k9a,integer Kva,string Kea returns nothing
set ZM[EM]=Kea
set EM=EM+1
if tY[k9a]==0 then
if k9a==0 then
call Cdv("Nullpointer exception when calling AbilityDefinitionSpellBook.presetBaseOrderID","when calling error in AbilityObjEditing, line 10547")
else
call Cdv("Called AbilityDefinitionSpellBook.presetBaseOrderID on invalid object.","when calling error in AbilityObjEditing, line 10547")
endif
endif
call k4a(k9a,Kva,"when calling presetBaseOrderID in AbilityObjEditing, line 10547")
set EM=EM-1
endfunction
function Kxa takes string Koa returns integer
local integer Kra
set ZM[EM]=Koa
set EM=EM+1
if BG==0 then
if NG<$8000 then
set NG=NG+1
set Kra=NG
set MG[Kra]=$F3A
else
call Cdv("Out of memory: Could not create OnCastListener_onCast_SotfrpGuiRegions.","when calling error in SotfrpGuiRegions, line 223")
set Kra=0
endif
else
set BG=BG-1
set Kra=VG[BG]
set MG[Kra]=$F3A
endif
set EM=EM-1
return Kra
endfunction
function Kia takes string Kaa returns integer
local integer Kna
set ZM[EM]=Kaa
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set Kna=Yj
set Gj[Kna]=$B27
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_setProvidingEnumUnit_registerProtectedBuiltin_SotfrpGuiRegions.","when calling error in SotfrpGuiRegions, line 134")
set Kna=0
endif
else
set Tj=Tj-1
set Kna=Rj[Tj]
set Gj[Kna]=$B27
endif
set EM=EM-1
return Kna
endfunction
function KVa takes string KEa returns integer
local integer KXa
set ZM[EM]=KEa
set EM=EM+1
if BG==0 then
if NG<$8000 then
set NG=NG+1
set KXa=NG
set MG[KXa]=$F3B
else
call Cdv("Out of memory: Could not create OnCastListener_onCast_SotfrpGuiRegions.","when calling error in SotfrpGuiRegions, line 227")
set KXa=0
endif
else
set BG=BG-1
set KXa=VG[BG]
set MG[KXa]=$F3B
endif
set EM=EM-1
return KXa
endfunction
function KOa takes string KRa returns integer
local integer KIa
set ZM[EM]=KRa
set EM=EM+1
if BG==0 then
if NG<$8000 then
set NG=NG+1
set KIa=NG
set MG[KIa]=$F35
else
call Cdv("Out of memory: Could not create OnCastListener_onCast_SotfrpGuiRegions.","when calling error in SotfrpGuiRegions, line 207")
set KIa=0
endif
else
set BG=BG-1
set KIa=VG[BG]
set MG[KIa]=$F35
endif
set EM=EM-1
return KIa
endfunction
function KAa takes string KNa returns integer
local integer Kba
set ZM[EM]=KNa
set EM=EM+1
if lY==0 then
if bY<$8000 then
set bY=bY+1
set Kba=bY
set yY[Kba]=4827
else
call Cdv("Out of memory: Could not create StringLevelClosure_presetBaseOrderID_SotfrpGuiRegions.","when calling error in SotfrpGuiRegions, line 37")
set Kba=0
endif
else
set lY=lY-1
set Kba=OY[lY]
set yY[Kba]=4827
endif
set EM=EM-1
return Kba
endfunction
function KBa takes string Kca returns integer
local integer KCa
set ZM[EM]=Kca
set EM=EM+1
if BG==0 then
if NG<$8000 then
set NG=NG+1
set KCa=NG
set MG[KCa]=$F3C
else
call Cdv("Out of memory: Could not create OnCastListener_onCast_SotfrpGuiRegions.","when calling error in SotfrpGuiRegions, line 231")
set KCa=0
endif
else
set BG=BG-1
set KCa=VG[BG]
set MG[KCa]=$F3C
endif
set EM=EM-1
return KCa
endfunction
function Kda takes string KDa returns integer
local integer Kfa
set ZM[EM]=KDa
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set Kfa=Yj
set Gj[Kfa]=$B1D
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_SotfrpGuiRegions.","when calling error in SotfrpGuiRegions, line 158")
set Kfa=0
endif
else
set Tj=Tj-1
set Kfa=Rj[Tj]
set Gj[Kfa]=$B1D
endif
set EM=EM-1
return Kfa
endfunction
function KFa takes string Kga returns integer
local integer KGa
set ZM[EM]=Kga
set EM=EM+1
if BG==0 then
if NG<$8000 then
set NG=NG+1
set KGa=NG
set MG[KGa]=$F36
else
call Cdv("Out of memory: Could not create OnCastListener_onCast_SotfrpGuiRegions.","when calling error in SotfrpGuiRegions, line 210")
set KGa=0
endif
else
set BG=BG-1
set KGa=VG[BG]
set MG[KGa]=$F36
endif
set EM=EM-1
return KGa
endfunction
function Kha takes string KHa returns integer
local integer Kja
set ZM[EM]=KHa
set EM=EM+1
if rY==0 then
if sY<$8000 then
set sY=sY+1
set Kja=sY
set tY[Kja]=571
else
call Cdv("Out of memory: Could not create SotfrpGuiCommandPalettePreset.","when calling error in SotfrpGuiPresets, line 180")
set Kja=0
endif
else
set rY=rY-1
set Kja=uY[rY]
set tY[Kja]=571
endif
set EM=EM-1
return Kja
endfunction
function KJa takes integer Zis returns nothing
endfunction
function Kka takes integer KKa returns nothing
set sQ[KKa]=1
set tQ[KKa]=0
set iQ[KKa]=false
endfunction
function Kla takes string tku,integer iku,integer Sku returns integer
set y1=0
return y1
endfunction
function KLa takes integer Kma,integer KMa,integer Kpa returns nothing
local integer KPa
call Kka(Kma)
set SQ[Kma]=KMa
set KPa=Kla("w3a",KMa,Kpa)
set rQ[Kma]=KPa
endfunction
function Kqa takes integer KQa,integer Ksa returns nothing
call KLa(KQa,Ksa,'Aspb')
call KJa(KQa)
endfunction
function KSa takes string Kta returns integer
local integer KTa
set ZM[EM]=Kta
set EM=EM+1
if SY==0 then
if cY<$8000 then
set cY=cY+1
set KTa=cY
set oY[KTa]=$C51
else
call Cdv("Out of memory: Could not create IntLevelClosure_presetMaximumSpells_SotfrpGuiCommandPalettePreset_SotfrpGuiPresets.","when calling error in SotfrpGuiPresets, line 184")
set KTa=0
endif
else
set SY=SY-1
set KTa=iY[SY]
set oY[KTa]=$C51
endif
set EM=EM-1
return KTa
endfunction
function Kua takes string KUa returns integer
local integer Kwa
set ZM[EM]=KUa
set EM=EM+1
if SY==0 then
if cY<$8000 then
set cY=cY+1
set Kwa=cY
set oY[Kwa]=$C52
else
call Cdv("Out of memory: Could not create IntLevelClosure_presetMinimumSpells_SotfrpGuiCommandPalettePreset_SotfrpGuiPresets.","when calling error in SotfrpGuiPresets, line 183")
set Kwa=0
endif
else
set SY=SY-1
set Kwa=iY[SY]
set oY[Kwa]=$C52
endif
set EM=EM-1
return Kwa
endfunction
function KWa takes string Kya returns integer
local integer KYa
set ZM[EM]=Kya
set EM=EM+1
if lY==0 then
if bY<$8000 then
set bY=bY+1
set KYa=bY
set yY[KYa]=4821
else
call Cdv("Out of memory: Could not create StringLevelClosure_addTooltipProperty_AbilityDefinition_AbilityObjEditing.","when calling error in AbilityObjEditing, line 74")
set KYa=0
endif
else
set lY=lY-1
set KYa=OY[lY]
set yY[KYa]=4821
endif
set EM=EM-1
return KYa
endfunction
function Kza takes integer KZa,string K_a,integer K0a,string K1a returns nothing
local integer K2a
local integer K3a
local string K4a
set ZM[EM]=K1a
set EM=EM+1
set K3a=KZa
set K4a=K_a
set K2a=KWa("when calling alloc_StringLevelClosure_addTooltipProperty_AbilityDefinition_AbilityObjEditing in AbilityObjEditing, line 74")
set OQ[K2a]=K0a
call hya(K3a,K4a,K2a,"when calling addTooltipProperty in AbilityObjEditing, line 74")
set EM=EM-1
endfunction
function K5a takes integer K6a,string K7a,integer K8a,string K9a returns nothing
set ZM[EM]=K9a
set EM=EM+1
if tY[K6a]==0 then
if K6a==0 then
call Cdv("Nullpointer exception when calling AbilityDefinition.addTooltipProperty","when calling error in AbilityObjEditing, line 73")
else
call Cdv("Called AbilityDefinition.addTooltipProperty on invalid object.","when calling error in AbilityObjEditing, line 73")
endif
endif
call Kza(K6a,K7a,K8a,"when calling addTooltipProperty in AbilityObjEditing, line 73")
set EM=EM-1
endfunction
function lva takes integer jku,string xku,integer vku,integer mku,integer Qku returns nothing
endfunction
function lea takes integer lxa,string loa,integer lra,integer lia,integer laa,string lna returns nothing
local integer lVa
local integer lEa
set ZM[EM]=lna
set EM=EM+1
set lVa=1
set lEa=lra
loop
exitwhen lVa>lEa
call lva(lxa,loa,lVa,lia,H7a(laa,lVa,"when calling run in ObjEditingNatives, line 94"))
set lVa=lVa+1
endloop
set EM=EM-1
endfunction
function lXa takes integer lOa,integer lRa,string lIa returns nothing
set ZM[EM]=lIa
set EM=EM+1
call lea(rQ[lOa],"spb3",sQ[lOa],3,lRa,"when calling setLevelsDataInt in AbilityObjEditing, line 10541")
call K5a(lOa,"MinimumSpells",lRa,"when calling addTooltipProperty in AbilityObjEditing, line 10542")
set EM=EM-1
endfunction
function lAa takes integer lNa,integer lba,string lBa returns nothing
set ZM[EM]=lBa
set EM=EM+1
if tY[lNa]==0 then
if lNa==0 then
call Cdv("Nullpointer exception when calling AbilityDefinitionSpellBook.presetMinimumSpells","when calling error in AbilityObjEditing, line 10540")
else
call Cdv("Called AbilityDefinitionSpellBook.presetMinimumSpells on invalid object.","when calling error in AbilityObjEditing, line 10540")
endif
endif
call lXa(lNa,lba,"when calling presetMinimumSpells in AbilityObjEditing, line 10540")
set EM=EM-1
endfunction
function lca takes integer lCa,integer lda,string lDa returns nothing
set ZM[EM]=lDa
set EM=EM+1
call lea(rQ[lCa],"spb4",sQ[lCa],4,lda,"when calling setLevelsDataInt in AbilityObjEditing, line 10520")
call K5a(lCa,"MaximumSpells",lda,"when calling addTooltipProperty in AbilityObjEditing, line 10521")
set EM=EM-1
endfunction
function lfa takes integer lFa,integer lga,string lGa returns nothing
set ZM[EM]=lGa
set EM=EM+1
if tY[lFa]==0 then
if lFa==0 then
call Cdv("Nullpointer exception when calling AbilityDefinitionSpellBook.presetMaximumSpells","when calling error in AbilityObjEditing, line 10519")
else
call Cdv("Called AbilityDefinitionSpellBook.presetMaximumSpells on invalid object.","when calling error in AbilityObjEditing, line 10519")
endif
endif
call lca(lFa,lga,"when calling presetMaximumSpells in AbilityObjEditing, line 10519")
set EM=EM-1
endfunction
function lha takes integer lHa,string lja returns nothing
local integer lJa
local integer lka
local integer lKa
local integer lla
set ZM[EM]=lja
set EM=EM+1
set lKa=lHa
set lJa=Kua("when calling alloc_IntLevelClosure_presetMinimumSpells_SotfrpGuiCommandPalettePreset_SotfrpGuiPresets in SotfrpGuiPresets, line 183")
call lAa(lKa,lJa,"when calling presetMinimumSpells in SotfrpGuiPresets, line 183")
set lla=lHa
set lka=KSa("when calling alloc_IntLevelClosure_presetMaximumSpells_SotfrpGuiCommandPalettePreset_SotfrpGuiPresets in SotfrpGuiPresets, line 184")
call lfa(lla,lka,"when calling presetMaximumSpells in SotfrpGuiPresets, line 184")
set EM=EM-1
endfunction
function lLa takes integer lma,string lMa returns nothing
set ZM[EM]=lMa
set EM=EM+1
if tY[lma]==0 then
if lma==0 then
call Cdv("Nullpointer exception when calling SotfrpGuiCommandPalettePreset.initialize","when calling error in SotfrpGuiPresets, line 182")
else
call Cdv("Called SotfrpGuiCommandPalettePreset.initialize on invalid object.","when calling error in SotfrpGuiPresets, line 182")
endif
endif
call lha(lma,"when calling initialize in SotfrpGuiPresets, line 182")
set EM=EM-1
endfunction
function lpa takes string lPa returns nothing
call COv(ta,0,lPa)
endfunction
function lqa takes integer lQa,string lsa returns boolean
local boolean lSa
set ZM[EM]=lsa
set EM=EM+1
set lSa=true
call wrv(Ga,lQa)
if Ga==null then
call Cdv("Do not load abilities after map init when autoFinish = true","when calling error in Preloader, line 26")
elseif not x8e(Ga,lQa)then
call lpa("PreloadAbility: Ability "+d0v(lQa)+" does not exist.")
set lSa=false
endif
set EM=EM-1
return lSa
endfunction
function lta takes integer L_t,integer lTa returns boolean
return lTa<48 or(lTa>57 and lTa<97)
endfunction
function lua takes integer lUa,integer lwa,string lWa returns boolean
local boolean lya
set ZM[EM]=lWa
set EM=EM+1
if qk[lUa]==0 then
if lUa==0 then
call Cdv("Nullpointer exception when calling IdGenerator.isInvalid","when calling error in ObjectIdGenerator, line 26")
else
call Cdv("Called IdGenerator.isInvalid on invalid object.","when calling error in ObjectIdGenerator, line 26")
endif
endif
set lya=lta(lUa,lwa)
set EM=EM-1
return lya
endfunction
function lYa takes integer lza,string lZa returns integer
local integer l_a
set ZM[EM]=lZa
set EM=EM+1
if TD[lza]<$7E then
set TD[lza]=TD[lza]+1
loop
exitwhen not lua(lza,TD[lza],"when calling isInvalid in ObjectIdGenerator, line 32")
set TD[lza]=TD[lza]+1
endloop
elseif YD[lza]<$7E then
set TD[lza]=33
set YD[lza]=YD[lza]+1
loop
exitwhen not lua(lza,YD[lza],"when calling isInvalid in ObjectIdGenerator, line 37")
set YD[lza]=YD[lza]+1
endloop
elseif GD[lza]<$7E then
set TD[lza]=33
set YD[lza]=33
set GD[lza]=GD[lza]+1
loop
exitwhen not lua(lza,GD[lza],"when calling isInvalid in ObjectIdGenerator, line 43")
set GD[lza]=GD[lza]+1
endloop
elseif gD[lza]<$7E then
set TD[lza]=33
set YD[lza]=33
set GD[lza]=33
set gD[lza]=gD[lza]+1
loop
exitwhen not lua(lza,gD[lza],"when calling isInvalid in ObjectIdGenerator, line 50")
set gD[lza]=gD[lza]+1
endloop
else
call Cdv("No vaild id left","when calling error in ObjectIdGenerator, line 53")
set EM=EM-1
return 0
endif
set l_a=TD[lza]+YD[lza]*256+GD[lza]*65536+gD[lza]*$1000000
if not me then
call lqa(l_a,"when calling preloadAbility in ObjectIdGenerator, line 57")
endif
set EM=EM-1
return l_a
endfunction
function l0a takes integer l1a,string l2a returns integer
local integer l3a
set ZM[EM]=l2a
set EM=EM+1
if qk[l1a]==0 then
if l1a==0 then
call Cdv("Nullpointer exception when calling IdGenerator.next","when calling error in ObjectIdGenerator, line 29")
else
call Cdv("Called IdGenerator.next on invalid object.","when calling error in ObjectIdGenerator, line 29")
endif
endif
set l3a=lYa(l1a,"when calling next in ObjectIdGenerator, line 29")
set EM=EM-1
return l3a
endfunction
function l4a takes nothing returns integer
set C1=0
return C1
endfunction
function l5a takes integer bUi returns nothing
endfunction
function l6a takes integer l7a,string l8a returns nothing
set ZM[EM]=l8a
set EM=EM+1
call l4a()
call yTv("when calling new_LinkedList in SotfrpGuiPresets, line 45")
call l5a(l7a)
set EM=EM-1
endfunction
function l9a takes integer Lva,string Lea returns nothing
set ZM[EM]=Lea
set EM=EM+1
call Kqa(Lva,l0a(qq,"when calling next in SotfrpGuiPresets, line 187"))
call l6a(Lva,"when calling SotfrpGuiCommandPalettePreset_init in SotfrpGuiPresets, line 186")
call lLa(Lva,"when calling initialize in SotfrpGuiPresets, line 188")
set EM=EM-1
endfunction
function Lxa takes string Loa returns integer
local integer Lra
set ZM[EM]=Loa
set EM=EM+1
set Lra=Kha("when calling alloc_SotfrpGuiCommandPalettePreset in SotfrpGuiPresets, line 186")
call l9a(Lra,"when calling construct_SotfrpGuiCommandPalettePreset in SotfrpGuiPresets, line 186")
set EM=EM-1
return Lra
endfunction
function Lia takes integer Laa,boolean Lna returns nothing
set QJ[Laa]=Lna
endfunction
function LVa takes integer LEa,boolean LXa,string LOa returns nothing
set ZM[EM]=LOa
set EM=EM+1
if ax[LEa]==0 then
if LEa==0 then
call Cdv("Nullpointer exception when calling BuiltinData.setProvidingEnumUnit","when calling error in ScmdDataTypes, line 1411")
else
call Cdv("Called BuiltinData.setProvidingEnumUnit on invalid object.","when calling error in ScmdDataTypes, line 1411")
endif
endif
call Lia(LEa,LXa)
set EM=EM-1
endfunction
function LRa takes integer LIa,string LAa returns nothing
set ZM[EM]=LAa
set EM=EM+1
call LVa(LIa,true,"when calling setProvidingEnumUnit in ScmdDataTypes, line 1415")
set EM=EM-1
endfunction
function LNa takes integer Lba,string LBa returns nothing
set ZM[EM]=LBa
set EM=EM+1
if ax[Lba]==0 then
if Lba==0 then
call Cdv("Nullpointer exception when calling BuiltinData.setProvidingEnumUnit","when calling error in ScmdDataTypes, line 1414")
else
call Cdv("Called BuiltinData.setProvidingEnumUnit on invalid object.","when calling error in ScmdDataTypes, line 1414")
endif
endif
call LRa(Lba,"when calling setProvidingEnumUnit in ScmdDataTypes, line 1414")
set EM=EM-1
endfunction
function Lca takes integer uRs returns nothing
endfunction
function LCa takes integer Lda returns nothing
call Gla(Lda)
call Lca(Lda)
endfunction
function LDa takes unit Lfa,integer LFa,integer Lga,string LGa returns integer
local integer Lha
set ZM[EM]=LGa
set EM=EM+1
set Lha=haa(Lfa,LFa,Lga,"when calling addSpellInternal in ClosureEvents, line 138")
set EM=EM-1
return Lha
endfunction
function LHa takes integer Lja,string LJa returns nothing
set ZM[EM]=LJa
set EM=EM+1
call rOa(Gd,Lja,"when calling add in ScmdPermissions, line 17")
set EM=EM-1
endfunction
function Lka takes string LKa returns boolean
local integer Lla
local integer LLa
local integer Lma
local integer LMa
local integer Lpa
local integer LPa
local integer Lqa
local integer LQa
local integer Lsa
local integer LSa
local integer Lta
local integer LTa
local integer Lua
local unit LUa
local integer Lwa
local integer LWa
local integer Lya
local integer LYa
local integer Lza
local integer LZa
local integer L_a
local integer L0a
local integer L1a
local integer L2a
local integer L3a
local integer L4a
local unit L5a
local integer L6a
local unit L7a
local integer L8a
local unit L9a
local integer mva
local unit mea
local integer mxa
local unit moa
local integer mra
local unit mia
local integer maa
local unit mna
local integer mVa
local unit mEa
local integer mXa
local unit mOa
local integer mRa
local unit mIa
local integer mAa
local unit mNa
local integer mba
set ZM[EM]=LKa
set EM=EM+1
set wR='x005'
set uR='RM01'
set rR='RM02'
if me then
set LLa=Lxa("when calling new_SotfrpGuiCommandPalettePreset in SotfrpGuiRegions, line 37")
set L4a=LLa
set Lla=KAa("when calling alloc_StringLevelClosure_presetBaseOrderID_SotfrpGuiRegions in SotfrpGuiRegions, line 37")
call k8a(L4a,Lla,"when calling presetBaseOrderID in SotfrpGuiRegions, line 37")
endif
set sR='AM0s'
set tR='AM0t'
set iR='AM0u'
set SR='AM0v'
set cR='AM0w'
set oR='AM0x'
set OR='AM0y'
set lR='AM0z'
set bR='AM0{'
set yR='AM0|'
set pR='AM0}'
set aR=Ctv("when calling new_HashMap in SotfrpGuiRegions, line 73")
call LHa(wR,"when calling protectUnitType in SotfrpGuiRegions, line 121")
set Lma=hsa("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_SotfrpGuiRegions in SotfrpGuiRegions, line 122")
set LMa=OPo(Lma,"when calling new_BuiltinData in SotfrpGuiRegions, line 122")
call Rxo(LMa,OFo(),"when calling setArgumentsTypes in SotfrpGuiRegions, line 133")
call Foa(ILo(LMa,"when calling new_BuiltinFunction in SotfrpGuiRegions, line 122"),"saveregion","when calling registerProtectedBuiltin in SotfrpGuiRegions, line 122")
set Lpa=Kia("when calling alloc_IBuiltin_setArgumentsTypes_setProvidingEnumUnit_registerProtectedBuiltin_SotfrpGuiRegions in SotfrpGuiRegions, line 134")
set LPa=OPo(Lpa,"when calling new_BuiltinData in SotfrpGuiRegions, line 134")
call Rxo(LPa,hda(),"when calling setArgumentsTypes in SotfrpGuiRegions, line 157")
set Lqa=LPa
call LNa(Lqa,"when calling setProvidingEnumUnit in SotfrpGuiRegions, line 157")
call Foa(G3a(Lqa,"when calling new_BuiltinSpecialForm in SotfrpGuiRegions, line 134"),"forregion","when calling registerProtectedBuiltin in SotfrpGuiRegions, line 134")
set LQa=Kda("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_SotfrpGuiRegions in SotfrpGuiRegions, line 158")
set Lsa=OPo(LQa,"when calling new_BuiltinData in SotfrpGuiRegions, line 158")
call Rxo(Lsa,OFo(),"when calling setArgumentsTypes in SotfrpGuiRegions, line 179")
call Foa(ILo(Lsa,"when calling new_BuiltinFunction in SotfrpGuiRegions, line 158"),"loadregion","when calling registerProtectedBuiltin in SotfrpGuiRegions, line 158")
set LSa=G7a("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_SotfrpGuiRegions in SotfrpGuiRegions, line 180")
set Lta=OPo(LSa,"when calling new_BuiltinData in SotfrpGuiRegions, line 180")
call Rxo(Lta,OFo(),"when calling setArgumentsTypes in SotfrpGuiRegions, line 201")
call Foa(ILo(Lta,"when calling new_BuiltinFunction in SotfrpGuiRegions, line 180"),"loadlegacyregion","when calling registerProtectedBuiltin in SotfrpGuiRegions, line 180")
set LTa=0
set Lua=bj_MAX_PLAYERS-1
loop
exitwhen LTa>Lua
set LUa=QKv(LTa)
if LUa!=null then
call hja(LTa,rR)
set L5a=LUa
set L6a=sR
set Lwa=KOa("when calling alloc_OnCastListener_onCast_SotfrpGuiRegions in SotfrpGuiRegions, line 207")
call Gla(Lwa)
set pX[Lwa]=LTa
call hOa(L5a,L6a,Lwa,"when calling onCast in SotfrpGuiRegions, line 207")
set L7a=LUa
set L8a=tR
set LWa=KFa("when calling alloc_OnCastListener_onCast_SotfrpGuiRegions in SotfrpGuiRegions, line 210")
call Gla(LWa)
set eX[LWa]=LTa
call hOa(L7a,L8a,LWa,"when calling onCast in SotfrpGuiRegions, line 210")
set L9a=LUa
set mva=iR
set Lya=hma("when calling alloc_OnCastListener_onCast_SotfrpGuiRegions in SotfrpGuiRegions, line 213")
call Gla(Lya)
set qX[Lya]=LTa
call hOa(L9a,mva,Lya,"when calling onCast in SotfrpGuiRegions, line 213")
set mea=LUa
set mxa=SR
set LYa=hPa("when calling alloc_OnCastListener_onCast_SotfrpGuiRegions in SotfrpGuiRegions, line 216")
call Gla(LYa)
set aX[LYa]=LTa
call hOa(mea,mxa,LYa,"when calling onCast in SotfrpGuiRegions, line 216")
set moa=LUa
set mra=cR
set Lza=hKa("when calling alloc_OnCastListener_onCast_SotfrpGuiRegions in SotfrpGuiRegions, line 219")
call Gla(Lza)
set nX[Lza]=LTa
call hOa(moa,mra,Lza,"when calling onCast in SotfrpGuiRegions, line 219")
set mia=LUa
set maa=oR
set LZa=Kxa("when calling alloc_OnCastListener_onCast_SotfrpGuiRegions in SotfrpGuiRegions, line 223")
call Gla(LZa)
set dX[LZa]=LTa
call hOa(mia,maa,LZa,"when calling onCast in SotfrpGuiRegions, line 223")
set mna=LUa
set mVa=OR
set L_a=KVa("when calling alloc_OnCastListener_onCast_SotfrpGuiRegions in SotfrpGuiRegions, line 227")
call Gla(L_a)
set fX[L_a]=LTa
call hOa(mna,mVa,L_a,"when calling onCast in SotfrpGuiRegions, line 227")
set mEa=LUa
set mXa=lR
set L0a=KBa("when calling alloc_OnCastListener_onCast_SotfrpGuiRegions in SotfrpGuiRegions, line 231")
call Gla(L0a)
set RX[L0a]=LTa
call hOa(mEa,mXa,L0a,"when calling onCast in SotfrpGuiRegions, line 231")
set qR[LTa]=BQa("when calling new_HashSet in SotfrpGuiRegions, line 235")
set mOa=LUa
set mRa=bR
set L1a=hoa("when calling alloc_OnPointCast_onPointCast_SotfrpGuiRegions in SotfrpGuiRegions, line 236")
call LCa(L1a)
set TX[L1a]=LTa
call LDa(mOa,mRa,L1a,"when calling onPointCast in SotfrpGuiRegions, line 236")
set mIa=LUa
set mAa=yR
set L2a=hBa("when calling alloc_OnCastListener_onCast_SotfrpGuiRegions in SotfrpGuiRegions, line 245")
call Gla(L2a)
set YX[L2a]=LTa
call hOa(mIa,mAa,L2a,"when calling onCast in SotfrpGuiRegions, line 245")
set mNa=LUa
set mba=pR
set L3a=hva("when calling alloc_OnCastListener_onCast_SotfrpGuiRegions in SotfrpGuiRegions, line 249")
call Gla(L3a)
set GX[L3a]=LTa
call hOa(mNa,mba,L3a,"when calling onCast in SotfrpGuiRegions, line 249")
endif
set LTa=LTa+1
endloop
set EM=EM-1
set LUa=null
set L5a=null
set L7a=null
set L9a=null
set mea=null
set moa=null
set mia=null
set mna=null
set mEa=null
set mOa=null
set mIa=null
set mNa=null
return true
endfunction
function mBa takes nothing returns boolean
set EM=0
return Lka("SotfrpGuiRegions, line 1")
endfunction
function mca takes nothing returns boolean
return true
endfunction
function mCa takes nothing returns boolean
return(Mu==2)
endfunction
function mda takes nothing returns boolean
return(Mu==1)
endfunction
function mDa takes nothing returns nothing
if mda()then
call UnitDamageTargetBJ(Nu,GetEnumUnit(),xu,ATTACK_TYPE_NORMAL,DAMAGE_TYPE_COLD)
call AddSpecialEffectTargetUnitBJ("chest",GetEnumUnit(),"Abilities\\Weapons\\LichMissile\\LichMissile.mdl")
elseif mCa()then
call UnitDamageTargetBJ(Nu,GetEnumUnit(),vu,ATTACK_TYPE_NORMAL,DAMAGE_TYPE_FIRE)
call AddSpecialEffectTargetUnitBJ("chest",GetEnumUnit(),"Abilities\\Weapons\\RedDragonBreath\\RedDragonMissile.mdl")
else
call UnitDamageTargetBJ(Nu,GetEnumUnit(),mu,ATTACK_TYPE_NORMAL,DAMAGE_TYPE_LIGHTNING)
call AddSpecialEffectTargetUnitBJ("chest",GetEnumUnit(),"Abilities\\Weapons\\FarseerMissile\\FarseerMissile.mdl")
endif
call DestroyEffectBJ(GetLastCreatedEffectBJ())
endfunction
function mfa takes nothing returns boolean
call InitHashtable()
return true
endfunction
function mFa takes nothing returns boolean
return(GetSpellAbilityId()=='A0ES')
endfunction
function mga takes nothing returns boolean
return(GetSpellAbilityId()=='A09I')
endfunction
function mGa takes nothing returns boolean
return(GetSpellAbilityId()=='A0CX')
endfunction
function mha takes nothing returns boolean
return IsUnitSelected(GetFilterUnit(),GetTriggerPlayer())
endfunction
function mHa takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),1,7)=="terrain")
endfunction
function mja takes nothing returns boolean
if GetSpellAbilityId()=='A0H9' then
return true
else
return false
endif
endfunction
function mJa takes location mka,location mKa returns real
local real mla=GetLocationX(mKa)-GetLocationX(mka)
local real mLa=GetLocationY(mKa)-GetLocationY(mka)
set mka=null
set mKa=null
return SquareRoot(mla*mla+mLa*mLa)
endfunction
function mma takes location mMa,location mpa returns real
local real mPa=bj_RADTODEG*Atan2(GetLocationY(mpa)-GetLocationY(mMa),GetLocationX(mpa)-GetLocationX(mMa))
set mMa=null
set mpa=null
return mPa
endfunction
function mqa takes location mQa,real msa,real mSa returns location
local real mta=GetLocationX(mQa)+msa*Cos(mSa*bj_DEGTORAD)
local real mTa=GetLocationY(mQa)+msa*Sin(mSa*bj_DEGTORAD)
set mQa=null
return Location(mta,mTa)
endfunction
function mua takes nothing returns nothing
local unit mUa=GetOrderedUnit()
local integer mwa=GetIssuedOrderId()
local unit mWa=GetOrderTargetUnit()
local destructable mya=GetOrderTargetDestructable()
local item mYa=GetOrderTargetItem()
local location mza=Location(GetDestructableX(mya),GetDestructableY(mya))
if GetOrderTargetItem()==null then
if GetIssuedOrderId()==851971and mWa!=null and IsUnitLoaded(mWa)then
call IssueImmediateOrderById(mUa,$D0004)
endif
if GetIssuedOrderId()!=851971and mWa!=null and mJa(GetUnitLoc(mUa),GetUnitLoc(mWa))>800. then
call SetUnitPositionLoc(mUa,mqa(GetUnitLoc(mUa),mJa(GetUnitLoc(mUa),GetUnitLoc(mWa))-800.,mma(GetUnitLoc(mUa),GetUnitLoc(mWa))))
call TriggerSleepAction(.01)
call IssueTargetOrderById(mUa,mwa,mWa)
elseif mya!=null and mJa(GetUnitLoc(mUa),mza)>800. then
call SetUnitPositionLoc(mUa,mqa(GetUnitLoc(mUa),mJa(GetUnitLoc(mUa),mza)-800.,mma(GetUnitLoc(mUa),mza)))
call TriggerSleepAction(.01)
call IssueTargetOrderById(mUa,mwa,mya)
endif
else
call SetUnitPositionLoc(mUa,Location(GetItemX(mYa),GetItemY(mYa)))
call UnitAddItem(mUa,mYa)
call TriggerSleepAction(.01)
call IssueImmediateOrderById(mUa,$D0004)
endif
call RemoveLocation(mza)
set mza=null
set mYa=null
set mya=null
set mWa=null
set mwa=0
set mUa=null
set mUa=null
set mWa=null
set mya=null
set mYa=null
set mza=null
endfunction
function mZa takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),9,'y')=="hdungeonredfog")
endfunction
function m_a takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),9,'y')=="llordaeronrain")
endfunction
function m0a takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),9,'y')=="hnorthrendsnow")
endfunction
function m1a takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),9,'y')=="hwind")
endfunction
function m2a takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),9,'y')=="raysofmoonlight")
endfunction
function m3a takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),9,'y')=="raysoflight")
endfunction
function m4a takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),9,'y')=="loutlandwind")
endfunction
function m5a takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),9,'y')=="houtlandwind")
endfunction
function m6a takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),9,'y')=="ldungeonwhitefog")
endfunction
function m7a takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),9,'y')=="hlordaeronrain")
endfunction
function m8a takes nothing returns boolean
return(GetTriggerPlayer()==Player(0))
endfunction
function m9a takes nothing returns boolean
return(qw[GetConvertedPlayerId(GetTriggerPlayer())]>=8)and(GetEventPlayerChatString()!="weather on")and(GetEventPlayerChatString()!="weather off")
endfunction
function Mva takes nothing returns boolean
return(GetTriggerPlayer()==Player($B))
endfunction
function Mea takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),9,'y')=="dalaranshield")
endfunction
function Mxa takes nothing returns boolean
return(qw[GetConvertedPlayerId(GetTriggerPlayer())]<1)
endfunction
function Moa takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),9,'y')=="northrendblizzard")
endfunction
function Mra takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),9,'y')=="lnorthrendsnow")
endfunction
function Mia takes nothing returns boolean
return(qw[GetConvertedPlayerId(GetTriggerPlayer())]>=9)
endfunction
function Maa takes nothing returns boolean
return(GetTriggerPlayer()==Player(7))
endfunction
function Mna takes nothing returns boolean
return(GetTriggerPlayer()==Player(2))
endfunction
function MVa takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),9,'y')=="lashenvillerain")
endfunction
function MEa takes nothing returns boolean
return(GetTriggerPlayer()==Player(9))
endfunction
function MXa takes nothing returns boolean
return(GetTriggerPlayer()==Player(5))
endfunction
function MOa takes nothing returns boolean
return(GetTriggerPlayer()==Player($A))
endfunction
function MRa takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),9,'y')=="hdungeonbluefog")
endfunction
function MIa takes nothing returns boolean
return(GetTriggerPlayer()==Player(1))
endfunction
function MAa takes nothing returns boolean
return(GetTriggerPlayer()==Player(8))
endfunction
function MNa takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),9,'y')=="hashenvillerain")
endfunction
function Mba takes nothing returns boolean
return(GetTriggerPlayer()==Player(4))
endfunction
function MBa takes nothing returns boolean
return(GetTriggerPlayer()==Player(6))
endfunction
function Mca takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),9,'y')=="ldungeongreenfog")
endfunction
function MCa takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),9,'y')=="hdungeongreenfog")
endfunction
function Mda takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),9,'y')=="ldungeonbluefog")
endfunction
function MDa takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),9,'y')=="ldungeonredfog")
endfunction
function Mfa takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),9,'y')=="hdungeonwhitefog")
endfunction
function MFa takes nothing returns boolean
return(GetTriggerPlayer()==Player(3))
endfunction
function Mga takes nothing returns nothing
if m9a()then
call DisplayTextToForce(GetPlayersMatching(Condition(vJv)),"TRIGSTR_047")
return
endif
set rw=RectFromLoc(Wt[GetConvertedPlayerId(GetTriggerPlayer())-1],Et[GetConvertedPlayerId(GetTriggerPlayer())-1])
if MNa()then
call AddWeatherEffectSaveLast(rw,'RAhr')
elseif MVa()then
call AddWeatherEffectSaveLast(rw,'RAlr')
elseif Mea()then
call AddWeatherEffectSaveLast(rw,'MEds')
elseif MRa()then
call AddWeatherEffectSaveLast(rw,'FDbh')
elseif Mda()then
call AddWeatherEffectSaveLast(rw,'FDbl')
elseif MCa()then
call AddWeatherEffectSaveLast(rw,'FDgh')
elseif Mca()then
call AddWeatherEffectSaveLast(rw,'FDgl')
else
if mZa()then
call AddWeatherEffectSaveLast(rw,'FDrh')
endif
if MDa()then
call AddWeatherEffectSaveLast(rw,'FDrl')
elseif Mfa()then
call AddWeatherEffectSaveLast(rw,'FDwh')
elseif m6a()then
call AddWeatherEffectSaveLast(rw,'FDwl')
elseif m7a()then
call AddWeatherEffectSaveLast(rw,'RLhr')
elseif m_a()then
call AddWeatherEffectSaveLast(rw,'RLlr')
elseif Moa()then
call AddWeatherEffectSaveLast(rw,'SNbs')
elseif m0a()then
call AddWeatherEffectSaveLast(rw,'SNhs')
elseif Mra()then
call AddWeatherEffectSaveLast(rw,'SNls')
elseif m5a()then
call AddWeatherEffectSaveLast(rw,'WOcw')
elseif m4a()then
call AddWeatherEffectSaveLast(rw,'WOlw')
elseif m3a()then
call AddWeatherEffectSaveLast(rw,'LRaa')
elseif m2a()then
call AddWeatherEffectSaveLast(rw,'LRma')
elseif m1a()then
call AddWeatherEffectSaveLast(rw,'WNcw')
else
return
endif
endif
call EnableWeatherEffect(GetLastCreatedWeatherEffect(),true)
if m8a()then
set sw[qw[GetConvertedPlayerId(GetTriggerPlayer())]]=GetLastCreatedWeatherEffect()
endif
if MIa()then
set tw[qw[GetConvertedPlayerId(GetTriggerPlayer())]]=GetLastCreatedWeatherEffect()
endif
if Mna()then
set yw[qw[GetConvertedPlayerId(GetTriggerPlayer())]]=GetLastCreatedWeatherEffect()
endif
if MFa()then
set bw[qw[GetConvertedPlayerId(GetTriggerPlayer())]]=GetLastCreatedWeatherEffect()
endif
if Mba()then
set lw[qw[GetConvertedPlayerId(GetTriggerPlayer())]]=GetLastCreatedWeatherEffect()
endif
if MXa()then
set Ow[qw[GetConvertedPlayerId(GetTriggerPlayer())]]=GetLastCreatedWeatherEffect()
endif
if MBa()then
set ow[qw[GetConvertedPlayerId(GetTriggerPlayer())]]=GetLastCreatedWeatherEffect()
endif
if Maa()then
set cw[qw[GetConvertedPlayerId(GetTriggerPlayer())]]=GetLastCreatedWeatherEffect()
endif
if MAa()then
set Sw[qw[GetConvertedPlayerId(GetTriggerPlayer())]]=GetLastCreatedWeatherEffect()
endif
if MEa()then
set iw[qw[GetConvertedPlayerId(GetTriggerPlayer())]]=GetLastCreatedWeatherEffect()
endif
if MOa()then
set ew[qw[GetConvertedPlayerId(GetTriggerPlayer())]]=GetLastCreatedWeatherEffect()
endif
if Mva()then
set pw[qw[GetConvertedPlayerId(GetTriggerPlayer())]]=GetLastCreatedWeatherEffect()
endif
set qw[GetConvertedPlayerId(GetTriggerPlayer())]=qw[GetConvertedPlayerId(GetTriggerPlayer())]+1
if Mxa()then
set qw[GetConvertedPlayerId(GetTriggerPlayer())]=1
endif
if Mia()then
set qw[GetConvertedPlayerId(GetTriggerPlayer())]=8
endif
endfunction
function MGa takes unit Mha returns nothing
if GetUnitAbilityLevel(Mha,'AaIB')==0 then
call UnitRemoveAbility(Mha,'AAI2')
endif
set Mha=null
endfunction
function MHa takes nothing returns nothing
call MGa(GetEnumUnit())
endfunction
function Mja takes nothing returns boolean
return(GetEventPlayerChatString()=="item swordofosiris")
endfunction
function MJa takes nothing returns nothing
set g[GetConvertedPlayerId(GetTriggerPlayer())]=GetUnitsOfPlayerAndTypeId(GetTriggerPlayer(),'h000')
if Mja()then
call ForGroupBJ(g[GetConvertedPlayerId(GetTriggerPlayer())],rBv)
endif
call DestroyGroup(g[GetPlayerId(GetTriggerPlayer())+1])
endfunction
function Mka takes nothing returns nothing
set h=GetUnitsInRectAll(It)
call ForGroupBJ(h,eiv)
call DestroyGroup(h)
call TriggerSleepAction(1.)
call DestroyTrigger(GetTriggeringTrigger())
endfunction
function MKa takes nothing returns boolean
set ly=.017453293
set by=57.295779513
return true
endfunction
function Mla takes integer MLa,string Mma returns boolean
local boolean MMa
set ZM[EM]=Mma
set EM=EM+1
set MMa=fcv(Gd,MLa,"when calling has in ScmdPermissions, line 20")
set EM=EM-1
return MMa
endfunction
function Mpa takes string MPa returns boolean
local boolean Mqa
set ZM[EM]=MPa
set EM=EM+1
set Mqa=not Mla(umv(GetFilterUnit()),"when calling isUnitTypeProtected in ScmdUnitBuiltins, line 235")
set EM=EM-1
return Mqa
endfunction
function MQa takes nothing returns boolean
set EM=0
return Mpa("ScmdUnitBuiltins, line 235")
endfunction
function Msa takes nothing returns boolean
local integer MSa=GetPlayerId(GetTriggerPlayer())
local integer Mta=Dl[Ql[MSa]]
call ForceRemovePlayer(u,ml[MSa])
set Il=Il-1
set Dl[Mta]=Dl[Il]
set Al[Mta]=Al[Il]
if Il==1 then
set Wl[El[MSa]]=vl
set El[Wl[MSa]]=vl
else
set Wl[El[MSa]]=Wl[MSa]
set El[Wl[MSa]]=El[MSa]
endif
return false
endfunction
function MTa takes nothing returns boolean
return true
endfunction
function Mua takes nothing returns nothing
set G=GetUnitLoc(GetEnumUnit())
call EnumDestructablesInCircleBJ(256.,G,vcv)
call RemoveLocation(G)
endfunction
function MUa takes string Mwa returns integer
local integer MWa
set ZM[EM]=Mwa
set EM=EM+1
if BG==0 then
if NG<$8000 then
set NG=NG+1
set MWa=NG
set MG[MWa]=$F44
else
call Cdv("Out of memory: Could not create OnUnitCast_onTargetCast_StickyGrenade.","when calling error in StickyGrenade, line 70")
set MWa=0
endif
else
set BG=BG-1
set MWa=VG[BG]
set MG[MWa]=$F44
endif
set EM=EM-1
return MWa
endfunction
function Mya takes string MYa returns integer
local integer Mza
set ZM[EM]=MYa
set EM=EM+1
if Zm==0 then
if Um<$8000 then
set Um=Um+1
set Mza=Um
set Im[Mza]=$445
else
call Cdv("Out of memory: Could not create Buff⟪integer⟫.","when calling error in Buffs, line 19")
set Mza=0
endif
else
set Zm=Zm-1
set Mza=Em[Zm]
set Im[Mza]=$445
endif
set EM=EM-1
return Mza
endfunction
function MZa takes integer M_a,string M0a returns nothing
set ZM[EM]=M0a
set EM=EM+1
set FM[M_a]=a6x("when calling new_Table in Buffs, line 21")
set kM[M_a]=0
set jM[M_a]=0
set EM=EM-1
endfunction
function M1a takes integer M2a,string M3a returns nothing
set ZM[EM]=M3a
set EM=EM+1
call MZa(M2a,"when calling Buff_init⟪integer⟫ in Buffs, line 19")
set EM=EM-1
endfunction
function M4a takes string M5a returns integer
local integer M6a
set ZM[EM]=M5a
set EM=EM+1
set M6a=Mya("when calling alloc_Buff⟪integer⟫ in Buffs, line 19")
call M1a(M6a,"when calling construct_Buff⟪integer⟫ in Buffs, line 19")
set EM=EM-1
return M6a
endfunction
function M7a takes integer M8a,integer M9a,string pva returns integer
local integer pea
set ZM[EM]=pva
set EM=EM+1
set pea=haa(null,M8a,M9a,"when calling addSpellInternal in ClosureEvents, line 147")
set EM=EM-1
return pea
endfunction
function pxa takes integer ORs returns nothing
endfunction
function poa takes integer pra returns nothing
call Gla(pra)
call pxa(pra)
endfunction
function pia takes string paa returns boolean
local integer pna
local integer pVa
set ZM[EM]=paa
set EM=EM+1
set RR='Astg'
set TR='AM0e'
set YR=5
set GR=30
set gR="G"
set hR=M4a("when calling new_Buff⟪integer⟫ in StickyGrenade, line 67")
set pVa=RR
set pna=MUa("when calling alloc_OnUnitCast_onTargetCast_StickyGrenade in StickyGrenade, line 70")
call poa(pna)
call M7a(pVa,pna,"when calling onTargetCast in StickyGrenade, line 70")
set EM=EM-1
return true
endfunction
function pEa takes nothing returns boolean
set EM=0
return pia("StickyGrenade, line 1")
endfunction
function pXa takes nothing returns boolean
return GetBooleanAnd(IsUnitAliveBJ(GetFilterUnit()),IsUnitEnemy(GetFilterUnit(),GetOwningPlayer(Nu)))
endfunction
function pOa takes nothing returns boolean
return(IsTriggerEnabled(Nt)==false)
endfunction
function pRa takes nothing returns nothing
call GroupAddUnitSimple(GetTriggerUnit(),Hu)
set Ju[0]=GetSpellTargetLoc()
set Cu=GetConvertedPlayerId(GetOwningPlayer(GetTriggerUnit()))-1
call SaveLocationHandleBJ(Ju[0],0,GetHandleIdBJ(GetTriggerUnit()),Au)
call CreateNUnitsAtLoc(1,'h0LF',GetOwningPlayer(GetTriggerUnit()),Ju[0],90.)
call SetUnitScalePercent(GetLastCreatedUnit(),Gu,Gu,Gu)
call SetUnitVertexColorBJ(GetLastCreatedUnit(),100.,100.,100.,100.)
if GetLocalPlayer()==Player(Cu)then
call SetUnitVertexColorBJ(GetLastCreatedUnit(),100.,100.,100.,.0)
endif
call SaveUnitHandleBJ(GetLastCreatedUnit(),2,GetHandleIdBJ(GetTriggerUnit()),Au)
call CreateNUnitsAtLoc(1,'h0LF',GetOwningPlayer(GetTriggerUnit()),Ju[0],90.)
call SetUnitScalePercent(GetLastCreatedUnit(),gu,gu,gu)
call SetUnitVertexColorBJ(GetLastCreatedUnit(),100.,100.,100.,100.)
if GetLocalPlayer()==Player(Cu)then
call SetUnitVertexColorBJ(GetLastCreatedUnit(),100.,100.,100.,.0)
endif
call SaveUnitHandleBJ(GetLastCreatedUnit(),3,GetHandleIdBJ(GetTriggerUnit()),Au)
call SaveIntegerBJ(Du+5,4,GetHandleIdBJ(GetTriggerUnit()),Au)
call UnitAddAbilityBJ('A07X',GetTriggerUnit())
call SetPlayerAbilityAvailableBJ(false,'A07W',GetOwningPlayer(GetTriggerUnit()))
if pOa()then
call EnableTrigger(Nt)
endif
endfunction
function pIa takes nothing returns nothing
call SetUnitLifeBJ(GetSpellAbilityUnit(),GetUnitStateSwap(UNIT_STATE_LIFE,GetSpellAbilityUnit())+GetUnitStateSwap(UNIT_STATE_LIFE,GetSpellTargetUnit())*.5*I2R(GetUnitAbilityLevelSwapped('A0EG',GetSpellAbilityUnit())))
call ExplodeUnitBJ(GetSpellTargetUnit())
endfunction
function pAa takes real pNa returns nothing
local timer pba=CreateTimer()
call TimerStart(pba,pNa,false,null)
loop
exitwhen TimerGetRemaining(pba)<=.0
call TriggerSleepAction(.1)
endloop
call DestroyTimer(pba)
set pba=null
set pba=null
endfunction
function pBa takes nothing returns nothing
local unit pca=CreateUnitAtLoc(GetOwningPlayer(GetSpellAbilityUnit()),'h0JO',GetUnitLoc(GetSpellAbilityUnit()),270.)
call UnitAddAbility(pca,'A04Q')
call SetUnitAbilityLevel(pca,'A04Q',GetUnitAbilityLevel(GetSpellAbilityUnit(),'A0GK'))
call IssueTargetOrderById(pca,$D00C0,GetSpellAbilityUnit())
call pAa(3.)
call RemoveUnit(pca)
set pca=null
set pca=null
endfunction
function pCa takes nothing returns nothing
call CreateNUnitsAtLoc(1,'h0JO',GetOwningPlayer(GetSpellAbilityUnit()),GetUnitLoc(GetEnumUnit()),bj_UNIT_FACING)
call UnitAddAbilityBJ('A0IL',GetLastCreatedUnit())
call UnitApplyTimedLifeBJ(3.,'BTLF',GetLastCreatedUnit())
call IssueTargetOrderBJ(GetLastCreatedUnit(),"attackonce",GetEnumUnit())
endfunction
function pda takes nothing returns nothing
local unit pDa=GetEnumUnit()
local integer pfa=0
if GetUnitState(pDa,UNIT_STATE_MANA)<37.5-GetUnitAbilityLevel(pDa,'A0K2')*7.5 then
call DestroyEffect(AddSpecialEffectLoc("Objects\\Spawnmodels\\Undead\\ImpaleTargetDust\\ImpaleTargetDust.mdl",GetUnitLoc(pDa)))
call GroupRemoveUnit(bt,pDa)
call SetUnitPathing(pDa,true)
call UnitAddAbility(pDa,'Amrf')
call UnitRemoveAbility(pDa,'Amrf')
call SetUnitFlyHeight(pDa,.0,240.)
set pfa=GetUnitAbilityLevel(pDa,'A0K2')
call UnitRemoveAbility(pDa,'A0K2')
call UnitRemoveAbility(pDa,'A0K3')
call UnitRemoveAbility(pDa,'A0K4')
call UnitRemoveAbility(pDa,'A0K5')
call UnitRemoveAbility(pDa,'B04J')
call UnitAddAbility(pDa,'A0K1')
call UnitMakeAbilityPermanent(pDa,true,'A0K1')
call SetUnitAbilityLevel(pDa,'A0K1',pfa)
else
call SetUnitState(pDa,UNIT_STATE_MANA,GetUnitState(pDa,UNIT_STATE_MANA)+GetUnitAbilityLevel(pDa,'A0K2')*7.5-37.5)
endif
set pDa=null
set pfa=0
set pDa=null
endfunction
function pFa takes nothing returns boolean
return GetSpellAbilityId()=='A0G3'
endfunction
function pga takes nothing returns boolean
return GetSpellAbilityId()=='AObm'
endfunction
function pGa takes nothing returns nothing
call GroupRemoveUnitSimple(GetEnumUnit(),us)
call GroupRemoveUnitSimple(GetEnumUnit(),ws)
call GroupRemoveUnitSimple(GetEnumUnit(),St)
call GroupRemoveUnitSimple(GetEnumUnit(),tt)
call GroupRemoveUnitSimple(GetEnumUnit(),os)
call GroupRemoveUnitSimple(GetEnumUnit(),ys)
call GroupRemoveUnitSimple(GetEnumUnit(),rs)
call GroupRemoveUnitSimple(GetEnumUnit(),Ot)
endfunction
function pha takes nothing returns boolean
set YT='hfoo'
return true
endfunction
function pHa takes nothing returns nothing
call DestroyTimerDialogBJ(jw)
endfunction
function pja takes nothing returns boolean
return(Qr[kr[3]]<vr[kr[3]])
endfunction
function pJa takes nothing returns boolean
return(IsUnitInGroup(Zr[kr[3]],Cr))
endfunction
function pka takes nothing returns boolean
return(Hr[kr[3]])
endfunction
function pKa takes nothing returns boolean
return(GetRandomInt(1,5)==1)
endfunction
function pla takes nothing returns boolean
return(kr[1]==0)
endfunction
function pLa takes nothing returns nothing
set kr[3]=1
loop
exitwhen kr[3]>kr[2]
if pJa()then
if pja()then
call QueueUnitAnimationBJ(Zr[kr[3]],Ar[kr[3]])
set jr[1]=GetUnitLoc(Zr[kr[3]])
set jr[2]=PolarProjectionBJ(jr[1],Wr[kr[3]],Ur[kr[3]])
if pka()then
call EnumDestructablesInCircleBJ(150.,jr[2],oQv)
endif
call SetUnitPositionLoc(Zr[kr[3]],jr[2])
set Qr[kr[3]]=Qr[kr[3]]+Wr[kr[3]]
if pKa()then
call AddSpecialEffectTargetUnitBJ("chest",Zr[kr[3]],Ir[kr[3]])
call DestroyEffectBJ(GetLastCreatedEffectBJ())
endif
set Vr[kr[3]]=Vr[kr[3]]+180./(vr[kr[3]]/Wr[kr[3]])
set Br[kr[3]]=SinBJ(Vr[kr[3]])*Kr[kr[3]]
call SetUnitFlyHeightBJ(Zr[kr[3]],Br[kr[3]],1000000000.)
call RemoveLocation(jr[1])
call RemoveLocation(jr[2])
else
call SetUnitPathing(Zr[kr[3]],true)
call GroupRemoveUnitSimple(Zr[kr[3]],Cr)
call SetUnitTimeScalePercent(Zr[kr[3]],100.)
call ResetUnitAnimation(Zr[kr[3]])
call ForGroupBJ(GetUnitsInRangeOfLocMatching(240.,GetUnitLoc(Zr[kr[3]]),Condition(osv)),oSv)
call DestroyEffect(AddSpecialEffectTarget("Abilities\\Spells\\Orc\\WarStomp\\WarStompCaster.mdl",Zr[kr[3]],"origin"))
set Vr[kr[3]]=.0
set kr[1]=kr[1]-1
if pla()then
set kr[2]=0
call DisableTrigger(GetTriggeringTrigger())
endif
endif
endif
set kr[3]=kr[3]+1
endloop
endfunction
function pma takes nothing returns nothing
local unit pMa=GetSpellAbilityUnit()
local integer ppa=GetUnitAbilityLevel(pMa,'A0HY')
local integer pPa=0
local effect pqa=null
if IsUnitInGroup(pMa,Ot) then
call GroupRemoveUnit(Ot,pMa)
call pAa(1.)
endif
call GroupAddUnit(Ot,pMa)
call UnitAddAbility(pMa,'A0HZ')
call UnitMakeAbilityPermanent(pMa,true,'A0HZ')
call SetUnitAbilityLevel(pMa,'A0HZ',ppa)
call SetUnitInvulnerable(pMa,true)
call SetUnitTimeScale(pMa,.0)
set pqa=AddSpecialEffectTarget("Abilities\\Spells\\Undead\\FreezingBreath\\FreezingBreathTargetArt.mdl",pMa,"origin")
loop
exitwhen IsUnitInGroup(pMa,Ot)==false
call pAa(1.)
call SetUnitState(pMa,UNIT_STATE_LIFE,GetUnitState(pMa,UNIT_STATE_LIFE)+50.)
call DestroyEffect(AddSpecialEffectTarget("Abilities\\Spells\\Items\\AIma\\AImaTarget.mdl",pMa,"origin"))
set pPa=pPa+1
if pPa==ppa*4 or GetUnitState(pMa,UNIT_STATE_LIFE)<=.0 then
call GroupRemoveUnit(Ot,pMa)
endif
endloop
call DestroyEffect(pqa)
call SetUnitInvulnerable(pMa,false)
call SetUnitTimeScale(pMa,1.)
call UnitRemoveAbility(pMa,'A0HZ')
call UnitRemoveAbility(pMa,'B04H')
call IssueImmediateOrderById(pMa,$D0004)
set pMa=null
set ppa=0
set pPa=0
set pqa=null
set pMa=null
set pqa=null
endfunction
function pQa takes nothing returns nothing
call KillUnit(GetTriggerUnit())
endfunction
function psa takes nothing returns nothing
local unit pSa=GetEnumUnit()
if GetUnitAbilityLevel(pSa,'Asw1')==0 and GetUnitAbilityLevel(pSa,'Asw2')==0 then
call UnitAddAbility(pSa,'Asw1')
call UnitMakeAbilityPermanent(pSa,true,'Asw1')
endif
set pSa=null
set pSa=null
endfunction
function pta takes nothing returns nothing
call SetBlightRadiusLocBJ(false,GetEnumPlayer(),G,220.)
endfunction
function pTa takes nothing returns nothing
set g[GetConvertedPlayerId(GetTriggerPlayer())]=GetUnitsOfPlayerAll(GetTriggerPlayer())
call ForGroupBJ(g[GetConvertedPlayerId(GetTriggerPlayer())],eIv)
call DestroyGroup(g[GetPlayerId(GetTriggerPlayer())+1])
endfunction
function pua takes nothing returns boolean
return true
endfunction
function pUa takes string pwa returns boolean
set ZM[EM]=pwa
set EM=EM+1
call BQa("when calling new_HashSet in Formations, line 18")
set EM=EM-1
return true
endfunction
function pWa takes nothing returns boolean
set EM=0
return pUa("Formations, line 1")
endfunction
function pya takes nothing returns nothing
call CameraSetEQNoiseForPlayer(GetEnumPlayer(),4.)
endfunction
function pYa takes unit pza,integer pZa,integer p_a,integer p0a,integer p1a returns nothing
call SetUnitVertexColor(pza,pZa,p_a,p0a,p1a)
endfunction
function p2a takes integer p3a,integer p4a,unit p5a,string p6a returns nothing
if p4a<0 or p4a>=6 then
call Cdv("Index out of Bounds",p6a)
elseif p4a<=2 then
if p4a<=1 then
if p4a<=0 then
set zF[p3a]=p5a
else
set zg[p3a]=p5a
endif
else
set zG[p3a]=p5a
endif
elseif p4a<=4 then
if p4a<=3 then
set zh[p3a]=p5a
else
set zH[p3a]=p5a
endif
else
set zj[p3a]=p5a
endif
endfunction
function p7a takes integer p8a,unit p9a,string Pva returns nothing
set ZM[EM]=Pva
set EM=EM+1
if LE[p8a]<Ip then
set LE[p8a]=LE[p8a]+1
set KE[p8a]=ModuloInteger(KE[p8a]+1,Ip)
call p2a(p8a,KE[p8a],p9a,"when writing array ArrayQueue_units in DummyRecycler, line 61")
else
call Cdv("Queue Overflow","when calling error in DummyRecycler, line 63")
endif
set EM=EM-1
endfunction
function Pea takes integer Pxa,unit Poa,string Pra returns nothing
set ZM[EM]=Pra
set EM=EM+1
if Ag[Pxa]==0 then
if Pxa==0 then
call Cdv("Nullpointer exception when calling ArrayQueue.enqueue","when calling error in DummyRecycler, line 57")
else
call Cdv("Called ArrayQueue.enqueue on invalid object.","when calling error in DummyRecycler, line 57")
endif
endif
call p7a(Pxa,Poa,"when calling enqueue in DummyRecycler, line 57")
set EM=EM-1
endfunction
function Pia takes unit Paa,string Pna returns nothing
local integer PVa
local integer PEa
local integer PXa
local unit POa
local unit PRa
local unit PIa
local unit PAa
local unit PNa
set ZM[EM]=Pna
set EM=EM+1
set PVa=0
set PEa=1
set PXa=Zp-1
loop
exitwhen PEa>PXa
if LE[Dp[PVa]]>LE[Dp[PEa]]then
set PVa=PEa
endif
set PEa=PEa+1
endloop
if LE[Dp[PVa]]>=Ip then
call PFv(Paa)
else
call Pea(Dp[PVa],Paa,"when calling enqueue in DummyRecycler, line 41")
set POa=Paa
call Rze(POa,He,Je)
set PRa=POa
call O3e(PRa)
set PIa=PRa
call T8v(PIa,vde(PVa*Up))
set PAa=PIa
call NXe(PAa,1.)
set PNa=PAa
call pYa(PNa,ep,qp,ap,np)
endif
set EM=EM-1
set POa=null
set PRa=null
set PIa=null
set PAa=null
set PNa=null
endfunction
function Pba takes timer PBa returns real
return TimerGetElapsed(PBa)
endfunction
function Pca takes nothing returns real
return Pba(oe)
endfunction
function PCa takes integer Wks returns nothing
endfunction
function Pda takes integer PDa,string Pfa returns nothing
set ZM[EM]=Pfa
set EM=EM+1
if Hg[PDa]==0 then
call Cdv("Double free: object of type DelayNode","when calling error in DummyRecycler, line 74")
else
set Dg=Dg+1
set Hg[PDa]=0
endif
set EM=EM-1
endfunction
function PFa takes integer Pga,string PGa returns nothing
set ZM[EM]=PGa
set EM=EM+1
call PCa(Pga)
call Pda(Pga,"when calling dealloc_DelayNode in DummyRecycler, line 74")
set EM=EM-1
endfunction
function Pha takes integer PHa,string Pja returns nothing
set ZM[EM]=Pja
set EM=EM+1
if Hg[PHa]==0 then
if PHa==0 then
call Cdv("Nullpointer exception when calling DelayNode.DelayNode","when calling error in DummyRecycler, line 74")
else
call Cdv("Called DelayNode.DelayNode on invalid object.","when calling error in DummyRecycler, line 74")
endif
endif
call PFa(PHa,"when calling destroyDelayNode in DummyRecycler, line 74")
set EM=EM-1
endfunction
function PJa takes string Pka returns nothing
local integer PKa
set ZM[EM]=Pka
set EM=EM+1
call Pia(XE[Ap],"when calling recycle in DummyRecycler, line 123")
set PKa=Ap
if VE[Ap]==0 then
set Ap=0
else
set Ap=VE[Ap]
call EAx(Pp,CE[Ap]-Pca(),Osv)
endif
call Pha(PKa,"when calling dispatch_DelayNode_destroyDelayNode in DummyRecycler, line 132")
set EM=EM-1
endfunction
function Pla takes nothing returns nothing
set EM=0
call PJa("DummyRecycler, line 130")
endfunction
function PLa takes nothing returns boolean
return true
endfunction
function Pma takes nothing returns boolean
return(GetSpellAbilityId()=='A0BL')
endfunction
function PMa takes nothing returns nothing
local unit Ppa=CreateUnitAtLoc(Player(PLAYER_NEUTRAL_PASSIVE),'h0JO',GetUnitLoc(GetSpellAbilityUnit()),GetUnitFacing(GetSpellAbilityUnit()))
call UnitAddAbility(Ppa,'A089')
call SetUnitAbilityLevel(Ppa,'A089',GetUnitAbilityLevel(GetSpellAbilityUnit(),'A088'))
call IssuePointOrderByIdLoc(Ppa,$D026F,GetSpellTargetLoc())
call TriggerSleepAction(12.8)
call RemoveUnit(Ppa)
set Ppa=null
set Ppa=null
endfunction
function PPa takes nothing returns nothing
local unit Pqa=GetSpellAbilityUnit()
local unit PQa=GetSpellTargetUnit()
local location Psa=GetUnitLoc(Pqa)
local location PSa=GetUnitLoc(PQa)
local effect Pta=AddSpecialEffectLoc("Abilities\\Spells\\Human\\MassTeleport\\MassTeleportCaster.mdl",Psa)
local effect PTa=AddSpecialEffectLoc("Abilities\\Spells\\Human\\MassTeleport\\MassTeleportCaster.mdl",PSa)
call TriggerSleepAction(.05)
call SetUnitPositionLoc(Pqa,PSa)
call SetUnitPositionLoc(PQa,Psa)
call SetUnitPositionLoc(Pqa,PSa)
set Pqa=null
set PQa=null
set Psa=null
set PSa=null
call TriggerSleepAction(5.)
call DestroyEffect(Pta)
call DestroyEffect(PTa)
set Pta=null
set PTa=null
set Pqa=null
set PQa=null
set Pta=null
set PTa=null
set Psa=null
set PSa=null
endfunction
function Pua takes nothing returns nothing
local unit PUa=GetSpellAbilityUnit()
local integer Pwa=0
call DestroyEffect(AddSpecialEffectLoc("Objects\\Spawnmodels\\Undead\\ImpaleTargetDust\\ImpaleTargetDust.mdl",GetUnitLoc(PUa)))
if GetSpellAbilityId()=='A0K1' then
if GetUnitState(PUa,UNIT_STATE_MANA)<37.5-GetUnitAbilityLevel(PUa,'A0K1')*7.5 then
set PUa=null
return
endif
set Pwa=GetUnitAbilityLevel(PUa,'A0K1')
call UnitRemoveAbility(PUa,'A0K1')
call UnitAddAbility(PUa,'A0K2')
call SetUnitAbilityLevel(PUa,'A0K2',Pwa)
call UnitMakeAbilityPermanent(PUa,true,'A0K2')
call UnitAddAbility(PUa,'A0K3')
call UnitMakeAbilityPermanent(PUa,true,'A0K3')
call UnitAddAbility(PUa,'A0K4')
call SetUnitAbilityLevel(PUa,'A0K4',Pwa)
call UnitMakeAbilityPermanent(PUa,true,'A0K4')
call UnitAddAbility(PUa,'A0K5')
call UnitMakeAbilityPermanent(PUa,true,'A0K5')
call UnitAddAbility(PUa,'Amrf')
call UnitRemoveAbility(PUa,'Amrf')
call SetUnitFlyHeight(PUa,240.,240.)
call SetUnitPathing(PUa,false)
call GroupAddUnit(bt,PUa)
else
call GroupRemoveUnit(bt,PUa)
call SetUnitPathing(PUa,true)
call UnitAddAbility(PUa,'Amrf')
call UnitRemoveAbility(PUa,'Amrf')
call SetUnitFlyHeight(PUa,.0,240.)
set Pwa=GetUnitAbilityLevel(PUa,'A0K2')
call UnitRemoveAbility(PUa,'A0K2')
call UnitRemoveAbility(PUa,'A0K3')
call UnitRemoveAbility(PUa,'A0K4')
call UnitRemoveAbility(PUa,'A0K5')
call UnitRemoveAbility(PUa,'B04J')
call UnitAddAbility(PUa,'A0K1')
call UnitMakeAbilityPermanent(PUa,true,'A0K1')
call SetUnitAbilityLevel(PUa,'A0K1',Pwa)
endif
set PUa=null
set Pwa=0
set PUa=null
endfunction
function PWa takes nothing returns boolean
return GetSpellAbilityId()=='AOdc'
endfunction
function Pya takes nothing returns boolean
set FR=$400
set kR=$800
return true
endfunction
function PYa takes nothing returns boolean
return(GetUnitTypeId(GetEnumUnit())!='h000')and(GetUnitTypeId(GetEnumUnit())!='h0KW')and(IsUnitSelected(GetEnumUnit(),GetTriggerPlayer()))
endfunction
function Pza takes nothing returns nothing
if PYa()then
call UnitRemoveTypeBJ(ConvertUnitType(20),GetEnumUnit())
endif
endfunction
function PZa takes nothing returns boolean
return IsUnitSelected(GetFilterUnit(),GetTriggerPlayer())
endfunction
function P_a takes nothing returns nothing
local timer P0a=GetExpiredTimer()
local integer P1a=LoadInteger(i,y,GetHandleId(P0a))
local integer P2a=LoadInteger(i,ub[Bl[P1a]],GetHandleId(P0a))
if P2a==0 then
call Gmv(P0a)
call RemoveSavedHandle(i,ub[Bl[P1a]],GetHandleId(Nl[P1a]))
call GKv(tb[Bl[P1a]],Nl[P1a])
call GKv(ib[Bl[P1a]],Nl[P1a])
call GJv(P1a)
set P0a=null
set P0a=null
return
endif
call GKv(Sb[Bl[P1a]],Nl[P1a])
call SaveInteger(i,ub[Bl[P1a]],GetHandleId(P0a),P2a-1)
set P0a=null
set P0a=null
endfunction
function P3a takes nothing returns boolean
return SubString(GetEventPlayerChatString(),0,1)=="'"
endfunction
function P4a takes nothing returns nothing
if GetUnitTypeId(GetEnumUnit())!='h000' and IsUnitSelected(GetEnumUnit(),GetTriggerPlayer()) then
call SetUnitAbilityLevel(GetEnumUnit(),'A0IS',GetUnitAbilityLevel(GetEnumUnit(),'A0IS')+1)
if GetUnitAbilityLevel(GetEnumUnit(),'A0IS')==0 then
call UnitAddAbility(GetEnumUnit(),'A0IS')
call UnitMakeAbilityPermanent(GetEnumUnit(),true,'A0IS')
if IsUnitInGroup(GetEnumUnit(),ns)==false then
call GroupAddUnit(ns,GetEnumUnit())
call TriggerRegisterUnitEvent(Uc,GetEnumUnit(),EVENT_UNIT_DAMAGED)
endif
endif
endif
endfunction
function P5a takes nothing returns boolean
return(GetUnitTypeId(GetEnumUnit())!='h000')and(IsUnitSelected(GetEnumUnit(),GetTriggerPlayer()))
endfunction
function P6a takes nothing returns nothing
if P5a()then
call UnitAddAbilityBJ('A07W',GetEnumUnit())
endif
endfunction
function P7a takes player P8a,integer P9a,boolean qva returns nothing
call SetPlayerAbilityAvailable(P8a,P9a,qva)
endfunction
function qea takes string qxa returns integer
local integer qoa
set ZM[EM]=qxa
set EM=EM+1
if jG==0 then
if xG<$8000 then
set xG=xG+1
set qoa=xG
set vG[qoa]=$471
else
call Cdv("Out of memory: Could not create CallbackSingle_nullTimer_OnUnitEnterLeave.","when calling error in OnUnitEnterLeave, line 63")
set qoa=0
endif
else
set jG=jG-1
set qoa=kG[jG]
set vG[qoa]=$471
endif
set EM=EM-1
return qoa
endfunction
function qra takes string qia returns boolean
local integer qaa
local integer qna
local integer qVa
set ZM[EM]=qia
set EM=EM+1
set hq=CreateTrigger()
set Fq=CreateGroup()
set jq=0
set xq='AM06'
set qaa=0
set qna=bj_MAX_PLAYER_SLOTS-1
loop
exitwhen qaa>qna
call P7a(sa[qaa],xq,false)
set qaa=qaa+1
endloop
set qVa=qea("when calling alloc_CallbackSingle_nullTimer_OnUnitEnterLeave in OnUnitEnterLeave, line 63")
call EUx(qVa)
call Lsx(qVa,"when calling nullTimer in OnUnitEnterLeave, line 63")
set EM=EM-1
return true
endfunction
function qEa takes nothing returns boolean
set EM=0
return qra("OnUnitEnterLeave, line 1")
endfunction
function qXa takes nothing returns nothing
call UnitDamageTargetBJ(Nu,GetEnumUnit(),Uu,ATTACK_TYPE_NORMAL,DAMAGE_TYPE_FIRE)
call AddSpecialEffectTargetUnitBJ("origin",GetEnumUnit(),"Abilities\\Spells\\Other\\Incinerate\\FireLordDeathExplode.mdl")
call DestroyEffectBJ(GetLastCreatedEffectBJ())
endfunction
function qOa takes nothing returns boolean
return IsUnitOwnedByPlayer(GetFilterUnit(),ua)
endfunction
function qRa takes nothing returns boolean
return GetFilterPlayer()==GetTriggerPlayer()
endfunction
function qIa takes eventid qAa returns boolean
local integer qNa=C0v(qAa)
return(qNa>=261 and qNa<=268)or qNa==17
endfunction
function qba takes eventid qBa returns boolean
local integer qca=C0v(qBa)
return qca>=305 and qca<=307
endfunction
function qCa takes trigger qda,player qDa,playerevent qfa returns event
return TriggerRegisterPlayerEvent(qda,qDa,qfa)
endfunction
function qFa takes trigger qga,player qGa,playerunitevent qha,boolexpr qHa returns event
return TriggerRegisterPlayerUnitEvent(qga,qGa,qha,qHa)
endfunction
function qja takes playerunitevent qJa,code qka,code qKa,code qla returns nothing
local integer qLa=C0v(qJa)
local integer qma
local filterfunc qMa
local trigger qpa
local player qPa
local playerunitevent qqa
if xa[qLa]==null then
set xa[qLa]=CreateTrigger()
set qma=bj_MAX_PLAYER_SLOTS-1
loop
exitwhen qma<0
set qpa=xa[qLa]
set qPa=sa[qma]
set qqa=qJa
if qka!=null then
set qMa=Filter(qka)
else
set qMa=null
endif
call qFa(qpa,qPa,qqa,qMa)
set qma=qma-1
endloop
endif
if qKa!=null then
call GPo(xa[qLa],Filter(qKa))
endif
if qla!=null then
call cQv(xa[qLa],qla)
endif
set qMa=null
set qpa=null
set qPa=null
set qqa=null
endfunction
function qQa takes playerunitevent qsa,code qSa returns nothing
call qja(qsa,null,qSa,null)
endfunction
function qta takes eventid qTa returns boolean
local integer qua=C0v(qTa)
return(qua>=18 and qua<=51)or(qua>=269 and qua<=277)or qua==315 or qua==308
endfunction
function qUa takes eventid qwa,string qWa returns integer
local integer qya
local integer qYa
local integer qza
local trigger qZa
local trigger q_a
local trigger q0a
set ZM[EM]=qWa
set EM=EM+1
set qya=C0v(qwa)
set By=By+1
set Vy[qya]=By
if qta(qwa)then
call qQa(ConvertPlayerUnitEvent(qya),Opv)
elseif qwa!=EVENT_UNIT_DAMAGED and qwa!=EVENT_PLAYER_LEAVE and qwa!=Ky and(not qIa(qwa))and(not qba(qwa))then
call Cdv("registering handleid: "+SMv(qya)+" non-playerunitevent. Except EVENT_UNIT_DAMAGED and EVENT_PLAYER_LEAVE these are not supported right now.","when calling error in ClosureEvents, line 245")
endif
if qba(qwa)and(not rp)then
set rp=true
set qYa=0
set qza=bj_MAX_PLAYERS-1
loop
exitwhen qYa>qza
set qZa=Cy
call qCa(qZa,sa[qYa],EVENT_PLAYER_MOUSE_UP)
set q_a=qZa
call qCa(q_a,sa[qYa],EVENT_PLAYER_MOUSE_DOWN)
set q0a=q_a
call qCa(q0a,sa[qYa],EVENT_PLAYER_MOUSE_MOVE)
set qYa=qYa+1
endloop
endif
set EM=EM-1
set qZa=null
set q_a=null
set q0a=null
return By
endfunction
function q1a takes eventid q2a,string q3a returns integer
local integer q4a
set ZM[EM]=q3a
set EM=EM+1
set q4a=Vy[C0v(q2a)]
if q4a==0 then
set q4a=qUa(q2a,"when calling registerEventId in ClosureEvents, line 232")
endif
set EM=EM-1
return q4a
endfunction
function q5a takes unit Itu returns boolean
return true
endfunction
function q6a takes string q7a returns integer
local integer q8a
set ZM[EM]=q7a
set EM=EM+1
if PY==0 then
if AY<$8000 then
set AY=AY+1
set q8a=AY
set DY[q8a]=$CE1
else
call Cdv("Out of memory: Could not create LimitedExecuteAction_executeWhile_Network_Network.","when calling error in Network, line 348")
set q8a=0
endif
else
set PY=PY-1
set q8a=IY[PY]
set DY[q8a]=$CE1
endif
set EM=EM-1
return q8a
endfunction
function q9a takes string Qva returns integer
local integer Qea
set ZM[EM]=Qva
set EM=EM+1
if EY==0 then
if ZY<$8000 then
set ZY=ZY+1
set Qea=ZY
set UY[Qea]=$D05
else
call Cdv("Out of memory: Could not create LimitedExecuteCondition_executeWhile_Network_Network.","when calling error in Network, line 348")
set Qea=0
endif
else
set EY=EY-1
set Qea=WY[EY]
set UY[Qea]=$D05
endif
set EM=EM-1
return Qea
endfunction
function Qxa takes integer Qoa,string Qra returns nothing
local integer Qia
local integer Qaa
local integer Qna
local integer QVa
set ZM[EM]=Qra
set EM=EM+1
set Qna=oq
set Qia=q9a("when calling alloc_LimitedExecuteCondition_executeWhile_Network_Network in Network, line 348")
set iD[Qia]=Qoa
set QVa=Qia
set Qaa=q6a("when calling alloc_LimitedExecuteAction_executeWhile_Network_Network in Network, line 348")
set SD[Qaa]=Qoa
call WOe(Qna,QVa,Qaa,"when calling executeWhile in Network, line 348")
set EM=EM-1
endfunction
function QEa takes integer QXa,string QOa returns nothing
set ZM[EM]=QOa
set EM=EM+1
if ck[QXa]==0 then
if QXa==0 then
call Cdv("Nullpointer exception when calling Network.writeReals","when calling error in Network, line 347")
else
call Cdv("Called Network.writeReals on invalid object.","when calling error in Network, line 347")
endif
endif
call Qxa(QXa,"when calling writeReals in Network, line 347")
set EM=EM-1
endfunction
function QRa takes integer QIa,integer QAa returns nothing
set HQ[QIa]=QAa
endfunction
function QNa takes integer Qba,integer QBa,string Qca returns nothing
set ZM[EM]=Qca
set EM=EM+1
if OG[Qba]==0 then
if Qba==0 then
call Cdv("Nullpointer exception when calling AbstractBuffer.setMode","when calling error in BufferInterface, line 131")
else
call Cdv("Called AbstractBuffer.setMode on invalid object.","when calling error in BufferInterface, line 131")
endif
endif
call QRa(Qba,QBa)
set EM=EM-1
endfunction
function QCa takes string Qda returns integer
local integer QDa
set ZM[EM]=Qda
set EM=EM+1
if EY==0 then
if ZY<$8000 then
set ZY=ZY+1
set QDa=ZY
set UY[QDa]=$D09
else
call Cdv("Out of memory: Could not create LimitedExecuteCondition_executeWhile_Network_Network.","when calling error in Network, line 372")
set QDa=0
endif
else
set EY=EY-1
set QDa=WY[EY]
set UY[QDa]=$D09
endif
set EM=EM-1
return QDa
endfunction
function Qfa takes string QFa returns integer
local integer Qga
set ZM[EM]=QFa
set EM=EM+1
if PY==0 then
if AY<$8000 then
set AY=AY+1
set Qga=AY
set DY[Qga]=$CE5
else
call Cdv("Out of memory: Could not create LimitedExecuteAction_executeWhile_Network_Network.","when calling error in Network, line 372")
set Qga=0
endif
else
set PY=PY-1
set Qga=IY[PY]
set DY[Qga]=$CE5
endif
set EM=EM-1
return Qga
endfunction
function QGa takes integer Qha,string QHa returns nothing
local integer Qja
local integer QJa
local integer Qka
local integer QKa
set ZM[EM]=QHa
set EM=EM+1
set Qka=oq
set Qja=QCa("when calling alloc_LimitedExecuteCondition_executeWhile_Network_Network in Network, line 372")
set pD[Qja]=Qha
set QKa=Qja
set QJa=Qfa("when calling alloc_LimitedExecuteAction_executeWhile_Network_Network in Network, line 372")
set eD[QJa]=Qha
call WOe(Qka,QKa,QJa,"when calling executeWhile in Network, line 372")
set EM=EM-1
endfunction
function Qla takes integer QLa,string Qma returns nothing
set ZM[EM]=Qma
set EM=EM+1
if ck[QLa]==0 then
if QLa==0 then
call Cdv("Nullpointer exception when calling Network.writeStrings","when calling error in Network, line 371")
else
call Cdv("Called Network.writeStrings on invalid object.","when calling error in Network, line 371")
endif
endif
call QGa(QLa,"when calling writeStrings in Network, line 371")
set EM=EM-1
endfunction
function QMa takes string Qpa returns integer
local integer QPa
set ZM[EM]=Qpa
set EM=EM+1
if sk==0 then
if tk<$8000 then
set tk=tk+1
set QPa=tk
set ik[QPa]=4874
else
call Cdv("Out of memory: Could not create SynchronizationCallback_onSynced_Network_Network.","when calling error in Network, line 420")
set QPa=0
endif
else
set sk=sk-1
set QPa=rk[sk]
set ik[QPa]=4874
endif
set EM=EM-1
return QPa
endfunction
function Qqa takes string QQa returns integer
local integer Qsa
set ZM[EM]=QQa
set EM=EM+1
if PY==0 then
if AY<$8000 then
set AY=AY+1
set Qsa=AY
set DY[Qsa]=$CE3
else
call Cdv("Out of memory: Could not create LimitedExecuteAction_executeWhile_Network_Network.","when calling error in Network, line 360")
set Qsa=0
endif
else
set PY=PY-1
set Qsa=IY[PY]
set DY[Qsa]=$CE3
endif
set EM=EM-1
return Qsa
endfunction
function QSa takes string Qta returns integer
local integer QTa
set ZM[EM]=Qta
set EM=EM+1
if EY==0 then
if ZY<$8000 then
set ZY=ZY+1
set QTa=ZY
set UY[QTa]=$D07
else
call Cdv("Out of memory: Could not create LimitedExecuteCondition_executeWhile_Network_Network.","when calling error in Network, line 360")
set QTa=0
endif
else
set EY=EY-1
set QTa=WY[EY]
set UY[QTa]=$D07
endif
set EM=EM-1
return QTa
endfunction
function Qua takes integer QUa,string Qwa returns nothing
local integer QWa
local integer Qya
local integer QYa
local integer Qza
set ZM[EM]=Qwa
set EM=EM+1
set QYa=oq
set QWa=QSa("when calling alloc_LimitedExecuteCondition_executeWhile_Network_Network in Network, line 360")
set OD[QWa]=QUa
set Qza=QWa
set Qya=Qqa("when calling alloc_LimitedExecuteAction_executeWhile_Network_Network in Network, line 360")
set lD[Qya]=QUa
call WOe(QYa,Qza,Qya,"when calling executeWhile in Network, line 360")
set EM=EM-1
endfunction
function QZa takes integer Q_a,string Q0a returns nothing
set ZM[EM]=Q0a
set EM=EM+1
if ck[Q_a]==0 then
if Q_a==0 then
call Cdv("Nullpointer exception when calling Network.writeBooleans","when calling error in Network, line 359")
else
call Cdv("Called Network.writeBooleans on invalid object.","when calling error in Network, line 359")
endif
endif
call Qua(Q_a,"when calling writeBooleans in Network, line 359")
set EM=EM-1
endfunction
function Q1a takes string Q2a returns integer
local integer Q3a
set ZM[EM]=Q2a
set EM=EM+1
if PY==0 then
if AY<$8000 then
set AY=AY+1
set Q3a=AY
set DY[Q3a]=$CDF
else
call Cdv("Out of memory: Could not create LimitedExecuteAction_executeWhile_Network_Network.","when calling error in Network, line 336")
set Q3a=0
endif
else
set PY=PY-1
set Q3a=IY[PY]
set DY[Q3a]=$CDF
endif
set EM=EM-1
return Q3a
endfunction
function Q4a takes string Q5a returns integer
local integer Q6a
set ZM[EM]=Q5a
set EM=EM+1
if EY==0 then
if ZY<$8000 then
set ZY=ZY+1
set Q6a=ZY
set UY[Q6a]=$D03
else
call Cdv("Out of memory: Could not create LimitedExecuteCondition_executeWhile_Network_Network.","when calling error in Network, line 336")
set Q6a=0
endif
else
set EY=EY-1
set Q6a=WY[EY]
set UY[Q6a]=$D03
endif
set EM=EM-1
return Q6a
endfunction
function Q7a takes integer Q8a,string Q9a returns nothing
local integer sva
local integer sea
local integer sxa
local integer soa
set ZM[EM]=Q9a
set EM=EM+1
set sxa=oq
set sva=Q4a("when calling alloc_LimitedExecuteCondition_executeWhile_Network_Network in Network, line 336")
set uD[sva]=Q8a
set soa=sva
set sea=Q1a("when calling alloc_LimitedExecuteAction_executeWhile_Network_Network in Network, line 336")
set rD[sea]=Q8a
call WOe(sxa,soa,sea,"when calling executeWhile in Network, line 336")
set EM=EM-1
endfunction
function sra takes integer sia,string saa returns nothing
set ZM[EM]=saa
set EM=EM+1
if ck[sia]==0 then
if sia==0 then
call Cdv("Nullpointer exception when calling Network.writeInts","when calling error in Network, line 335")
else
call Cdv("Called Network.writeInts on invalid object.","when calling error in Network, line 335")
endif
endif
call Q7a(sia,"when calling writeInts in Network, line 335")
set EM=EM-1
endfunction
function sna takes integer sVa,string sEa returns nothing
local integer sXa
local integer sOa
local integer sRa
set ZM[EM]=sEa
set EM=EM+1
if Ca and jA[sVa]!=1 then
call Cdv("Network: trying to send round at the wrong time","when calling error in Network, line 385")
endif
set sXa=UPx("when calling new_SimpleSynchronizer in Network, line 387")
call uex(QA[sVa],"when calling reset in Network, line 390")
call uex(WA[sVa],"when calling reset in Network, line 391")
call uex(EA[sVa],"when calling reset in Network, line 392")
call uex(ZA[sVa],"when calling reset in Network, line 393")
call T6x(yq,xA[sVa])
call T6x(pq,xA[sVa])
if ta==IA[sVa]then
call QNa(vA[sVa],0,"when calling setMode in Network, line 401")
call sra(sVa,"when calling writeInts in Network, line 404")
call QZa(sVa,"when calling writeBooleans in Network, line 405")
call QEa(sVa,"when calling writeReals in Network, line 406")
call Qla(sVa,"when calling writeStrings in Network, line 407")
call QNa(vA[sVa],3,"when calling setMode in Network, line 410")
call uyx(QA[sVa],"when calling sync in Network, line 413")
call uyx(EA[sVa],"when calling sync in Network, line 414")
call uyx(WA[sVa],"when calling sync in Network, line 415")
call uyx(ZA[sVa],"when calling sync in Network, line 416")
endif
call wGx(sXa,"when calling sync in Network, line 419")
set sRa=sXa
set sOa=QMa("when calling alloc_SynchronizationCallback_onSynced_Network_Network in Network, line 420")
set nD[sOa]=sVa
call wzx(sRa,sOa,"when calling onSynced in Network, line 420")
set EM=EM-1
endfunction
function sIa takes integer sAa,string sNa returns nothing
set ZM[EM]=sNa
set EM=EM+1
if ck[sAa]==0 then
if sAa==0 then
call Cdv("Nullpointer exception when calling Network.sendRound","when calling error in Network, line 383")
else
call Cdv("Called Network.sendRound on invalid object.","when calling error in Network, line 383")
endif
endif
call sna(sAa,"when calling sendRound in Network, line 383")
set EM=EM-1
endfunction
function sba takes integer sBa,string sca returns nothing
set ZM[EM]=sca
set EM=EM+1
if bk[sBa]==0 then
call Cdv("Double free: object of type NetworkFinishedCallback","when calling error in Network, line 204")
else
set ok[Ok]=sBa
set Ok=Ok+1
set bk[sBa]=0
endif
set EM=EM-1
endfunction
function sCa takes integer sda,string sDa returns nothing
set ZM[EM]=sDa
set EM=EM+1
call sba(sda,"when calling dealloc_NetworkFinishedCallback in Network, line 204")
set EM=EM-1
endfunction
function sfa takes integer sFa,string sga returns nothing
set ZM[EM]=sga
set EM=EM+1
if bk[sFa]==0 then
if sFa==0 then
call Cdv("Nullpointer exception when calling NetworkFinishedCallback.NetworkFinishedCallback","when calling error in Network, line 204")
else
call Cdv("Called NetworkFinishedCallback.NetworkFinishedCallback on invalid object.","when calling error in Network, line 204")
endif
endif
call sCa(sFa,"when calling destroyNetworkFinishedCallback in Network, line 204")
set EM=EM-1
endfunction
function sGa takes integer Pps returns nothing
endfunction
function sha takes integer sHa,string sja returns nothing
set ZM[EM]=sja
set EM=EM+1
call idx(WZ[sHa],"when calling dispatch_Table_destroyTable in HashBuffer, line 28")
call sGa(sHa)
set EM=EM-1
endfunction
function sJa takes integer ska,string sKa returns nothing
set ZM[EM]=sKa
set EM=EM+1
if OG[ska]==0 then
call Cdv("Double free: object of type HashBuffer","when calling error in HashBuffer, line 10")
else
set SG[cG]=ska
set cG=cG+1
set OG[ska]=0
endif
set EM=EM-1
endfunction
function sla takes integer sLa,string sma returns nothing
set ZM[EM]=sma
set EM=EM+1
call sha(sLa,"when calling HashBuffer_onDestroy in HashBuffer, line 27")
call sJa(sLa,"when calling dealloc_HashBuffer in HashBuffer, line 27")
set EM=EM-1
endfunction
function sMa takes integer spa,string sPa returns nothing
set ZM[EM]=sPa
set EM=EM+1
if OG[spa]==0 then
if spa==0 then
call Cdv("Nullpointer exception when calling HashBuffer.HashBuffer","when calling error in HashBuffer, line 10")
else
call Cdv("Called HashBuffer.HashBuffer on invalid object.","when calling error in HashBuffer, line 10")
endif
endif
call sla(spa,"when calling destroyHashBuffer in HashBuffer, line 10")
set EM=EM-1
endfunction
function sqa takes integer sQa,string ssa returns nothing
set ZM[EM]=ssa
set EM=EM+1
call Slx(QA[sQa],"when calling dispatch_GamecacheBuffer_destroyGamecacheBuffer in Network, line 250")
call Slx(WA[sQa],"when calling dispatch_GamecacheBuffer_destroyGamecacheBuffer in Network, line 251")
call Slx(EA[sQa],"when calling dispatch_GamecacheBuffer_destroyGamecacheBuffer in Network, line 252")
call Slx(ZA[sQa],"when calling dispatch_GamecacheBuffer_destroyGamecacheBuffer in Network, line 253")
call S0x(mA[sQa],"when calling dispatch_StringEncoder_destroyStringEncoder in Network, line 254")
call sMa(vA[sQa],"when calling dispatch_HashBuffer_destroyHashBuffer in Network, line 255")
call tvx(UA[sQa],"when calling dispatch_MetadataStore_destroyMetadataStore in Network, line 256")
call sfa(NA[sQa],"when calling dispatch_NetworkFinishedCallback_destroyNetworkFinishedCallback in Network, line 257")
set EM=EM-1
endfunction
function sSa takes integer sta,string sTa returns nothing
set ZM[EM]=sTa
set EM=EM+1
if ck[sta]==0 then
call Cdv("Double free: object of type Network","when calling error in Network, line 207")
else
set Sk=Sk+1
set ck[sta]=0
endif
set EM=EM-1
endfunction
function sua takes integer sUa,string swa returns nothing
set ZM[EM]=swa
set EM=EM+1
call sqa(sUa,"when calling Network_onDestroy in Network, line 249")
call sSa(sUa,"when calling dealloc_Network in Network, line 249")
set EM=EM-1
endfunction
function sWa takes integer sya,string sYa returns nothing
set ZM[EM]=sYa
set EM=EM+1
if ck[sya]==0 then
if sya==0 then
call Cdv("Nullpointer exception when calling Network.Network","when calling error in Network, line 207")
else
call Cdv("Called Network.Network on invalid object.","when calling error in Network, line 207")
endif
endif
call sua(sya,"when calling destroyNetwork in Network, line 207")
set EM=EM-1
endfunction
function sza takes integer Z_t,integer U_t,integer I_t,string sZa returns nothing
set ZM[EM]=sZa
set EM=EM+1
call Cdv("Network: did not specify any callback function","when calling error in Network, line 244")
set EM=EM-1
endfunction
function s_a takes string s0a returns integer
local integer s1a
set ZM[EM]=s0a
set EM=EM+1
if CY==0 then
if VY<$8000 then
set VY=VY+1
set s1a=VY
set BY[s1a]=$872
else
call Cdv("Out of memory: Could not create ForForceCallback_try_start_onSynced_PersistentStore_Persistable.","when calling error in Persistable, line 183")
set s1a=0
endif
else
set CY=CY-1
set s1a=XY[CY]
set BY[s1a]=$872
endif
set EM=EM-1
return s1a
endfunction
function s2a takes string s3a returns nothing
call COv(ta,3,s3a)
endfunction
function s4a takes integer s5a,integer s6a,string s7a,string s8a returns nothing
set ZM[EM]=s8a
set EM=EM+1
set JQ[s5a]=s6a
if s6a==2 then
call Cdv("Buffer: "+s7a,"when calling error in BufferInterface, line 127")
else
call s2a("Buffer: "+s7a)
endif
set EM=EM-1
endfunction
function s9a takes integer Sva,integer Sea,string Sxa,string Soa returns nothing
set ZM[EM]=Soa
set EM=EM+1
if OG[Sva]==0 then
if Sva==0 then
call Cdv("Nullpointer exception when calling AbstractBuffer.fail","when calling error in BufferInterface, line 123")
else
call Cdv("Called AbstractBuffer.fail on invalid object.","when calling error in BufferInterface, line 123")
endif
endif
call s4a(Sva,Sea,Sxa,"when calling fail in BufferInterface, line 123")
set EM=EM-1
endfunction
function Sra takes integer Sia,string Saa returns boolean
local boolean Sna
set ZM[EM]=Saa
set EM=EM+1
set Sna=hye(gX[Sia],"when calling size in StringBuffer, line 105")>0 or GZv(hX[Sia])>0
set EM=EM-1
return Sna
endfunction
function SVa takes integer SEa,string SXa returns boolean
local boolean SOa
set ZM[EM]=SXa
set EM=EM+1
if OG[SEa]==0 then
if SEa==0 then
call Cdv("Nullpointer exception when calling AbstractStringBuffer.isDataAvailable","when calling error in StringBuffer, line 104")
else
call Cdv("Called AbstractStringBuffer.isDataAvailable on invalid object.","when calling error in StringBuffer, line 104")
endif
endif
set SOa=Sra(SEa,"when calling isDataAvailable in StringBuffer, line 104")
set EM=EM-1
return SOa
endfunction
function SRa takes integer SIa,string SAa returns nothing
set ZM[EM]=SAa
set EM=EM+1
if not SVa(SIa,"when calling isDataAvailable in StringBuffer, line 111")then
call s9a(SIa,1,"reached EOF","when calling fail in StringBuffer, line 112")
endif
set EM=EM-1
endfunction
function SNa takes integer Sba,string SBa returns nothing
set ZM[EM]=SBa
set EM=EM+1
if OG[Sba]==0 then
if Sba==0 then
call Cdv("Nullpointer exception when calling AbstractStringBuffer.checkDataAvailable","when calling error in StringBuffer, line 110")
else
call Cdv("Called AbstractStringBuffer.checkDataAvailable on invalid object.","when calling error in StringBuffer, line 110")
endif
endif
call SRa(Sba,"when calling checkDataAvailable in StringBuffer, line 110")
set EM=EM-1
endfunction
function Sca takes integer SCa,string Sda returns nothing
set ZM[EM]=Sda
set EM=EM+1
if iv[SCa]==0 then
call Cdv("Double free: object of type ChunkElement","when calling error in StringBuffer, line 7")
else
set rv[sv]=SCa
set sv=sv+1
set iv[SCa]=0
endif
set EM=EM-1
endfunction
function SDa takes integer FXi returns nothing
endfunction
function Sfa takes integer SFa,string Sga returns nothing
set ZM[EM]=Sga
set EM=EM+1
call SDa(SFa)
call Sca(SFa,"when calling dealloc_ChunkElement in StringBuffer, line 7")
set EM=EM-1
endfunction
function SGa takes integer Sha,string SHa returns nothing
set ZM[EM]=SHa
set EM=EM+1
if iv[Sha]==0 then
if Sha==0 then
call Cdv("Nullpointer exception when calling ChunkElement.ChunkElement","when calling error in StringBuffer, line 7")
else
call Cdv("Called ChunkElement.ChunkElement on invalid object.","when calling error in StringBuffer, line 7")
endif
endif
call Sfa(Sha,"when calling destroyChunkElement in StringBuffer, line 7")
set EM=EM-1
endfunction
function Sja takes integer SJa,string Ska returns nothing
local integer SKa
set ZM[EM]=Ska
set EM=EM+1
if YYv(gX[SJa],"when calling isEmpty in StringBuffer, line 116")then
call s9a(SJa,1,"reached EOF","when calling fail in StringBuffer, line 117")
set EM=EM-1
return
endif
set SKa=Gqe(gX[SJa],"when calling dequeue in StringBuffer, line 120")
set hX[SJa]=hX[SJa]+jX[SKa]
call SGa(SKa,"when calling dispatch_ChunkElement_destroyChunkElement in StringBuffer, line 122")
set EM=EM-1
endfunction
function Sla takes integer SLa,string Sma returns nothing
set ZM[EM]=Sma
set EM=EM+1
if OG[SLa]==0 then
if SLa==0 then
call Cdv("Nullpointer exception when calling AbstractStringBuffer.nextChunk","when calling error in StringBuffer, line 115")
else
call Cdv("Called AbstractStringBuffer.nextChunk on invalid object.","when calling error in StringBuffer, line 115")
endif
endif
call Sja(SLa,"when calling nextChunk in StringBuffer, line 115")
set EM=EM-1
endfunction
function SMa takes integer Spa returns boolean
return JQ[Spa]==0
endfunction
function SPa takes integer Sqa,string SQa returns boolean
local boolean Ssa
set ZM[EM]=SQa
set EM=EM+1
if OG[Sqa]==0 then
if Sqa==0 then
call Cdv("Nullpointer exception when calling AbstractBuffer.isValid","when calling error in BufferInterface, line 143")
else
call Cdv("Called AbstractBuffer.isValid on invalid object.","when calling error in BufferInterface, line 143")
endif
endif
set Ssa=SMa(Sqa)
set EM=EM-1
return Ssa
endfunction
function SSa takes integer Sta,integer STa,string Sua returns string
local string SUa
set ZM[EM]=Sua
set EM=EM+1
if Ca and STa>kR then
call s9a(Sta,2,"trying to pop a string above max size","when calling fail in StringBuffer, line 161")
endif
if STa==0 then
set EM=EM-1
return""
endif
call SNa(Sta,"when calling checkDataAvailable in StringBuffer, line 167")
loop
exitwhen not(SPa(Sta,"when calling isValid in StringBuffer, line 169")and GZv(hX[Sta])<STa)
call Sla(Sta,"when calling nextChunk in StringBuffer, line 170")
endloop
if SPa(Sta,"when calling isValid in StringBuffer, line 172")then
set SUa=Psv(hX[Sta],0,STa)
set hX[Sta]=Tgv(hX[Sta],STa)
set EM=EM-1
return SUa
else
set EM=EM-1
return null
endif
endfunction
function Swa takes integer SWa,integer Sya,string SYa returns string
local string Sza
set ZM[EM]=SYa
set EM=EM+1
if OG[SWa]==0 then
if SWa==0 then
call Cdv("Nullpointer exception when calling AbstractStringBuffer.popString","when calling error in StringBuffer, line 159")
else
call Cdv("Called AbstractStringBuffer.popString on invalid object.","when calling error in StringBuffer, line 159")
endif
endif
set Sza=SSa(SWa,Sya,"when calling popString in StringBuffer, line 159")
set EM=EM-1
return Sza
endfunction
function SZa takes integer S_a,string S0a returns nothing
set ZM[EM]=S0a
set EM=EM+1
if Ca and(not SPa(S_a,"when calling isValid in BufferInterface, line 120"))then
call Cdv("Buffer: trying to use a failed buffer","when calling error in BufferInterface, line 121")
endif
set EM=EM-1
endfunction
function S1a takes integer S2a,string S3a returns nothing
set ZM[EM]=S3a
set EM=EM+1
if OG[S2a]==0 then
if S2a==0 then
call Cdv("Nullpointer exception when calling AbstractBuffer.checkFailed","when calling error in BufferInterface, line 119")
else
call Cdv("Called AbstractBuffer.checkFailed on invalid object.","when calling error in BufferInterface, line 119")
endif
endif
call SZa(S2a,"when calling checkFailed in BufferInterface, line 119")
set EM=EM-1
endfunction
function S4a takes integer S5a returns string
local integer S6a=S5a
local string S7a
if S6a==0 then
set S7a="READ"
elseif S6a==1 then
set S7a="WRITE"
elseif S6a==2 then
set S7a="READ_WRITE"
else
set S7a="LOCKED"
endif
return S7a
endfunction
function S8a takes integer S9a returns boolean
return HQ[S9a]==0 or HQ[S9a]==2
endfunction
function tva takes integer tea,string txa returns boolean
local boolean toa
set ZM[EM]=txa
set EM=EM+1
if OG[tea]==0 then
if tea==0 then
call Cdv("Nullpointer exception when calling AbstractBuffer.isReadable","when calling error in BufferInterface, line 140")
else
call Cdv("Called AbstractBuffer.isReadable on invalid object.","when calling error in BufferInterface, line 140")
endif
endif
set toa=S8a(tea)
set EM=EM-1
return toa
endfunction
function tra takes integer tia,string taa returns nothing
set ZM[EM]=taa
set EM=EM+1
call S1a(tia,"when calling checkFailed in BufferInterface, line 166")
if Ca and(not tva(tia,"when calling isReadable in BufferInterface, line 167"))then
call Cdv("Buffer: cannot read from buffer with mode "+S4a(HQ[tia]),"when calling error in BufferInterface, line 168")
endif
set EM=EM-1
endfunction
function tna takes integer tVa,string tEa returns nothing
set ZM[EM]=tEa
set EM=EM+1
if OG[tVa]==0 then
if tVa==0 then
call Cdv("Nullpointer exception when calling AbstractBuffer.checkRead","when calling error in BufferInterface, line 165")
else
call Cdv("Called AbstractBuffer.checkRead on invalid object.","when calling error in BufferInterface, line 165")
endif
endif
call tra(tVa,"when calling checkRead in BufferInterface, line 165")
set EM=EM-1
endfunction
function tXa takes integer tOa,string tRa returns string
local string tIa
local integer tAa
set ZM[EM]=tRa
set EM=EM+1
set tIa=""
set tAa=tOa
if tAa==0 then
set tIa="i"
elseif tAa==1 then
set tIa="r"
elseif tAa==3 then
set tIa="b"
elseif tAa==2 then
set tIa="s"
else
call Cdv("ValueType: INVALID should never be serializable","when calling error in OrderedStringBuffer, line 26")
endif
set EM=EM-1
return tIa
endfunction
function tNa takes string tba returns integer
local integer tBa=4
local string tca=tba
if tca=="i" then
set tBa=0
elseif tca=="r" then
set tBa=1
elseif tca=="b" then
set tBa=3
elseif tca=="s" then
set tBa=2
endif
return tBa
endfunction
function tCa takes integer tda,string tDa returns integer
local integer tfa
set ZM[EM]=tDa
set EM=EM+1
set tfa=tNa(Swa(tda,1,"when calling popString in OrderedStringBuffer, line 96"))
if tfa==4 then
call s9a(tda,3,"malformed input","when calling fail in OrderedStringBuffer, line 98")
endif
set EM=EM-1
return tfa
endfunction
function tFa takes integer tga,string tGa returns integer
local integer tha
set ZM[EM]=tGa
set EM=EM+1
if OG[tga]==0 then
if tga==0 then
call Cdv("Nullpointer exception when calling OrderedStringBuffer.popTypeIdentifier","when calling error in OrderedStringBuffer, line 95")
else
call Cdv("Called OrderedStringBuffer.popTypeIdentifier on invalid object.","when calling error in OrderedStringBuffer, line 95")
endif
endif
set tha=tCa(tga,"when calling popTypeIdentifier in OrderedStringBuffer, line 95")
set EM=EM-1
return tha
endfunction
function tHa takes integer tja,integer tJa,string tka returns boolean
local integer tKa
set ZM[EM]=tka
set EM=EM+1
set tKa=tFa(tja,"when calling popTypeIdentifier in OrderedStringBuffer, line 103")
if not SPa(tja,"when calling isValid in OrderedStringBuffer, line 105")then
set EM=EM-1
return false
endif
if tKa!=tJa then
call s9a(tja,4,"tried to read "+tXa(tJa,"when calling toString in OrderedStringBuffer, line 108")+" but was "+tXa(tKa,"when calling toString in OrderedStringBuffer, line 108"),"when calling fail in OrderedStringBuffer, line 108")
set EM=EM-1
return false
endif
set EM=EM-1
return true
endfunction
function tla takes integer tLa,integer tma,string tMa returns boolean
local boolean tpa
set ZM[EM]=tMa
set EM=EM+1
if OG[tLa]==0 then
if tLa==0 then
call Cdv("Nullpointer exception when calling OrderedStringBuffer.checkType","when calling error in OrderedStringBuffer, line 102")
else
call Cdv("Called OrderedStringBuffer.checkType on invalid object.","when calling error in OrderedStringBuffer, line 102")
endif
endif
set tpa=tHa(tLa,tma,"when calling checkType in OrderedStringBuffer, line 102")
set EM=EM-1
return tpa
endfunction
function tPa takes integer tqa,string tQa returns boolean
local boolean tsa
local boolean tSa
set ZM[EM]=tQa
set EM=EM+1
call tna(tqa,"when calling checkRead in OrderedStringBuffer, line 166")
if tla(tqa,3,"when calling checkType in OrderedStringBuffer, line 167")then
set tsa=Swa(tqa,1,"when calling popString in OrderedStringBuffer, line 167")=="1"
else
set tsa=false
endif
set tSa=tsa
set EM=EM-1
return tSa
endfunction
function tta takes integer tTa,integer tua returns boolean
return cWv(XR,tTa,tua)
endfunction
function tUa takes integer twa,integer tWa,string tya returns boolean
local boolean tYa
set ZM[EM]=tya
set EM=EM+1
if ph[twa]==0 then
if twa==0 then
call Cdv("Nullpointer exception when calling Table.hasBoolean","when calling error in Table, line 15")
else
call Cdv("Called Table.hasBoolean on invalid object.","when calling error in Table, line 15")
endif
endif
set tYa=tta(twa,tWa)
set EM=EM-1
return tYa
endfunction
function tza takes integer tZa,string t_a returns boolean
local boolean t0a
set ZM[EM]=t_a
set EM=EM+1
call tna(tZa,"when calling checkRead in HashBuffer, line 75")
set DZ[tZa]=DZ[tZa]+1
if not tUa(WZ[tZa],DZ[tZa],"when calling hasBoolean in HashBuffer, line 77")then
call Cdv("HashBuffer: trying to read non-present boolean at pos#"+SMv(DZ[tZa]),"when calling error in HashBuffer, line 78")
endif
set t0a=CKx(WZ[tZa],DZ[tZa],"when calling loadBoolean in HashBuffer, line 79")
set EM=EM-1
return t0a
endfunction
function t1a takes integer t2a,string t3a returns boolean
local boolean t4a
set ZM[EM]=t3a
set EM=EM+1
if OG[t2a]==0 then
if t2a==0 then
call Cdv("Nullpointer exception when calling Buffer.readBoolean","when calling error in BufferInterface, line 61")
else
call Cdv("Called Buffer.readBoolean on invalid object.","when calling error in BufferInterface, line 61")
endif
endif
if OG[t2a]<=$441 then
set t4a=tPa(t2a,"when calling readBoolean in BufferInterface, line 61")
else
set t4a=tza(t2a,"when calling readBoolean in BufferInterface, line 61")
endif
set EM=EM-1
return t4a
endfunction
function t5a takes integer ytt,integer ptt returns nothing
endfunction
function t6a takes integer t7a,integer t8a,string t9a returns nothing
set ZM[EM]=t9a
set EM=EM+1
if lG[t7a]==0 then
if t7a==0 then
call Cdv("Nullpointer exception when calling Persistable.onLoaded","when calling error in Persistable, line 79")
else
call Cdv("Called Persistable.onLoaded on invalid object.","when calling error in Persistable, line 79")
endif
endif
call t5a(t7a,t8a)
set EM=EM-1
endfunction
function Tva takes integer uLc returns nothing
endfunction
function Tea takes integer lLc,integer bLc returns nothing
endfunction
function Txa takes integer Toa,integer Tra,integer Tia,string Taa returns nothing
set ZM[EM]=Taa
set EM=EM+1
if Tra!=0 then
call Tva(DD[Toa])
endif
if Tia!=0 then
call Tea(Tia,Tra)
endif
call t6a(DD[Toa],Tra,"when calling onLoaded in Persistable, line 132")
set EM=EM-1
endfunction
function Tna takes integer TVa,integer TEa,integer TXa,string TOa returns nothing
set ZM[EM]=TOa
set EM=EM+1
if vk[TVa]==0 then
if TVa==0 then
call Cdv("Nullpointer exception when calling PersistentStore.finishWithStatus","when calling error in Persistable, line 126")
else
call Cdv("Called PersistentStore.finishWithStatus on invalid object.","when calling error in Persistable, line 126")
endif
endif
call Txa(TVa,TEa,TXa,"when calling finishWithStatus in Persistable, line 126")
set EM=EM-1
endfunction
function TRa takes integer TIa,integer TAa,integer TNa,string Tba returns nothing
local integer TBa
local boolean Tca
local boolean TCa
local integer Tda
set ZM[EM]=Tba
set EM=EM+1
set TBa=0
if TAa==1 then
set TBa=4
else
set Tca=t1a(TNa,"when calling readBoolean in Persistable, line 179")
if Tca then
set Tda=s_a("when calling alloc_ForForceCallback_try_start_onSynced_PersistentStore_Persistable in Persistable, line 183")
set sH[Tda]=uH[TIa]
set tH[Tda]=TNa
set TCa=FPe(Tda,"when calling try in Persistable, line 183")
if not TCa then
set TBa=3
endif
else
set TBa=2
endif
endif
call Tna(uH[TIa],TBa,rH[TIa],"when calling finishWithStatus in Persistable, line 189")
set EM=EM-1
endfunction
function TDa takes integer Tfa,integer TFa,integer Tga,string TGa returns nothing
set ZM[EM]=TGa
set EM=EM+1
if bk[Tfa]==0 then
if Tfa==0 then
call Cdv("Nullpointer exception when calling NetworkFinishedCallback.onFinish","when calling error in Network, line 205")
else
call Cdv("Called NetworkFinishedCallback.onFinish on invalid object.","when calling error in Network, line 205")
endif
endif
if bk[Tfa]<=$E54 then
call sza(Tfa,TFa,Tga,"when calling onFinish_Network_Network in Network, line 205")
else
call TRa(Tfa,TFa,Tga,"when calling onFinish_start_onSynced_PersistentStore_Persistable in Network, line 205")
endif
set EM=EM-1
endfunction
function Tha takes integer THa,string Tja returns nothing
set ZM[EM]=Tja
set EM=EM+1
set jA[THa]=2
call TDa(NA[THa],1,vA[THa],"when calling onFinish in Network, line 265")
call sWa(THa,"when calling dispatch_Network_destroyNetwork in Network, line 266")
set EM=EM-1
endfunction
function TJa takes integer Tka,string TKa returns nothing
set ZM[EM]=TKa
set EM=EM+1
if ck[Tka]==0 then
if Tka==0 then
call Cdv("Nullpointer exception when calling Network.abort","when calling error in Network, line 263")
else
call Cdv("Called Network.abort on invalid object.","when calling error in Network, line 263")
endif
endif
call Tha(Tka,"when calling abort in Network, line 263")
set EM=EM-1
endfunction
function Tla takes string TLa returns integer
local integer Tma
set ZM[EM]=TLa
set EM=EM+1
if EY==0 then
if ZY<$8000 then
set ZY=ZY+1
set Tma=ZY
set UY[Tma]=$D02
else
call Cdv("Out of memory: Could not create LimitedExecuteCondition_executeWhile_Network_Network.","when calling error in Network, line 282")
set Tma=0
endif
else
set EY=EY-1
set Tma=WY[EY]
set UY[Tma]=$D02
endif
set EM=EM-1
return Tma
endfunction
function TMa takes string Tpa returns integer
local integer TPa
set ZM[EM]=Tpa
set EM=EM+1
if PY==0 then
if AY<$8000 then
set AY=AY+1
set TPa=AY
set DY[TPa]=$CDE
else
call Cdv("Out of memory: Could not create LimitedExecuteAction_executeWhile_Network_Network.","when calling error in Network, line 282")
set TPa=0
endif
else
set PY=PY-1
set TPa=IY[PY]
set DY[TPa]=$CDE
endif
set EM=EM-1
return TPa
endfunction
function Tqa takes integer TQa returns integer
return UZ[TQa]+1
endfunction
function Tsa takes integer TSa,string Tta returns integer
local integer TTa
set ZM[EM]=Tta
set EM=EM+1
if OG[TSa]==0 then
if TSa==0 then
call Cdv("Nullpointer exception when calling HashBuffer.getBooleanCount","when calling error in HashBuffer, line 131")
else
call Cdv("Called HashBuffer.getBooleanCount on invalid object.","when calling error in HashBuffer, line 131")
endif
endif
set TTa=Tqa(TSa)
set EM=EM-1
return TTa
endfunction
function Tua takes integer TUa returns integer
return ZZ[TUa]+1
endfunction
function Twa takes integer TWa,string Tya returns integer
local integer TYa
set ZM[EM]=Tya
set EM=EM+1
if OG[TWa]==0 then
if TWa==0 then
call Cdv("Nullpointer exception when calling HashBuffer.getRealCount","when calling error in HashBuffer, line 128")
else
call Cdv("Called HashBuffer.getRealCount on invalid object.","when calling error in HashBuffer, line 128")
endif
endif
set TYa=Tua(TWa)
set EM=EM-1
return TYa
endfunction
function Tza takes integer TZa returns integer
return EZ[TZa]+1
endfunction
function T_a takes integer T0a,string T1a returns integer
local integer T2a
set ZM[EM]=T1a
set EM=EM+1
if OG[T0a]==0 then
if T0a==0 then
call Cdv("Nullpointer exception when calling HashBuffer.getIntCount","when calling error in HashBuffer, line 125")
else
call Cdv("Called HashBuffer.getIntCount on invalid object.","when calling error in HashBuffer, line 125")
endif
endif
set T2a=Tza(T0a)
set EM=EM-1
return T2a
endfunction
function T3a takes integer T4a,string T5a returns nothing
local integer T6a
local integer T7a
local integer T8a
local integer T9a
local integer uva
local integer uea
local integer uxa
local integer uoa
local integer ura
local integer uia
local integer uaa
local integer una
local integer uVa
local integer uEa
local integer uXa
set ZM[EM]=T5a
set EM=EM+1
if Ca and jA[T4a]!=0 then
call Cdv("Network: trying to send duplicate metadata","when calling error in Network, line 272")
endif
if not wRx(IA[T4a])then
call TJa(T4a,"when calling abort in Network, line 276")
set EM=EM-1
return
endif
if ta==IA[T4a]then
set ura=oq
set T6a=Tla("when calling alloc_LimitedExecuteCondition_executeWhile_Network_Network in Network, line 282")
set MA[T6a]=T4a
set uia=T6a
set T7a=TMa("when calling alloc_LimitedExecuteAction_executeWhile_Network_Network in Network, line 282")
set wD[T7a]=T4a
call WOe(ura,uia,T7a,"when calling executeWhile in Network, line 282")
call WIx(mA[T4a],"when calling encode in Network, line 287")
endif
call QNa(vA[T4a],3,"when calling setMode in Network, line 291")
set T8a=T_a(vA[T4a],"when calling getIntCount in Network, line 294")
set T9a=Twa(vA[T4a],"when calling getRealCount in Network, line 295")
set uva=Tsa(vA[T4a],"when calling getBooleanCount in Network, line 296")
set uea=TRx(mA[T4a],"when calling getIntCount in Network, line 297")
set uxa=t3x(T8a,T9a,uva,uea)
set uoa=uxa/ee+1
if ta==IA[T4a]then
set uaa=T8a
set una=T9a
set uVa=uva
set uEa=uea
set uXa=uoa
set PA[T4a]=uaa
set AA[T4a]=una
set DA[T4a]=uVa
set HA[T4a]=uEa
set JA[T4a]=uXa
set KA[T4a]=true
call tyx(UA[T4a],PA[T4a],AA[T4a],DA[T4a],HA[T4a],JA[T4a],"when calling setCounts in Network, line 311")
call Tjx(UA[T4a],"when calling sync in Network, line 312")
endif
set jA[T4a]=1
call sIa(T4a,"when calling sendRound in Network, line 316")
set EM=EM-1
endfunction
function uOa takes integer uRa,string uIa returns nothing
set ZM[EM]=uIa
set EM=EM+1
if ck[uRa]==0 then
if uRa==0 then
call Cdv("Nullpointer exception when calling Network.sendMetadata","when calling error in Network, line 269")
else
call Cdv("Called Network.sendMetadata on invalid object.","when calling error in Network, line 269")
endif
endif
call T3a(uRa,"when calling sendMetadata in Network, line 269")
set EM=EM-1
endfunction
function uAa takes integer uNa,integer uba,string uBa returns nothing
set ZM[EM]=uBa
set EM=EM+1
set NA[uNa]=uba
call uOa(uNa,"when calling sendMetadata in Network, line 473")
set EM=EM-1
endfunction
function uca takes integer uCa,integer uda,string uDa returns nothing
set ZM[EM]=uDa
set EM=EM+1
if ck[uCa]==0 then
if uCa==0 then
call Cdv("Nullpointer exception when calling Network.start","when calling error in Network, line 471")
else
call Cdv("Called Network.start on invalid object.","when calling error in Network, line 471")
endif
endif
call uAa(uCa,uda,"when calling start in Network, line 471")
set EM=EM-1
endfunction
function ufa takes string uFa returns integer
local integer uga
set ZM[EM]=uFa
set EM=EM+1
if Ok==0 then
if lk<$8000 then
set lk=lk+1
set uga=lk
set bk[uga]=$E55
else
call Cdv("Out of memory: Could not create NetworkFinishedCallback_start_onSynced_PersistentStore_Persistable.","when calling error in Persistable, line 172")
set uga=0
endif
else
set Ok=Ok-1
set uga=ok[Ok]
set bk[uga]=$E55
endif
set EM=EM-1
return uga
endfunction
function uGa takes integer uha,string uHa returns nothing
set ZM[EM]=uHa
set EM=EM+1
if fh[uha]==0 then
call Cdv("Double free: object of type IOTask","when calling error in IOTaskExecutor, line 10")
else
set ah[nh]=uha
set nh=nh+1
set fh[uha]=0
endif
set EM=EM-1
endfunction
function uja takes integer uJa,string uka returns nothing
set ZM[EM]=uka
set EM=EM+1
call uGa(uJa,"when calling dealloc_IOTask in IOTaskExecutor, line 10")
set EM=EM-1
endfunction
function uKa takes integer ula,string uLa returns nothing
set ZM[EM]=uLa
set EM=EM+1
if fh[ula]==0 then
if ula==0 then
call Cdv("Nullpointer exception when calling IOTask.IOTask","when calling error in IOTaskExecutor, line 10")
else
call Cdv("Called IOTask.IOTask on invalid object.","when calling error in IOTaskExecutor, line 10")
endif
endif
call uja(ula,"when calling destroyIOTask in IOTaskExecutor, line 10")
set EM=EM-1
endfunction
function uma takes integer uMa,string upa returns nothing
local integer uPa
local integer uqa
set ZM[EM]=upa
set EM=EM+1
set uPa=Xle(pU[uMa],"when calling iterator in IOTaskExecutor, line 41")
loop
exitwhen not Xie(uPa)
set uqa=E3e(uPa)
call uKa(uqa,"when calling dispatch_IOTask_destroyIOTask in IOTaskExecutor, line 42")
endloop
call Xpe(uPa,"when calling close in IOTaskExecutor, line 41")
call Hcv(pU[uMa],"when calling dispatch_LinkedList_destroyLinkedList in IOTaskExecutor, line 43")
if eU[uMa]!=0 then
call uKa(eU[uMa],"when calling dispatch_IOTask_destroyIOTask in IOTaskExecutor, line 45")
endif
set EM=EM-1
endfunction
function uQa takes integer usa,string uSa returns nothing
set ZM[EM]=uSa
set EM=EM+1
if qh[usa]==0 then
call Cdv("Double free: object of type AbstractIOTaskExecutor","when calling error in IOTaskExecutor, line 35")
else
set eh=eh+1
set qh[usa]=0
endif
set EM=EM-1
endfunction
function uta takes integer uTa,string uua returns nothing
set ZM[EM]=uua
set EM=EM+1
call uma(uTa,"when calling AbstractIOTaskExecutor_onDestroy in IOTaskExecutor, line 40")
call uQa(uTa,"when calling dealloc_AbstractIOTaskExecutor in IOTaskExecutor, line 40")
set EM=EM-1
endfunction
function uUa takes integer uwa,string uWa returns nothing
set ZM[EM]=uWa
set EM=EM+1
if qh[uwa]==0 then
call Cdv("Double free: object of type TimedIOTaskExecutor","when calling error in IOTaskExecutor, line 92")
else
set eh=eh+1
set qh[uwa]=0
endif
set EM=EM-1
endfunction
function uya takes integer uYa returns nothing
set he=he-1
if uYa!=Ge then
set TU[RU[uYa]]=TU[uYa]
else
set Ge=TU[uYa]
endif
if uYa!=ge then
set RU[TU[uYa]]=RU[uYa]
else
set ge=RU[uYa]
endif
endfunction
function uza takes integer uZa,string u_a returns nothing
set ZM[EM]=u_a
set EM=EM+1
if qh[uZa]==0 then
if uZa==0 then
call Cdv("Nullpointer exception when calling TimedIOTaskExecutor.remove","when calling error in LinkedListModule, line 37")
else
call Cdv("Called TimedIOTaskExecutor.remove on invalid object.","when calling error in LinkedListModule, line 37")
endif
endif
call uya(uZa)
set EM=EM-1
endfunction
function u0a takes integer u1a,string u2a returns nothing
set ZM[EM]=u2a
set EM=EM+1
call uza(u1a,"when calling remove in LinkedListModule, line 49")
call uma(u1a,"when calling AbstractIOTaskExecutor_onDestroy in IOTaskExecutor, line 92")
set EM=EM-1
endfunction
function u3a takes integer u4a,string u5a returns nothing
set ZM[EM]=u5a
set EM=EM+1
call u0a(u4a,"when calling TimedIOTaskExecutor_onDestroy in IOTaskExecutor, line 91")
call uUa(u4a,"when calling dealloc_TimedIOTaskExecutor in IOTaskExecutor, line 91")
set EM=EM-1
endfunction
function u6a takes integer u7a,string u8a returns nothing
set ZM[EM]=u8a
set EM=EM+1
if qh[u7a]==0 then
call Cdv("Double free: object of type IOTaskExecutor","when calling error in IOTaskExecutor, line 19")
else
set eh=eh+1
set qh[u7a]=0
endif
set EM=EM-1
endfunction
function u9a takes integer Uva,string Uea returns nothing
set ZM[EM]=Uea
set EM=EM+1
call u6a(Uva,"when calling dealloc_IOTaskExecutor in IOTaskExecutor, line 19")
set EM=EM-1
endfunction
function Uxa takes integer Uoa,string Ura returns nothing
set ZM[EM]=Ura
set EM=EM+1
if qh[Uoa]==0 then
call Cdv("Double free: object of type InstantIOTaskExecutor","when calling error in IOTaskExecutor, line 77")
else
set eh=eh+1
set qh[Uoa]=0
endif
set EM=EM-1
endfunction
function Uia takes integer Uaa,string Una returns nothing
set ZM[EM]=Una
set EM=EM+1
call uma(Uaa,"when calling AbstractIOTaskExecutor_onDestroy in IOTaskExecutor, line 77")
set EM=EM-1
endfunction
function UVa takes integer UEa,string UXa returns nothing
set ZM[EM]=UXa
set EM=EM+1
call Uia(UEa,"when calling InstantIOTaskExecutor_onDestroy in IOTaskExecutor, line 76")
call Uxa(UEa,"when calling dealloc_InstantIOTaskExecutor in IOTaskExecutor, line 76")
set EM=EM-1
endfunction
function UOa takes integer URa,string UIa returns nothing
set ZM[EM]=UIa
set EM=EM+1
if qh[URa]==0 then
if URa==0 then
call Cdv("Nullpointer exception when calling IOTaskExecutor.IOTaskExecutor","when calling error in IOTaskExecutor, line 19")
else
call Cdv("Called IOTaskExecutor.IOTaskExecutor on invalid object.","when calling error in IOTaskExecutor, line 19")
endif
endif
if qh[URa]<=$BB3 then
if qh[URa]<=$BB2 then
call u9a(URa,"when calling destroyIOTaskExecutor in IOTaskExecutor, line 19")
else
call uta(URa,"when calling destroyAbstractIOTaskExecutor in IOTaskExecutor, line 19")
endif
elseif qh[URa]<=$BB4 then
call UVa(URa,"when calling destroyInstantIOTaskExecutor in IOTaskExecutor, line 19")
else
call u3a(URa,"when calling destroyTimedIOTaskExecutor in IOTaskExecutor, line 19")
endif
set EM=EM-1
endfunction
function UAa takes integer UNa,string Uba returns nothing
set ZM[EM]=Uba
set EM=EM+1
call sMa(fP[UNa],"when calling dispatch_HashBuffer_destroyHashBuffer in MultifileIO, line 67")
call UOa(YP[UNa],"when calling dispatch_IOTaskExecutor_destroyIOTaskExecutor in MultifileIO, line 68")
set EM=EM-1
endfunction
function UBa takes integer Uca,string UCa returns nothing
set ZM[EM]=UCa
set EM=EM+1
call UAa(Uca,"when calling AbstractFile_onDestroy in MultifileIO, line 192")
set EM=EM-1
endfunction
function Uda takes integer UDa,string Ufa returns nothing
set ZM[EM]=Ufa
set EM=EM+1
if PF[UDa]==0 then
call Cdv("Double free: object of type FileReader","when calling error in MultifileIO, line 192")
else
set IF=IF+1
set PF[UDa]=0
endif
set EM=EM-1
endfunction
function UFa takes integer Uga,string UGa returns nothing
set ZM[EM]=UGa
set EM=EM+1
call UBa(Uga,"when calling FileReader_onDestroy in MultifileIO, line 191")
call Uda(Uga,"when calling dealloc_FileReader in MultifileIO, line 191")
set EM=EM-1
endfunction
function Uha takes integer UHa,string Uja returns nothing
set ZM[EM]=Uja
set EM=EM+1
if PF[UHa]==0 then
if UHa==0 then
call Cdv("Nullpointer exception when calling FileReader.FileReader","when calling error in MultifileIO, line 192")
else
call Cdv("Called FileReader.FileReader on invalid object.","when calling error in MultifileIO, line 192")
endif
endif
call UFa(UHa,"when calling destroyFileReader in MultifileIO, line 192")
set EM=EM-1
endfunction
function UJa takes integer Uka,string UKa returns nothing
local integer Ula
local integer ULa
set ZM[EM]=UKa
set EM=EM+1
call Uha(BD[Uka],"when calling dispatch_FileReader_destroyFileReader in Persistable, line 170")
set ULa=ND[Uka]
set Ula=ufa("when calling alloc_NetworkFinishedCallback_start_onSynced_PersistentStore_Persistable in Persistable, line 172")
set uH[Ula]=MD[Uka]
set rH[Ula]=wH[Uka]
call uca(ULa,Ula,"when calling start in Persistable, line 172")
set EM=EM-1
endfunction
function Uma takes integer UMa returns nothing
set XZ[UMa]=0
set CZ[UMa]=0
set VZ[UMa]=0
set BZ[UMa]=0
endfunction
function Upa takes integer UPa,string Uqa returns nothing
set ZM[EM]=Uqa
set EM=EM+1
if gY[UPa]==0 then
if UPa==0 then
call Cdv("Nullpointer exception when calling HashReader.reset","when calling error in HashData, line 222")
else
call Cdv("Called HashReader.reset on invalid object.","when calling error in HashData, line 222")
endif
endif
call Uma(UPa)
set EM=EM-1
endfunction
function UQa takes string Usa returns integer
local integer USa
set ZM[EM]=Usa
set EM=EM+1
if PY==0 then
if AY<$8000 then
set AY=AY+1
set USa=AY
set DY[USa]=$CEA
else
call Cdv("Out of memory: Could not create LimitedExecuteAction_executeWhile_Network_NetworkData.","when calling error in NetworkData, line 351")
set USa=0
endif
else
set PY=PY-1
set USa=IY[PY]
set DY[USa]=$CEA
endif
set EM=EM-1
return USa
endfunction
function Uta takes string UTa returns integer
local integer Uua
set ZM[EM]=UTa
set EM=EM+1
if EY==0 then
if ZY<$8000 then
set ZY=ZY+1
set Uua=ZY
set UY[Uua]=$D0E
else
call Cdv("Out of memory: Could not create LimitedExecuteCondition_executeWhile_Network_NetworkData.","when calling error in NetworkData, line 351")
set Uua=0
endif
else
set EY=EY-1
set Uua=WY[EY]
set UY[Uua]=$D0E
endif
set EM=EM-1
return Uua
endfunction
function UUa takes integer Uwa,string UWa returns nothing
local integer Uya
local integer UYa
local integer Uza
local integer UZa
set ZM[EM]=UWa
set EM=EM+1
set Uza=oq
set Uya=Uta("when calling alloc_LimitedExecuteCondition_executeWhile_Network_NetworkData in NetworkData, line 351")
set lA[Uya]=Uwa
set UZa=Uya
set UYa=UQa("when calling alloc_LimitedExecuteAction_executeWhile_Network_NetworkData in NetworkData, line 351")
set bA[UYa]=Uwa
call WOe(Uza,UZa,UYa,"when calling executeWhile in NetworkData, line 351")
set EM=EM-1
endfunction
function U_a takes integer U0a,string U1a returns nothing
set ZM[EM]=U1a
set EM=EM+1
if LF[U0a]==0 then
if U0a==0 then
call Cdv("Nullpointer exception when calling Network.readInts","when calling error in NetworkData, line 350")
else
call Cdv("Called Network.readInts on invalid object.","when calling error in NetworkData, line 350")
endif
endif
call UUa(U0a,"when calling readInts in NetworkData, line 350")
set EM=EM-1
endfunction
function U2a takes string U3a returns integer
local integer U4a
set ZM[EM]=U3a
set EM=EM+1
if CY==0 then
if VY<$8000 then
set VY=VY+1
set U4a=VY
set BY[U4a]=$858
else
call Cdv("Out of memory: Could not create ForForceCallback_execute_Network_NetworkData.","when calling error in NetworkData, line 443")
set U4a=0
endif
else
set CY=CY-1
set U4a=XY[CY]
set BY[U4a]=$858
endif
set EM=EM-1
return U4a
endfunction
function U5a takes string U6a returns integer
local integer U7a
set ZM[EM]=U6a
set EM=EM+1
if PY==0 then
if AY<$8000 then
set AY=AY+1
set U7a=AY
set DY[U7a]=$CEE
else
call Cdv("Out of memory: Could not create LimitedExecuteAction_executeWhile_Network_NetworkData.","when calling error in NetworkData, line 375")
set U7a=0
endif
else
set PY=PY-1
set U7a=IY[PY]
set DY[U7a]=$CEE
endif
set EM=EM-1
return U7a
endfunction
function U8a takes string U9a returns integer
local integer wva
set ZM[EM]=U9a
set EM=EM+1
if EY==0 then
if ZY<$8000 then
set ZY=ZY+1
set wva=ZY
set UY[wva]=$D12
else
call Cdv("Out of memory: Could not create LimitedExecuteCondition_executeWhile_Network_NetworkData.","when calling error in NetworkData, line 375")
set wva=0
endif
else
set EY=EY-1
set wva=WY[EY]
set UY[wva]=$D12
endif
set EM=EM-1
return wva
endfunction
function wea takes integer wxa,string woa returns nothing
local integer wra
local integer wia
local integer waa
local integer wna
set ZM[EM]=woa
set EM=EM+1
set waa=oq
set wra=U8a("when calling alloc_LimitedExecuteCondition_executeWhile_Network_NetworkData in NetworkData, line 375")
set dA[wra]=wxa
set wna=wra
set wia=U5a("when calling alloc_LimitedExecuteAction_executeWhile_Network_NetworkData in NetworkData, line 375")
set fA[wia]=wxa
call WOe(waa,wna,wia,"when calling executeWhile in NetworkData, line 375")
set EM=EM-1
endfunction
function wVa takes integer wEa,string wXa returns nothing
set ZM[EM]=wXa
set EM=EM+1
if LF[wEa]==0 then
if wEa==0 then
call Cdv("Nullpointer exception when calling Network.readBooleans","when calling error in NetworkData, line 374")
else
call Cdv("Called Network.readBooleans on invalid object.","when calling error in NetworkData, line 374")
endif
endif
call wea(wEa,"when calling readBooleans in NetworkData, line 374")
set EM=EM-1
endfunction
function wOa takes string wRa returns integer
local integer wIa
set ZM[EM]=wRa
set EM=EM+1
if EY==0 then
if ZY<$8000 then
set ZY=ZY+1
set wIa=ZY
set UY[wIa]=$D14
else
call Cdv("Out of memory: Could not create LimitedExecuteCondition_executeWhile_Network_NetworkData.","when calling error in NetworkData, line 387")
set wIa=0
endif
else
set EY=EY-1
set wIa=WY[EY]
set UY[wIa]=$D14
endif
set EM=EM-1
return wIa
endfunction
function wAa takes string wNa returns integer
local integer wba
set ZM[EM]=wNa
set EM=EM+1
if PY==0 then
if AY<$8000 then
set AY=AY+1
set wba=AY
set DY[wba]=$CF0
else
call Cdv("Out of memory: Could not create LimitedExecuteAction_executeWhile_Network_NetworkData.","when calling error in NetworkData, line 387")
set wba=0
endif
else
set PY=PY-1
set wba=IY[PY]
set DY[wba]=$CF0
endif
set EM=EM-1
return wba
endfunction
function wBa takes integer wca,string wCa returns nothing
local integer wda
local integer wDa
local integer wfa
local integer wFa
set ZM[EM]=wCa
set EM=EM+1
set wfa=oq
set wda=wOa("when calling alloc_LimitedExecuteCondition_executeWhile_Network_NetworkData in NetworkData, line 387")
set YA[wda]=wca
set wFa=wda
set wDa=wAa("when calling alloc_LimitedExecuteAction_executeWhile_Network_NetworkData in NetworkData, line 387")
set GA[wDa]=wca
call WOe(wfa,wFa,wDa,"when calling executeWhile in NetworkData, line 387")
set EM=EM-1
endfunction
function wga takes integer wGa,string wha returns nothing
set ZM[EM]=wha
set EM=EM+1
if LF[wGa]==0 then
if wGa==0 then
call Cdv("Nullpointer exception when calling Network.readStrings","when calling error in NetworkData, line 386")
else
call Cdv("Called Network.readStrings on invalid object.","when calling error in NetworkData, line 386")
endif
endif
call wBa(wGa,"when calling readStrings in NetworkData, line 386")
set EM=EM-1
endfunction
function wHa takes string wja returns integer
local integer wJa
set ZM[EM]=wja
set EM=EM+1
if EY==0 then
if ZY<$8000 then
set ZY=ZY+1
set wJa=ZY
set UY[wJa]=$D15
else
call Cdv("Out of memory: Could not create LimitedExecuteCondition_executeWhile_Network_NetworkData.","when calling error in NetworkData, line 450")
set wJa=0
endif
else
set EY=EY-1
set wJa=WY[EY]
set UY[wJa]=$D15
endif
set EM=EM-1
return wJa
endfunction
function wka takes string wKa returns integer
local integer wla
set ZM[EM]=wKa
set EM=EM+1
if EY==0 then
if ZY<$8000 then
set ZY=ZY+1
set wla=ZY
set UY[wla]=$D10
else
call Cdv("Out of memory: Could not create LimitedExecuteCondition_executeWhile_Network_NetworkData.","when calling error in NetworkData, line 363")
set wla=0
endif
else
set EY=EY-1
set wla=WY[EY]
set UY[wla]=$D10
endif
set EM=EM-1
return wla
endfunction
function wLa takes string wma returns integer
local integer wMa
set ZM[EM]=wma
set EM=EM+1
if PY==0 then
if AY<$8000 then
set AY=AY+1
set wMa=AY
set DY[wMa]=$CEC
else
call Cdv("Out of memory: Could not create LimitedExecuteAction_executeWhile_Network_NetworkData.","when calling error in NetworkData, line 363")
set wMa=0
endif
else
set PY=PY-1
set wMa=IY[PY]
set DY[wMa]=$CEC
endif
set EM=EM-1
return wMa
endfunction
function wpa takes integer wPa,string wqa returns nothing
local integer wQa
local integer wsa
local integer wSa
local integer wta
set ZM[EM]=wqa
set EM=EM+1
set wSa=oq
set wQa=wka("when calling alloc_LimitedExecuteCondition_executeWhile_Network_NetworkData in NetworkData, line 363")
set eA[wQa]=wPa
set wta=wQa
set wsa=wLa("when calling alloc_LimitedExecuteAction_executeWhile_Network_NetworkData in NetworkData, line 363")
set qA[wsa]=wPa
call WOe(wSa,wta,wsa,"when calling executeWhile in NetworkData, line 363")
set EM=EM-1
endfunction
function wTa takes integer wua,string wUa returns nothing
set ZM[EM]=wUa
set EM=EM+1
if LF[wua]==0 then
if wua==0 then
call Cdv("Nullpointer exception when calling Network.readReals","when calling error in NetworkData, line 362")
else
call Cdv("Called Network.readReals on invalid object.","when calling error in NetworkData, line 362")
endif
endif
call wpa(wua,"when calling readReals in NetworkData, line 362")
set EM=EM-1
endfunction
function wwa takes string wWa returns integer
local integer wya
set ZM[EM]=wWa
set EM=EM+1
if PY==0 then
if AY<$8000 then
set AY=AY+1
set wya=AY
set DY[wya]=$CF1
else
call Cdv("Out of memory: Could not create LimitedExecuteAction_executeWhile_Network_NetworkData.","when calling error in NetworkData, line 450")
set wya=0
endif
else
set PY=PY-1
set wya=IY[PY]
set DY[wya]=$CF1
endif
set EM=EM-1
return wya
endfunction
function wYa takes gamecache wza,string wZa,string w_a returns integer
return GetStoredInteger(wza,wZa,w_a)
endfunction
function w0a takes integer w1a,string w2a returns integer
return wYa(wq,nP[w1a],w2a)
endfunction
function w3a takes integer w4a,string w5a,string w6a returns integer
local integer w7a
set ZM[EM]=w6a
set EM=EM+1
if UF[w4a]==0 then
if w4a==0 then
call Cdv("Nullpointer exception when calling MetadataStore.loadValue","when calling error in Metadata, line 32")
else
call Cdv("Called MetadataStore.loadValue on invalid object.","when calling error in Metadata, line 32")
endif
endif
set w7a=w0a(w4a,w5a)
set EM=EM-1
return w7a
endfunction
function w8a takes integer w9a,string Wva returns integer
local integer Wea
local integer Wxa
local integer Woa
local integer Wra
local integer Wia
local integer Waa
local integer Wna
local integer WVa
local integer WEa
local integer WXa
set ZM[EM]=Wva
set EM=EM+1
set Waa=w3a(w9a,uq,"when calling loadValue in Metadata, line 44")
set Wna=w3a(w9a,rq,"when calling loadValue in Metadata, line 45")
set WVa=w3a(w9a,sq,"when calling loadValue in Metadata, line 46")
set WEa=w3a(w9a,tq,"when calling loadValue in Metadata, line 47")
set WXa=w3a(w9a,iq,"when calling loadValue in Metadata, line 48")
set Wea=Waa
set Wxa=Wna
set Woa=WVa
set Wra=WEa
set Wia=WXa
set EM=EM-1
set x9=Wea
set v9=Wxa
set m9=Woa
set Q9=Wra
set W9=Wia
return x9
endfunction
function WOa takes integer WRa,string WIa returns integer
local integer WAa
local integer WNa
local integer Wba
local integer WBa
local integer Wca
local integer WCa
local integer Wda
local integer WDa
local integer Wfa
local integer WFa
set ZM[EM]=WIa
set EM=EM+1
if UF[WRa]==0 then
if WRa==0 then
call Cdv("Nullpointer exception when calling MetadataStore.getCounts","when calling error in Metadata, line 42")
else
call Cdv("Called MetadataStore.getCounts on invalid object.","when calling error in Metadata, line 42")
endif
endif
set WCa=w8a(WRa,"when calling getCounts in Metadata, line 42")
set Wda=v9
set WDa=m9
set Wfa=Q9
set WFa=W9
set WAa=WCa
set WNa=Wda
set Wba=WDa
set WBa=Wfa
set Wca=WFa
set EM=EM-1
set E9=WAa
set Z9=WNa
set U9=Wba
set I9=WBa
set P9=Wca
return E9
endfunction
function Wga takes integer WGa,string Wha returns nothing
local integer WHa
local integer Wja
local integer WJa
local integer Wka
local integer WKa
set ZM[EM]=Wha
set EM=EM+1
if ta==DP[WGa]then
set EM=EM-1
return
endif
set WHa=WOa(AP[WGa],"when calling getCounts in NetworkData, line 335")
set Wja=Z9
set WJa=U9
set Wka=I9
set WKa=P9
set HP[WGa]=WHa
set JP[WGa]=Wja
set KP[WGa]=WJa
set LP[WGa]=Wka
set XP[WGa]=WKa
set CP[WGa]=true
set EM=EM-1
endfunction
function Wla takes integer WLa,string Wma returns nothing
set ZM[EM]=Wma
set EM=EM+1
if LF[WLa]==0 then
if WLa==0 then
call Cdv("Nullpointer exception when calling Network.receiveMetadata","when calling error in NetworkData, line 330")
else
call Cdv("Called Network.receiveMetadata on invalid object.","when calling error in NetworkData, line 330")
endif
endif
call Wga(WLa,"when calling receiveMetadata in NetworkData, line 330")
set EM=EM-1
endfunction
function WMa takes string Wpa returns integer
local integer WPa
set ZM[EM]=Wpa
set EM=EM+1
if PY==0 then
if AY<$8000 then
set AY=AY+1
set WPa=AY
set DY[WPa]=$CF8
else
call Cdv("Out of memory: Could not create LimitedExecuteAction_executeWhile_StringEncoder_StringEncoder.","when calling error in StringEncoder, line 112")
set WPa=0
endif
else
set PY=PY-1
set WPa=IY[PY]
set DY[WPa]=$CF8
endif
set EM=EM-1
return WPa
endfunction
function Wqa takes string WQa returns integer
local integer Wsa
set ZM[EM]=WQa
set EM=EM+1
if EY==0 then
if ZY<$8000 then
set ZY=ZY+1
set Wsa=ZY
set UY[Wsa]=$D1C
else
call Cdv("Out of memory: Could not create LimitedExecuteCondition_executeWhile_StringEncoder_StringEncoder.","when calling error in StringEncoder, line 112")
set Wsa=0
endif
else
set EY=EY-1
set Wsa=WY[EY]
set UY[Wsa]=$D1C
endif
set EM=EM-1
return Wsa
endfunction
function WSa takes integer Wta,string WTa returns nothing
local integer Wua
local integer WUa
local integer Wwa
local integer WWa
set ZM[EM]=WTa
set EM=EM+1
set QX[Wta]=T2x(mX[Wta],"when calling intoReader in StringEncoder, line 110")
set mX[Wta]=0
set Wwa=oq
set Wua=Wqa("when calling alloc_LimitedExecuteCondition_executeWhile_StringEncoder_StringEncoder in StringEncoder, line 112")
set LX[Wua]=Wta
set WWa=Wua
set WUa=WMa("when calling alloc_LimitedExecuteAction_executeWhile_StringEncoder_StringEncoder in StringEncoder, line 112")
set XX[WUa]=Wta
call WOe(Wwa,WWa,WUa,"when calling executeWhile in StringEncoder, line 112")
set EX[Wta]=T2x(WX[Wta],"when calling intoReader in StringEncoder, line 113")
set WX[Wta]=0
set EM=EM-1
endfunction
function Wya takes integer WYa,string Wza returns nothing
set ZM[EM]=Wza
set EM=EM+1
if Ov[WYa]==0 then
if WYa==0 then
call Cdv("Nullpointer exception when calling StringEncoder.decode","when calling error in StringEncoder, line 109")
else
call Cdv("Called StringEncoder.decode on invalid object.","when calling error in StringEncoder, line 109")
endif
endif
call WSa(WYa,"when calling decode in StringEncoder, line 109")
set EM=EM-1
endfunction
function WZa takes integer W_a,string W0a returns nothing
local integer W1a
local integer W2a
local integer W3a
local integer W4a
local integer W5a
set ZM[EM]=W0a
set EM=EM+1
if not wRx(DP[W_a])then
call tNx(W_a,"when calling abort in NetworkData, line 424")
set EM=EM-1
return
endif
if not CP[W_a]then
call Wla(W_a,"when calling receiveMetadata in NetworkData, line 429")
endif
if ta!=DP[W_a]then
call U_a(W_a,"when calling readInts in NetworkData, line 434")
call wTa(W_a,"when calling readReals in NetworkData, line 435")
call wVa(W_a,"when calling readBooleans in NetworkData, line 436")
call wga(W_a,"when calling readStrings in NetworkData, line 437")
endif
set wA[W_a]=wA[W_a]+1
if wA[W_a]<XP[W_a]then
set W1a=U2a("when calling alloc_ForForceCallback_execute_Network_NetworkData in NetworkData, line 443")
set hA[W1a]=W_a
call Fte(W1a,"when calling execute in NetworkData, line 443")
else
if ta!=DP[W_a]then
call Wya(EP[W_a],"when calling decode in NetworkData, line 448")
set W4a=oq
set W2a=wHa("when calling alloc_LimitedExecuteCondition_executeWhile_Network_NetworkData in NetworkData, line 450")
set FA[W2a]=W_a
set W5a=W2a
set W3a=wwa("when calling alloc_LimitedExecuteAction_executeWhile_Network_NetworkData in NetworkData, line 450")
set kA[W3a]=W_a
call WOe(W4a,W5a,W3a,"when calling executeWhile in NetworkData, line 450")
set WP[W_a]=T2x(QP[W_a],"when calling intoReader in NetworkData, line 453")
set QP[W_a]=0
endif
call Upa(WP[W_a],"when calling reset in NetworkData, line 456")
call Sxx(uA[W_a],0,WP[W_a],"when calling onFinish in NetworkData, line 458")
call tEx(W_a,"when calling dispatch_Network_destroyNetwork in NetworkData, line 459")
endif
set EM=EM-1
endfunction
function W6a takes integer W7a,string W8a returns nothing
set ZM[EM]=W8a
set EM=EM+1
if LF[W7a]==0 then
if W7a==0 then
call Cdv("Nullpointer exception when calling Network.receiveRound","when calling error in NetworkData, line 422")
else
call Cdv("Called Network.receiveRound on invalid object.","when calling error in NetworkData, line 422")
endif
endif
call WZa(W7a,"when calling receiveRound in NetworkData, line 422")
set EM=EM-1
endfunction
function W9a takes integer yva,string yea returns nothing
set ZM[EM]=yea
set EM=EM+1
call W6a(gA[yva],"when calling receiveRound in NetworkData, line 420")
set EM=EM-1
endfunction
function yxa takes string yoa returns integer
local integer yra
set ZM[EM]=yoa
set EM=EM+1
if EY==0 then
if ZY<$8000 then
set ZY=ZY+1
set yra=ZY
set UY[yra]=$D0B
else
call Cdv("Out of memory: Could not create LimitedExecuteCondition_executeWhile_Network_Network.","when calling error in Network, line 460")
set yra=0
endif
else
set EY=EY-1
set yra=WY[EY]
set UY[yra]=$D0B
endif
set EM=EM-1
return yra
endfunction
function yia takes string yaa returns integer
local integer yna
set ZM[EM]=yaa
set EM=EM+1
if PY==0 then
if AY<$8000 then
set AY=AY+1
set yna=AY
set DY[yna]=$CE7
else
call Cdv("Out of memory: Could not create LimitedExecuteAction_executeWhile_Network_Network.","when calling error in Network, line 460")
set yna=0
endif
else
set PY=PY-1
set yna=IY[PY]
set DY[yna]=$CE7
endif
set EM=EM-1
return yna
endfunction
function yVa takes string yEa returns integer
local integer yXa
set ZM[EM]=yEa
set EM=EM+1
if EY==0 then
if ZY<$8000 then
set ZY=ZY+1
set yXa=ZY
set UY[yXa]=$D0A
else
call Cdv("Out of memory: Could not create LimitedExecuteCondition_executeWhile_Network_Network.","when calling error in Network, line 378")
set yXa=0
endif
else
set EY=EY-1
set yXa=WY[EY]
set UY[yXa]=$D0A
endif
set EM=EM-1
return yXa
endfunction
function yOa takes string yRa returns integer
local integer yIa
set ZM[EM]=yRa
set EM=EM+1
if PY==0 then
if AY<$8000 then
set AY=AY+1
set yIa=AY
set DY[yIa]=$CE6
else
call Cdv("Out of memory: Could not create LimitedExecuteAction_executeWhile_Network_Network.","when calling error in Network, line 378")
set yIa=0
endif
else
set PY=PY-1
set yIa=IY[PY]
set DY[yIa]=$CE6
endif
set EM=EM-1
return yIa
endfunction
function yAa takes integer yNa,string yba returns nothing
local integer yBa
local integer yca
local integer yCa
local integer yda
set ZM[EM]=yba
set EM=EM+1
set yCa=oq
set yBa=yVa("when calling alloc_LimitedExecuteCondition_executeWhile_Network_Network in Network, line 378")
set qD[yBa]=yNa
set yda=yBa
set yca=yOa("when calling alloc_LimitedExecuteAction_executeWhile_Network_Network in Network, line 378")
set aD[yca]=yNa
call WOe(yCa,yda,yca,"when calling executeWhile in Network, line 378")
set EM=EM-1
endfunction
function yDa takes integer yfa,string yFa returns nothing
set ZM[EM]=yFa
set EM=EM+1
if ck[yfa]==0 then
if yfa==0 then
call Cdv("Nullpointer exception when calling Network.readStrings","when calling error in Network, line 377")
else
call Cdv("Called Network.readStrings on invalid object.","when calling error in Network, line 377")
endif
endif
call yAa(yfa,"when calling readStrings in Network, line 377")
set EM=EM-1
endfunction
function yga takes integer yGa returns nothing
set PZ[yGa]=-1
set AZ[yGa]=-1
set DZ[yGa]=-1
set HZ[yGa]=-1
endfunction
function yha takes integer yHa,string yja returns nothing
set ZM[EM]=yja
set EM=EM+1
if OG[yHa]==0 then
if yHa==0 then
call Cdv("Nullpointer exception when calling HashBuffer.resetRead","when calling error in HashBuffer, line 119")
else
call Cdv("Called HashBuffer.resetRead on invalid object.","when calling error in HashBuffer, line 119")
endif
endif
call yga(yHa)
set EM=EM-1
endfunction
function yJa takes string yka returns integer
local integer yKa
set ZM[EM]=yka
set EM=EM+1
if PY==0 then
if AY<$8000 then
set AY=AY+1
set yKa=AY
set DY[yKa]=$CE0
else
call Cdv("Out of memory: Could not create LimitedExecuteAction_executeWhile_Network_Network.","when calling error in Network, line 342")
set yKa=0
endif
else
set PY=PY-1
set yKa=IY[PY]
set DY[yKa]=$CE0
endif
set EM=EM-1
return yKa
endfunction
function yla takes string yLa returns integer
local integer yma
set ZM[EM]=yLa
set EM=EM+1
if EY==0 then
if ZY<$8000 then
set ZY=ZY+1
set yma=ZY
set UY[yma]=$D04
else
call Cdv("Out of memory: Could not create LimitedExecuteCondition_executeWhile_Network_Network.","when calling error in Network, line 342")
set yma=0
endif
else
set EY=EY-1
set yma=WY[EY]
set UY[yma]=$D04
endif
set EM=EM-1
return yma
endfunction
function yMa takes integer ypa,string yPa returns nothing
local integer yqa
local integer yQa
local integer ysa
local integer ySa
set ZM[EM]=yPa
set EM=EM+1
set ysa=oq
set yqa=yla("when calling alloc_LimitedExecuteCondition_executeWhile_Network_Network in Network, line 342")
set sD[yqa]=ypa
set ySa=yqa
set yQa=yJa("when calling alloc_LimitedExecuteAction_executeWhile_Network_Network in Network, line 342")
set tD[yQa]=ypa
call WOe(ysa,ySa,yQa,"when calling executeWhile in Network, line 342")
set EM=EM-1
endfunction
function yta takes integer yTa,string yua returns nothing
set ZM[EM]=yua
set EM=EM+1
if ck[yTa]==0 then
if yTa==0 then
call Cdv("Nullpointer exception when calling Network.readInts","when calling error in Network, line 341")
else
call Cdv("Called Network.readInts on invalid object.","when calling error in Network, line 341")
endif
endif
call yMa(yTa,"when calling readInts in Network, line 341")
set EM=EM-1
endfunction
function yUa takes string ywa returns integer
local integer yWa
set ZM[EM]=ywa
set EM=EM+1
if EY==0 then
if ZY<$8000 then
set ZY=ZY+1
set yWa=ZY
set UY[yWa]=$D06
else
call Cdv("Out of memory: Could not create LimitedExecuteCondition_executeWhile_Network_Network.","when calling error in Network, line 354")
set yWa=0
endif
else
set EY=EY-1
set yWa=WY[EY]
set UY[yWa]=$D06
endif
set EM=EM-1
return yWa
endfunction
function yya takes string yYa returns integer
local integer yza
set ZM[EM]=yYa
set EM=EM+1
if PY==0 then
if AY<$8000 then
set AY=AY+1
set yza=AY
set DY[yza]=$CE2
else
call Cdv("Out of memory: Could not create LimitedExecuteAction_executeWhile_Network_Network.","when calling error in Network, line 354")
set yza=0
endif
else
set PY=PY-1
set yza=IY[PY]
set DY[yza]=$CE2
endif
set EM=EM-1
return yza
endfunction
function yZa takes integer y_a,string y0a returns nothing
local integer y1a
local integer y2a
local integer y3a
local integer y4a
set ZM[EM]=y0a
set EM=EM+1
set y3a=oq
set y1a=yUa("when calling alloc_LimitedExecuteCondition_executeWhile_Network_Network in Network, line 354")
set cD[y1a]=y_a
set y4a=y1a
set y2a=yya("when calling alloc_LimitedExecuteAction_executeWhile_Network_Network in Network, line 354")
set oD[y2a]=y_a
call WOe(y3a,y4a,y2a,"when calling executeWhile in Network, line 354")
set EM=EM-1
endfunction
function y5a takes integer y6a,string y7a returns nothing
set ZM[EM]=y7a
set EM=EM+1
if ck[y6a]==0 then
if y6a==0 then
call Cdv("Nullpointer exception when calling Network.readReals","when calling error in Network, line 353")
else
call Cdv("Called Network.readReals on invalid object.","when calling error in Network, line 353")
endif
endif
call yZa(y6a,"when calling readReals in Network, line 353")
set EM=EM-1
endfunction
function y8a takes string y9a returns integer
local integer Yva
set ZM[EM]=y9a
set EM=EM+1
if CY==0 then
if VY<$8000 then
set VY=VY+1
set Yva=VY
set BY[Yva]=$856
else
call Cdv("Out of memory: Could not create ForForceCallback_execute_Network_Network.","when calling error in Network, line 451")
set Yva=0
endif
else
set CY=CY-1
set Yva=XY[CY]
set BY[Yva]=$856
endif
set EM=EM-1
return Yva
endfunction
function Yea takes string Yxa returns integer
local integer Yoa
set ZM[EM]=Yxa
set EM=EM+1
if EY==0 then
if ZY<$8000 then
set ZY=ZY+1
set Yoa=ZY
set UY[Yoa]=$D08
else
call Cdv("Out of memory: Could not create LimitedExecuteCondition_executeWhile_Network_Network.","when calling error in Network, line 366")
set Yoa=0
endif
else
set EY=EY-1
set Yoa=WY[EY]
set UY[Yoa]=$D08
endif
set EM=EM-1
return Yoa
endfunction
function Yra takes string Yia returns integer
local integer Yaa
set ZM[EM]=Yia
set EM=EM+1
if PY==0 then
if AY<$8000 then
set AY=AY+1
set Yaa=AY
set DY[Yaa]=$CE4
else
call Cdv("Out of memory: Could not create LimitedExecuteAction_executeWhile_Network_Network.","when calling error in Network, line 366")
set Yaa=0
endif
else
set PY=PY-1
set Yaa=IY[PY]
set DY[Yaa]=$CE4
endif
set EM=EM-1
return Yaa
endfunction
function Yna takes integer YVa,string YEa returns nothing
local integer YXa
local integer YOa
local integer YRa
local integer YIa
set ZM[EM]=YEa
set EM=EM+1
set YRa=oq
set YXa=Yea("when calling alloc_LimitedExecuteCondition_executeWhile_Network_Network in Network, line 366")
set bD[YXa]=YVa
set YIa=YXa
set YOa=Yra("when calling alloc_LimitedExecuteAction_executeWhile_Network_Network in Network, line 366")
set yD[YOa]=YVa
call WOe(YRa,YIa,YOa,"when calling executeWhile in Network, line 366")
set EM=EM-1
endfunction
function YAa takes integer YNa,string Yba returns nothing
set ZM[EM]=Yba
set EM=EM+1
if ck[YNa]==0 then
if YNa==0 then
call Cdv("Nullpointer exception when calling Network.readBooleans","when calling error in Network, line 365")
else
call Cdv("Called Network.readBooleans on invalid object.","when calling error in Network, line 365")
endif
endif
call Yna(YNa,"when calling readBooleans in Network, line 365")
set EM=EM-1
endfunction
function YBa takes integer Yca,string YCa returns nothing
local integer Yda
local integer YDa
local integer Yfa
local integer YFa
local integer Yga
set ZM[EM]=YCa
set EM=EM+1
if ta==IA[Yca]then
set EM=EM-1
return
endif
if Ca and jA[Yca]!=1 then
call Cdv("Network: trying to receive metadata at a wrong time","when calling error in Network, line 325")
endif
set Yda=WOa(UA[Yca],"when calling getCounts in Network, line 328")
set YDa=Z9
set Yfa=U9
set YFa=I9
set Yga=P9
set PA[Yca]=Yda
set AA[Yca]=YDa
set DA[Yca]=Yfa
set HA[Yca]=YFa
set JA[Yca]=Yga
set KA[Yca]=true
set EM=EM-1
endfunction
function YGa takes integer Yha,string YHa returns nothing
set ZM[EM]=YHa
set EM=EM+1
if ck[Yha]==0 then
if Yha==0 then
call Cdv("Nullpointer exception when calling Network.receiveMetadata","when calling error in Network, line 319")
else
call Cdv("Called Network.receiveMetadata on invalid object.","when calling error in Network, line 319")
endif
endif
call YBa(Yha,"when calling receiveMetadata in Network, line 319")
set EM=EM-1
endfunction
function Yja takes integer YJa,string Yka returns nothing
local integer YKa
local integer Yla
local integer YLa
local integer Yma
local integer YMa
set ZM[EM]=Yka
set EM=EM+1
if Ca and jA[YJa]!=1 then
call Cdv("Network: trying to receive round at the wrong time","when calling error in Network, line 424")
endif
if not wRx(IA[YJa])then
call TJa(YJa,"when calling abort in Network, line 427")
set EM=EM-1
return
endif
if not KA[YJa]then
call YGa(YJa,"when calling receiveMetadata in Network, line 432")
endif
if ta!=IA[YJa]then
call QNa(vA[YJa],1,"when calling setMode in Network, line 437")
call yta(YJa,"when calling readInts in Network, line 439")
call y5a(YJa,"when calling readReals in Network, line 440")
call YAa(YJa,"when calling readBooleans in Network, line 441")
call yDa(YJa,"when calling readStrings in Network, line 442")
call QNa(vA[YJa],3,"when calling setMode in Network, line 445")
endif
set BA[YJa]=BA[YJa]+1
if BA[YJa]<JA[YJa]then
set YKa=y8a("when calling alloc_ForForceCallback_execute_Network_Network in Network, line 451")
set dD[YKa]=YJa
call Fte(YKa,"when calling execute in Network, line 451")
else
if ta!=IA[YJa]then
call Wya(mA[YJa],"when calling decode in Network, line 456")
call QNa(vA[YJa],1,"when calling setMode in Network, line 458")
set Yma=oq
set Yla=yxa("when calling alloc_LimitedExecuteCondition_executeWhile_Network_Network in Network, line 460")
set fD[Yla]=YJa
set YMa=Yla
set YLa=yia("when calling alloc_LimitedExecuteAction_executeWhile_Network_Network in Network, line 460")
set RD[YLa]=YJa
call WOe(Yma,YMa,YLa,"when calling executeWhile in Network, line 460")
endif
call QNa(vA[YJa],0,"when calling setMode in Network, line 464")
call yha(vA[YJa],"when calling resetRead in Network, line 465")
set jA[YJa]=2
call TDa(NA[YJa],0,vA[YJa],"when calling onFinish in Network, line 467")
call sWa(YJa,"when calling dispatch_Network_destroyNetwork in Network, line 468")
endif
set EM=EM-1
endfunction
function Ypa takes integer YPa,string Yqa returns nothing
set ZM[EM]=Yqa
set EM=EM+1
if ck[YPa]==0 then
if YPa==0 then
call Cdv("Nullpointer exception when calling Network.receiveRound","when calling error in Network, line 422")
else
call Cdv("Called Network.receiveRound on invalid object.","when calling error in Network, line 422")
endif
endif
call Yja(YPa,"when calling receiveRound in Network, line 422")
set EM=EM-1
endfunction
function YQa takes integer Ysa,string YSa returns nothing
set ZM[EM]=YSa
set EM=EM+1
call Ypa(nD[Ysa],"when calling receiveRound in Network, line 420")
set EM=EM-1
endfunction
function Yta takes integer qtt returns nothing
endfunction
function YTa takes integer Yua,string YUa returns nothing
set ZM[EM]=YUa
set EM=EM+1
if lG[Yua]==0 then
if Yua==0 then
call Cdv("Nullpointer exception when calling Persistable.onSaved","when calling error in Persistable, line 81")
else
call Cdv("Called Persistable.onSaved on invalid object.","when calling error in Persistable, line 81")
endif
endif
call Yta(Yua)
set EM=EM-1
endfunction
function Ywa takes integer pLc returns nothing
endfunction
function YWa takes integer Yya,string YYa returns nothing
set ZM[EM]=YYa
set EM=EM+1
if PF[Yya]==0 then
call Cdv("Double free: object of type FileWriter","when calling error in MultifileIO, line 97")
else
set IF=IF+1
set PF[Yya]=0
endif
set EM=EM-1
endfunction
function Yza takes integer YZa,string Y_a returns nothing
set ZM[EM]=Y_a
set EM=EM+1
call UAa(YZa,"when calling AbstractFile_onDestroy in MultifileIO, line 97")
set EM=EM-1
endfunction
function Y0a takes integer Y1a,string Y2a returns nothing
set ZM[EM]=Y2a
set EM=EM+1
call Yza(Y1a,"when calling FileWriter_onDestroy in MultifileIO, line 96")
call YWa(Y1a,"when calling dealloc_FileWriter in MultifileIO, line 96")
set EM=EM-1
endfunction
function Y3a takes integer Y4a,string Y5a returns nothing
set ZM[EM]=Y5a
set EM=EM+1
if PF[Y4a]==0 then
if Y4a==0 then
call Cdv("Nullpointer exception when calling FileWriter.FileWriter","when calling error in MultifileIO, line 97")
else
call Cdv("Called FileWriter.FileWriter on invalid object.","when calling error in MultifileIO, line 97")
endif
endif
call Y0a(Y4a,"when calling destroyFileWriter in MultifileIO, line 97")
set EM=EM-1
endfunction
function Y6a takes integer Y7a,string Y8a returns nothing
set ZM[EM]=Y8a
set EM=EM+1
if ta==AD[oH[Y7a]]then
call Y3a(OH[Y7a],"when calling dispatch_FileWriter_destroyFileWriter in Persistable, line 216")
endif
if lH[Y7a]!=0 then
call Ywa(lH[Y7a])
endif
call YTa(DD[oH[Y7a]],"when calling onSaved in Persistable, line 220")
set EM=EM-1
endfunction
function Y9a takes integer zva,string zea returns nothing
set ZM[EM]=zea
set EM=EM+1
if ik[zva]==0 then
if zva==0 then
call Cdv("Nullpointer exception when calling SynchronizationCallback.onSynchronized","when calling error in SyncSimple, line 111")
else
call Cdv("Called SynchronizationCallback.onSynchronized on invalid object.","when calling error in SyncSimple, line 111")
endif
endif
if ik[zva]<=4875 then
if ik[zva]<=4874 then
call YQa(zva,"when calling onSynchronized_onSynced_Network_Network in SyncSimple, line 111")
else
call W9a(zva,"when calling onSynchronized_onSynced_Network_NetworkData in SyncSimple, line 111")
endif
elseif ik[zva]<=4876 then
call UJa(zva,"when calling onSynchronized_onSynced_PersistentStore_Persistable in SyncSimple, line 111")
else
call Y6a(zva,"when calling onSynchronized_onSynced_PersistentStore_Persistable in SyncSimple, line 111")
endif
set EM=EM-1
endfunction
function zxa takes integer zoa returns boolean
return lC[zoa]==AR
endfunction
function zra takes integer zia,string zaa returns boolean
local boolean zna
set ZM[EM]=zaa
set EM=EM+1
if nv[zia]==0 then
if zia==0 then
call Cdv("Nullpointer exception when calling SimpleSynchronizer.areAllPlayersSynced","when calling error in SyncSimple, line 147")
else
call Cdv("Called SimpleSynchronizer.areAllPlayersSynced on invalid object.","when calling error in SyncSimple, line 147")
endif
endif
set zna=zxa(zia)
set EM=EM-1
return zna
endfunction
function zVa takes integer zEa,string zXa returns nothing
set ZM[EM]=zXa
set EM=EM+1
if ik[zEa]==0 then
call Cdv("Double free: object of type SynchronizationCallback","when calling error in SyncSimple, line 110")
else
set rk[sk]=zEa
set sk=sk+1
set ik[zEa]=0
endif
set EM=EM-1
endfunction
function zOa takes integer zRa,string zIa returns nothing
set ZM[EM]=zIa
set EM=EM+1
call zVa(zRa,"when calling dealloc_SynchronizationCallback in SyncSimple, line 110")
set EM=EM-1
endfunction
function zAa takes integer zNa,string zba returns nothing
set ZM[EM]=zba
set EM=EM+1
if ik[zNa]==0 then
if zNa==0 then
call Cdv("Nullpointer exception when calling SynchronizationCallback.SynchronizationCallback","when calling error in SyncSimple, line 110")
else
call Cdv("Called SynchronizationCallback.SynchronizationCallback on invalid object.","when calling error in SyncSimple, line 110")
endif
endif
call zOa(zNa,"when calling destroySynchronizationCallback in SyncSimple, line 110")
set EM=EM-1
endfunction
function zBa takes integer zca returns nothing
set JR=JR-1
if zca!=DR then
set pC[yC[zca]]=pC[zca]
else
set DR=pC[zca]
endif
if zca!=HR then
set yC[pC[zca]]=yC[zca]
else
set HR=yC[zca]
endif
endfunction
function zCa takes integer zda,string zDa returns nothing
set ZM[EM]=zDa
set EM=EM+1
if nv[zda]==0 then
if zda==0 then
call Cdv("Nullpointer exception when calling SimpleSynchronizer.remove","when calling error in LinkedListModule, line 37")
else
call Cdv("Called SimpleSynchronizer.remove on invalid object.","when calling error in LinkedListModule, line 37")
endif
endif
call zBa(zda)
set EM=EM-1
endfunction
function zfa takes integer zFa,string zga returns nothing
set ZM[EM]=zga
set EM=EM+1
set PR[UHx(OC[zFa])]=0
call PFv(OC[zFa])
call zAa(bC[zFa],"when calling dispatch_SynchronizationCallback_destroySynchronizationCallback in SyncSimple, line 131")
call zCa(zFa,"when calling remove in LinkedListModule, line 49")
set EM=EM-1
endfunction
function zGa takes integer zha,string zHa returns nothing
set ZM[EM]=zHa
set EM=EM+1
if nv[zha]==0 then
call Cdv("Double free: object of type SimpleSynchronizer","when calling error in SyncSimple, line 113")
else
set ev[qv]=zha
set qv=qv+1
set nv[zha]=0
endif
set EM=EM-1
endfunction
function zja takes integer zJa,string zka returns nothing
set ZM[EM]=zka
set EM=EM+1
call zfa(zJa,"when calling SimpleSynchronizer_onDestroy in SyncSimple, line 128")
call zGa(zJa,"when calling dealloc_SimpleSynchronizer in SyncSimple, line 128")
set EM=EM-1
endfunction
function zKa takes integer zla,string zLa returns nothing
set ZM[EM]=zLa
set EM=EM+1
if nv[zla]==0 then
if zla==0 then
call Cdv("Nullpointer exception when calling SimpleSynchronizer.SimpleSynchronizer","when calling error in SyncSimple, line 113")
else
call Cdv("Called SimpleSynchronizer.SimpleSynchronizer on invalid object.","when calling error in SyncSimple, line 113")
endif
endif
call zja(zla,"when calling destroySimpleSynchronizer in SyncSimple, line 113")
set EM=EM-1
endfunction
function zma takes integer zMa,player zpa,string zPa returns nothing
local integer zqa
set ZM[EM]=zPa
set EM=EM+1
set zqa=dpv(lC[zMa],Hme(zpa))
set lC[zMa]=zqa
if zra(zMa,"when calling areAllPlayersSynced in SyncSimple, line 153")then
call Y9a(bC[zMa],"when calling onSynchronized in SyncSimple, line 154")
call zKa(zMa,"when calling dispatch_SimpleSynchronizer_destroySimpleSynchronizer in SyncSimple, line 156")
endif
set EM=EM-1
endfunction
function zQa takes integer zsa,player zSa,string zta returns nothing
set ZM[EM]=zta
set EM=EM+1
if nv[zsa]==0 then
if zsa==0 then
call Cdv("Nullpointer exception when calling SimpleSynchronizer.onPlayerFinishedSync","when calling error in SyncSimple, line 150")
else
call Cdv("Called SimpleSynchronizer.onPlayerFinishedSync on invalid object.","when calling error in SyncSimple, line 150")
endif
endif
call zma(zsa,zSa,"when calling onPlayerFinishedSync in SyncSimple, line 150")
set EM=EM-1
endfunction
function zTa takes unit zua returns integer
return PR[UHx(zua)]
endfunction
function zUa takes integer ENi,string zwa returns nothing
local integer zWa
set ZM[EM]=zwa
set EM=EM+1
set zWa=zTa(GetTriggerUnit())
if zWa!=0 then
call zQa(zWa,GetTriggerPlayer(),"when calling onPlayerFinishedSync in SyncSimple, line 169")
endif
set EM=EM-1
endfunction
function zya takes nothing returns integer
return GetIssuedOrderId()
endfunction
function zYa takes nothing returns unit
return GetOrderedUnit()
endfunction
function zza takes integer zZa,unit z_a,string z0a returns group
local group z1a
local group z2a
set ZM[EM]=z0a
set EM=EM+1
set z1a=CreateGroup()
call j3o(z1a,jho(f3v(aL[zZa],Hzo(z_a),"when calling get in ScmdUnitParamLinkingBuiltins, line 45"),"when calling groupFromIndex in ScmdUnitParamLinkingBuiltins, line 45"))
set z2a=z1a
set EM=EM-1
set Iav=z2a
set z1a=null
set z2a=null
return Iav
endfunction
function z3a takes integer z4a,unit z5a,string z6a returns group
local group z7a
set ZM[EM]=z6a
set EM=EM+1
if Bx[z4a]==0 then
if z4a==0 then
call Cdv("Nullpointer exception when calling DisjointGroups.get","when calling error in ScmdUnitParamLinkingBuiltins, line 44")
else
call Cdv("Called DisjointGroups.get on invalid object.","when calling error in ScmdUnitParamLinkingBuiltins, line 44")
endif
endif
set z7a=zza(z4a,z5a,"when calling get in ScmdUnitParamLinkingBuiltins, line 44")
set EM=EM-1
set IPv=z7a
set z7a=null
return IPv
endfunction
function z8a takes unit z9a,integer Zva returns boolean
return IssueImmediateOrderById(z9a,Zva)
endfunction
function Zea takes integer Zxa,string Zoa returns nothing
local group Zra
local integer Zia
local group Zaa
local unit Zna
set ZM[EM]=Zoa
set EM=EM+1
if not xM[SL[Zxa]]then
set Zra=z3a(cL[Zxa],zYa(),"when calling get in ScmdUnitParamLinkingBuiltins, line 116")
if Zra!=null then
set xM[SL[Zxa]]=true
set Zia=zya()
set Zaa=QEe(Zra)
loop
exitwhen not F9e(Zaa)
set Zna=F6e(Zaa)
call z8a(Zna,Zia)
endloop
call QOe(Zaa)
set xM[SL[Zxa]]=false
endif
endif
set EM=EM-1
set Zra=null
set Zaa=null
set Zna=null
endfunction
function ZVa takes integer ZEa returns integer
local integer ZXa=eC[ZEa]
set eC[ZEa]=pC[eC[ZEa]]
return ZXa
endfunction
function ZOa takes integer ZRa returns boolean
return eC[ZRa]!=0
endfunction
function ZIa takes integer ZAa,player ZNa,string Zba returns nothing
set ZM[EM]=Zba
set EM=EM+1
call zQa(ZAa,ZNa,"when calling onPlayerFinishedSync in SyncSimple, line 159")
set EM=EM-1
endfunction
function ZBa takes integer Zca,player ZCa,string Zda returns nothing
set ZM[EM]=Zda
set EM=EM+1
if nv[Zca]==0 then
if Zca==0 then
call Cdv("Nullpointer exception when calling SimpleSynchronizer.onPlayerLeave","when calling error in SyncSimple, line 158")
else
call Cdv("Called SimpleSynchronizer.onPlayerLeave on invalid object.","when calling error in SyncSimple, line 158")
endif
endif
call ZIa(Zca,ZCa,"when calling onPlayerLeave in SyncSimple, line 158")
set EM=EM-1
endfunction
function ZDa takes integer Zfa,string ZFa returns nothing
set ZM[EM]=ZFa
set EM=EM+1
if gv[Zfa]==0 then
call Cdv("Double free: object of type Iterator","when calling error in LinkedListModule, line 71")
else
set Tv[Yv]=Zfa
set Yv=Yv+1
set gv[Zfa]=0
endif
set EM=EM-1
endfunction
function Zga takes integer b3i returns nothing
endfunction
function ZGa takes integer Zha,string ZHa returns nothing
set ZM[EM]=ZHa
set EM=EM+1
call Zga(Zha)
call ZDa(Zha,"when calling dealloc_Iterator in LinkedListModule, line 71")
set EM=EM-1
endfunction
function Zja takes integer ZJa,string Zka returns nothing
set ZM[EM]=Zka
set EM=EM+1
if gv[ZJa]==0 then
if ZJa==0 then
call Cdv("Nullpointer exception when calling Iterator.Iterator","when calling error in LinkedListModule, line 71")
else
call Cdv("Called Iterator.Iterator on invalid object.","when calling error in LinkedListModule, line 71")
endif
endif
call ZGa(ZJa,"when calling destroyIterator in LinkedListModule, line 71")
set EM=EM-1
endfunction
function ZKa takes integer Zla,string ZLa returns nothing
set ZM[EM]=ZLa
set EM=EM+1
if qC[Zla]then
call Zja(Zla,"when calling dispatch_Iterator_destroyIterator in LinkedListModule, line 91")
endif
set EM=EM-1
endfunction
function Zma takes string ZMa returns integer
local integer Zpa
set ZM[EM]=ZMa
set EM=EM+1
if Yv==0 then
if Gv<$8000 then
set Gv=Gv+1
set Zpa=Gv
set gv[Zpa]=$C86
else
call Cdv("Out of memory: Could not create Iterator.","when calling error in LinkedListModule, line 71")
set Zpa=0
endif
else
set Yv=Yv-1
set Zpa=Tv[Yv]
set gv[Zpa]=$C86
endif
set EM=EM-1
return Zpa
endfunction
function ZPa takes integer Zqa returns nothing
set eC[Zqa]=DR
endfunction
function ZQa takes integer Zsa,boolean ZSa returns nothing
call ZPa(Zsa)
set qC[Zsa]=ZSa
endfunction
function Zta takes boolean ZTa,string Zua returns integer
local integer ZUa
set ZM[EM]=Zua
set EM=EM+1
set ZUa=Zma("when calling alloc_Iterator in LinkedListModule, line 75")
call ZQa(ZUa,ZTa)
set EM=EM-1
return ZUa
endfunction
function Zwa takes string ZWa returns integer
local integer Zya
set ZM[EM]=ZWa
set EM=EM+1
set Zya=Zta(true,"when calling new_Iterator in LinkedListModule, line 53")
set EM=EM-1
return Zya
endfunction
function ZYa takes integer PNi,string Zza returns nothing
local player ZZa
local integer Z_a
local integer Z0a
set ZM[EM]=Zza
set EM=EM+1
set ZZa=GetTriggerPlayer()
set Z_a=Zwa("when calling iterator in SyncSimple, line 174")
loop
exitwhen not ZOa(Z_a)
set Z0a=ZVa(Z_a)
call ZBa(Z0a,ZZa,"when calling onPlayerLeave in SyncSimple, line 175")
endloop
call ZKa(Z_a,"when calling close in SyncSimple, line 174")
set EM=EM-1
set ZZa=null
endfunction
function Z1a takes nothing returns unit
return GetDyingUnit()
endfunction
function Z2a takes integer Z3a,string Z4a returns nothing
local group Z5a
local unit Z6a
local group Z7a
set ZM[EM]=Z4a
set EM=EM+1
if not xM[tL[Z3a]]then
set Z5a=z3a(iL[Z3a],Z1a(),"when calling get in ScmdUnitParamLinkingBuiltins, line 105")
if Z5a!=null then
set xM[tL[Z3a]]=true
set Z7a=Z5a
loop
exitwhen not F9e(Z7a)
set Z6a=F6e(Z7a)
call Sfe(Z6a)
endloop
set xM[tL[Z3a]]=false
endif
endif
set EM=EM-1
set Z5a=null
set Z6a=null
set Z7a=null
endfunction
function Z8a takes integer Z9a,integer vvn,string ven returns nothing
set ZM[EM]=ven
set EM=EM+1
if Oh[Z9a]==0 then
if Z9a==0 then
call Cdv("Nullpointer exception when calling HashSet.removeAt","when calling error in HashSet, line 21")
else
call Cdv("Called HashSet.removeAt on invalid object.","when calling error in HashSet, line 21")
endif
endif
call gEo(Z9a,vvn,"when calling removeAt in HashSet, line 21")
set EM=EM-1
endfunction
function vxn takes integer von,integer vrn,string vin returns nothing
set ZM[EM]=vin
set EM=EM+1
if div(von,vrn,"when calling count in HashSet, line 17")>0 then
call Z8a(von,c8v(fe,von,vrn),"when calling removeAt in HashSet, line 18")
endif
set EM=EM-1
endfunction
function van takes integer vnn,integer vVn,string vEn returns nothing
set ZM[EM]=vEn
set EM=EM+1
if Oh[vnn]==0 then
if vnn==0 then
call Cdv("Nullpointer exception when calling HashSet.remove","when calling error in HashSet, line 16")
else
call Cdv("Called HashSet.remove on invalid object.","when calling error in HashSet, line 16")
endif
endif
call vxn(vnn,vVn,"when calling remove in HashSet, line 16")
set EM=EM-1
endfunction
function vXn takes hashtable vOn,integer vRn,integer vIn returns lightning
return LoadLightningHandle(vOn,vRn,vIn)
endfunction
function vAn takes integer vNn,integer vbn returns lightning
return vXn(XR,vNn,vbn)
endfunction
function vBn takes integer vcn,integer vCn,string vdn returns lightning
local lightning vDn
set ZM[EM]=vdn
set EM=EM+1
if ph[vcn]==0 then
if vcn==0 then
call Cdv("Nullpointer exception when calling Table.loadLightning","when calling error in Table, line 213")
else
call Cdv("Called Table.loadLightning on invalid object.","when calling error in Table, line 213")
endif
endif
set vDn=vAn(vcn,vCn)
set EM=EM-1
set IUv=vDn
set vDn=null
return IUv
endfunction
function vfn takes integer vFn,string vgn returns lightning
local lightning vGn
set ZM[EM]=vgn
set EM=EM+1
set vGn=vBn(RT,vFn,"when calling loadLightning in TypeCasting, line 207")
set EM=EM-1
set R4v=vGn
set vGn=null
return R4v
endfunction
function vhn takes lightning vHn returns boolean
return DestroyLightning(vHn)
endfunction
function vjn takes integer vJn,string vkn returns nothing
local integer vKn
local lightning vln
set ZM[EM]=vkn
set EM=EM+1
set vKn=jdv(hH[vJn],"when calling iterator in RectDrawing, line 38")
loop
exitwhen not Jgv(vKn,"when calling hasNext in RectDrawing, line 38")
set vln=vfn(jTv(vKn,"when calling next in RectDrawing, line 38"),"when calling lightningFromIndex in RectDrawing, line 38")
call vhn(vln)
endloop
call Jqv(vKn,"when calling close in RectDrawing, line 38")
call j1v(hH[vJn],"when calling clear in RectDrawing, line 40")
set EM=EM-1
set vln=null
endfunction
function vLn takes integer vmn,string vMn returns nothing
set ZM[EM]=vMn
set EM=EM+1
if Jk[vmn]==0 then
if vmn==0 then
call Cdv("Nullpointer exception when calling RectDrawing.clear","when calling error in RectDrawing, line 37")
else
call Cdv("Called RectDrawing.clear on invalid object.","when calling error in RectDrawing, line 37")
endif
endif
call vjn(vmn,"when calling clear in RectDrawing, line 37")
set EM=EM-1
endfunction
function vpn takes lightning vPn,integer vqn,integer vQn,integer vsn,integer vSn returns boolean
return SetLightningColor(vPn,vqn*1./$FF,vQn*1./$FF,vsn*1./$FF,vSn*1./$FF)
endfunction
function vtn takes hashtable vTn,integer vun,integer vUn,lightning vwn returns nothing
call SaveLightningHandle(vTn,vun,vUn,vwn)
endfunction
function vWn takes integer vyn,integer vYn,lightning vzn returns nothing
call vtn(XR,vyn,vYn,vzn)
endfunction
function vZn takes integer v_n,integer v0n,lightning v1n,string v2n returns nothing
set ZM[EM]=v2n
set EM=EM+1
if ph[v_n]==0 then
if v_n==0 then
call Cdv("Nullpointer exception when calling Table.saveLightning","when calling error in Table, line 216")
else
call Cdv("Called Table.saveLightning on invalid object.","when calling error in Table, line 216")
endif
endif
call vWn(v_n,v0n,v1n)
set EM=EM-1
endfunction
function v3n takes lightning v4n,string v5n returns integer
local integer v6n
set ZM[EM]=v5n
set EM=EM+1
call vZn(RT,-C0v(v4n),v4n,"when calling saveLightning in TypeCasting, line 210")
set v6n=-C0v(v4n)
set EM=EM-1
return v6n
endfunction
function v7n takes string v8n,boolean v9n,real evn,real een,real exn,real eon returns lightning
return AddLightning(v8n,v9n,evn,een,exn,eon)
endfunction
function ern takes integer ein,real ean,real enn,real eVn,real eEn,string eXn returns nothing
local lightning eOn
set ZM[EM]=eXn
set EM=EM+1
set eOn=v7n(kH[ein],false,ean,enn,eVn,eEn)
if ta!=FH[ein]then
call vpn(eOn,0,0,0,0)
endif
call dlv(hH[ein],v3n(eOn,"when calling lightningToIndex in RectDrawing, line 19"),"when calling add in RectDrawing, line 19")
set EM=EM-1
set eOn=null
endfunction
function eRn takes integer eIn,real eAn,real eNn,real ebn,real eBn,string ecn returns nothing
set ZM[EM]=ecn
set EM=EM+1
if Jk[eIn]==0 then
if eIn==0 then
call Cdv("Nullpointer exception when calling RectDrawing.drawSegment","when calling error in RectDrawing, line 15")
else
call Cdv("Called RectDrawing.drawSegment on invalid object.","when calling error in RectDrawing, line 15")
endif
endif
call ern(eIn,eAn,eNn,ebn,eBn,"when calling drawSegment in RectDrawing, line 15")
set EM=EM-1
endfunction
function eCn takes integer edn,real eDn,real efn,real eFn,string egn returns nothing
local integer eGn
local real ehn
local real eHn
local integer ejn
local integer eJn
set ZM[EM]=egn
set EM=EM+1
set eGn=P3x(yWe(eFn/ja))
set ehn=eFn/eGn
set eHn=eDn
set ejn=0
set eJn=eGn-1
loop
exitwhen ejn>eJn
call eRn(edn,eHn,efn,eHn+ehn,efn,"when calling drawSegment in RectDrawing, line 26")
set eHn=eHn+ehn
set ejn=ejn+1
endloop
set EM=EM-1
endfunction
function ekn takes integer eKn,real eln,real eLn,real emn,string eMn returns nothing
set ZM[EM]=eMn
set EM=EM+1
if Jk[eKn]==0 then
if eKn==0 then
call Cdv("Nullpointer exception when calling RectDrawing.drawHorizontalLine","when calling error in RectDrawing, line 21")
else
call Cdv("Called RectDrawing.drawHorizontalLine on invalid object.","when calling error in RectDrawing, line 21")
endif
endif
call eCn(eKn,eln,eLn,emn,"when calling drawHorizontalLine in RectDrawing, line 21")
set EM=EM-1
endfunction
function epn takes integer ePn,real eqn,real eQn,real esn,string eSn returns nothing
local integer etn
local real eTn
local real eun
local integer eUn
local integer ewn
set ZM[EM]=eSn
set EM=EM+1
set etn=P3x(yWe(esn/ja))
set eTn=esn/etn
set eun=eQn
set eUn=0
set ewn=etn-1
loop
exitwhen eUn>ewn
call eRn(ePn,eqn,eun,eqn,eun+eTn,"when calling drawSegment in RectDrawing, line 34")
set eun=eun+eTn
set eUn=eUn+1
endloop
set EM=EM-1
endfunction
function eWn takes integer eyn,real eYn,real ezn,real eZn,string e_n returns nothing
set ZM[EM]=e_n
set EM=EM+1
if Jk[eyn]==0 then
if eyn==0 then
call Cdv("Nullpointer exception when calling RectDrawing.drawVerticalLine","when calling error in RectDrawing, line 29")
else
call Cdv("Called RectDrawing.drawVerticalLine on invalid object.","when calling error in RectDrawing, line 29")
endif
endif
call epn(eyn,eYn,ezn,eZn,"when calling drawVerticalLine in RectDrawing, line 29")
set EM=EM-1
endfunction
function e0n takes integer e1n,string e2n returns nothing
set ZM[EM]=e2n
set EM=EM+1
call ekn(e1n,jH[e1n],xH[e1n],vH[e1n]-jH[e1n],"when calling drawHorizontalLine in RectDrawing, line 43")
call ekn(e1n,vH[e1n],mH[e1n],jH[e1n]-vH[e1n],"when calling drawHorizontalLine in RectDrawing, line 44")
call eWn(e1n,jH[e1n],mH[e1n],xH[e1n]-mH[e1n],"when calling drawVerticalLine in RectDrawing, line 45")
call eWn(e1n,vH[e1n],xH[e1n],mH[e1n]-xH[e1n],"when calling drawVerticalLine in RectDrawing, line 46")
set EM=EM-1
endfunction
function e3n takes integer e4n,string e5n returns nothing
set ZM[EM]=e5n
set EM=EM+1
if Jk[e4n]==0 then
if e4n==0 then
call Cdv("Nullpointer exception when calling RectDrawing.draw","when calling error in RectDrawing, line 42")
else
call Cdv("Called RectDrawing.draw on invalid object.","when calling error in RectDrawing, line 42")
endif
endif
call e0n(e4n,"when calling draw in RectDrawing, line 42")
set EM=EM-1
endfunction
function e6n takes rect e7n,real e8n,real e9n,real xvn,real xen returns nothing
call SetRect(e7n,e8n,e9n,xvn,xen)
endfunction
function xxn takes integer xon,string xrn returns nothing
set ZM[EM]=xrn
set EM=EM+1
call vLn(xon,"when calling clear in RectDrawing, line 49")
call e6n(QH[xon],jH[xon],xH[xon],vH[xon],mH[xon])
call e3n(xon,"when calling draw in RectDrawing, line 51")
set EM=EM-1
endfunction
function xin takes integer xan,string xnn returns nothing
set ZM[EM]=xnn
set EM=EM+1
if Jk[xan]==0 then
if xan==0 then
call Cdv("Nullpointer exception when calling RectDrawing.repaint","when calling error in RectDrawing, line 48")
else
call Cdv("Called RectDrawing.repaint on invalid object.","when calling error in RectDrawing, line 48")
endif
endif
call xxn(xan,"when calling repaint in RectDrawing, line 48")
set EM=EM-1
endfunction
function xVn takes integer xEn,string xXn,string xOn returns nothing
set ZM[EM]=xOn
set EM=EM+1
set kH[xEn]=xXn
call xin(xEn,"when calling repaint in RectDrawing, line 85")
set EM=EM-1
endfunction
function xRn takes integer xIn,string xAn,string xNn returns nothing
set ZM[EM]=xNn
set EM=EM+1
if Jk[xIn]==0 then
if xIn==0 then
call Cdv("Nullpointer exception when calling RectDrawing.setCodeName","when calling error in RectDrawing, line 83")
else
call Cdv("Called RectDrawing.setCodeName on invalid object.","when calling error in RectDrawing, line 83")
endif
endif
call xVn(xIn,xAn,"when calling setCodeName in RectDrawing, line 83")
set EM=EM-1
endfunction
function xbn takes integer xBn,string xcn returns nothing
local integer xCn
set ZM[EM]=xcn
set EM=EM+1
if GetTriggerPlayer()==sa[DL[xBn]]then
set xCn=f3v(aR,Hzo(HL[xBn]),"when calling get in SotfrpGuiRegions, line 115")
call xRn(xCn,null,"when calling setCodeName in SotfrpGuiRegions, line 116")
call van(qR[DL[xBn]],xCn,"when calling remove in SotfrpGuiRegions, line 117")
endif
set EM=EM-1
endfunction
function xdn takes nothing returns unit
return BlzGetEventDamageTarget()
endfunction
function xDn takes nothing returns real
return GetEventDamage()
endfunction
function xfn takes integer xFn,string xgn returns nothing
local group xGn
local unit xhn
local real xHn
local integer xjn
local group xJn
local unit xkn
local real xKn
local real xln
local unit xLn
local group xmn
set ZM[EM]=xgn
set EM=EM+1
set xGn=z3a(wL[xFn],xdn(),"when calling get in ScmdUnitParamLinkingBuiltins, line 72")
if xGn!=null then
set xhn=xdn()
set xHn=.0
set xjn=0
set xJn=QEe(xGn)
loop
exitwhen not F9e(xJn)
set xkn=F6e(xJn)
set xHn=xHn+aae(xkn)
set xjn=xjn+zJv(xkn)
endloop
call QOe(xJn)
set xKn=xDn()
if aae(xhn)<xKn then
endif
set xHn=xHn-xKn
set xln=xHn/xjn
set xmn=xGn
loop
exitwhen not F9e(xmn)
set xLn=F6e(xmn)
call IBe(xLn,xln*zJv(xLn))
endloop
endif
set EM=EM-1
set xGn=null
set xhn=null
set xJn=null
set xkn=null
set xLn=null
set xmn=null
endfunction
function xMn takes string xpn returns integer
local integer xPn
set ZM[EM]=xpn
set EM=EM+1
if jG==0 then
if xG<$8000 then
set xG=xG+1
set xPn=xG
set vG[xPn]=$478
else
call Cdv("Out of memory: Could not create CallbackSingle_nullTimer_add_ScmdUnitParamLinkingBuiltins.","when calling error in ScmdUnitParamLinkingBuiltins, line 95")
set xPn=0
endif
else
set jG=jG-1
set xPn=kG[jG]
set vG[xPn]=$478
endif
set EM=EM-1
return xPn
endfunction
function xqn takes integer xQn,string xsn returns nothing
local group xSn
local real xtn
local integer xTn
set ZM[EM]=xsn
set EM=EM+1
set xSn=z3a(uL[xQn],xdn(),"when calling get in ScmdUnitParamLinkingBuiltins, line 91")
if xSn!=null then
call HQo(xSn,xdn())
set xtn=xDn()
set xTn=xMn("when calling alloc_CallbackSingle_nullTimer_add_ScmdUnitParamLinkingBuiltins in ScmdUnitParamLinkingBuiltins, line 95")
call EUx(xTn)
set rL[xTn]=xSn
set sL[xTn]=xtn
call Lsx(xTn,"when calling nullTimer in ScmdUnitParamLinkingBuiltins, line 95")
endif
set EM=EM-1
set xSn=null
endfunction
function xun takes integer kWi returns nothing
call PFv(QKv(Hme(GetTriggerPlayer())))
endfunction
function xUn takes nothing returns widget
return GetOrderTarget()
endfunction
function xwn takes unit xWn,integer xyn,widget xYn returns boolean
return IssueTargetOrderById(xWn,xyn,xYn)
endfunction
function xzn takes integer xZn,string x_n returns nothing
local group x0n
local integer x1n
local widget x2n
local group x3n
local unit x4n
set ZM[EM]=x_n
set EM=EM+1
if not xM[lL[xZn]]then
set x0n=z3a(bL[xZn],zYa(),"when calling get in ScmdUnitParamLinkingBuiltins, line 137")
if x0n!=null then
set xM[lL[xZn]]=true
set x1n=zya()
set x2n=xUn()
set x3n=QEe(x0n)
loop
exitwhen not F9e(x3n)
set x4n=F6e(x3n)
call xwn(x4n,x1n,x2n)
endloop
call QOe(x3n)
set xM[lL[xZn]]=false
endif
endif
set EM=EM-1
set x0n=null
set x2n=null
set x3n=null
set x4n=null
endfunction
function x5n takes unit x6n,integer x7n,real x8n,real x9n returns boolean
return IssuePointOrderById(x6n,x7n,x8n,x9n)
endfunction
function ovn takes nothing returns real
set K3=GetOrderPointX()
set L3=GetOrderPointY()
return K3
endfunction
function oen takes integer oxn,string oon returns nothing
local group orn
local integer oin
local real oan
local real onn
local group oVn
local unit oEn
local real oXn
local real oOn
set ZM[EM]=oon
set EM=EM+1
if not xM[oL[oxn]]then
set orn=z3a(OL[oxn],zYa(),"when calling get in ScmdUnitParamLinkingBuiltins, line 125")
if orn!=null then
set xM[oL[oxn]]=true
set oin=zya()
if oin==Zq then
set oin=Wq
endif
set oXn=ovn()
set oOn=L3
set oan=oXn
set onn=oOn
set oVn=QEe(orn)
loop
exitwhen not F9e(oVn)
set oEn=F6e(oVn)
call x5n(oEn,oin,oan,onn)
endloop
call QOe(oVn)
set xM[oL[oxn]]=false
endif
endif
set EM=EM-1
set orn=null
set oVn=null
set oEn=null
endfunction
function oRn takes integer oIn,string oAn returns nothing
local integer oNn
set ZM[EM]=oAn
set EM=EM+1
if GetTriggerPlayer()==sa[PL[oIn]]then
set oNn=f3v(aR,Hzo(AL[oIn]),"when calling get in SotfrpGuiRegions, line 108")
call xRn(oNn,ve,"when calling setCodeName in SotfrpGuiRegions, line 109")
call rOa(qR[PL[oIn]],oNn,"when calling add in SotfrpGuiRegions, line 110")
else
call wox(GetTriggerPlayer(),AL[oIn])
endif
set EM=EM-1
endfunction
function obn takes integer oBn,string ocn returns nothing
set ZM[EM]=ocn
set EM=EM+1
if CG[oBn]==0 then
if oBn==0 then
call Cdv("Nullpointer exception when calling EventListener.onEvent","when calling error in ClosureEvents, line 109")
else
call Cdv("Called EventListener.onEvent on invalid object.","when calling error in ClosureEvents, line 109")
endif
endif
if CG[oBn]<=$7B8 then
if CG[oBn]<=$7B5 then
if CG[oBn]<=$7B4 then
if CG[oBn]<=$7B3 then
call xfn(oBn,"when calling onEvent_add_ScmdUnitParamLinkingBuiltins in ClosureEvents, line 109")
else
call xqn(oBn,"when calling onEvent_add_ScmdUnitParamLinkingBuiltins in ClosureEvents, line 109")
endif
else
call Z2a(oBn,"when calling onEvent_add_ScmdUnitParamLinkingBuiltins in ClosureEvents, line 109")
endif
elseif CG[oBn]<=$7B7 then
if CG[oBn]<=$7B6 then
call Zea(oBn,"when calling onEvent_add_ScmdUnitParamLinkingBuiltins in ClosureEvents, line 109")
else
call oen(oBn,"when calling onEvent_add_ScmdUnitParamLinkingBuiltins in ClosureEvents, line 109")
endif
else
call xzn(oBn,"when calling onEvent_add_ScmdUnitParamLinkingBuiltins in ClosureEvents, line 109")
endif
elseif CG[oBn]<=$7BB then
if CG[oBn]<=$7BA then
if CG[oBn]<=$7B9 then
call xun(oBn)
else
call oRn(oBn,"when calling onEvent_add_SotfrpGuiRegions in ClosureEvents, line 109")
endif
else
call xbn(oBn,"when calling onEvent_add_SotfrpGuiRegions in ClosureEvents, line 109")
endif
elseif CG[oBn]<=$7BC then
call zUa(oBn,"when calling onEvent_add_SyncSimple in ClosureEvents, line 109")
else
call ZYa(oBn,"when calling onEvent_add_SyncSimple in ClosureEvents, line 109")
endif
set EM=EM-1
endfunction
function oCn takes string odn returns nothing
local unit oDn
local integer ofn
local integer oFn
local integer ogn
local integer oGn
local integer ohn
set ZM[EM]=odn
set EM=EM+1
set oDn=GetTriggerUnit()
set ofn=q1a(GetTriggerEventId(),"when calling toIntId in ClosureEvents, line 170")
if oDn!=null and q5a(oDn)and UHx(oDn)>0 then
if up[UHx(oDn)]!=0 then
set oFn=up[UHx(oDn)]
loop
exitwhen not(oFn!=0)
set ogn=GW[oFn]
if YW[oFn]==ofn then
call obn(oFn,"when calling onEvent in ClosureEvents, line 178")
endif
set oFn=ogn
endloop
endif
endif
if wp[ofn]!=0 then
set oGn=wp[ofn]
loop
exitwhen not(oGn!=0)
set ohn=GW[oGn]
call obn(oGn,"when calling onEvent in ClosureEvents, line 185")
set oGn=ohn
endloop
endif
set EM=EM-1
set oDn=null
endfunction
function oHn takes nothing returns nothing
set EM=0
call oCn("ClosureEvents, line 243")
endfunction
function ojn takes nothing returns boolean
return true
endfunction
function oJn takes nothing returns nothing
call CreateNUnitsAtLoc(1,'u030',GetOwningPlayer(GetSpellAbilityUnit()),GetSpellTargetLoc(),bj_UNIT_FACING)
call SetUnitPathing(GetLastCreatedUnit(),false)
call SetUnitPositionLoc(GetLastCreatedUnit(),GetSpellTargetLoc())
call UnitApplyTimedLifeBJ(3.,'BTLF',GetLastCreatedUnit())
call ForGroupBJ(GetUnitsInRangeOfLocMatching(200.,GetSpellTargetLoc(),Condition(ahv)),aHv)
endfunction
function okn takes nothing returns nothing
local unit oKn=CreateUnitAtLoc(Player(PLAYER_NEUTRAL_PASSIVE),'h0JO',GetUnitLoc(GetSpellAbilityUnit()),GetUnitFacing(GetSpellAbilityUnit()))
call UnitAddAbility(oKn,'A086')
call SetUnitAbilityLevel(oKn,'A086',GetUnitAbilityLevel(GetSpellAbilityUnit(),'A085'))
call IssuePointOrderByIdLoc(oKn,$D010E,GetSpellTargetLoc())
call TriggerSleepAction(12.)
call RemoveUnit(oKn)
set oKn=null
set oKn=null
endfunction
function oln takes nothing returns nothing
call ForGroup(bt,nmv)
endfunction
function oLn takes unit omn,real oMn returns nothing
local timer opn=CreateTimer()
call SaveUnitHandle(c,GetHandleId(opn),o,omn)
call TimerStart(opn,oMn,false,Az)
set opn=null
set opn=null
endfunction
function oPn takes nothing returns nothing
local unit oqn=GetSpellAbilityUnit()
local unit oQn=CreateUnitAtLoc(GetOwningPlayer(oqn),'h0JO',GetUnitLoc(oqn),270.)
local integer osn=GetUnitAbilityLevel(oqn,'AOdc')
local integer oSn=GetRandomInt(1,4)
set oqn=null
if oSn==1 then
call UnitAddAbility(oQn,'AOad')
call SetUnitAbilityLevel(oQn,'AOad',osn)
elseif oSn==2 then
call UnitAddAbility(oQn,'AObd')
call SetUnitAbilityLevel(oQn,'AObd',osn)
elseif oSn==3 then
call UnitAddAbility(oQn,'AOgd')
call SetUnitAbilityLevel(oQn,'AOgd',osn)
elseif oSn==4 then
call UnitAddAbility(oQn,'AOrd')
call SetUnitAbilityLevel(oQn,'AOrd',osn)
endif
set osn=0
set oSn=0
call IssueImmediateOrderById(oQn,$D0274)
call oLn(oQn,3.)
set oQn=null
set oqn=null
set oQn=null
endfunction
function otn takes nothing returns nothing
local timer oTn=GetExpiredTimer()
local unit oun=LoadUnitHandle(nr,GetHandleId(oTn),StringHash("u"))
local location oUn=LoadLocationHandle(nr,GetHandleId(oTn),StringHash("l"))
call FlushChildHashtable(nr,GetHandleId(oTn))
call DestroyTimer(oTn)
set oTn=null
call UnitDamagePoint(oun,.0,200.,GetLocationX(oUn),GetLocationY(oUn),475.,true,true,ATTACK_TYPE_NORMAL,DAMAGE_TYPE_MAGIC,WEAPON_TYPE_WHOKNOWS)
call RemoveLocation(oUn)
set oUn=null
set oun=null
set oTn=null
set oun=null
set oUn=null
endfunction
function own takes code oWn returns nothing
call GPo(hq,Filter(oWn))
endfunction
function oyn takes code oYn returns nothing
call cQv(hq,oYn)
endfunction
function ozn takes nothing returns boolean
set GT=CreateTrigger()
set gT=CreateTrigger()
set FT=0
call own(Rav)
call oyn(Rnv)
return true
endfunction
function oZn takes nothing returns boolean
return(GetDestructableMaxLife(GetEnumDestructable())<1000000000.)
endfunction
function o_n takes nothing returns nothing
if oZn()then
call DestructableRestoreLife(GetEnumDestructable(),GetDestructableMaxLife(GetEnumDestructable()),true)
endif
endfunction
function o0n takes nothing returns nothing
set Nr[Mr]='LTg1'
set Mr=Mr+1
set Nr[Mr]='LTg2'
set Mr=Mr+1
set Nr[Mr]='ZTg1'
set Mr=Mr+1
set Nr[Mr]='ZTg2'
set Mr=Mr+1
set Nr[Mr]='ITtg'
set Mr=Mr+1
set Nr[Mr]='ATg1'
set Mr=Mr+1
set Nr[Mr]='ATg2'
set Mr=Mr+1
set Nr[Mr]='YTcx'
set Mr=Mr+1
set Nr[Mr]='YTce'
set Mr=Mr+1
set Nr[Mr]='DTc1'
set Mr=Mr+1
set Nr[Mr]='DTc2'
set Mr=Mr+1
set Nr[Mr]='DTg5'
set Mr=Mr+1
set Nr[Mr]='DTg6'
set Mr=Mr+1
set Nr[Mr]='ZTd1'
set Mr=Mr+1
set Nr[Mr]='ZTd5'
set Mr=Mr+1
set Nr[Mr]='ITg1'
set Mr=Mr+1
set Nr[Mr]='ITg2'
set Mr=Mr+1
set Nr[Mr]='ZTsx'
set Mr=Mr+1
set Nr[Mr]='DTg1'
set Mr=Mr+1
set Nr[Mr]='DTg2'
set Mr=Mr+1
set Nr[Mr]='ITx1'
set Mr=Mr+1
set Nr[Mr]='ITx2'
set Mr=Mr+1
set Nr[Mr]='LTe1'
set Mr=Mr+1
set Nr[Mr]='LTe2'
set Mr=Mr+1
call DestroyTrigger(GetTriggeringTrigger())
endfunction
function o1n takes nothing returns integer
local integer o2n=GetRandomInt(0,1)
if o2n==0 then
return-1
else
return 1
endif
endfunction
function o3n takes nothing returns nothing
local location o4n=GetSpellTargetLoc()
local destructable o5n=null
local integer o6n=GetPlayerId(GetTriggerPlayer())
local integer o7n=0
local integer o8n=0
if et[o6n]then
set o8n=GetRandomInt(2,$C)
else
set o8n=bs[o6n]
endif
loop
exitwhen o7n==o8n
if mw[o6n]then
set vw[o6n]=GetRandomReal(.8,1.2)
endif
if is[o6n]then
set Ss[o6n]=GetRandomReal(.0,360.)
endif
if dt[o7n]then
set nt[o7n]=GetRandomInt(0,ft[o7n])
endif
set o5n=CreateDestructableZ(j[o6n],GetLocationX(o4n)+o1n()*GetRandomReal(.0,150.),GetLocationY(o4n)+o1n()*GetRandomReal(.0,150.),Gt[o6n]+GetLocationZ(o4n),Ss[o6n],vw[o6n],nt[o6n])
call FlushChildHashtable(nr,GetHandleId(o5n))
if qt[o6n]==false then
call SetDestructableOccluderHeight(o5n,at[o6n])
endif
if Rt[o6n]then
call SetDestructableInvulnerable(o5n,true)
endif
set o7n=o7n+1
endloop
set o8n=0
set o7n=0
set o6n=0
set o5n=null
call RemoveLocation(o4n)
set o4n=null
set o4n=null
set o5n=null
endfunction
function o9n takes nothing returns boolean
return IsUnitSelected(GetFilterUnit(),GetTriggerPlayer())
endfunction
function rvn takes nothing returns boolean
return(GetSpellAbilityId()=='A080')
endfunction
function ren takes nothing returns nothing
call SetBlightRadiusLocBJ(false,GetEnumPlayer(),G,380.)
endfunction
function rxn takes nothing returns boolean
return(GetEventPlayerChatString()=="@frostblast")
endfunction
function ron takes nothing returns boolean
return(GetEventPlayerChatString()=="'frostblast")
endfunction
function rrn takes nothing returns nothing
set g[GetConvertedPlayerId(GetTriggerPlayer())]=GetUnitsOfPlayerMatching(GetTriggerPlayer(),Condition(rhv))
if ron()then
call ForGroupBJ(g[GetConvertedPlayerId(GetTriggerPlayer())],rHv)
elseif rxn()then
call ForGroupBJ(g[GetConvertedPlayerId(GetTriggerPlayer())],rjv)
endif
call DestroyGroup(g[GetPlayerId(GetTriggerPlayer())+1])
endfunction
function rin takes nothing returns boolean
set yy=500
set py=500
set ey=0
set qy=0
set ay[0]="A"
set ay[1]="B"
set ay[2]="C"
set ay[3]="D"
set ay[4]="E"
set ay[5]="F"
set ay[6]="G"
set ay[7]="H"
set ay[8]="I"
set ay[9]="J"
set ay[$A]="K"
set ay[$B]="L"
set ay[$C]="M"
set ay[$D]="N"
set ay[$E]="O"
set ay[$F]="P"
set ay[16]="Q"
set ay[17]="R"
set ay[18]="S"
set ay[19]="T"
set ay[20]="U"
set ay[21]="V"
set ay[22]="W"
set ay[23]="X"
set ay[24]="Y"
set ay[25]="Z"
set ay[26]="a"
set ay[27]="b"
set ay[28]="c"
set ay[29]="d"
set ay[30]="e"
set ay[31]="f"
set ay[32]="g"
set ay[33]="h"
set ay[34]="i"
set ay[35]="j"
set ay[36]="k"
set ay[37]="l"
set ay[38]="m"
set ay[39]="n"
set ay[40]="o"
set ay[41]="p"
set ay[42]="q"
set ay[43]="r"
set ay[44]="s"
set ay[45]="t"
set ay[46]="u"
set ay[47]="v"
set ay[48]="w"
set ay[49]="x"
set ay[50]="y"
set ay[51]="z"
set ay[52]="0"
set ay[53]="1"
set ay[54]="2"
set ay[55]="3"
set ay[56]="4"
set ay[57]="5"
set ay[58]="6"
set ay[59]="7"
set ay[60]="8"
set ay[61]="9"
set ay[62]="+"
set ay[63]="/"
set ny[0]=-1
set ny[1]=-1
set ny[2]=-1
set ny[3]=-1
set ny[4]=-1
set ny[5]=-1
set ny[6]=-1
set ny[7]=-1
set ny[8]=-1
set ny[9]=-1
set ny[$A]=-1
set ny[$B]=-1
set ny[$C]=-1
set ny[$D]=-1
set ny[$E]=-1
set ny[$F]=-1
set ny[16]=-1
set ny[17]=-1
set ny[18]=-1
set ny[19]=-1
set ny[20]=-1
set ny[21]=-1
set ny[22]=-1
set ny[23]=-1
set ny[24]=-1
set ny[25]=-1
set ny[26]=-1
set ny[27]=-1
set ny[28]=-1
set ny[29]=-1
set ny[30]=-1
set ny[31]=-1
set ny[32]=-1
set ny[33]=-1
set ny[34]=-1
set ny[35]=-1
set ny[36]=-1
set ny[37]=-1
set ny[38]=-1
set ny[39]=-1
set ny[40]=-1
set ny[41]=-1
set ny[42]=-1
set ny[43]=62
set ny[44]=-1
set ny[45]=-1
set ny[46]=-1
set ny[47]=63
set ny[48]=52
set ny[49]=53
set ny[50]=54
set ny[51]=55
set ny[52]=56
set ny[53]=57
set ny[54]=58
set ny[55]=59
set ny[56]=60
set ny[57]=61
set ny[58]=-1
set ny[59]=-1
set ny[60]=-1
set ny[61]=-1
set ny[62]=-1
set ny[63]=-1
set ny[64]=-1
set ny[65]=0
set ny[66]=1
set ny[67]=2
set ny[68]=3
set ny[69]=4
set ny[70]=5
set ny[71]=6
set ny[72]=7
set ny[73]=8
set ny[74]=9
set ny[75]=$A
set ny[76]=$B
set ny[77]=$C
set ny[78]=$D
set ny[79]=$E
set ny[80]=$F
set ny[81]=16
set ny[82]=17
set ny[83]=18
set ny[84]=19
set ny[85]=20
set ny[86]=21
set ny[87]=22
set ny[88]=23
set ny[89]=24
set ny[90]=25
set ny[91]=-1
set ny[92]=-1
set ny[93]=-1
set ny[94]=-1
set ny[95]=-1
set ny[96]=-1
set ny[97]=26
set ny[98]=27
set ny[99]=28
set ny['d']=29
set ny['e']=30
set ny['f']=31
set ny['g']=32
set ny['h']=33
set ny['i']=34
set ny['j']=35
set ny['k']=36
set ny['l']=37
set ny['m']=38
set ny['n']=39
set ny['o']=40
set ny['p']=41
set ny['q']=42
set ny['r']=43
set ny['s']=44
set ny['t']=45
set ny['u']=46
set ny['v']=47
set ny['w']=48
set ny['x']=49
set ny['y']=50
set ny['z']=51
set ny['{']=-1
set ny['|']=-1
set ny['}']=-1
set ny[$7E]=-1
set ny[$7F]=-1
set ny[$80]=-1
set ny[$81]=-1
set ny[$82]=-1
set ny[$83]=-1
set ny[$84]=-1
set ny[$85]=-1
set ny[$86]=-1
set ny[$87]=-1
set ny[$88]=-1
set ny[$89]=-1
set ny[$8A]=-1
set ny[$8B]=-1
set ny[$8C]=-1
set ny[$8D]=-1
set ny[$8E]=-1
set ny[$8F]=-1
set ny[$90]=-1
set ny[$91]=-1
set ny[$92]=-1
set ny[$93]=-1
set ny[$94]=-1
set ny[$95]=-1
set ny[$96]=-1
set ny[$97]=-1
set ny[$98]=-1
set ny[$99]=-1
set ny[$9A]=-1
set ny[$9B]=-1
set ny[$9C]=-1
set ny[$9D]=-1
set ny[$9E]=-1
set ny[$9F]=-1
set ny[$A0]=-1
set ny[$A1]=-1
set ny[$A2]=-1
set ny[$A3]=-1
set ny[$A4]=-1
set ny[$A5]=-1
set ny[$A6]=-1
set ny[$A7]=-1
set ny[$A8]=-1
set ny[$A9]=-1
set ny[$AA]=-1
set ny[$AB]=-1
set ny[$AC]=-1
set ny[$AD]=-1
set ny[$AE]=-1
set ny[$AF]=-1
set ny[$B0]=-1
set ny[$B1]=-1
set ny[$B2]=-1
set ny[$B3]=-1
set ny[$B4]=-1
set ny[$B5]=-1
set ny[$B6]=-1
set ny[$B7]=-1
set ny[$B8]=-1
set ny[$B9]=-1
set ny[$BA]=-1
set ny[$BB]=-1
set ny[$BC]=-1
set ny[$BD]=-1
set ny[$BE]=-1
set ny[$BF]=-1
set ny[$C0]=-1
set ny[$C1]=-1
set ny[$C2]=-1
set ny[$C3]=-1
set ny[$C4]=-1
set ny[$C5]=-1
set ny[$C6]=-1
set ny[$C7]=-1
set ny[$C8]=-1
set ny[$C9]=-1
set ny[$CA]=-1
set ny[$CB]=-1
set ny[$CC]=-1
set ny[$CD]=-1
set ny[$CE]=-1
set ny[$CF]=-1
set ny[$D0]=-1
set ny[$D1]=-1
set ny[$D2]=-1
set ny[$D3]=-1
set ny[$D4]=-1
set ny[$D5]=-1
set ny[$D6]=-1
set ny[$D7]=-1
set ny[$D8]=-1
set ny[$D9]=-1
set ny[$DA]=-1
set ny[$DB]=-1
set ny[$DC]=-1
set ny[$DD]=-1
set ny[$DE]=-1
set ny[$DF]=-1
set ny[$E0]=-1
set ny[$E1]=-1
set ny[$E2]=-1
set ny[$E3]=-1
set ny[$E4]=-1
set ny[$E5]=-1
set ny[$E6]=-1
set ny[$E7]=-1
set ny[$E8]=-1
set ny[$E9]=-1
set ny[$EA]=-1
set ny[$EB]=-1
set ny[$EC]=-1
set ny[$ED]=-1
set ny[$EE]=-1
set ny[$EF]=-1
set ny[$F0]=-1
set ny[$F1]=-1
set ny[$F2]=-1
set ny[$F3]=-1
set ny[$F4]=-1
set ny[$F5]=-1
set ny[$F6]=-1
set ny[$F7]=-1
set ny[$F8]=-1
set ny[$F9]=-1
set ny[$FA]=-1
set ny[$FB]=-1
set ny[$FC]=-1
set ny[$FD]=-1
set ny[$FE]=-1
return true
endfunction
function ran takes string rnn returns integer
local integer rVn
set ZM[EM]=rnn
set EM=EM+1
if CY==0 then
if VY<$8000 then
set VY=VY+1
set rVn=VY
set BY[rVn]=$853
else
call Cdv("Out of memory: Could not create ForForceCallback_execute_GamecacheKeys.","when calling error in GamecacheKeys, line 40")
set rVn=0
endif
else
set CY=CY-1
set rVn=XY[CY]
set BY[rVn]=$853
endif
set EM=EM-1
return rVn
endfunction
function rEn takes string rXn returns boolean
local integer rOn
local integer rRn
local integer rIn
set ZM[EM]=rXn
set EM=EM+1
set le=" !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`{|}~"
set be=69
set ye='d'
set ee=0
set rOn=1
set rRn=Oq-1
loop
exitwhen rOn>rRn
set rIn=ran("when calling alloc_ForForceCallback_execute_GamecacheKeys in GamecacheKeys, line 40")
set xZ[rIn]=rOn
call Fte(rIn,"when calling execute in GamecacheKeys, line 40")
set rOn=rOn+1
endloop
set EM=EM-1
return true
endfunction
function rAn takes nothing returns boolean
set EM=0
return rEn("GamecacheKeys, line 1")
endfunction
function rNn takes string rbn returns boolean
return Icx(hf,rbn)
endfunction
function rBn takes string rcn returns nothing
local integer rCn=GZv(rcn)
local string rdn=""
local integer rDn=0
local boolean rfn=false
local integer rFn=0
local integer rgn=rCn-1
loop
exitwhen rFn>rgn
if rNn(duv(rcn,rFn))then
set rdn=rdn+duv(rcn,rFn)
elseif rfn then
set rdn=rdn+duv(rcn,rFn)
set rfn=false
else
if(rDn+2==df and rFn+1==rCn-1)or rDn+2<df then
set rdn=rdn+duv(rcn,rFn)
else
call Preload(rdn+"^")
set rdn=duv(rcn,rFn)
set rDn=0
endif
set rfn=true
endif
set rDn=rDn+1
if rDn+1==df and rFn+2<rCn then
call Preload(rdn+"^")
set rdn=""
set rDn=0
endif
set rFn=rFn+1
endloop
if rDn!=0 then
call Preload(rdn)
endif
endfunction
function rGn takes string rhn,boolean rHn returns string
return SMv(yRe(rHn))+rhn
endfunction
function rjn takes destructable rJn returns string
local string rkn=rGn("",DKv(rJn))
set U1=rkn
return U1
endfunction
function rKn takes integer rln returns integer
local integer rLn
if rln<0 then
set rLn=-rln
else
set rLn=rln
endif
return rLn
endfunction
function rmn takes integer rMn returns string
local string rpn
local string rPn
local integer rqn
local integer rQn
if rMn==0 then
return duv(gn,0)
endif
if rMn<0 then
set rPn="-"
else
set rPn=""
endif
set rpn=rPn
set rqn=rKn(rMn)
loop
exitwhen not(rqn!=0)
set rQn=rqn/hn
set rpn=rpn+duv(gn,rqn-rQn*hn)
set rqn=rQn
endloop
return rpn
endfunction
function rsn takes string rSn returns integer
local integer rtn=1
local integer rTn=0
local integer run=GZv(rSn)-1
local string rUn
loop
exitwhen run<0
set rUn=duv(rSn,run)
if rUn!=" " then
if rUn=="1" then
set rTn=rTn+rtn
endif
set rtn=rtn*2
endif
set run=run-1
endloop
return rTn
endfunction
function rwn takes string rWn returns integer
return rsn(rWn)
endfunction
function ryn takes real rYn returns string
local real rzn=yWe(rYn)
local integer rZn=c6v(rzn)
local integer r_n=c6v((rzn-rZn)*1000.)
local string r0n
local string r1n
local string r2n
if rYn<.0 then
set r0n="-"
else
set r0n=""
endif
set r2n=r0n+rmn(rZn)
if r_n!=0 then
set r1n="."+rmn(r_n)
else
set r1n=""
endif
return r2n+r1n
endfunction
function r3n takes destructable r4n,real r5n,real r6n returns string
return rmn(rwn(rjn(r4n)))+Fn+d0v(FBv(r4n))+Fn+ryn(DCv(r4n)-r5n)+Fn+ryn(DBv(r4n)-r6n)+Fn+ryn(DPv(r4n))+Fn+ryn(DHv(r4n))+Fn+ryn(DJv(r4n))+Fn+rmn(Drv(r4n))+Fn+ryn(dtv(r4n))+Fn+ryn(FNv(r4n))+Fn+ryn(DLv(r4n))
endfunction
function r7n takes nothing returns nothing
call rBn(r3n(GetEnumDestructable(),Ff,kf))
endfunction
function r8n takes nothing returns nothing
local unit r9n
local real ivn
local real ien
if GetEventDamage()==.0 then
set r9n=null
return
endif
set pl=GetEventDamage()/2.
call ForGroup(LoadGroupHandle(i,bl,GetHandleId(GetEventDamageSource())),Mz)
if GetUnitAbilityLevel(GetTriggerUnit(),rl)==0 then
set r9n=null
return
endif
set r9n=GetTriggerUnit()
set pl=GetEventDamage()
set ivn=LoadReal(i,Ol,GetHandleId(r9n))
if pl<ivn then
set ien=pl
else
set ien=ivn
endif
call BlzSetEventDamage(pl-ien)
call SaveReal(i,Ol,GetHandleId(r9n),(ivn-ien)*1.)
if ivn==ien then
call UnitRemoveAbility(r9n,rl)
endif
set r9n=null
set r9n=null
endfunction
function ixn takes integer ion,integer irn returns nothing
call RemoveSavedHandle(LR,ion,irn)
endfunction
function iin takes integer ian,integer inn,string iVn returns nothing
set ZM[EM]=iVn
set EM=EM+1
if jv[ian]==0 then
if ian==0 then
call Cdv("Nullpointer exception when calling Table.removeHandle","when calling error in TableJurst, line 47")
else
call Cdv("Called Table.removeHandle on invalid object.","when calling error in TableJurst, line 47")
endif
endif
call ixn(ian,inn)
set EM=EM-1
endfunction
function iEn takes integer iXn,string iOn returns nothing
set ZM[EM]=iOn
set EM=EM+1
if eG[iXn]==0 then
call Cdv("Double free: object of type Buff","when calling error in BuffsJurst, line 3")
else
set bG[yG]=iXn
set yG=yG+1
set eG[iXn]=0
endif
set EM=EM-1
endfunction
function iRn takes integer res returns nothing
endfunction
function iIn takes integer iAn,string iNn returns nothing
set ZM[EM]=iNn
set EM=EM+1
call iRn(iAn)
call iEn(iAn,"when calling dealloc_Buff in BuffsJurst, line 3")
set EM=EM-1
endfunction
function ibn takes integer iBn,string icn returns nothing
set ZM[EM]=icn
set EM=EM+1
if eG[iBn]==0 then
if iBn==0 then
call Cdv("Nullpointer exception when calling Buff.Buff","when calling error in BuffsJurst, line 3")
else
call Cdv("Called Buff.Buff on invalid object.","when calling error in BuffsJurst, line 3")
endif
endif
call iIn(iBn,"when calling destroyBuff in BuffsJurst, line 3")
set EM=EM-1
endfunction
function iCn takes integer idn,string iDn returns nothing
set ZM[EM]=iDn
set EM=EM+1
call ibn(idn,"when calling dispatch_Buff_destroyBuff in BuffsJurst, line 16")
set EM=EM-1
endfunction
function ifn takes integer iFn,string ign returns nothing
set ZM[EM]=ign
set EM=EM+1
if eG[iFn]==0 then
if iFn==0 then
call Cdv("Nullpointer exception when calling Buff.destroy","when calling error in BuffsJurst, line 15")
else
call Cdv("Called Buff.destroy on invalid object.","when calling error in BuffsJurst, line 15")
endif
endif
call iCn(iFn,"when calling destroy in BuffsJurst, line 15")
set EM=EM-1
endfunction
function iGn takes integer ihn,integer iHn,timer ijn returns nothing
call SaveTimerHandle(LR,ihn,iHn,ijn)
endfunction
function iJn takes integer ikn,integer iKn,timer iln,string iLn returns nothing
set ZM[EM]=iLn
set EM=EM+1
if jv[ikn]==0 then
if ikn==0 then
call Cdv("Nullpointer exception when calling Table.saveTimer","when calling error in TableJurst, line 175")
else
call Cdv("Called Table.saveTimer on invalid object.","when calling error in TableJurst, line 175")
endif
endif
call iGn(ikn,iKn,iln)
set EM=EM-1
endfunction
function imn takes unit iMn returns nothing
call UnitAddAbility(iMn,Jp)
call UnitMakeAbilityPermanent(iMn,true,Jp)
endfunction
function ipn takes integer Zks,unit iPn returns nothing
call imn(iPn)
endfunction
function iqn takes unit iQn returns nothing
if not IsUnitInGroup(iQn,Ad)then
call GroupAddUnit(Ad,iQn)
call TriggerRegisterUnitEvent(Pd,iQn,EVENT_UNIT_DAMAGED)
endif
endfunction
function isn takes integer Bxi,unit iSn returns nothing
call iqn(iSn)
endfunction
function itn takes unit iTn returns nothing
call UnitRemoveAbility(iTn,Jp)
endfunction
function iun takes integer Xks,unit iUn returns nothing
call itn(iUn)
endfunction
function iwn takes integer iWn,integer iyn,integer iYn returns nothing
call SaveInteger(LR,iWn,iyn,iYn)
endfunction
function izn takes integer iZn,integer i_n,integer i0n,string i1n returns nothing
set ZM[EM]=i1n
set EM=EM+1
if jv[iZn]==0 then
if iZn==0 then
call Cdv("Nullpointer exception when calling Table.saveInteger","when calling error in TableJurst, line 55")
else
call Cdv("Called Table.saveInteger on invalid object.","when calling error in TableJurst, line 55")
endif
endif
call iwn(iZn,i_n,i0n)
set EM=EM-1
endfunction
function i2n takes integer i3n,integer i4n,real i5n returns nothing
call SaveReal(LR,i3n,i4n,i5n)
endfunction
function i6n takes integer i7n,integer i8n,real i9n,string avn returns nothing
set ZM[EM]=avn
set EM=EM+1
if jv[i7n]==0 then
if i7n==0 then
call Cdv("Nullpointer exception when calling Table.saveReal","when calling error in TableJurst, line 63")
else
call Cdv("Called Table.saveReal on invalid object.","when calling error in TableJurst, line 63")
endif
endif
call i2n(i7n,i8n,i9n)
set EM=EM-1
endfunction
function aen takes unit axn,string aon returns nothing
local integer arn
set ZM[EM]=aon
set EM=EM+1
set arn=GetHandleId(axn)
call i6n(pT,arn,75.+GetUnitAbilityLevel(axn,ST)*$FA,"when calling saveReal in TouchOfKarma, line 53")
call izn(eT,arn,GetUnitAbilityLevel(axn,ST),"when calling saveInteger in TouchOfKarma, line 54")
if not IsUnitInGroup(axn,fT)then
call GroupAddUnit(fT,axn)
call TriggerRegisterUnitEvent(dT,axn,EVENT_UNIT_DAMAGED)
endif
set EM=EM-1
endfunction
function ain takes integer t7S,unit aan,string ann returns nothing
set ZM[EM]=ann
set EM=EM+1
call aen(aan,"when calling OnBuffApplication in TouchOfKarma, line 82")
set EM=EM-1
endfunction
function aVn takes integer aEn,integer aXn returns real
return LoadReal(LR,aEn,aXn)
endfunction
function aOn takes integer aRn,integer aIn,string aAn returns real
local real aNn
set ZM[EM]=aAn
set EM=EM+1
if jv[aRn]==0 then
if aRn==0 then
call Cdv("Nullpointer exception when calling Table.loadReal","when calling error in TableJurst, line 59")
else
call Cdv("Called Table.loadReal on invalid object.","when calling error in TableJurst, line 59")
endif
endif
set aNn=aVn(aRn,aIn)
set EM=EM-1
return aNn
endfunction
function abn takes integer aBn,integer acn returns unit
return LoadUnitHandle(LR,aBn,acn)
endfunction
function aCn takes integer adn,integer aDn,string afn returns unit
local unit aFn
set ZM[EM]=afn
set EM=EM+1
if jv[adn]==0 then
if adn==0 then
call Cdv("Nullpointer exception when calling Table.loadUnit","when calling error in TableJurst, line 99")
else
call Cdv("Called Table.loadUnit on invalid object.","when calling error in TableJurst, line 99")
endif
endif
set aFn=abn(adn,aDn)
set EM=EM-1
set Iqv=aFn
set aFn=null
return Iqv
endfunction
function agn takes unit aGn,string ahn returns nothing
local integer aHn
local real ajn
set ZM[EM]=ahn
set EM=EM+1
set aHn=GetHandleId(aGn)
set ajn=aOn(nT,aHn,"when calling loadReal in TouchOfKarma, line 75")
call UnitDamageTarget(aCn(aT,aHn,"when calling loadUnit in TouchOfKarma, line 76"),aGn,ajn/6.,true,true,ATTACK_TYPE_NORMAL,DAMAGE_TYPE_MAGIC,WEAPON_TYPE_WHOKNOWS)
call i6n(nT,aHn,ajn-ajn/6.,"when calling saveReal in TouchOfKarma, line 77")
set EM=EM-1
endfunction
function aJn takes integer q7S,unit akn,string aKn returns nothing
set ZM[EM]=aKn
set EM=EM+1
call agn(akn,"when calling OnDotDamage in TouchOfKarma, line 88")
set EM=EM-1
endfunction
function aln takes integer aLn,unit amn,string aMn returns nothing
set ZM[EM]=aMn
set EM=EM+1
if YG[aLn]==0 then
if aLn==0 then
call Cdv("Nullpointer exception when calling UnitHandler.evaluate","when calling error in BuffsJurst, line 24")
else
call Cdv("Called UnitHandler.evaluate on invalid object.","when calling error in BuffsJurst, line 24")
endif
endif
if YG[aLn]<=5106 then
if YG[aLn]<=5105 then
if YG[aLn]<=5104 then
call ipn(aLn,amn)
else
call ain(aLn,amn,"when calling evaluate in BuffsJurst, line 24")
endif
else
call isn(aLn,amn)
endif
elseif YG[aLn]<=5107 then
call iun(aLn,amn)
else
call aJn(aLn,amn,"when calling evaluate in BuffsJurst, line 24")
endif
set EM=EM-1
endfunction
function apn takes timer aPn returns nothing
call PauseTimer(aPn)
endfunction
function aqn takes timer aQn,string asn returns integer
local integer aSn
set ZM[EM]=asn
set EM=EM+1
set aSn=fwv(tT,EVx(aQn),"when calling loadInt in TimerUtils, line 22")
set EM=EM-1
return aSn
endfunction
function atn takes timer aTn,string aun returns nothing
set ZM[EM]=aun
set EM=EM+1
if aTn==null then
call Cdv("Trying to release a null timer","when calling error in TimerUtils, line 38")
set EM=EM-1
return
endif
if aqn(aTn,"when calling getData in TimerUtils, line 40")==iT then
call Cdv("ReleaseTimer: Double free!","when calling error in TimerUtils, line 41")
set EM=EM-1
return
endif
call EXx(aTn,iT,"when calling setData in TimerUtils, line 43")
call apn(aTn)
set rT[sT]=aTn
set sT=sT+1
set EM=EM-1
endfunction
function aUn takes string awn returns integer
local integer aWn
set ZM[EM]=awn
set EM=EM+1
if yG==0 then
if pG<$8000 then
set pG=pG+1
set aWn=pG
set eG[aWn]=$43B
else
call Cdv("Out of memory: Could not create Buff.","when calling error in BuffsJurst, line 3")
set aWn=0
endif
else
set yG=yG-1
set aWn=bG[yG]
set eG[aWn]=$43B
endif
set EM=EM-1
return aWn
endfunction
function ayn takes integer Nps returns nothing
endfunction
function aYn takes integer azn returns nothing
call ayn(azn)
endfunction
function aZn takes string a_n returns integer
local integer a0n
set ZM[EM]=a_n
set EM=EM+1
set a0n=aUn("when calling alloc_Buff in BuffsJurst, line 3")
call aYn(a0n)
set EM=EM-1
return a0n
endfunction
function a1n takes integer a2n,unit a3n,string a4n returns integer
local integer a5n
set ZM[EM]=a4n
set EM=EM+1
set a5n=aZn("when calling new_Buff in BuffsJurst, line 9")
set KQ[a5n]=a2n
set LQ[a5n]=a3n
set EM=EM-1
return a5n
endfunction
function a6n takes integer a7n,integer a8n returns timer
return LoadTimerHandle(LR,a7n,a8n)
endfunction
function a9n takes integer nvn,integer nen,string nxn returns timer
local timer non
set ZM[EM]=nxn
set EM=EM+1
if jv[nvn]==0 then
if nvn==0 then
call Cdv("Nullpointer exception when calling Table.loadTimer","when calling error in TableJurst, line 171")
else
call Cdv("Called Table.loadTimer on invalid object.","when calling error in TableJurst, line 171")
endif
endif
set non=a6n(nvn,nen)
set EM=EM-1
set IQv=non
set non=null
return IQv
endfunction
function nrn takes integer nin,unit nan,string nnn returns timer
local integer nVn
local timer nEn
local integer nXn
set ZM[EM]=nnn
set EM=EM+1
set nVn=GetHandleId(nan)
set nEn=a9n(XQ[nin],nVn,"when calling loadTimer in BuffsJurst, line 108")
set nXn=a1n(nin,nan,"when calling create in BuffsJurst, line 109")
if nEn!=null then
call ifn(aqn(nEn,"when calling getData in BuffsJurst, line 111"),"when calling destroy in BuffsJurst, line 111")
call atn(nEn,"when calling release in BuffsJurst, line 112")
call iin(XQ[nin],nVn,"when calling removeHandle in BuffsJurst, line 113")
if MQ[nin]!=0 then
call aln(MQ[nin],nan,"when calling evaluate in BuffsJurst, line 115")
endif
endif
if CQ[nin]!=0 then
call aln(CQ[nin],nan,"when calling evaluate in BuffsJurst, line 119")
endif
if nEn==null then
if VQ[nin]!=0 then
call aln(VQ[nin],nan,"when calling evaluate in BuffsJurst, line 123")
endif
elseif BQ[nin]!=0 then
call aln(BQ[nin],nan,"when calling evaluate in BuffsJurst, line 126")
endif
set nEn=EMx("when calling getTimer in BuffsJurst, line 128")
call EXx(nEn,nXn,"when calling setData in BuffsJurst, line 129")
call iJn(XQ[nin],nVn,nEn,"when calling saveTimer in BuffsJurst, line 130")
set EM=EM-1
set R5v=nEn
set nEn=null
return R5v
endfunction
function nOn takes integer nRn,unit nIn,string nAn returns timer
local timer nNn
set ZM[EM]=nAn
set EM=EM+1
if dG[nRn]==0 then
if nRn==0 then
call Cdv("Nullpointer exception when calling BuffType.prepare","when calling error in BuffsJurst, line 106")
else
call Cdv("Called BuffType.prepare on invalid object.","when calling error in BuffsJurst, line 106")
endif
endif
set nNn=nrn(nRn,nIn,"when calling prepare in BuffsJurst, line 106")
set EM=EM-1
set IOv=nNn
set nNn=null
return IOv
endfunction
function nbn takes integer nBn,unit ncn,real nCn,string ndn returns nothing
local timer nDn
set ZM[EM]=ndn
set EM=EM+1
set nDn=nOn(nBn,ncn,"when calling prepare in BuffsJurst, line 135")
call TimerStart(nDn,nCn,false,RVv)
set EM=EM-1
set nDn=null
endfunction
function nfn takes integer nFn,unit ngn,real nGn,string nhn returns nothing
set ZM[EM]=nhn
set EM=EM+1
if dG[nFn]==0 then
if nFn==0 then
call Cdv("Nullpointer exception when calling BuffType.apply","when calling error in BuffsJurst, line 134")
else
call Cdv("Called BuffType.apply on invalid object.","when calling error in BuffsJurst, line 134")
endif
endif
call nbn(nFn,ngn,nGn,"when calling apply in BuffsJurst, line 134")
set EM=EM-1
endfunction
function nHn takes player njn,integer nJn,integer nkn,string nKn,widget nln,real nLn,real nmn,real nMn returns nothing
local unit npn=CreateUnit(njn,Y,nLn,nmn,Rad2Deg(Atan2(GetWidgetY(nln)-nmn,GetWidgetX(nln)-nLn)))
call UnitAddAbility(npn,nJn)
call clv(npn,nJn,nkn)
call IssueTargetOrder(npn,nKn,nln)
call Gav(GAv(npn),nMn)
set npn=null
endfunction
function nPn takes player nqn,integer nQn,integer nsn,string nSn,widget ntn,real nTn,real nun returns nothing
call nHn(nqn,nQn,nsn,nSn,ntn,nTn,nun,1.)
endfunction
function nUn takes string nwn returns nothing
local unit nWn
set ZM[EM]=nwn
set EM=EM+1
if GetSpellAbilityId()==Hp then
set nWn=GetSpellAbilityUnit()
call nfn(Lp,nWn,2.,"when calling apply in EmergencyEvade, line 25")
call nPn(GetOwningPlayer(nWn),Kp,GetUnitAbilityLevel(nWn,Hp),"attackonce",nWn,GetUnitX(nWn),GetUnitY(nWn))
endif
set EM=EM-1
set nWn=null
endfunction
function nyn takes nothing returns nothing
set EM=0
call nUn("EmergencyEvade, line 47")
endfunction
function nYn takes nothing returns boolean
return(GetSpellAbilityId()=='A09H')
endfunction
function nzn takes nothing returns boolean
return(GetSpellAbilityId()=='Adcn')or(GetSpellAbilityId()=='ACde')
endfunction
function nZn takes nothing returns boolean
return(nzn())
endfunction
function n_n takes nothing returns boolean
return(GetSpellAbilityId()=='Adsm')or(GetSpellAbilityId()=='Adis')or(GetSpellAbilityId()=='Adch')or(GetSpellAbilityId()=='Advm')
endfunction
function n0n takes nothing returns boolean
return(n_n())
endfunction
function n1n takes nothing returns nothing
if n0n()then
call ForGroupBJ(GetUnitsInRangeOfLocAll(200.,GetSpellTargetLoc()),ihv)
elseif nZn()then
call ForGroupBJ(GetUnitsInRangeOfLocAll(250.,GetSpellTargetLoc()),iHv)
endif
endfunction
function n2n takes nothing returns nothing
set G=GetUnitLoc(GetEnumUnit())
call EnumDestructablesInCircleBJ(256.,G,xqv)
call RemoveLocation(G)
endfunction
function n3n takes nothing returns nothing
local unit n4n
local integer n5n
if GetSpellAbilityId()!='A0MQ' then
set n4n=null
return
endif
set n4n=GetSpellAbilityUnit()
set fl=n4n
set Rl=GetOwningPlayer(n4n)
set n5n=GetUnitAbilityLevel(n4n,'A0MQ')
if n5n==3 then
set Tl=220.
elseif n5n==2 then
set Tl=160.
else
set Tl=90.
endif
call GroupEnumUnitsInRange(w,GetUnitX(n4n)*1.,GetUnitY(n4n)*1.,200.*1.,Filter(Yz))
call GBv('A0MR',n5n,"lightningshield",n4n)
set n4n=null
set n4n=null
endfunction
function n6n takes nothing returns nothing
call GetConvertedPlayerId(GetTriggerPlayer())
call GetUnitLoc(GetEnumUnit())
endfunction
function n7n takes nothing returns nothing
local string n8n=GetEventPlayerChatString()
local integer n9n=S2I(SubString(n8n,5,StringLength(n8n)))
if n9n>999 then
set n9n=999
endif
call SetItemCharges(UnitItemInSlot(GetEnumUnit(),S2I(SubString(n8n,3,4))-1),n9n)
set n9n=0
set n8n=null
endfunction
function Vvn takes nothing returns boolean
return(GetSpellAbilityId()=='A0EJ')
endfunction
function Ven takes nothing returns boolean
if GetSpellAbilityId()=='A0HY' then
return true
else
return false
endif
endfunction
function Vxn takes nothing returns boolean
return GetFilterPlayer()==GetTriggerPlayer()
endfunction
function Von takes nothing returns boolean
return(GetEventPlayerChatString()=="deleteweather")
endfunction
function Vrn takes nothing returns boolean
return(F[GetConvertedPlayerId(GetTriggerPlayer())])and(GetEventPlayerChatString()=="weather on")
endfunction
function Vin takes nothing returns boolean
return(GetTriggerPlayer()==Player(9))
endfunction
function Van takes nothing returns boolean
return(GetTriggerPlayer()==Player(1))
endfunction
function Vnn takes nothing returns boolean
return(F[GetConvertedPlayerId(GetTriggerPlayer())])and(GetEventPlayerChatString()=="weather off")
endfunction
function VVn takes nothing returns boolean
return(qw[GetConvertedPlayerId(GetTriggerPlayer())]<1)
endfunction
function VEn takes nothing returns boolean
return(F[GetConvertedPlayerId(GetTriggerPlayer())])and(GetEventPlayerChatString()=="deleteweather all")
endfunction
function VXn takes nothing returns boolean
return(qw[GetConvertedPlayerId(GetTriggerPlayer())]>=9)
endfunction
function VOn takes nothing returns boolean
return(GetTriggerPlayer()==Player(7))
endfunction
function VRn takes nothing returns boolean
return(GetTriggerPlayer()==Player($B))
endfunction
function VIn takes nothing returns boolean
return(GetTriggerPlayer()==Player(8))
endfunction
function VAn takes nothing returns boolean
return(GetTriggerPlayer()==Player($A))
endfunction
function VNn takes nothing returns boolean
return(GetTriggerPlayer()==Player(0))
endfunction
function Vbn takes nothing returns boolean
return(GetTriggerPlayer()==Player(3))
endfunction
function VBn takes nothing returns boolean
return(GetTriggerPlayer()==Player(2))
endfunction
function Vcn takes nothing returns boolean
return(GetTriggerPlayer()==Player(6))
endfunction
function VCn takes nothing returns boolean
return(GetTriggerPlayer()==Player(5))
endfunction
function Vdn takes nothing returns boolean
return(GetTriggerPlayer()==Player(4))
endfunction
function VDn takes nothing returns nothing
if Von()then
if VNn()then
call RemoveWeatherEffectBJ(sw[qw[GetConvertedPlayerId(GetTriggerPlayer())]])
set qw[GetConvertedPlayerId(GetTriggerPlayer())]=qw[GetConvertedPlayerId(GetTriggerPlayer())]-1
endif
if Van()then
call RemoveWeatherEffectBJ(tw[qw[GetConvertedPlayerId(GetTriggerPlayer())]])
set qw[GetConvertedPlayerId(GetTriggerPlayer())]=qw[GetConvertedPlayerId(GetTriggerPlayer())]-1
endif
if VBn()then
call RemoveWeatherEffectBJ(yw[qw[GetConvertedPlayerId(GetTriggerPlayer())]])
set qw[GetConvertedPlayerId(GetTriggerPlayer())]=qw[GetConvertedPlayerId(GetTriggerPlayer())]-1
endif
if Vbn()then
call RemoveWeatherEffectBJ(bw[qw[GetConvertedPlayerId(GetTriggerPlayer())]])
set qw[GetConvertedPlayerId(GetTriggerPlayer())]=qw[GetConvertedPlayerId(GetTriggerPlayer())]-1
endif
if Vdn()then
call RemoveWeatherEffectBJ(lw[qw[GetConvertedPlayerId(GetTriggerPlayer())]])
set qw[GetConvertedPlayerId(GetTriggerPlayer())]=qw[GetConvertedPlayerId(GetTriggerPlayer())]-1
endif
if VCn()then
call RemoveWeatherEffectBJ(Ow[qw[GetConvertedPlayerId(GetTriggerPlayer())]])
set qw[GetConvertedPlayerId(GetTriggerPlayer())]=qw[GetConvertedPlayerId(GetTriggerPlayer())]-1
endif
if Vcn()then
call RemoveWeatherEffectBJ(ow[qw[GetConvertedPlayerId(GetTriggerPlayer())]])
set qw[GetConvertedPlayerId(GetTriggerPlayer())]=qw[GetConvertedPlayerId(GetTriggerPlayer())]-1
endif
if VOn()then
call RemoveWeatherEffectBJ(cw[qw[GetConvertedPlayerId(GetTriggerPlayer())]])
set qw[GetConvertedPlayerId(GetTriggerPlayer())]=qw[GetConvertedPlayerId(GetTriggerPlayer())]-1
endif
if VIn()then
call RemoveWeatherEffectBJ(Sw[qw[GetConvertedPlayerId(GetTriggerPlayer())]])
set qw[GetConvertedPlayerId(GetTriggerPlayer())]=qw[GetConvertedPlayerId(GetTriggerPlayer())]-1
endif
if Vin()then
call RemoveWeatherEffectBJ(iw[qw[GetConvertedPlayerId(GetTriggerPlayer())]])
set qw[GetConvertedPlayerId(GetTriggerPlayer())]=qw[GetConvertedPlayerId(GetTriggerPlayer())]-1
endif
if VAn()then
call RemoveWeatherEffectBJ(ew[qw[GetConvertedPlayerId(GetTriggerPlayer())]])
set qw[GetConvertedPlayerId(GetTriggerPlayer())]=qw[GetConvertedPlayerId(GetTriggerPlayer())]-1
endif
if VRn()then
call RemoveWeatherEffectBJ(pw[qw[GetConvertedPlayerId(GetTriggerPlayer())]])
set qw[GetConvertedPlayerId(GetTriggerPlayer())]=qw[GetConvertedPlayerId(GetTriggerPlayer())]-1
endif
if VVn()then
set qw[GetConvertedPlayerId(GetTriggerPlayer())]=1
endif
if VXn()then
set qw[GetConvertedPlayerId(GetTriggerPlayer())]=8
endif
return
endif
if Vrn()then
set ww=true
return
endif
if Vnn()then
set ww=false
return
endif
if VEn()then
set bj_forLoopAIndex=1
set bj_forLoopAIndexEnd=9
loop
exitwhen bj_forLoopAIndex>bj_forLoopAIndexEnd
call RemoveWeatherEffectBJ(sw[GetForLoopIndexA()])
call RemoveWeatherEffectBJ(tw[GetForLoopIndexA()])
call RemoveWeatherEffectBJ(yw[GetForLoopIndexA()])
call RemoveWeatherEffectBJ(bw[GetForLoopIndexA()])
call RemoveWeatherEffectBJ(lw[GetForLoopIndexA()])
call RemoveWeatherEffectBJ(Ow[GetForLoopIndexA()])
call RemoveWeatherEffectBJ(ow[GetForLoopIndexA()])
call RemoveWeatherEffectBJ(cw[GetForLoopIndexA()])
call RemoveWeatherEffectBJ(Sw[GetForLoopIndexA()])
call RemoveWeatherEffectBJ(iw[GetForLoopIndexA()])
call RemoveWeatherEffectBJ(ew[GetForLoopIndexA()])
call RemoveWeatherEffectBJ(pw[GetForLoopIndexA()])
set bj_forLoopAIndex=bj_forLoopAIndex+1
endloop
endif
endfunction
function Vfn takes nothing returns nothing
call SetBlightRadiusLocBJ(false,GetEnumPlayer(),G,572.)
endfunction
function VFn takes nothing returns boolean
return true
endfunction
function Vgn takes string VGn returns integer
local integer Vhn
set ZM[EM]=VGn
set EM=EM+1
if gh==0 then
if hh<$8000 then
set hh=hh+1
set Vhn=hh
set Fh[Vhn]=$C85
else
call Cdv("Out of memory: Could not create Iterator.","when calling error in LinkedListModule, line 71")
set Vhn=0
endif
else
set gh=gh-1
set Vhn=Gh[gh]
set Fh[Vhn]=$C85
endif
set EM=EM-1
return Vhn
endfunction
function VHn takes integer Vjn returns nothing
set YU[Vjn]=Ge
endfunction
function VJn takes integer Vkn,boolean VKn returns nothing
call VHn(Vkn)
set GU[Vkn]=VKn
endfunction
function Vln takes boolean VLn,string Vmn returns integer
local integer VMn
set ZM[EM]=Vmn
set EM=EM+1
set VMn=Vgn("when calling alloc_Iterator in LinkedListModule, line 75")
call VJn(VMn,VLn)
set EM=EM-1
return VMn
endfunction
function Vpn takes integer xDs returns nothing
endfunction
function VPn takes integer Vqn,boolean QDs returns nothing
call Vpn(Vqn)
endfunction
function VQn takes string Vsn returns integer
local integer VSn
set ZM[EM]=Vsn
set EM=EM+1
if Th==0 then
if Yh<$8000 then
set Yh=Yh+1
set VSn=Yh
else
call Cdv("Out of memory: Could not create BackIterator.","when calling error in LinkedListModule, line 93")
set VSn=0
endif
else
set Th=Th-1
set VSn=Rh[Th]
endif
set EM=EM-1
return VSn
endfunction
function Vtn takes boolean VTn,string Vun returns integer
local integer VUn
set ZM[EM]=Vun
set EM=EM+1
set VUn=VQn("when calling alloc_BackIterator in LinkedListModule, line 97")
call VPn(VUn,VTn)
set EM=EM-1
return VUn
endfunction
function Vwn takes string VWn returns boolean
set ZM[EM]=VWn
set EM=EM+1
set Ge=0
set ge=0
set he=0
call Vln(false,"when calling new_Iterator in LinkedListModule, line 55")
call Vtn(false,"when calling new_BackIterator in LinkedListModule, line 65")
set Re=EMx("when calling getTimer in IOTaskExecutor, line 96")
set Te=0
set Ye=false
call qYx(Re,dy,Owv)
call apn(Re)
set EM=EM-1
return true
endfunction
function Vyn takes nothing returns boolean
set EM=0
return Vwn("IOTaskExecutor, line 1")
endfunction
function VYn takes nothing returns integer
return ue[re-1]
endfunction
function Vzn takes boolean VZn returns nothing
set we[re-1]=VZn
endfunction
function V_n takes integer V0n,string V1n returns integer
set ZM[EM]=V1n
set EM=EM+1
if(Ca and V0n<0)or V0n>$FF then
call Cdv(SMv(V0n)+" cannot be converted to utf-8 code unit. Valid values are between 0 and 255","when calling error in Utf8CodeUnit, line 49")
endif
set EM=EM-1
set a9=V0n
return a9
endfunction
function V2n takes integer V3n,string V4n returns nothing
local integer V5n
local integer V6n
local string V7n
set ZM[EM]=V4n
set EM=EM+1
set V5n=0
set V6n=OI[V3n]-1
loop
exitwhen V5n>V6n
set V7n=rI[lI[V3n]]
call fVx(0,bI[V3n],"when calling readByte in LegacyStringTable, line 42")
set rI[lI[V3n]]=V7n+EDo(V_n(RJv,"when calling toUtf8CodeUnit in LegacyStringTable, line 42"))
set V5n=V5n+1
endloop
set EM=EM-1
endfunction
function V8n takes string V9n returns integer
local integer Evn
set ZM[EM]=V9n
set EM=EM+1
if rm==0 then
if sm<$8000 then
set sm=sm+1
set Evn=sm
set tm[Evn]=4648
else
call Cdv("Out of memory: Could not create SingleUnitData.","when calling error in UnitTypeData, line 1299")
set Evn=0
endif
else
set rm=rm-1
set Evn=um[rm]
set tm[Evn]=4648
endif
set EM=EM-1
return Evn
endfunction
function Een takes nothing returns integer
set p9=0
return p9
endfunction
function Exn takes integer Eon returns nothing
local integer Ern=Een()
local real Ein
local real Ean
set HB[Eon]=Ern
set Ein=F7v()
set Ean=a1
set JB[Eon]=Ein
set KB[Eon]=Ean
set LB[Eon]=.0
set XB[Eon]=0
set CB[Eon]=0
call F7v()
endfunction
function Enn takes integer EVn,integer EEn,integer EXn returns nothing
call Exn(EVn)
set AB[EVn]=EEn
set DB[EVn]=EXn
endfunction
function EOn takes integer ERn,integer EIn,string EAn returns integer
local integer ENn
set ZM[EM]=EAn
set EM=EM+1
set ENn=V8n("when calling alloc_SingleUnitData in UnitTypeData, line 1318")
call Enn(ENn,ERn,EIn)
set EM=EM-1
return ENn
endfunction
function Ebn takes integer EBn,integer Ecn,string ECn returns nothing
local real Edn
local real EDn
set ZM[EM]=ECn
set EM=EM+1
set Edn=gbx(Ecn,"when calling readPointData in UnitTypeData, line 1338")
set EDn=Y1
set JB[EBn]=Edn
set KB[EBn]=EDn
call fhx(1,Ecn,"when calling readShort in UnitTypeData, line 1339")
set LB[EBn]=RJv*1./$B4
set EM=EM-1
endfunction
function Efn takes integer EFn,integer Egn,string EGn returns nothing
set ZM[EM]=EGn
set EM=EM+1
if tm[EFn]==0 then
if EFn==0 then
call Cdv("Nullpointer exception when calling SingleUnitData.deserialize","when calling error in UnitTypeData, line 1337")
else
call Cdv("Called SingleUnitData.deserialize on invalid object.","when calling error in UnitTypeData, line 1337")
endif
endif
call Ebn(EFn,Egn,"when calling deserialize in UnitTypeData, line 1337")
set EM=EM-1
endfunction
function Ehn takes integer EHn,string Ejn returns nothing
local integer EJn
local integer Ekn
set ZM[EM]=Ejn
set EM=EM+1
set Ekn=MB[tN[EHn]]
set EJn=EOn(VB[tN[EHn]],NB[tN[EHn]],"when calling new_SingleUnitData in UnitTypeData, line 1403")
call Efn(EJn,iN[EHn],"when calling deserialize in UnitTypeData, line 1403")
call dlv(Ekn,EJn,"when calling add in UnitTypeData, line 1403")
set EM=EM-1
endfunction
function EKn takes string Eln returns integer
local integer ELn
set ZM[EM]=Eln
set EM=EM+1
if CY==0 then
if VY<$8000 then
set VY=VY+1
set ELn=VY
set BY[ELn]=$867
else
call Cdv("Out of memory: Could not create ForForceCallback_execute_execute_LegacyPositionedUnitData_LegacyUnitData.","when calling error in LegacyUnitData, line 404")
set ELn=0
endif
else
set CY=CY-1
set ELn=XY[CY]
set BY[ELn]=$867
endif
set EM=EM-1
return ELn
endfunction
function Emn takes integer EMn,string Epn returns nothing
local integer EPn
local integer Eqn
local integer EQn
local integer Esn
set ZM[EM]=Epn
set EM=EM+1
call dEx(0,eI[EMn],"when calling readInt in LegacyUnitData, line 401")
set EPn=RJv
call pnx(EPn)
set Eqn=0
set EQn=EPn-1
loop
exitwhen Eqn>EQn
set Esn=EKn("when calling alloc_ForForceCallback_execute_execute_LegacyPositionedUnitData_LegacyUnitData in LegacyUnitData, line 404")
set aI[Esn]=qI[EMn]
set nI[Esn]=eI[EMn]
call Fte(Esn,"when calling execute in LegacyUnitData, line 404")
set Eqn=Eqn+1
endloop
set EM=EM-1
endfunction
function ESn takes integer Etn,integer ETn,string Eun returns nothing
set ZM[EM]=Eun
set EM=EM+1
call Y7e(ETn,JB[Etn],KB[Etn],"when calling writePointData in UnitTypeData, line 1334")
call uYe(ETn,c6v(LB[Etn]*180.),"when calling writeShort in UnitTypeData, line 1335")
set EM=EM-1
endfunction
function EUn takes integer Ewn,integer EWn,string Eyn returns nothing
set ZM[EM]=Eyn
set EM=EM+1
if tm[Ewn]==0 then
if Ewn==0 then
call Cdv("Nullpointer exception when calling SingleUnitData.serialize","when calling error in UnitTypeData, line 1333")
else
call Cdv("Called SingleUnitData.serialize on invalid object.","when calling error in UnitTypeData, line 1333")
endif
endif
call ESn(Ewn,EWn,"when calling serialize in UnitTypeData, line 1333")
set EM=EM-1
endfunction
function EYn takes integer Ezn,string EZn returns nothing
set ZM[EM]=EZn
set EM=EM+1
call EUn(wN[Ezn],uN[Ezn],"when calling serialize in UnitTypeData, line 1385")
set EM=EM-1
endfunction
function E_n takes string E0n returns integer
local integer E1n
set ZM[EM]=E0n
set EM=EM+1
if CY==0 then
if VY<$8000 then
set VY=VY+1
set E1n=VY
set BY[E1n]=$86A
else
call Cdv("Out of memory: Could not create ForForceCallback_execute_execute_UnitData_UnitTypeData.","when calling error in UnitTypeData, line 1402")
set E1n=0
endif
else
set CY=CY-1
set E1n=XY[CY]
set BY[E1n]=$86A
endif
set EM=EM-1
return E1n
endfunction
function E2n takes integer E3n,string E4n returns nothing
local integer E5n
local integer E6n
local integer E7n
local integer E8n
set ZM[EM]=E4n
set EM=EM+1
if zYe(BB[rN[E3n]],0)then
if zYe(BB[rN[E3n]],1)then
call dEx(0,sN[E3n],"when calling readInt in UnitTypeData, line 1396")
set E5n=RJv
else
call fhx(1,sN[E3n],"when calling readShort in UnitTypeData, line 1398")
set E5n=RJv
endif
else
call fVx(0,sN[E3n],"when calling readByte in UnitTypeData, line 1400")
set E5n=RJv
endif
set E6n=0
set E7n=E5n-1
loop
exitwhen E6n>E7n
set E8n=E_n("when calling alloc_ForForceCallback_execute_execute_UnitData_UnitTypeData in UnitTypeData, line 1402")
set tN[E8n]=rN[E3n]
set iN[E8n]=sN[E3n]
call Fte(E8n,"when calling execute in UnitTypeData, line 1402")
set E6n=E6n+1
endloop
set EM=EM-1
endfunction
function E9n takes integer Xvn returns integer
return Xvn
endfunction
function Xen takes integer Xxn,string Xon returns nothing
local integer Xrn
local integer Xin
set ZM[EM]=Xon
set EM=EM+1
set Xrn=0
set Xin=SI[Xxn]-1
loop
exitwhen Xrn>Xin
call uAe(cI[Xxn],E9n(Xxo(oI[Xxn],Xrn,"when calling utf8CodeUnitAt in LegacyStringTable, line 35")),"when calling writeByte in LegacyStringTable, line 35")
set Xrn=Xrn+1
endloop
set EM=EM-1
endfunction
function Xan takes nothing returns string
local string Xnn=BlzGetAbilityTooltip(Uq,Lq)
if Xnn=="END OF FILE" then
return""
endif
set Lq=Lq+1
return Xnn
endfunction
function XVn takes integer KKc,integer LKc returns integer
return 0
endfunction
function XEn takes integer XXn,integer XOn,integer XRn,string XIn returns nothing
local integer XAn
local integer XNn
set ZM[EM]=XIn
set EM=EM+1
call nGx(XXn)
set XAn=Xle(XOn,"when calling iterator in BigString, line 54")
loop
exitwhen not Xie(XAn)
set XNn=E3e(XAn)
if GZv(mQ[XNn])>XRn then
call Cdv("BigString: trying to construct a BigString with one of the elements above the requested max size.","when calling error in BigString, line 56")
endif
set vQ[XXn]=vQ[XXn]+GZv(mQ[XNn])
endloop
call Xpe(XAn,"when calling close in BigString, line 54")
set xQ[XXn]=XRn
set FQ[XXn]=XOn
set EM=EM-1
endfunction
function Xbn takes integer XBn,integer Xcn,string XCn returns integer
local integer Xdn
set ZM[EM]=XCn
set EM=EM+1
set Xdn=nfx("when calling alloc_BigString in BigString, line 53")
call XEn(Xdn,XBn,Xcn,"when calling construct_BigString2 in BigString, line 53")
set EM=EM-1
return Xdn
endfunction
function XDn takes string Xfn returns integer
local integer XFn
set ZM[EM]=Xfn
set EM=EM+1
if sG==0 then
if tG<$8000 then
set tG=tG+1
set XFn=tG
set iG[XFn]=990
else
call Cdv("Out of memory: Could not create BigStringElement.","when calling error in BigString, line 15")
set XFn=0
endif
else
set sG=sG-1
set XFn=rG[sG]
set iG[XFn]=990
endif
set EM=EM-1
return XFn
endfunction
function Xgn takes integer Gys returns nothing
endfunction
function XGn takes integer Xhn,string XHn returns nothing
call Xgn(Xhn)
set mQ[Xhn]=XHn
endfunction
function Xjn takes string XJn,string Xkn returns integer
local integer XKn
set ZM[EM]=Xkn
set EM=EM+1
set XKn=XDn("when calling alloc_BigStringElement in BigString, line 16")
call XGn(XKn,XJn)
set EM=EM-1
return XKn
endfunction
function Xln takes string XLn returns integer
local integer Xmn
local string XMn
local integer Xpn
set ZM[EM]=XLn
set EM=EM+1
set Xmn=yTv("when calling new_LinkedList in PacketIO, line 183")
set XMn=Xan()
loop
exitwhen not(XMn!="")
call lIe(Xmn,Xjn(XMn,"when calling new_BigStringElement in PacketIO, line 187"),"when calling push in PacketIO, line 187")
set XMn=Xan()
endloop
set Xpn=Xbn(Xmn,Yy,"when calling new_BigString in PacketIO, line 190")
set EM=EM-1
return Xpn
endfunction
function XPn takes integer Xqn,string XQn returns nothing
set ZM[EM]=XQn
set EM=EM+1
if aY[Xqn]==0 then
call Cdv("Double free: object of type Base64DataDecoder","when calling error in Base64Data, line 117")
else
set pY[eY]=Xqn
set eY=eY+1
set aY[Xqn]=0
endif
set EM=EM-1
endfunction
function Xsn takes integer xSs returns nothing
endfunction
function XSn takes integer Xtn,string XTn returns nothing
set ZM[EM]=XTn
set EM=EM+1
call Xsn(Xtn)
call XPn(Xtn,"when calling dealloc_Base64DataDecoder in Base64Data, line 117")
set EM=EM-1
endfunction
function Xun takes integer XUn,string Xwn returns nothing
set ZM[EM]=Xwn
set EM=EM+1
if aY[XUn]==0 then
if XUn==0 then
call Cdv("Nullpointer exception when calling Base64DataDecoder.Base64DataDecoder","when calling error in Base64Data, line 117")
else
call Cdv("Called Base64DataDecoder.Base64DataDecoder on invalid object.","when calling error in Base64Data, line 117")
endif
endif
call XSn(XUn,"when calling destroyBase64DataDecoder in Base64Data, line 117")
set EM=EM-1
endfunction
function XWn takes integer Xyn,string XYn returns nothing
local integer Xzn
local integer XZn
set ZM[EM]=XYn
set EM=EM+1
if RQ[Xyn]!=0 then
call iJx(RQ[Xyn],"when calling dispatch_ByteBuffer_destroyByteBuffer in Base64, line 199")
endif
if dQ[Xyn]!=0 then
call iix(dQ[Xyn],"when calling dispatch_BigString_destroyBigString in Base64, line 202")
endif
if fQ[Xyn]!=0 then
set Xzn=Xle(fQ[Xyn],"when calling iterator in Base64, line 205")
loop
exitwhen not Xie(Xzn)
set XZn=E3e(Xzn)
call rqx(XZn,"when calling dispatch_BigStringElement_destroyBigStringElement in Base64, line 206")
endloop
call Xpe(Xzn,"when calling close in Base64, line 205")
call Hcv(fQ[Xyn],"when calling dispatch_LinkedList_destroyLinkedList in Base64, line 208")
endif
set EM=EM-1
endfunction
function X_n takes integer X0n,string X1n returns nothing
set ZM[EM]=X1n
set EM=EM+1
if QY[X0n]==0 then
call Cdv("Double free: object of type Base64Decoder","when calling error in Base64, line 189")
else
set xY[vY]=X0n
set vY=vY+1
set QY[X0n]=0
endif
set EM=EM-1
endfunction
function X2n takes integer X3n,string X4n returns nothing
set ZM[EM]=X4n
set EM=EM+1
call XWn(X3n,"when calling Base64Decoder_onDestroy in Base64, line 197")
call X_n(X3n,"when calling dealloc_Base64Decoder in Base64, line 197")
set EM=EM-1
endfunction
function X5n takes integer X6n,string X7n returns nothing
set ZM[EM]=X7n
set EM=EM+1
if QY[X6n]==0 then
if X6n==0 then
call Cdv("Nullpointer exception when calling Base64Decoder.Base64Decoder","when calling error in Base64, line 189")
else
call Cdv("Called Base64Decoder.Base64Decoder on invalid object.","when calling error in Base64, line 189")
endif
endif
call X2n(X6n,"when calling destroyBase64Decoder in Base64, line 189")
set EM=EM-1
endfunction
function X8n takes integer X9n,string Ovn returns integer
local integer Oen
set ZM[EM]=Ovn
set EM=EM+1
set Oen=RQ[X9n]
set RQ[X9n]=0
call X5n(X9n,"when calling dispatch_Base64Decoder_destroyBase64Decoder in Base64, line 280")
set EM=EM-1
return Oen
endfunction
function Oxn takes integer Oon,string Orn returns integer
local integer Oin
set ZM[EM]=Orn
set EM=EM+1
if QY[Oon]==0 then
if Oon==0 then
call Cdv("Nullpointer exception when calling Base64Decoder.intoData","when calling error in Base64, line 277")
else
call Cdv("Called Base64Decoder.intoData on invalid object.","when calling error in Base64, line 277")
endif
endif
set Oin=X8n(Oon,"when calling intoData in Base64, line 277")
set EM=EM-1
return Oin
endfunction
function Oan takes integer Onn returns integer
return vQ[Onn]
endfunction
function OVn takes integer OEn,string OXn returns integer
local integer OOn
set ZM[EM]=OXn
set EM=EM+1
if uG[OEn]==0 then
if OEn==0 then
call Cdv("Nullpointer exception when calling BigString.length","when calling error in BigString, line 204")
else
call Cdv("Called BigString.length on invalid object.","when calling error in BigString, line 204")
endif
endif
set OOn=Oan(OEn)
set EM=EM-1
return OOn
endfunction
function ORn takes integer OIn,string OAn returns nothing
set ZM[EM]=OAn
set EM=EM+1
if SW[OIn]>0 then
call Toe(OIn,"when calling commitInt in ByteBuffer, line 92")
endif
call c4x(OIn,"when calling loadInt in ByteBuffer, line 93")
set EM=EM-1
endfunction
function ONn takes integer Obn,string OBn returns nothing
set ZM[EM]=OBn
set EM=EM+1
if EG[Obn]==0 then
if Obn==0 then
call Cdv("Nullpointer exception when calling ByteBuffer.toReadMode","when calling error in ByteBuffer, line 90")
else
call Cdv("Called ByteBuffer.toReadMode on invalid object.","when calling error in ByteBuffer, line 90")
endif
endif
call ORn(Obn,"when calling toReadMode in ByteBuffer, line 90")
set EM=EM-1
endfunction
function Ocn takes string OCn returns integer
local integer Odn
set ZM[EM]=OCn
set EM=EM+1
if PY==0 then
if AY<$8000 then
set AY=AY+1
set Odn=AY
set DY[Odn]=$CD9
else
call Cdv("Out of memory: Could not create LimitedExecuteAction_executeWhile_Base64Decoder_Base64.","when calling error in Base64, line 255")
set Odn=0
endif
else
set PY=PY-1
set Odn=IY[PY]
set DY[Odn]=$CD9
endif
set EM=EM-1
return Odn
endfunction
function ODn takes string Ofn returns integer
local integer OFn
set ZM[EM]=Ofn
set EM=EM+1
if EY==0 then
if ZY<$8000 then
set ZY=ZY+1
set OFn=ZY
set UY[OFn]=$CFD
else
call Cdv("Out of memory: Could not create LimitedExecuteCondition_executeWhile_Base64Decoder_Base64.","when calling error in Base64, line 255")
set OFn=0
endif
else
set EY=EY-1
set OFn=WY[EY]
set UY[OFn]=$CFD
endif
set EM=EM-1
return OFn
endfunction
function Ogn takes integer OGn,string Ohn returns nothing
local integer OHn
local integer Ojn
local integer OJn
local integer Okn
local integer OKn
set ZM[EM]=Ohn
set EM=EM+1
if dQ[OGn]==0 then
set dQ[OGn]=Xbn(fQ[OGn],Yy,"when calling new_BigString in Base64, line 244")
elseif fQ[OGn]!=0 then
call Hcv(fQ[OGn],"when calling dispatch_LinkedList_destroyLinkedList in Base64, line 247")
endif
set fQ[OGn]=0
set OHn=OVn(dQ[OGn],"when calling length in Base64, line 250")/4-1
set ey=0
set qy=OHn
set Okn=py
set Ojn=ODn("when calling alloc_LimitedExecuteCondition_executeWhile_Base64Decoder_Base64 in Base64, line 255")
set OKn=Ojn
set OJn=Ocn("when calling alloc_LimitedExecuteAction_executeWhile_Base64Decoder_Base64 in Base64, line 255")
set TQ[OJn]=OGn
call WOe(Okn,OKn,OJn,"when calling executeWhile in Base64, line 255")
call ONn(RQ[OGn],"when calling toReadMode in Base64, line 258")
set EM=EM-1
endfunction
function Oln takes integer OLn,string Omn returns nothing
set ZM[EM]=Omn
set EM=EM+1
if QY[OLn]==0 then
if OLn==0 then
call Cdv("Nullpointer exception when calling Base64Decoder.decode","when calling error in Base64, line 242")
else
call Cdv("Called Base64Decoder.decode on invalid object.","when calling error in Base64, line 242")
endif
endif
call Ogn(OLn,"when calling decode in Base64, line 242")
set EM=EM-1
endfunction
function OMn takes string Opn returns integer
local integer OPn
set ZM[EM]=Opn
set EM=EM+1
if vY==0 then
if mY<$8000 then
set mY=mY+1
set OPn=mY
set QY[OPn]=955
else
call Cdv("Out of memory: Could not create Base64Decoder.","when calling error in Base64, line 189")
set OPn=0
endif
else
set vY=vY-1
set OPn=xY[vY]
set QY[OPn]=955
endif
set EM=EM-1
return OPn
endfunction
function Oqn takes integer OQn,string Osn returns nothing
set ZM[EM]=Osn
set EM=EM+1
set RQ[OQn]=nbx("when calling new_ByteBuffer in Base64, line 192")
set EM=EM-1
endfunction
function OSn takes integer Otn,integer OTn,string Oun returns nothing
set ZM[EM]=Oun
set EM=EM+1
call Oqn(Otn,"when calling Base64Decoder_init in Base64, line 194")
set dQ[Otn]=OTn
set EM=EM-1
endfunction
function OUn takes integer Own,string OWn returns integer
local integer Oyn
set ZM[EM]=OWn
set EM=EM+1
set Oyn=OMn("when calling alloc_Base64Decoder in Base64, line 194")
call OSn(Oyn,Own,"when calling construct_Base64Decoder in Base64, line 194")
set EM=EM-1
return Oyn
endfunction
function OYn takes string Ozn returns integer
local integer OZn
set ZM[EM]=Ozn
set EM=EM+1
if YY==0 then
if GY<$8000 then
set GY=GY+1
set OZn=GY
set gY[OZn]=$6CE
else
call Cdv("Out of memory: Could not create Base64DataReader.","when calling error in Base64Data, line 77")
set OZn=0
endif
else
set YY=YY-1
set OZn=TY[YY]
set gY[OZn]=$6CE
endif
set EM=EM-1
return OZn
endfunction
function O_n takes integer hcs returns nothing
endfunction
function O0n takes integer O1n,integer O2n returns nothing
call O_n(O1n)
set aQ[O1n]=O2n
endfunction
function O3n takes integer O4n,string O5n returns integer
local integer O6n
set ZM[EM]=O5n
set EM=EM+1
set O6n=OYn("when calling alloc_Base64DataReader in Base64Data, line 80")
call O0n(O6n,O4n)
set EM=EM-1
return O6n
endfunction
function O7n takes integer O8n,integer O9n,string Rvn returns integer
local integer Ren
local integer Rxn
set ZM[EM]=Rvn
set EM=EM+1
call Xun(O8n,"when calling dispatch_Base64DataDecoder_destroyBase64DataDecoder in Base64Data, line 119")
set Ren=OUn(O9n,"when calling new_Base64Decoder in Base64Data, line 120")
call Oln(Ren,"when calling decode in Base64Data, line 121")
set Rxn=O3n(Oxn(Ren,"when calling intoData in Base64Data, line 122"),"when calling new_Base64DataReader in Base64Data, line 122")
set EM=EM-1
return Rxn
endfunction
function Ron takes integer Rrn,integer Rin,string Ran returns integer
local integer Rnn
set ZM[EM]=Ran
set EM=EM+1
if aY[Rrn]==0 then
if Rrn==0 then
call Cdv("Nullpointer exception when calling Base64DataDecoder.decode","when calling error in Base64Data, line 118")
else
call Cdv("Called Base64DataDecoder.decode on invalid object.","when calling error in Base64Data, line 118")
endif
endif
set Rnn=O7n(Rrn,Rin,"when calling decode in Base64Data, line 118")
set EM=EM-1
return Rnn
endfunction
function RVn takes string REn returns integer
local integer RXn
set ZM[EM]=REn
set EM=EM+1
if eY==0 then
if qY<$8000 then
set qY=qY+1
set RXn=qY
set aY[RXn]=$6CA
else
call Cdv("Out of memory: Could not create Base64DataDecoder.","when calling error in Base64Data, line 117")
set RXn=0
endif
else
set eY=eY-1
set RXn=pY[eY]
set aY[RXn]=$6CA
endif
set EM=EM-1
return RXn
endfunction
function ROn takes integer YSs returns nothing
endfunction
function RRn takes integer RIn returns nothing
call ROn(RIn)
endfunction
function RAn takes string RNn returns integer
local integer Rbn
set ZM[EM]=RNn
set EM=EM+1
set Rbn=RVn("when calling alloc_Base64DataDecoder in Base64Data, line 117")
call RRn(Rbn)
set EM=EM-1
return Rbn
endfunction
function RBn takes integer xrt,integer Rcn,string RCn returns integer
local integer Rdn
set ZM[EM]=RCn
set EM=EM+1
set Rdn=Ron(RAn("when calling new_Base64DataDecoder in PersistableData, line 73"),Rcn,"when calling decode in PersistableData, line 73")
set EM=EM-1
return Rdn
endfunction
function RDn takes integer Rfn,integer RFn,string Rgn returns integer
local integer RGn
set ZM[EM]=Rgn
set EM=EM+1
if Gg[Rfn]==0 then
if Rfn==0 then
call Cdv("Nullpointer exception when calling Persistable.getReader","when calling error in PersistableData, line 72")
else
call Cdv("Called Persistable.getReader on invalid object.","when calling error in PersistableData, line 72")
endif
endif
set RGn=RBn(Rfn,RFn,"when calling getReader in PersistableData, line 72")
set EM=EM-1
return RGn
endfunction
function Rhn takes string RHn returns integer
local integer Rjn
set ZM[EM]=RHn
set EM=EM+1
if CY==0 then
if VY<$8000 then
set VY=VY+1
set Rjn=VY
set BY[Rjn]=$859
else
call Cdv("Out of memory: Could not create ForForceCallback_execute_PacketReader_PacketIO.","when calling error in PacketIO, line 159")
set Rjn=0
endif
else
set CY=CY-1
set Rjn=XY[CY]
set BY[Rjn]=$859
endif
set EM=EM-1
return Rjn
endfunction
function RJn takes string Rkn,string RKn returns nothing
local integer Rln
set ZM[EM]=RKn
set EM=EM+1
call PreloadGenClear()
call PreloadGenStart()
set Rln=Rhn("when calling alloc_ForForceCallback_execute_PacketReader_PacketIO in PacketIO, line 159")
call Fte(Rln,"when calling execute in PacketIO, line 159")
call Preloader(Rkn)
set Lq=1
set EM=EM-1
endfunction
function RLn takes integer Rmn,string RMn returns nothing
local integer Rpn
local integer RPn
set ZM[EM]=RMn
set EM=EM+1
call RJn(tYe(mD[Rmn],"when calling getPath in PersistableData, line 80"),"when calling open in PersistableData, line 80")
set Rpn=uqv(Xan())
set RPn=Xln("when calling readBigString in PersistableData, line 82")
if Rpn==0 or Rpn!=eMx(RPn,"when calling checksum in PersistableData, line 83")then
call iix(RPn,"when calling dispatch_BigString_destroyBigString in PersistableData, line 84")
call Cdv("Persistable: checksum failed to validate","when calling error in PersistableData, line 85")
else
if vD[mD[Rmn]]!=0 then
set RPn=XVn(vD[mD[Rmn]],RPn)
endif
set mM[QD[Rmn]]=RDn(mD[Rmn],RPn,"when calling getReader in PersistableData, line 89")
endif
set EM=EM-1
endfunction
function Rqn takes string RQn,integer Rsn returns string
return RQn+"/chunk"+SMv(Rsn)+".txt"
endfunction
function RSn takes integer Rtn returns boolean
return HQ[Rtn]==1 or HQ[Rtn]==2
endfunction
function RTn takes integer Run,string RUn returns boolean
local boolean Rwn
set ZM[EM]=RUn
set EM=EM+1
if OG[Run]==0 then
if Run==0 then
call Cdv("Nullpointer exception when calling AbstractBuffer.isWriteable","when calling error in BufferInterface, line 137")
else
call Cdv("Called AbstractBuffer.isWriteable on invalid object.","when calling error in BufferInterface, line 137")
endif
endif
set Rwn=RSn(Run)
set EM=EM-1
return Rwn
endfunction
function RWn takes integer Ryn,string RYn returns nothing
set ZM[EM]=RYn
set EM=EM+1
call S1a(Ryn,"when calling checkFailed in BufferInterface, line 157")
if Ca and(not RTn(Ryn,"when calling isWriteable in BufferInterface, line 158"))then
call Cdv("Buffer: cannot write to buffer with mode "+S4a(HQ[Ryn]),"when calling error in BufferInterface, line 159")
endif
set EM=EM-1
endfunction
function Rzn takes integer RZn,string R_n returns nothing
set ZM[EM]=R_n
set EM=EM+1
if OG[RZn]==0 then
if RZn==0 then
call Cdv("Nullpointer exception when calling AbstractBuffer.checkWrite","when calling error in BufferInterface, line 156")
else
call Cdv("Called AbstractBuffer.checkWrite on invalid object.","when calling error in BufferInterface, line 156")
endif
endif
call RWn(RZn,"when calling checkWrite in BufferInterface, line 156")
set EM=EM-1
endfunction
function R0n takes integer R1n,string R2n,string R3n returns nothing
set ZM[EM]=R3n
set EM=EM+1
call Rzn(R1n,"when calling checkWrite in HashBuffer, line 41")
set IZ[R1n]=IZ[R1n]+1
call Kxv(WZ[R1n],IZ[R1n],R2n,"when calling saveString in HashBuffer, line 43")
set EM=EM-1
endfunction
function R4n takes integer R5n,string R6n,string R7n returns nothing
set ZM[EM]=R7n
set EM=EM+1
if OG[R5n]==0 then
if R5n==0 then
call Cdv("Nullpointer exception when calling HashBuffer.writeString","when calling error in HashBuffer, line 40")
else
call Cdv("Called HashBuffer.writeString on invalid object.","when calling error in HashBuffer, line 40")
endif
endif
call R0n(R5n,R6n,"when calling writeString in HashBuffer, line 40")
set EM=EM-1
endfunction
function R8n takes string R9n returns integer
local integer Ivn
set ZM[EM]=R9n
set EM=EM+1
if nh==0 then
if dh<$8000 then
set dh=dh+1
set Ivn=dh
set fh[Ivn]=$BAF
else
call Cdv("Out of memory: Could not create IOTask_submit_FileReader_MultifileIO.","when calling error in MultifileIO, line 213")
set Ivn=0
endif
else
set nh=nh-1
set Ivn=ah[nh]
set fh[Ivn]=$BAF
endif
set EM=EM-1
return Ivn
endfunction
function Ien takes integer Ixn,integer Ion,string Irn returns nothing
set ZM[EM]=Irn
set EM=EM+1
call zGv(pU[Ixn],Ion,"when calling add in IOTaskExecutor, line 48")
set EM=EM-1
endfunction
function Iin takes integer Ian,integer Inn,string IVn returns nothing
set ZM[EM]=IVn
set EM=EM+1
if qh[Ian]==0 then
if Ian==0 then
call Cdv("Nullpointer exception when calling IOTaskExecutor.submit","when calling error in IOTaskExecutor, line 21")
else
call Cdv("Called IOTaskExecutor.submit on invalid object.","when calling error in IOTaskExecutor, line 21")
endif
endif
call Ien(Ian,Inn,"when calling submit in IOTaskExecutor, line 21")
set EM=EM-1
endfunction
function IEn takes integer IXn,integer IOn,string IRn returns nothing
local integer IIn
local integer IAn
set ZM[EM]=IRn
set EM=EM+1
set IAn=YP[IXn]
set IIn=R8n("when calling alloc_IOTask_submit_FileReader_MultifileIO in MultifileIO, line 213")
set GP[IIn]=IXn
set gP[IIn]=IOn
call Iin(IAn,IIn,"when calling submit in MultifileIO, line 213")
set EM=EM-1
endfunction
function INn takes player Ibn returns string
return GetPlayerName(Ibn)
endfunction
function IBn takes player Icn,string ICn returns nothing
call SetPlayerName(Icn,ICn)
endfunction
function Idn takes nothing returns nothing
local integer IDn=0
local integer Ifn=la-1
loop
exitwhen IDn>Ifn
call IBn(sa[IDn],ya[IDn])
set IDn=IDn+1
endloop
endfunction
function IFn takes nothing returns nothing
local integer Ign=0
local integer IGn=la-1
loop
exitwhen Ign>IGn
set ya[Ign]=INn(sa[Ign])
set pa[Ign]=null
set Ign=Ign+1
endloop
endfunction
function Ihn takes string IHn returns nothing
local integer Ijn
local integer IJn
set ea=0
set qa=0
call IFn()
call Preloader(IHn)
set Ijn=0
set IJn=la-1
loop
exitwhen Ijn>IJn
if ya[Ijn]!=INn(sa[Ijn])then
set pa[Ijn]=INn(sa[Ijn])
set qa=qa+1
else
exitwhen true
endif
set Ijn=Ijn+1
endloop
call Idn()
endfunction
function Ikn takes integer IKn returns string
return pa[IKn]
endfunction
function Iln takes nothing returns integer
return qa-ea
endfunction
function ILn takes nothing returns boolean
return Iln()>0
endfunction
function Imn takes string IMn returns string
set ZM[EM]=IMn
set EM=EM+1
if ea==qa then
call Cdv("IOReader: tried to read more packets than available","when calling error in PreloadIO, line 140")
endif
set ea=ea+1
set EM=EM-1
return pa[ea-1]
endfunction
function Ipn takes integer IPn,string Iqn returns nothing
set ZM[EM]=Iqn
set EM=EM+1
if RP[GP[IPn]]then
call Ihn(Rqn(TP[GP[IPn]],gP[IPn]))
else
call Ihn(TP[GP[IPn]])
endif
if Ikn(0)!=dP[GP[IPn]]and ILn()then
loop
exitwhen not ILn()
call R4n(fP[GP[IPn]],Imn("when calling readPacket in MultifileIO, line 224"),"when calling writeString in MultifileIO, line 224")
endloop
if RP[GP[IPn]]then
call IEn(GP[IPn],gP[IPn]+1,"when calling readChunk in MultifileIO, line 228")
endif
endif
set EM=EM-1
endfunction
function IQn takes integer Isn,string ISn returns nothing
set ZM[EM]=ISn
set EM=EM+1
call wGx(cH[Isn],"when calling sync in Persistable, line 209")
set EM=EM-1
endfunction
function Itn takes integer ITn,string Iun returns nothing
set ZM[EM]=Iun
set EM=EM+1
if DF[ITn]==0 then
if ITn==0 then
call Cdv("Nullpointer exception when calling FileSaveCallback.run","when calling error in MultifileIO, line 31")
else
call Cdv("Called FileSaveCallback.run on invalid object.","when calling error in MultifileIO, line 31")
endif
endif
call IQn(ITn,"when calling run_save_PersistentStore_Persistable in MultifileIO, line 31")
set EM=EM-1
endfunction
function IUn takes integer Iwn,string IWn returns nothing
set ZM[EM]=IWn
set EM=EM+1
call Itn(vP[Iwn],"when calling run in MultifileIO, line 168")
set EM=EM-1
endfunction
function Iyn takes string IYn returns nothing
call Preload(fa)
call PreloadGenEnd(IYn)
endfunction
function Izn takes string IZn returns nothing
call Preload(IZn)
endfunction
function I_n takes string I0n,string I1n returns nothing
set ZM[EM]=I1n
set EM=EM+1
if Ra==la then
call Cdv("IOWriter: tried to write more packets than allowed","when calling error in PreloadIO, line 57")
endif
if GZv(I0n)>ba then
call Cdv("IOWriter: tried to write more than max packet length","when calling error in PreloadIO, line 60")
endif
call Izn(aa+SMv(Ra)+na+I0n+da)
set Ra=Ra+1
set EM=EM-1
endfunction
function I2n takes nothing returns nothing
set Ra=0
call PreloadGenClear()
call PreloadGenStart()
endfunction
function I3n takes integer I4n,string I5n returns nothing
set ZM[EM]=I5n
set EM=EM+1
call I2n()
call I_n(dP[FP[I4n]],"when calling writePacket in MultifileIO, line 128")
call Iyn(Rqn(TP[FP[I4n]],kP[I4n]))
set EM=EM-1
endfunction
function I6n takes nothing returns integer
return la-Ra
endfunction
function I7n takes nothing returns boolean
return I6n()>0
endfunction
function I8n takes integer I9n returns boolean
return HZ[I9n]<IZ[I9n]
endfunction
function Avn takes integer Aen,string Axn returns boolean
local boolean Aon
set ZM[EM]=Axn
set EM=EM+1
if OG[Aen]==0 then
if Aen==0 then
call Cdv("Nullpointer exception when calling HashBuffer.hasString","when calling error in HashBuffer, line 146")
else
call Cdv("Called HashBuffer.hasString on invalid object.","when calling error in HashBuffer, line 146")
endif
endif
set Aon=I8n(Aen)
set EM=EM-1
return Aon
endfunction
function Arn takes integer Ain,string Aan returns string
local string Ann
set ZM[EM]=Aan
set EM=EM+1
call tna(Ain,"when calling checkRead in HashBuffer, line 68")
set HZ[Ain]=HZ[Ain]+1
if not KAv(WZ[Ain],HZ[Ain],"when calling hasString in HashBuffer, line 70")then
call Cdv("HashBuffer: trying to read non-present string at pos#"+SMv(HZ[Ain]),"when calling error in HashBuffer, line 71")
endif
set Ann=G7v(WZ[Ain],HZ[Ain],"when calling loadString in HashBuffer, line 72")
set EM=EM-1
return Ann
endfunction
function AVn takes integer AEn,string AXn returns string
local string AOn
set ZM[EM]=AXn
set EM=EM+1
if OG[AEn]==0 then
if AEn==0 then
call Cdv("Nullpointer exception when calling HashBuffer.readString","when calling error in HashBuffer, line 67")
else
call Cdv("Called HashBuffer.readString on invalid object.","when calling error in HashBuffer, line 67")
endif
endif
set AOn=Arn(AEn,"when calling readString in HashBuffer, line 67")
set EM=EM-1
return AOn
endfunction
function ARn takes integer AIn,string AAn returns nothing
set ZM[EM]=AAn
set EM=EM+1
call I2n()
loop
exitwhen not(Avn(fP[jP[AIn]],"when calling hasString in MultifileIO, line 136")and I7n())
call I_n(AVn(fP[jP[AIn]],"when calling readString in MultifileIO, line 137"),"when calling writePacket in MultifileIO, line 137")
endloop
if RP[jP[AIn]]then
call Iyn(Rqn(TP[jP[AIn]],xP[AIn]))
else
call Iyn(TP[jP[AIn]])
endif
set EM=EM-1
endfunction
function ANn takes string Abn returns integer
local integer ABn
set ZM[EM]=Abn
set EM=EM+1
if CY==0 then
if VY<$8000 then
set VY=VY+1
set ABn=VY
set BY[ABn]=$871
else
call Cdv("Out of memory: Could not create ForForceCallback_try_load_PersistentStore_Persistable.","when calling error in Persistable, line 152")
set ABn=0
endif
else
set CY=CY-1
set ABn=XY[CY]
set BY[ABn]=$871
endif
set EM=EM-1
return ABn
endfunction
function Acn takes string ACn returns integer
local integer Adn
set ZM[EM]=ACn
set EM=EM+1
if CY==0 then
if VY<$8000 then
set VY=VY+1
set Adn=VY
set BY[Adn]=$870
else
call Cdv("Out of memory: Could not create ForForceCallback_try_load_PersistentStore_Persistable.","when calling error in Persistable, line 148")
set Adn=0
endif
else
set CY=CY-1
set Adn=XY[CY]
set BY[Adn]=$870
endif
set EM=EM-1
return Adn
endfunction
function ADn takes integer Afn,string AFn returns nothing
set ZM[EM]=AFn
set EM=EM+1
if OG[Afn]==0 then
call Cdv("Double free: object of type OrderedStringBuffer","when calling error in OrderedStringBuffer, line 79")
else
set SG[cG]=Afn
set cG=cG+1
set OG[Afn]=0
endif
set EM=EM-1
endfunction
function Agn takes integer AGn,string Ahn returns nothing
local integer AHn
local integer Ajn
set ZM[EM]=Ahn
set EM=EM+1
set AHn=Xle(gX[AGn],"when calling iterator in StringBuffer, line 63")
loop
exitwhen not Xie(AHn)
set Ajn=E3e(AHn)
call SGa(Ajn,"when calling dispatch_ChunkElement_destroyChunkElement in StringBuffer, line 64")
endloop
call Xpe(AHn,"when calling close in StringBuffer, line 63")
call Hcv(gX[AGn],"when calling dispatch_LinkedList_destroyLinkedList in StringBuffer, line 65")
call sGa(AGn)
set EM=EM-1
endfunction
function AJn takes integer Akn,string AKn returns nothing
set ZM[EM]=AKn
set EM=EM+1
call Agn(Akn,"when calling AbstractStringBuffer_onDestroy in OrderedStringBuffer, line 79")
set EM=EM-1
endfunction
function Aln takes integer ALn,string Amn returns nothing
set ZM[EM]=Amn
set EM=EM+1
call AJn(ALn,"when calling OrderedStringBuffer_onDestroy in OrderedStringBuffer, line 78")
call ADn(ALn,"when calling dealloc_OrderedStringBuffer in OrderedStringBuffer, line 78")
set EM=EM-1
endfunction
function AMn takes integer Apn,string APn returns nothing
set ZM[EM]=APn
set EM=EM+1
if OG[Apn]==0 then
if Apn==0 then
call Cdv("Nullpointer exception when calling OrderedStringBuffer.OrderedStringBuffer","when calling error in OrderedStringBuffer, line 79")
else
call Cdv("Called OrderedStringBuffer.OrderedStringBuffer on invalid object.","when calling error in OrderedStringBuffer, line 79")
endif
endif
call Aln(Apn,"when calling destroyOrderedStringBuffer in OrderedStringBuffer, line 79")
set EM=EM-1
endfunction
function Aqn takes integer AQn,string Asn returns nothing
set ZM[EM]=Asn
set EM=EM+1
call lgv(WZ[AQn],"when calling flush in HashBuffer, line 117")
set EM=EM-1
endfunction
function ASn takes integer Atn,string ATn returns nothing
set ZM[EM]=ATn
set EM=EM+1
if OG[Atn]==0 then
if Atn==0 then
call Cdv("Nullpointer exception when calling HashBuffer.clear","when calling error in HashBuffer, line 116")
else
call Cdv("Called HashBuffer.clear on invalid object.","when calling error in HashBuffer, line 116")
endif
endif
call Aqn(Atn,"when calling clear in HashBuffer, line 116")
set EM=EM-1
endfunction
function Aun takes integer AUn,boolean Awn,string AWn returns nothing
set ZM[EM]=AWn
set EM=EM+1
call Rzn(AUn,"when calling checkWrite in HashBuffer, line 46")
set UZ[AUn]=UZ[AUn]+1
call yoe(WZ[AUn],UZ[AUn],Awn,"when calling saveBoolean in HashBuffer, line 48")
set EM=EM-1
endfunction
function Ayn takes integer AYn,boolean Azn,string AZn returns nothing
set ZM[EM]=AZn
set EM=EM+1
if OG[AYn]==0 then
if AYn==0 then
call Cdv("Nullpointer exception when calling HashBuffer.writeBoolean","when calling error in HashBuffer, line 45")
else
call Cdv("Called HashBuffer.writeBoolean on invalid object.","when calling error in HashBuffer, line 45")
endif
endif
call Aun(AYn,Azn,"when calling writeBoolean in HashBuffer, line 45")
set EM=EM-1
endfunction
function A_n takes integer A0n returns integer
return vA[A0n]
endfunction
function A1n takes integer A2n,string A3n returns integer
local integer A4n
set ZM[EM]=A3n
set EM=EM+1
if ck[A2n]==0 then
if A2n==0 then
call Cdv("Nullpointer exception when calling Network.getData","when calling error in Network, line 259")
else
call Cdv("Called Network.getData on invalid object.","when calling error in Network, line 259")
endif
endif
set A4n=A_n(A2n)
set EM=EM-1
return A4n
endfunction
function A5n takes integer Vut returns nothing
endfunction
function A6n takes integer A7n returns nothing
set HQ[A7n]=2
set JQ[A7n]=0
endfunction
function A8n takes integer A9n returns nothing
call A6n(A9n)
endfunction
function Nvn takes integer Nen,string Nxn returns nothing
set ZM[EM]=Nxn
set EM=EM+1
set gX[Nen]=yTv("when calling new_LinkedList in StringBuffer, line 42")
set hX[Nen]=""
set FX[Nen]=""
set EM=EM-1
endfunction
function Non takes integer Nrn,integer Nin,string Nan returns nothing
set ZM[EM]=Nan
set EM=EM+1
call A8n(Nrn)
call Nvn(Nrn,"when calling AbstractStringBuffer_init in StringBuffer, line 51")
if Nin>FR then
call s2a("Trying to instantiate an instance of AbstractStringBuffer with maxSize="+SMv(Nin)+", but MAX_BACKBUFFER_SIZE is "+SMv(FR))
call s2a("The value will be clamped to "+SMv(FR))
endif
set kX[Nrn]=bUe(Nin,FR)
set EM=EM-1
endfunction
function Nnn takes integer NVn,integer NEn,string NXn returns nothing
set ZM[EM]=NXn
set EM=EM+1
call Non(NVn,NEn,"when calling construct_AbstractStringBuffer in OrderedStringBuffer, line 85")
call A5n(NVn)
set EM=EM-1
endfunction
function NOn takes string NRn returns integer
local integer NIn
set ZM[EM]=NRn
set EM=EM+1
if cG==0 then
if oG<$8000 then
set oG=oG+1
set NIn=oG
set OG[NIn]=$441
else
call Cdv("Out of memory: Could not create OrderedStringBuffer.","when calling error in OrderedStringBuffer, line 79")
set NIn=0
endif
else
set cG=cG-1
set NIn=SG[cG]
set OG[NIn]=$441
endif
set EM=EM-1
return NIn
endfunction
function NAn takes integer NNn,string Nbn returns integer
local integer NBn
set ZM[EM]=Nbn
set EM=EM+1
set NBn=NOn("when calling alloc_OrderedStringBuffer in OrderedStringBuffer, line 85")
call Nnn(NBn,NNn,"when calling construct_OrderedStringBuffer2 in OrderedStringBuffer, line 85")
set EM=EM-1
return NBn
endfunction
function Ncn takes integer NCn,integer Gtt,string Ndn returns nothing
local integer NDn
local boolean Nfn
local boolean NFn
local integer Ngn
local integer NGn
set ZM[EM]=Ndn
set EM=EM+1
set NDn=NAn(ba,"when calling new_OrderedStringBuffer in Persistable, line 142")
call Ayn(A1n(HD[NCn],"when calling getData in Persistable, line 144"),true,"when calling writeBoolean in Persistable, line 144")
set Ngn=Acn("when calling alloc_ForForceCallback_try_load_PersistentStore_Persistable in Persistable, line 148")
set LD[Ngn]=NDn
set XD[Ngn]=JD[NCn]
set NFn=FPe(Ngn,"when calling try in Persistable, line 148")
if NFn then
set NGn=ANn("when calling alloc_ForForceCallback_try_load_PersistentStore_Persistable in Persistable, line 152")
set CD[NGn]=NDn
set VD[NGn]=HD[NCn]
set Nfn=FPe(NGn,"when calling try in Persistable, line 152")
else
set Nfn=false
endif
if(not NFn)or(not Nfn)or(not SPa(NDn,"when calling isValid in Persistable, line 158"))then
call ASn(A1n(HD[NCn],"when calling getData in Persistable, line 159"),"when calling clear in Persistable, line 159")
call Ayn(A1n(HD[NCn],"when calling getData in Persistable, line 160"),false,"when calling writeBoolean in Persistable, line 160")
endif
call AMn(NDn,"when calling dispatch_OrderedStringBuffer_destroyOrderedStringBuffer in Persistable, line 162")
call wGx(KD[NCn],"when calling sync in Persistable, line 163")
set EM=EM-1
endfunction
function Nhn takes integer NHn,integer Njn,string NJn returns nothing
set ZM[EM]=NJn
set EM=EM+1
if AF[NHn]==0 then
if NHn==0 then
call Cdv("Nullpointer exception when calling FileLoadCallback.run","when calling error in MultifileIO, line 28")
else
call Cdv("Called FileLoadCallback.run on invalid object.","when calling error in MultifileIO, line 28")
endif
endif
call Ncn(NHn,Njn,"when calling run_load_PersistentStore_Persistable in MultifileIO, line 28")
set EM=EM-1
endfunction
function Nkn takes integer NKn,string Nln returns nothing
set ZM[EM]=Nln
set EM=EM+1
call Nhn(hP[NKn],0,"when calling run in MultifileIO, line 240")
set EM=EM-1
endfunction
function NLn takes integer Nmn,string NMn returns nothing
set ZM[EM]=NMn
set EM=EM+1
if fh[Nmn]==0 then
if Nmn==0 then
call Cdv("Nullpointer exception when calling IOTask.run","when calling error in IOTaskExecutor, line 11")
else
call Cdv("Called IOTask.run on invalid object.","when calling error in IOTaskExecutor, line 11")
endif
endif
if fh[Nmn]<=$BAF then
if fh[Nmn]<=$BAE then
if fh[Nmn]<=$BAD then
call Nkn(Nmn,"when calling run_onComplete_FileReader_MultifileIO in IOTaskExecutor, line 11")
else
call IUn(Nmn,"when calling run_onComplete_FileWriter_MultifileIO in IOTaskExecutor, line 11")
endif
else
call Ipn(Nmn,"when calling run_submit_FileReader_MultifileIO in IOTaskExecutor, line 11")
endif
elseif fh[Nmn]<=$BB0 then
call I3n(Nmn,"when calling run_submit_FileWriter_MultifileIO in IOTaskExecutor, line 11")
else
call ARn(Nmn,"when calling run_submit_FileWriter_MultifileIO in IOTaskExecutor, line 11")
endif
set EM=EM-1
endfunction
function Npn takes integer NPn,string Nqn returns nothing
local integer NQn
set ZM[EM]=Nqn
set EM=EM+1
set NQn=Gqe(pU[aU[NPn]],"when calling dequeue in IOTaskExecutor, line 63")
call NLn(NQn,"when calling run in IOTaskExecutor, line 64")
call uKa(NQn,"when calling dispatch_IOTask_destroyIOTask in IOTaskExecutor, line 65")
set EM=EM-1
endfunction
function Nsn takes integer NSn,string Ntn returns nothing
local integer NTn
local integer Nun
set ZM[EM]=Ntn
set EM=EM+1
set NTn=0
set Nun=wC[NSn]-1
loop
exitwhen NTn>Nun
call uAe(uC[NSn],E9n(Xxo(rC[NSn],NTn,"when calling utf8CodeUnitAt in StringTable, line 68")),"when calling writeByte in StringTable, line 68")
set NTn=NTn+1
endloop
set EM=EM-1
endfunction
function NUn takes string Nwn returns integer
local integer NWn
set ZM[EM]=Nwn
set EM=EM+1
if CY==0 then
if VY<$8000 then
set VY=VY+1
set NWn=VY
set BY[NWn]=$854
else
call Cdv("Out of memory: Could not create ForForceCallback_execute_GamecacheKeys_GamecacheKeys.","when calling error in GamecacheKeys, line 33")
set NWn=0
endif
else
set CY=CY-1
set NWn=XY[CY]
set BY[NWn]=$854
endif
set EM=EM-1
return NWn
endfunction
function Nyn takes string NYn,integer Nzn,string NZn returns nothing
local integer N_n
local integer N0n
local integer N1n
local integer N2n
local integer N3n
set ZM[EM]=NZn
set EM=EM+1
if Nzn==0 then
set N_n=0
set N0n=be-1
loop
exitwhen N_n>N0n
if ee==ye then
set EM=EM-1
return
endif
set pe[ee]=NYn+duv(le,N_n)
set ee=ee+1
set N_n=N_n+1
endloop
else
set N1n=0
set N2n=be-1
loop
exitwhen N1n>N2n
if ee==ye then
set EM=EM-1
return
endif
set N3n=NUn("when calling alloc_ForForceCallback_execute_GamecacheKeys_GamecacheKeys in GamecacheKeys, line 33")
set vZ[N3n]=NYn
set mZ[N3n]=N1n
set QZ[N3n]=Nzn
call Fte(N3n,"when calling execute in GamecacheKeys, line 33")
set N1n=N1n+1
endloop
endif
set EM=EM-1
endfunction
function N4n takes integer N5n,string N6n returns nothing
set ZM[EM]=N6n
set EM=EM+1
call Nyn(vZ[N5n]+duv(le,mZ[N5n]),QZ[N5n]-1,"when calling precompute in GamecacheKeys, line 33")
set EM=EM-1
endfunction
function N7n takes integer N8n,integer N9n returns nothing
local integer bvn=tK[N9n]
local integer ben
set tK[N9n]=tK[N8n]
set tK[N8n]=bvn
set ben=iK[N9n]
set iK[N9n]=iK[N8n]
set iK[N8n]=ben
endfunction
function bxn takes integer bon,integer brn,string bin returns nothing
set ZM[EM]=bin
set EM=EM+1
if gx[bon]==0 then
if bon==0 then
call Cdv("Nullpointer exception when calling GenericSharedPointer.swap","when calling error in ScmdDataTypes, line 146")
else
call Cdv("Called GenericSharedPointer.swap on invalid object.","when calling error in ScmdDataTypes, line 146")
endif
endif
call N7n(bon,brn)
set EM=EM-1
endfunction
function ban takes integer bnn,string bVn returns nothing
local integer bEn
local integer bXn
set ZM[EM]=bVn
set EM=EM+1
call m7v(LL[bnn],XL[bnn],"when calling setEnumUnit in SotfrpGuiRegions, line 147")
call xda(22,M7v(CL[bnn],0,"when calling get in SotfrpGuiRegions, line 148"),LL[bnn],"when calling evaluate in SotfrpGuiRegions, line 148",0,null,0,null)
set bEn=RJv
set bXn=ox[m0v(bEn,"when calling get in SotfrpGuiRegions, line 149")]
if bXn>=$EF1 and bXn<=$EF2 then
call bxn(VL[bnn],bEn,"when calling swap in SotfrpGuiRegions, line 150")
endif
call mfv(20,bEn,"when calling dispatch_GenericSharedPointer_destroyGenericSharedPointer in SotfrpGuiRegions, line 151")
set EM=EM-1
endfunction
function bOn takes integer bRn,string bIn returns nothing
set ZM[EM]=bIn
set EM=EM+1
call w7x(hA[bRn],"when calling sendRound in NetworkData, line 443")
set EM=EM-1
endfunction
function bAn takes string bNn,string bbn returns integer
local integer bBn
local integer bcn
set ZM[EM]=bbn
set EM=EM+1
if(XAx(bNn)==bNn and tYv(bNn)!=bNn)or bNn=="/" then
set bBn=Ccv("00"+bNn)
else
set bBn=Ccv(bNn)
endif
if Ca and(not fov(vR,bBn,"when calling has in StringEncoder, line 27"))then
call Cdv("Network: trying to get index from invalid character '"+bNn+"'","when calling error in StringEncoder, line 28")
endif
set bcn=f3v(vR,bBn,"when calling get in StringEncoder, line 30")
set EM=EM-1
return bcn
endfunction
function bCn takes integer bdn,string bDn returns string
local string bfn
set ZM[EM]=bDn
set EM=EM+1
if bdn>xR then
call Cdv("Network: trying to get invalid character from index '"+SMv(bdn)+"'","when calling error in StringEncoder, line 17")
endif
set bfn=duv(jR,bdn)
set EM=EM-1
return bfn
endfunction
function bFn takes string bgn returns nothing
local integer bGn
local integer bhn
set ZM[EM]=bgn
set EM=EM+1
set bGn=0
set bhn=xR-1
loop
exitwhen bGn>bhn
if bAn(bCn(bGn,"when calling getCharFromIndex in StringEncoder, line 46"),"when calling getIndexFromChar in StringEncoder, line 46")!=bGn then
call Cbv("CollisionTest failed for "+SMv(bGn)+" "+bCn(bGn,"when calling getCharFromIndex in StringEncoder, line 47"))
call Cbv("getIndexFromChar() == "+SMv(bAn(bCn(bGn,"when calling getCharFromIndex in StringEncoder, line 48"),"when calling getIndexFromChar in StringEncoder, line 48")))
call Cbv("getCharFromIndex(getIndexFromChar)) == "+bCn(bAn(bCn(bGn,"when calling getCharFromIndex in StringEncoder, line 49"),"when calling getIndexFromChar in StringEncoder, line 49"),"when calling getCharFromIndex in StringEncoder, line 49"))
call Cbv("This is a BAD thing and you should report it to wurst devs!")
endif
set bGn=bGn+1
endloop
set EM=EM-1
endfunction
function bHn takes integer EXi,string bjn returns nothing
set ZM[EM]=bjn
set EM=EM+1
call bFn("when calling testCollisions in StringEncoder, line 54")
set EM=EM-1
endfunction
function bJn takes string bkn returns integer
local integer bKn
set ZM[EM]=bkn
set EM=EM+1
if EY==0 then
if ZY<$8000 then
set ZY=ZY+1
set bKn=ZY
set UY[bKn]=$CFE
else
call Cdv("Out of memory: Could not create LimitedExecuteCondition_executeWhile_BufferAdapters.","when calling error in BufferAdapters, line 21")
set bKn=0
endif
else
set EY=EY-1
set bKn=WY[EY]
set UY[bKn]=$CFE
endif
set EM=EM-1
return bKn
endfunction
function bln takes string bLn returns integer
local integer bmn
set ZM[EM]=bLn
set EM=EM+1
if PY==0 then
if AY<$8000 then
set AY=AY+1
set bmn=AY
set DY[bmn]=$CDA
else
call Cdv("Out of memory: Could not create LimitedExecuteAction_executeWhile_BufferAdapters.","when calling error in BufferAdapters, line 21")
set bmn=0
endif
else
set PY=PY-1
set bmn=IY[PY]
set DY[bmn]=$CDA
endif
set EM=EM-1
return bmn
endfunction
function bMn takes integer bpn,integer bPn,string bqn returns nothing
local integer bQn
local integer bsn
local integer bSn
set ZM[EM]=bqn
set EM=EM+1
set bQn=bJn("when calling alloc_LimitedExecuteCondition_executeWhile_BufferAdapters in BufferAdapters, line 21")
set QQ[bQn]=bpn
set bSn=bQn
set bsn=bln("when calling alloc_LimitedExecuteAction_executeWhile_BufferAdapters in BufferAdapters, line 21")
set WQ[bsn]=bpn
set EQ[bsn]=bPn
call WOe(64,bSn,bsn,"when calling executeWhile in BufferAdapters, line 21")
set EM=EM-1
endfunction
function btn takes integer bTn,string bun returns nothing
set ZM[EM]=bun
set EM=EM+1
call bMn(CD[bTn],A1n(VD[bTn],"when calling getData in Persistable, line 153"),"when calling transfer in Persistable, line 153")
set EM=EM-1
endfunction
function bUn takes integer bwn,integer bWn returns boolean
return n9e(bwn,bWn)
endfunction
function byn takes integer bYn,integer bzn,string bZn returns nothing
set ZM[EM]=bZn
set EM=EM+1
call uAe(bzn,RE[bYn],"when calling writeByte in DestructableData, line 146")
if bUn(RE[bYn],7)then
call uAe(bzn,TE[bYn],"when calling writeByte in DestructableData, line 148")
endif
call Wwe(bzn,fE[bYn],YE[bYn],"when calling writeRawcodeTableIndex in DestructableData, line 149")
call Y7e(bzn,GE[bYn],gE[bYn],"when calling writePointData in DestructableData, line 151")
if bUn(RE[bYn],2)then
if bUn(RE[bYn],1)then
call y3e(bzn,hE[bYn],"when calling writeReal in DestructableData, line 154")
else
call uYe(bzn,c6v(hE[bYn]*10.)+$7FFF,"when calling writeShort in DestructableData, line 156")
endif
elseif bUn(RE[bYn],1)then
call uAe(bzn,c6v(hE[bYn]),"when calling writeByte in DestructableData, line 158")
endif
call uYe(bzn,c6v(FE[bYn]*180.),"when calling writeShort in DestructableData, line 159")
if bUn(RE[bYn],4)then
if bUn(RE[bYn],3)then
call y3e(bzn,kE[bYn],"when calling writeReal in DestructableData, line 163")
else
call uYe(bzn,c6v(kE[bYn]*10.)+$7FFF,"when calling writeShort in DestructableData, line 165")
endif
elseif bUn(RE[bYn],3)then
call uAe(bzn,c6v(kE[bYn]),"when calling writeByte in DestructableData, line 167")
endif
if(not bUn(RE[bYn],5))and(not bUn(RE[bYn],6))then
call uAe(bzn,jE[bYn],"when calling writeByte in DestructableData, line 170")
endif
set EM=EM-1
endfunction
function b_n takes integer b0n,integer b1n,string b2n returns nothing
set ZM[EM]=b2n
set EM=EM+1
if mg[b0n]==0 then
if b0n==0 then
call Cdv("Nullpointer exception when calling SingleDestructableData.serialize","when calling error in DestructableData, line 145")
else
call Cdv("Called SingleDestructableData.serialize on invalid object.","when calling error in DestructableData, line 145")
endif
endif
call byn(b0n,b1n,"when calling serialize in DestructableData, line 145")
set EM=EM-1
endfunction
function b3n takes integer b4n,string b5n returns nothing
set ZM[EM]=b5n
set EM=EM+1
call b_n(sE[b4n],tE[b4n],"when calling serialize in DestructableData, line 249")
set EM=EM-1
endfunction
function b6n takes string b7n returns nothing
local integer b8n
local integer b9n
local string Bvn
set ZM[EM]=b7n
set EM=EM+1
set b8n=0
set b9n=xR-1
loop
exitwhen b8n>b9n
set Bvn=duv(jR,b8n)
if(XAx(Bvn)==Bvn and tYv(Bvn)!=Bvn)or Bvn=="/" then
call fqv(vR,Ccv("00"+Bvn),b8n,"when calling put in StringEncoder, line 38")
else
call fqv(vR,Ccv(Bvn),b8n,"when calling put in StringEncoder, line 40")
endif
set b8n=b8n+1
endloop
set EM=EM-1
endfunction
function Ben takes integer mXi,string Bxn returns nothing
set ZM[EM]=Bxn
set EM=EM+1
call b6n("when calling precomputeLookup in StringEncoder, line 53")
set EM=EM-1
endfunction
function Bon takes string Brn returns integer
local integer Bin
set ZM[EM]=Brn
set EM=EM+1
if EY==0 then
if ZY<$8000 then
set ZY=ZY+1
set Bin=ZY
set UY[Bin]=$CFF
else
call Cdv("Out of memory: Could not create LimitedExecuteCondition_executeWhile_BufferAdapters.","when calling error in BufferAdapters, line 25")
set Bin=0
endif
else
set EY=EY-1
set Bin=WY[EY]
set UY[Bin]=$CFF
endif
set EM=EM-1
return Bin
endfunction
function Ban takes string Bnn returns integer
local integer BVn
set ZM[EM]=Bnn
set EM=EM+1
if PY==0 then
if AY<$8000 then
set AY=AY+1
set BVn=AY
set DY[BVn]=$CDB
else
call Cdv("Out of memory: Could not create LimitedExecuteAction_executeWhile_BufferAdapters.","when calling error in BufferAdapters, line 25")
set BVn=0
endif
else
set PY=PY-1
set BVn=IY[PY]
set DY[BVn]=$CDB
endif
set EM=EM-1
return BVn
endfunction
function BEn takes integer BXn,integer BOn,string BRn returns nothing
local integer BIn
local integer BAn
local integer BNn
set ZM[EM]=BRn
set EM=EM+1
set BIn=Bon("when calling alloc_LimitedExecuteCondition_executeWhile_BufferAdapters in BufferAdapters, line 25")
set ZQ[BIn]=BOn
set BNn=BIn
set BAn=Ban("when calling alloc_LimitedExecuteAction_executeWhile_BufferAdapters in BufferAdapters, line 25")
set UQ[BAn]=BXn
set IQ[BAn]=BOn
call WOe(64,BNn,BAn,"when calling executeWhile in BufferAdapters, line 25")
set EM=EM-1
endfunction
function Bbn takes integer BBn,string Bcn returns nothing
set ZM[EM]=Bcn
set EM=EM+1
call BEn(LD[BBn],XD[BBn],"when calling populateFromFile in Persistable, line 149")
set EM=EM-1
endfunction
function BCn takes string Bdn returns integer
local integer BDn
set ZM[EM]=Bdn
set EM=EM+1
if uF==0 then
if rF<$8000 then
set rF=rF+1
set BDn=rF
set sF[BDn]=$CC8
else
call Cdv("Out of memory: Could not create LegacySingleUnitDataPositioned.","when calling error in LegacyUnitData, line 369")
set BDn=0
endif
else
set uF=uF-1
set BDn=wF[uF]
set sF[BDn]=$CC8
endif
set EM=EM-1
return BDn
endfunction
function Bfn takes integer BFn returns nothing
local real Bgn=.0
local real BGn=.0
local real Bhn
set BI[BFn]=Bgn
set NI[BFn]=BGn
set Bhn=.0
set MI[BFn]=Bhn
endfunction
function BHn takes integer Bjn,string BJn returns nothing
local integer Bkn
local integer BKn
local integer Bln
local integer BLn
local integer Bmn
set ZM[EM]=BJn
set EM=EM+1
set Bkn=0
set fI[Bjn]=Bkn
set RI[Bjn]=0
set TI[Bjn]=0
set YI[Bjn]=.0
set GI[Bjn]=0
set BKn=0
set Bln=0
set BLn=0
set Bmn=0
set gI[Bjn]=BKn
set hI[Bjn]=Bln
set FI[Bjn]=BLn
set kI[Bjn]=Bmn
set jI[Bjn]=.0
set xI[Bjn]=.0
set vI[Bjn]=.0
set mI[Bjn]=.0
set QI[Bjn]=.0
set WI[Bjn]=.0
set EI[Bjn]=0
set ZI[Bjn]=0
set UI[Bjn]=0
set II[Bjn]=0
set PI[Bjn]=0
set AI[Bjn]=.0
set DI[Bjn]=0
set HI[Bjn]=.0
set JI[Bjn]=0
set KI[Bjn]=.0
set LI[Bjn]=0
set XI[Bjn]=TEv("when calling new_HashList in LegacyUnitData, line 162")
set CI[Bjn]=TEv("when calling new_HashList in LegacyUnitData, line 163")
set VI[Bjn]=TEv("when calling new_HashList in LegacyUnitData, line 164")
set EM=EM-1
endfunction
function BMn takes integer Bpn,integer BPn,string Bqn returns nothing
set ZM[EM]=Bqn
set EM=EM+1
call BHn(Bpn,"when calling LegacySingleUnitData_init in LegacyUnitData, line 171")
set dI[Bpn]=BPn
set EM=EM-1
endfunction
function BQn takes integer Bsn,integer BSn,string Btn returns nothing
set ZM[EM]=Btn
set EM=EM+1
call BMn(Bsn,BSn,"when calling construct_LegacySingleUnitData in LegacyUnitData, line 374")
call Bfn(Bsn)
set EM=EM-1
endfunction
function BTn takes integer Bun,string BUn returns integer
local integer Bwn
set ZM[EM]=BUn
set EM=EM+1
set Bwn=BCn("when calling alloc_LegacySingleUnitDataPositioned in LegacyUnitData, line 374")
call BQn(Bwn,Bun,"when calling construct_LegacySingleUnitDataPositioned in LegacyUnitData, line 374")
set EM=EM-1
return Bwn
endfunction
function BWn takes integer Byn,integer BYn,integer Bzn,string BZn returns nothing
if BYn<0 or BYn>=6 then
call Cdv("Index out of Bounds",BZn)
elseif BYn<=2 then
if BYn<=1 then
if BYn<=0 then
set zJ[Byn]=Bzn
else
set zk[Byn]=Bzn
endif
else
set zK[Byn]=Bzn
endif
elseif BYn<=4 then
if BYn<=3 then
set zl[Byn]=Bzn
else
set zL[Byn]=Bzn
endif
else
set zm[Byn]=Bzn
endif
endfunction
function B_n takes integer B0n,integer B1n,integer B2n,string B3n returns nothing
if B1n<0 or B1n>=2 then
call Cdv("Index out of Bounds",B3n)
elseif B1n<=0 then
set zM[B0n]=B2n
else
set zp[B0n]=B2n
endif
endfunction
function B4n takes integer B5n,integer B6n,integer B7n,string B8n returns nothing
if B6n<0 or B6n>=2 then
call Cdv("Index out of Bounds",B8n)
elseif B6n<=0 then
set zt[B5n]=B7n
else
set zT[B5n]=B7n
endif
endfunction
function B9n takes integer cvn,string cen returns integer
local integer cxn
local integer con
local real crn
local integer cin
local integer can
local integer cnn
local integer cVn
local real cEn
local integer cXn
local integer cOn
set ZM[EM]=cen
set EM=EM+1
set cnn=0
call dEx(0,cvn,"when calling readInt in LegacyUnitData, line 125")
set cVn=RJv
call d7x(0,cvn,"when calling readReal in LegacyUnitData, line 125")
set cEn=Rkv
call dEx(0,cvn,"when calling readInt in LegacyUnitData, line 125")
set cXn=RJv
call dEx(0,cvn,"when calling readInt in LegacyUnitData, line 125")
set cOn=RJv
set cxn=cnn
set con=cVn
set crn=cEn
set cin=cXn
set can=cOn
set EM=EM-1
set s1=cxn
set t1=con
set i1=crn
set S1=cin
set c1=can
return s1
endfunction
function cRn takes string cIn returns integer
local integer cAn
set ZM[EM]=cIn
set EM=EM+1
if Qh==0 then
if Wh<$8000 then
set Wh=Wh+1
set cAn=Wh
set Eh[cAn]=4644
else
call Cdv("Out of memory: Could not create SingleItemData.","when calling error in LegacyItemData, line 30")
set cAn=0
endif
else
set Qh=Qh-1
set cAn=mh[Qh]
set Eh[cAn]=4644
endif
set EM=EM-1
return cAn
endfunction
function cNn takes integer cbn returns nothing
local integer cBn=0
set PU[cbn]=cBn
set AU[cbn]=0
set DU[cbn]=0
set HU[cbn]=.0
set JU[cbn]=0
set KU[cbn]=0
set LU[cbn]=0
set XU[cbn]=0
set CU[cbn]=0
endfunction
function ccn takes integer cCn,integer cdn returns nothing
call cNn(cCn)
set IU[cCn]=cdn
endfunction
function cDn takes integer cfn,string cFn returns integer
local integer cgn
set ZM[EM]=cFn
set EM=EM+1
set cgn=cRn("when calling alloc_SingleItemData in LegacyItemData, line 44")
call ccn(cgn,cfn)
set EM=EM-1
return cgn
endfunction
function cGn takes integer chn,integer cHn,real cjn,string cJn returns nothing
if cHn<0 or cHn>=2 then
call Cdv("Index out of Bounds",cJn)
elseif cHn<=0 then
set zQ[chn]=cjn
else
set zs[chn]=cjn
endif
endfunction
function ckn takes integer cKn,integer cln,integer cLn,string cmn returns nothing
if cln<0 or cln>=2 then
call Cdv("Index out of Bounds",cmn)
elseif cln<=0 then
set zS[cKn]=cLn
else
set it[cKn]=cLn
endif
endfunction
function cMn takes integer cpn,integer cPn,integer cqn,string cQn returns nothing
if cPn<0 or cPn>=2 then
call Cdv("Index out of Bounds",cQn)
elseif cPn<=0 then
set zP[cpn]=cqn
else
set zq[cpn]=cqn
endif
endfunction
function csn takes integer cSn,integer ctn,string cTn returns nothing
local integer cun
set ZM[EM]=cTn
set EM=EM+1
call fhx(1,ctn,"when calling readShort in LegacyItemData, line 135")
set cun=RJv
set PU[cSn]=cun
call dEx(0,ctn,"when calling readInt in LegacyItemData, line 136")
set AU[cSn]=RJv
if mwx(PU[cSn],4)then
set DU[cSn]=0
elseif mwx(PU[cSn],5)then
set DU[cSn]=1
else
call dEx(0,ctn,"when calling readInt in LegacyItemData, line 142")
set DU[cSn]=RJv
endif
if mwx(PU[cSn],6)then
call d7x(0,ctn,"when calling readReal in LegacyItemData, line 144")
set HU[cSn]=Rkv
endif
if mwx(PU[cSn],7)then
call dEx(0,ctn,"when calling readInt in LegacyItemData, line 146")
set JU[cSn]=RJv
endif
if mwx(PU[cSn],8)then
call dEx(0,ctn,"when calling readInt in LegacyItemData, line 148")
set KU[cSn]=RJv
endif
if mwx(PU[cSn],9)then
call dEx(0,ctn,"when calling readInt in LegacyItemData, line 150")
set LU[cSn]=RJv
endif
if mwx(PU[cSn],$A)then
call dEx(0,ctn,"when calling readInt in LegacyItemData, line 152")
set XU[cSn]=RJv
endif
if mwx(PU[cSn],$B)then
call dEx(0,ctn,"when calling readInt in LegacyItemData, line 154")
set CU[cSn]=RJv
endif
set EM=EM-1
endfunction
function cUn takes integer cwn,integer cWn,string cyn returns nothing
set ZM[EM]=cyn
set EM=EM+1
call d7x(0,cWn,"when calling readReal in LegacyItemData, line 176")
call d7x(0,cWn,"when calling readReal in LegacyItemData, line 177")
call csn(cwn,cWn,"when calling deserialize in LegacyItemData, line 178")
set EM=EM-1
endfunction
function cYn takes integer czn,integer cZn,string c_n returns nothing
set ZM[EM]=c_n
set EM=EM+1
if Eh[czn]==0 then
if czn==0 then
call Cdv("Nullpointer exception when calling SingleItemData.deserialize","when calling error in LegacyItemData, line 134")
else
call Cdv("Called SingleItemData.deserialize on invalid object.","when calling error in LegacyItemData, line 134")
endif
endif
if Eh[czn]<=4644 then
call csn(czn,cZn,"when calling deserialize in LegacyItemData, line 134")
else
call cUn(czn,cZn,"when calling deserialize in LegacyItemData, line 134")
endif
set EM=EM-1
endfunction
function c0n takes real c1n returns nothing
call lUx(R2S(c1n))
endfunction
function c2n takes integer c3n,integer c4n,string c5n returns nothing
local integer c6n
local integer c7n
local integer c8n
local integer c9n
local integer Cvn
local integer Cen
local integer Cxn
local integer Con
local integer Crn
local integer Cin
local integer Can
local integer Cnn
local integer CVn
local real CEn
local integer CXn
local integer COn
local integer CRn
local integer CIn
local real CAn
local integer CNn
local integer Cbn
local integer CBn
local integer Ccn
local integer CCn
local integer Cdn
local integer CDn
local integer Cfn
set ZM[EM]=c5n
set EM=EM+1
call dEx(0,c4n,"when calling readInt in LegacyUnitData, line 280")
set Can=RJv
set fI[c3n]=Can
call dEx(0,c4n,"when calling readInt in LegacyUnitData, line 281")
set RI[c3n]=RJv
if L9x(fI[c3n],7)then
call d7x(0,c4n,"when calling readReal in LegacyUnitData, line 283")
set YI[c3n]=Rkv
endif
if L9x(fI[c3n],8)then
call fVx(0,c4n,"when calling readByte in LegacyUnitData, line 285")
set GI[c3n]=RJv
endif
if L9x(fI[c3n],9)then
call fVx(0,c4n,"when calling readByte in LegacyUnitData, line 287")
set gI[c3n]=RJv
call fVx(0,c4n,"when calling readByte in LegacyUnitData, line 288")
set hI[c3n]=RJv
call fVx(0,c4n,"when calling readByte in LegacyUnitData, line 289")
set FI[c3n]=RJv
call fVx(0,c4n,"when calling readByte in LegacyUnitData, line 290")
set kI[c3n]=RJv
endif
if L9x(fI[c3n],$A)then
call d7x(0,c4n,"when calling readReal in LegacyUnitData, line 292")
set jI[c3n]=Rkv
endif
if L9x(fI[c3n],$B)then
call d7x(0,c4n,"when calling readReal in LegacyUnitData, line 294")
set xI[c3n]=Rkv
endif
if L9x(fI[c3n],$C)then
call d7x(0,c4n,"when calling readReal in LegacyUnitData, line 296")
set vI[c3n]=Rkv
endif
if L9x(fI[c3n],$D)then
call d7x(0,c4n,"when calling readReal in LegacyUnitData, line 298")
set mI[c3n]=Rkv
endif
if L9x(fI[c3n],$E)then
call d7x(0,c4n,"when calling readReal in LegacyUnitData, line 300")
set QI[c3n]=Rkv
endif
if L9x(fI[c3n],$F)then
call d7x(0,c4n,"when calling readReal in LegacyUnitData, line 302")
set WI[c3n]=Rkv
endif
if L9x(fI[c3n],3)then
call dEx(0,c4n,"when calling readInt in LegacyUnitData, line 304")
set II[c3n]=RJv
call dEx(0,c4n,"when calling readInt in LegacyUnitData, line 305")
set EI[c3n]=RJv
call dEx(0,c4n,"when calling readInt in LegacyUnitData, line 306")
set ZI[c3n]=RJv
call dEx(0,c4n,"when calling readInt in LegacyUnitData, line 307")
set UI[c3n]=RJv
call dEx(0,c4n,"when calling readInt in LegacyUnitData, line 308")
set PI[c3n]=RJv
endif
call lUx("graphics&hero oK")
if L9x(fI[c3n],16)then
call dEx(0,c4n,"when calling readInt in LegacyUnitData, line 311")
set TI[c3n]=RJv
set c6n=0
set c7n=TI[c3n]-1
loop
exitwhen c6n>c7n
call Cyx(0,c4n,"when calling readBoolean in LegacyUnitData, line 313")
if Rjv then
set c8n=cDn(dI[c3n],"when calling new_SingleItemData in LegacyUnitData, line 314")
call cYn(c8n,c4n,"when calling deserialize in LegacyUnitData, line 314")
call BWn(c3n,c6n,c8n,"when writing array LegacySingleUnitData_items in LegacyUnitData, line 314")
endif
set c6n=c6n+1
endloop
endif
call lUx("inventory")
if L9x(fI[c3n],17)then
call d7x(0,c4n,"when calling readReal in LegacyUnitData, line 317")
set AI[c3n]=Rkv
call c0n(AI[c3n])
endif
call lUx("armor")
if L9x(fI[c3n],18)then
set Cnn=B9n(c4n,"when calling readAttackParameters in LegacyUnitData, line 321")
set CVn=t1
set CEn=i1
set CXn=S1
set COn=c1
call B_n(c3n,0,Cnn,"when writing array LegacySingleUnitData_weapons_flags_val in LegacyUnitData, line 321")
call cMn(c3n,0,CVn,"when writing array LegacySingleUnitData_weapons_baseDamage in LegacyUnitData, line 321")
call cGn(c3n,0,CEn,"when writing array LegacySingleUnitData_weapons_cooldown in LegacyUnitData, line 321")
call ckn(c3n,0,CXn,"when writing array LegacySingleUnitData_weapons_diceSides in LegacyUnitData, line 321")
call B4n(c3n,0,COn,"when writing array LegacySingleUnitData_weapons_diceNumber in LegacyUnitData, line 321")
call pnx(mLx(c3n,0,"when reading array LegacySingleUnitData_weapons_baseDamage in  in LegacyUnitData, line 322"))
call c0n(LWx(c3n,0,"when reading array LegacySingleUnitData_weapons_cooldown in  in LegacyUnitData, line 323"))
call pnx(mBx(c3n,0,"when reading array LegacySingleUnitData_weapons_diceSides in  in LegacyUnitData, line 324"))
call pnx(L_x(c3n,0,"when reading array LegacySingleUnitData_weapons_diceNumber in  in LegacyUnitData, line 325"))
endif
call lUx("atk1")
if L9x(fI[c3n],19)then
set CRn=B9n(c4n,"when calling readAttackParameters in LegacyUnitData, line 328")
set CIn=t1
set CAn=i1
set CNn=S1
set Cbn=c1
call B_n(c3n,1,CRn,"when writing array LegacySingleUnitData_weapons_flags_val in LegacyUnitData, line 328")
call cMn(c3n,1,CIn,"when writing array LegacySingleUnitData_weapons_baseDamage in LegacyUnitData, line 328")
call cGn(c3n,1,CAn,"when writing array LegacySingleUnitData_weapons_cooldown in LegacyUnitData, line 328")
call ckn(c3n,1,CNn,"when writing array LegacySingleUnitData_weapons_diceSides in LegacyUnitData, line 328")
call B4n(c3n,1,Cbn,"when writing array LegacySingleUnitData_weapons_diceNumber in LegacyUnitData, line 328")
call pnx(mLx(c3n,1,"when reading array LegacySingleUnitData_weapons_baseDamage in  in LegacyUnitData, line 329"))
call c0n(LWx(c3n,1,"when reading array LegacySingleUnitData_weapons_cooldown in  in LegacyUnitData, line 330"))
call pnx(mBx(c3n,1,"when reading array LegacySingleUnitData_weapons_diceSides in  in LegacyUnitData, line 331"))
call pnx(L_x(c3n,1,"when reading array LegacySingleUnitData_weapons_diceNumber in  in LegacyUnitData, line 332"))
endif
call lUx("at2k")
if L9x(fI[c3n],20)then
call dEx(0,c4n,"when calling readInt in LegacyUnitData, line 335")
set DI[c3n]=RJv
call pnx(DI[c3n])
endif
if L9x(fI[c3n],21)then
call d7x(0,c4n,"when calling readReal in LegacyUnitData, line 338")
set HI[c3n]=Rkv
endif
if L9x(fI[c3n],22)then
call dEx(0,c4n,"when calling readInt in LegacyUnitData, line 340")
set JI[c3n]=RJv
endif
if L9x(fI[c3n],23)then
call d7x(0,c4n,"when calling readReal in LegacyUnitData, line 342")
set KI[c3n]=Rkv
endif
call lUx("stats")
if L9x(fI[c3n],24)then
call dEx(0,c4n,"when calling readInt in LegacyUnitData, line 345")
set LI[c3n]=RJv
endif
call lUx("name")
if L9x(fI[c3n],25)then
call lUx("starting removed")
call dEx(0,c4n,"when calling readInt in LegacyUnitData, line 349")
set c9n=RJv
call pnx(c9n)
set Cvn=0
set Cen=c9n-1
loop
exitwhen Cvn>Cen
set Ccn=XI[c3n]
call dEx(0,c4n,"when calling readInt in LegacyUnitData, line 352")
call dlv(Ccn,RJv,"when calling add in LegacyUnitData, line 352")
set Cvn=Cvn+1
endloop
endif
if L9x(fI[c3n],26)then
call dEx(0,c4n,"when calling readInt in LegacyUnitData, line 354")
set Cxn=RJv
call lUx("starting added")
call pnx(Cxn)
set Con=0
set Crn=Cxn-1
loop
exitwhen Con>Crn
set CCn=CI[c3n]
call dEx(0,c4n,"when calling readInt in LegacyUnitData, line 358")
call dlv(CCn,RJv,"when calling add in LegacyUnitData, line 358")
call fVx(0,c4n,"when calling readByte in LegacyUnitData, line 359")
set CBn=RJv
set Cin=CBn
call dlv(CI[c3n],Cin,"when calling add in LegacyUnitData, line 360")
if mxx(Cin,4)then
set Cdn=CI[c3n]
call fhx(1,c4n,"when calling readShort in LegacyUnitData, line 362")
call dlv(Cdn,RJv,"when calling add in LegacyUnitData, line 362")
endif
if mxx(Cin,5)then
set CDn=CI[c3n]
call dEx(0,c4n,"when calling readInt in LegacyUnitData, line 364")
call dlv(CDn,RJv,"when calling add in LegacyUnitData, line 364")
endif
if mxx(Cin,6)then
set Cfn=VI[c3n]
call d7x(0,c4n,"when calling readReal in LegacyUnitData, line 366")
call dlv(Cfn,ALo(Rkv),"when calling add in LegacyUnitData, line 366")
endif
set Con=Con+1
endloop
endif
call lUx("abils")
set EM=EM-1
endfunction
function CFn takes integer Cgn,integer CGn,string Chn returns nothing
local real CHn
set ZM[EM]=Chn
set EM=EM+1
call d7x(0,CGn,"when calling readReal in LegacyUnitData, line 381")
set BI[Cgn]=Rkv
call d7x(0,CGn,"when calling readReal in LegacyUnitData, line 382")
set NI[Cgn]=Rkv
call d7x(0,CGn,"when calling readReal in LegacyUnitData, line 383")
set CHn=vde(Rkv)
set MI[Cgn]=CHn
call c2n(Cgn,CGn,"when calling deserialize in LegacyUnitData, line 385")
set EM=EM-1
endfunction
function Cjn takes integer CJn,integer Ckn,string CKn returns nothing
set ZM[EM]=CKn
set EM=EM+1
if sF[CJn]==0 then
if CJn==0 then
call Cdv("Nullpointer exception when calling LegacySingleUnitDataPositioned.deserialize","when calling error in LegacyUnitData, line 380")
else
call Cdv("Called LegacySingleUnitDataPositioned.deserialize on invalid object.","when calling error in LegacyUnitData, line 380")
endif
endif
call CFn(CJn,Ckn,"when calling deserialize in LegacyUnitData, line 380")
set EM=EM-1
endfunction
function Cln takes integer CLn,string Cmn returns nothing
local integer CMn
local integer Cpn
set ZM[EM]=Cmn
set EM=EM+1
set Cpn=pI[aI[CLn]]
set CMn=BTn(yI[aI[CLn]],"when calling new_LegacySingleUnitDataPositioned in LegacyUnitData, line 405")
call Cjn(CMn,nI[CLn],"when calling deserialize in LegacyUnitData, line 405")
call dlv(Cpn,CMn,"when calling add in LegacyUnitData, line 405")
set EM=EM-1
endfunction
function CPn takes integer Cqn,string CQn returns nothing
local integer Csn
local integer CSn
set ZM[EM]=CQn
set EM=EM+1
call m7v(KK[Cqn],LK[Cqn],"when calling setEnumUnit in ScmdUnitBuiltins, line 192")
call xda(22,M7v(XK[Cqn],1,"when calling get in ScmdUnitBuiltins, line 193"),KK[Cqn],"when calling evaluate in ScmdUnitBuiltins, line 193",0,null,0,null)
set Csn=RJv
set CSn=ox[m0v(Csn,"when calling get in ScmdUnitBuiltins, line 194")]
if CSn>=$EF1 and CSn<=$EF2 then
call bxn(CK[Cqn],Csn,"when calling swap in ScmdUnitBuiltins, line 195")
call mfv(20,Csn,"when calling dispatch_GenericSharedPointer_destroyGenericSharedPointer in ScmdUnitBuiltins, line 196")
else
call mfv(20,Csn,"when calling dispatch_GenericSharedPointer_destroyGenericSharedPointer in ScmdUnitBuiltins, line 198")
endif
set EM=EM-1
endfunction
function Ctn takes integer CTn,string Cun returns nothing
set ZM[EM]=Cun
set EM=EM+1
if Ca and RZ[CTn]+1>=ee then
call Cdv("GamecacheBuffer: trying to read out of available keys bounds","when calling error in GamecacheBuffer, line 57")
endif
set RZ[CTn]=RZ[CTn]+1
set EM=EM-1
endfunction
function CUn takes integer Cwn,string CWn returns nothing
set ZM[EM]=CWn
set EM=EM+1
if Bg[Cwn]==0 then
if Cwn==0 then
call Cdv("Nullpointer exception when calling GamecacheBuffer.advanceReadIndex","when calling error in GamecacheBuffer, line 55")
else
call Cdv("Called GamecacheBuffer.advanceReadIndex on invalid object.","when calling error in GamecacheBuffer, line 55")
endif
endif
call Ctn(Cwn,"when calling advanceReadIndex in GamecacheBuffer, line 55")
set EM=EM-1
endfunction
function Cyn takes integer CYn,integer Czn,string CZn returns nothing
set ZM[EM]=CZn
set EM=EM+1
if Ca and TZ[CYn]!=Czn then
call Cdv("GamecacheBuffer: invalid buffer usage - mismatched type","when calling error in GamecacheBuffer, line 48")
endif
set EM=EM-1
endfunction
function C_n takes integer C0n,integer C1n,string C2n returns nothing
set ZM[EM]=C2n
set EM=EM+1
if Bg[C0n]==0 then
if C0n==0 then
call Cdv("Nullpointer exception when calling GamecacheBuffer.checkType","when calling error in GamecacheBuffer, line 46")
else
call Cdv("Called GamecacheBuffer.checkType on invalid object.","when calling error in GamecacheBuffer, line 46")
endif
endif
call Cyn(C0n,C1n,"when calling checkType in GamecacheBuffer, line 46")
set EM=EM-1
endfunction
function C3n takes gamecache C4n,string C5n,string C6n returns boolean
return HaveStoredInteger(C4n,C5n,C6n)
endfunction
function C7n takes integer C8n,string C9n returns integer
local integer dvn
set ZM[EM]=C9n
set EM=EM+1
call CUn(C8n,"when calling advanceReadIndex in GamecacheBuffer, line 76")
call C_n(C8n,0,"when calling checkType in GamecacheBuffer, line 77")
if not C3n(nZ[C8n],dZ[C8n],Tbx(RZ[C8n],"when calling get in GamecacheBuffer, line 78"))then
call Cdv("GamecacheBuffer: trying to read non-present int #"+SMv(RZ[C8n]),"when calling error in GamecacheBuffer, line 79")
endif
set dvn=wYa(nZ[C8n],dZ[C8n],Tbx(RZ[C8n],"when calling get in GamecacheBuffer, line 80"))
set EM=EM-1
return dvn
endfunction
function den takes integer dxn,string don returns integer
local integer drn
set ZM[EM]=don
set EM=EM+1
if Bg[dxn]==0 then
if dxn==0 then
call Cdv("Nullpointer exception when calling GamecacheBuffer.readInt","when calling error in GamecacheBuffer, line 75")
else
call Cdv("Called GamecacheBuffer.readInt on invalid object.","when calling error in GamecacheBuffer, line 75")
endif
endif
set drn=C7n(dxn,"when calling readInt in GamecacheBuffer, line 75")
set EM=EM-1
return drn
endfunction
function din takes integer dan,string dnn returns nothing
set ZM[EM]=dnn
set EM=EM+1
call uae(QP[bA[dan]],den(ZP[bA[dan]],"when calling readInt in NetworkData, line 352"),"when calling writeInt in NetworkData, line 352")
set VP[bA[dan]]=VP[bA[dan]]+1
set EM=EM-1
endfunction
function dVn takes gamecache dEn,string dXn,string dOn,real dRn returns nothing
call StoreReal(dEn,dXn,dOn,dRn)
endfunction
function dIn takes integer dAn,string dNn returns nothing
set ZM[EM]=dNn
set EM=EM+1
if Ca and fZ[dAn]+1>=ee then
call Cdv("GamecacheBuffer: trying to write out of available keys bounds","when calling error in GamecacheBuffer, line 52")
endif
set fZ[dAn]=fZ[dAn]+1
set EM=EM-1
endfunction
function dbn takes integer dBn,string dcn returns nothing
set ZM[EM]=dcn
set EM=EM+1
if Bg[dBn]==0 then
if dBn==0 then
call Cdv("Nullpointer exception when calling GamecacheBuffer.advanceWriteIndex","when calling error in GamecacheBuffer, line 50")
else
call Cdv("Called GamecacheBuffer.advanceWriteIndex on invalid object.","when calling error in GamecacheBuffer, line 50")
endif
endif
call dIn(dBn,"when calling advanceWriteIndex in GamecacheBuffer, line 50")
set EM=EM-1
endfunction
function dCn takes integer ddn,real dDn,string dfn returns nothing
set ZM[EM]=dfn
set EM=EM+1
call dbn(ddn,"when calling advanceWriteIndex in GamecacheBuffer, line 66")
call C_n(ddn,1,"when calling checkType in GamecacheBuffer, line 67")
call dVn(nZ[ddn],dZ[ddn],Tbx(fZ[ddn],"when calling get in GamecacheBuffer, line 68"),dDn)
set EM=EM-1
endfunction
function dFn takes integer dgn,real dGn,string dhn returns nothing
set ZM[EM]=dhn
set EM=EM+1
if Bg[dgn]==0 then
if dgn==0 then
call Cdv("Nullpointer exception when calling GamecacheBuffer.writeReal","when calling error in GamecacheBuffer, line 65")
else
call Cdv("Called GamecacheBuffer.writeReal on invalid object.","when calling error in GamecacheBuffer, line 65")
endif
endif
call dCn(dgn,dGn,"when calling writeReal in GamecacheBuffer, line 65")
set EM=EM-1
endfunction
function dHn takes integer djn,string dJn returns nothing
set ZM[EM]=dJn
set EM=EM+1
call dFn(UP[pA[djn]],dmx(WP[pA[djn]],"when calling readRealUnchecked in NetworkData, line 358"),"when calling writeReal in NetworkData, line 358")
set BP[pA[djn]]=BP[pA[djn]]+1
set EM=EM-1
endfunction
function dkn takes integer dKn,string dln returns string
local string dLn
set ZM[EM]=dln
set EM=EM+1
set dLn=G7v(LZ[dKn],VZ[dKn],"when calling loadString in HashData, line 191")
set VZ[dKn]=VZ[dKn]+1
set EM=EM-1
return dLn
endfunction
function dmn takes integer dMn,string dpn returns string
local string dPn
set ZM[EM]=dpn
set EM=EM+1
if gY[dMn]==0 then
if dMn==0 then
call Cdv("Nullpointer exception when calling HashReader.readStringUnchecked","when calling error in HashData, line 190")
else
call Cdv("Called HashReader.readStringUnchecked on invalid object.","when calling error in HashData, line 190")
endif
endif
set dPn=dkn(dMn,"when calling readStringUnchecked in HashData, line 190")
set EM=EM-1
return dPn
endfunction
function dqn takes integer dQn,string dsn returns string
local string dSn
set ZM[EM]=dsn
set EM=EM+1
call cjx(dQn,2,"when calling validateType in HashData, line 186")
set dSn=dmn(dQn,"when calling readStringUnchecked in HashData, line 187")
set EM=EM-1
return dSn
endfunction
function dtn takes integer dTn,string dun returns string
local string dUn
set ZM[EM]=dun
set EM=EM+1
if gY[dTn]==0 then
if dTn==0 then
call Cdv("Nullpointer exception when calling HashReader.readString","when calling error in HashData, line 185")
else
call Cdv("Called HashReader.readString on invalid object.","when calling error in HashData, line 185")
endif
endif
set dUn=dqn(dTn,"when calling readString in HashData, line 185")
set EM=EM-1
return dUn
endfunction
function dwn takes integer dWn,string dyn returns string
local string dYn
set ZM[EM]=dyn
set EM=EM+1
set dYn=dtn(EX[dWn],"when calling readString in StringEncoder, line 120")
set EM=EM-1
return dYn
endfunction
function dzn takes integer dZn,string d_n returns string
local string d0n
set ZM[EM]=d_n
set EM=EM+1
if Ov[dZn]==0 then
if dZn==0 then
call Cdv("Nullpointer exception when calling StringEncoder.popString","when calling error in StringEncoder, line 119")
else
call Cdv("Called StringEncoder.popString on invalid object.","when calling error in StringEncoder, line 119")
endif
endif
set d0n=dwn(dZn,"when calling popString in StringEncoder, line 119")
set EM=EM-1
return d0n
endfunction
function d1n takes integer d2n,string d3n returns nothing
set ZM[EM]=d3n
set EM=EM+1
call R4n(vA[RD[d2n]],dzn(mA[RD[d2n]],"when calling popString in Network, line 461"),"when calling writeString in Network, line 461")
set EM=EM-1
endfunction
function d4n takes integer d5n,integer d6n,string d7n returns nothing
set ZM[EM]=d7n
set EM=EM+1
call dbn(d5n,"when calling advanceWriteIndex in GamecacheBuffer, line 61")
call C_n(d5n,0,"when calling checkType in GamecacheBuffer, line 62")
call thx(nZ[d5n],dZ[d5n],Tbx(fZ[d5n],"when calling get in GamecacheBuffer, line 63"),d6n)
set EM=EM-1
endfunction
function d8n takes integer d9n,integer Dvn,string Den returns nothing
set ZM[EM]=Den
set EM=EM+1
if Bg[d9n]==0 then
if d9n==0 then
call Cdv("Nullpointer exception when calling GamecacheBuffer.writeInt","when calling error in GamecacheBuffer, line 60")
else
call Cdv("Called GamecacheBuffer.writeInt on invalid object.","when calling error in GamecacheBuffer, line 60")
endif
endif
call d4n(d9n,Dvn,"when calling writeInt in GamecacheBuffer, line 60")
set EM=EM-1
endfunction
function Dxn takes integer Don,string Drn returns integer
local integer Din
set ZM[EM]=Drn
set EM=EM+1
call tna(Don,"when calling checkRead in HashBuffer, line 89")
set PZ[Don]=PZ[Don]+1
if Ca and(not D3v(WZ[Don],PZ[Don],"when calling hasInt in HashBuffer, line 91"))then
call Cdv("HashBuffer: trying to read non-present int at pos#"+SMv(PZ[Don]),"when calling error in HashBuffer, line 92")
endif
set Din=fwv(WZ[Don],PZ[Don],"when calling loadInt in HashBuffer, line 93")
set EM=EM-1
return Din
endfunction
function Dan takes integer Dnn,string DVn returns integer
local integer DEn
set ZM[EM]=DVn
set EM=EM+1
if OG[Dnn]==0 then
if Dnn==0 then
call Cdv("Nullpointer exception when calling HashBuffer.readIntUnsafe","when calling error in HashBuffer, line 88")
else
call Cdv("Called HashBuffer.readIntUnsafe on invalid object.","when calling error in HashBuffer, line 88")
endif
endif
set DEn=Dxn(Dnn,"when calling readIntUnsafe in HashBuffer, line 88")
set EM=EM-1
return DEn
endfunction
function DXn takes integer DOn,string DRn returns nothing
set ZM[EM]=DRn
set EM=EM+1
call d8n(QA[rD[DOn]],Dan(vA[rD[DOn]],"when calling readIntUnsafe in Network, line 337"),"when calling writeInt in Network, line 337")
set LA[rD[DOn]]=LA[rD[DOn]]+1
set EM=EM-1
endfunction
function DIn takes integer DAn,string DNn returns integer
local integer Dbn
set ZM[EM]=DNn
set EM=EM+1
if ih[DAn]==0 then
if DAn==0 then
call Cdv("Nullpointer exception when calling HLIterator.next","when calling error in HashList, line 138")
else
call Cdv("Called HLIterator.next on invalid object.","when calling error in HashList, line 138")
endif
endif
set Dbn=jTv(DAn,"when calling next in HashList, line 138")
set EM=EM-1
return Dbn
endfunction
function DBn takes integer Dcn,integer DCn,string Ddn returns integer
local integer DDn
set ZM[EM]=Ddn
set EM=EM+1
set DDn=jqv(dH[Dcn],DCn,"when calling get in RawcodeTable, line 59")
set EM=EM-1
return DDn
endfunction
function Dfn takes integer DFn,integer Dgn,string DGn returns integer
local integer Dhn
set ZM[EM]=DGn
set EM=EM+1
if Gg[DFn]==0 then
if DFn==0 then
call Cdv("Nullpointer exception when calling RawcodeTable.getRawcode","when calling error in RawcodeTable, line 58")
else
call Cdv("Called RawcodeTable.getRawcode on invalid object.","when calling error in RawcodeTable, line 58")
endif
endif
set Dhn=DBn(DFn,Dgn,"when calling getRawcode in RawcodeTable, line 58")
set EM=EM-1
return Dhn
endfunction
function DHn takes integer Djn returns real
local real DJn=GH[Djn]
local real Dkn=gH[Djn]
local real DKn=DJn
local real Dln=Dkn
set GH[Djn]=GH[Djn]+128.
if GH[Djn]>TH[Djn]then
set GH[Djn]=fH[Djn]
set gH[Djn]=gH[Djn]+128.
endif
call lUx("("+qwv(GH[Djn])+", "+qwv(gH[Djn])+")")
set D9=DKn
set H9=Dln
return D9
endfunction
function DLn takes integer Dmn,string DMn returns real
local real Dpn
local real DPn
local real Dqn
local real DQn
set ZM[EM]=DMn
set EM=EM+1
if Pk[Dmn]==0 then
if Dmn==0 then
call Cdv("Nullpointer exception when calling RectCellIterator.next","when calling error in RectCellIterator, line 20")
else
call Cdv("Called RectCellIterator.next on invalid object.","when calling error in RectCellIterator, line 20")
endif
endif
set Dqn=DHn(Dmn)
set DQn=H9
set Dpn=Dqn
set DPn=DQn
set EM=EM-1
set zB=Dpn
set zc=DPn
return zB
endfunction
function Dsn takes integer DSn,string Dtn returns nothing
local real DTn
local real Dun
local integer DUn
local integer Dwn
local integer DWn
local real Dyn
local real DYn
set ZM[EM]=Dtn
set EM=EM+1
set Dyn=DLn(xC[DSn],"when calling next in TerrainData, line 77")
set DYn=zc
set DTn=Dyn
set Dun=DYn
set DUn=Dfn(aC[vC[DSn]],DIn(mC[DSn],"when calling next in TerrainData, line 78"),"when calling getRawcode in TerrainData, line 78")
if QC[DSn]then
set DWn=DIn(WC[DSn],"when calling next in TerrainData, line 79")
else
set DWn=-1
endif
set Dwn=DWn
call SetTerrainType(DTn,Dun,DUn,Dwn,1,1)
set EM=EM-1
endfunction
function Dzn takes integer DZn,string D_n returns integer
local integer D0n
set ZM[EM]=D_n
set EM=EM+1
set D0n=cpx(EX[DZn],"when calling readIntUnchecked in StringEncoder, line 126")
set EM=EM-1
return D0n
endfunction
function D1n takes integer D2n,string D3n returns integer
local integer D4n
set ZM[EM]=D3n
set EM=EM+1
if Ov[D2n]==0 then
if D2n==0 then
call Cdv("Nullpointer exception when calling StringEncoder.popInt","when calling error in StringEncoder, line 125")
else
call Cdv("Called StringEncoder.popInt on invalid object.","when calling error in StringEncoder, line 125")
endif
endif
set D4n=Dzn(D2n,"when calling popInt in StringEncoder, line 125")
set EM=EM-1
return D4n
endfunction
function D5n takes integer D6n,string D7n returns nothing
set ZM[EM]=D7n
set EM=EM+1
call d8n(PP[TA[D6n]],D1n(EP[TA[D6n]],"when calling popInt in NetworkData, line 382"),"when calling writeInt in NetworkData, line 382")
set MP[TA[D6n]]=MP[TA[D6n]]+1
set EM=EM-1
endfunction
function D8n takes integer D9n,integer fvn returns boolean
return CYv(XR,D9n,fvn)
endfunction
function fen takes integer fxn,integer fon,string frn returns boolean
local boolean fin
set ZM[EM]=frn
set EM=EM+1
if ph[fxn]==0 then
if fxn==0 then
call Cdv("Nullpointer exception when calling Table.hasReal","when calling error in Table, line 12")
else
call Cdv("Called Table.hasReal on invalid object.","when calling error in Table, line 12")
endif
endif
set fin=D8n(fxn,fon)
set EM=EM-1
return fin
endfunction
function fan takes integer fnn,string fVn returns real
local real fEn
set ZM[EM]=fVn
set EM=EM+1
call tna(fnn,"when calling checkRead in HashBuffer, line 96")
set AZ[fnn]=AZ[fnn]+1
if Ca and(not fen(WZ[fnn],AZ[fnn],"when calling hasReal in HashBuffer, line 98"))then
call Cdv("HashBuffer: trying to read non-present real at pos#"+SMv(AZ[fnn]),"when calling error in HashBuffer, line 99")
endif
set fEn=dGx(WZ[fnn],AZ[fnn],"when calling loadReal in HashBuffer, line 100")
set EM=EM-1
return fEn
endfunction
function fXn takes integer fOn,string fRn returns real
local real fIn
set ZM[EM]=fRn
set EM=EM+1
if OG[fOn]==0 then
if fOn==0 then
call Cdv("Nullpointer exception when calling HashBuffer.readRealUnsafe","when calling error in HashBuffer, line 95")
else
call Cdv("Called HashBuffer.readRealUnsafe on invalid object.","when calling error in HashBuffer, line 95")
endif
endif
set fIn=fan(fOn,"when calling readRealUnsafe in HashBuffer, line 95")
set EM=EM-1
return fIn
endfunction
function fAn takes integer fNn,string fbn returns nothing
set ZM[EM]=fbn
set EM=EM+1
call dFn(WA[SD[fNn]],fXn(vA[SD[fNn]],"when calling readRealUnsafe in Network, line 349"),"when calling writeReal in Network, line 349")
set XA[SD[fNn]]=XA[SD[fNn]]+1
set EM=EM-1
endfunction
function fBn takes integer fcn,string fCn,string fdn returns nothing
set ZM[EM]=fdn
set EM=EM+1
call Kxv(rU[fcn],iU[fcn],fCn,"when calling saveString in HashData, line 39")
set iU[fcn]=iU[fcn]+1
set EM=EM-1
endfunction
function fDn takes integer ffn,string fFn,string fgn returns nothing
set ZM[EM]=fgn
set EM=EM+1
if jY[ffn]==0 then
if ffn==0 then
call Cdv("Nullpointer exception when calling HashWriter.writeString","when calling error in HashData, line 38")
else
call Cdv("Called HashWriter.writeString on invalid object.","when calling error in HashData, line 38")
endif
endif
call fBn(ffn,fFn,"when calling writeString in HashData, line 38")
set EM=EM-1
endfunction
function fGn takes integer fhn,string fHn returns nothing
set ZM[EM]=fHn
set EM=EM+1
call fDn(QP[kA[fhn]],dzn(EP[kA[fhn]],"when calling popString in NetworkData, line 451"),"when calling writeString in NetworkData, line 451")
set EM=EM-1
endfunction
function fjn takes integer fJn,string fkn returns integer
local integer fKn
set ZM[EM]=fkn
set EM=EM+1
set fKn=tFa(fJn,"when calling popTypeIdentifier in OrderedStringBuffer, line 170")
set hX[fJn]=tXa(fKn,"when calling toString in OrderedStringBuffer, line 172")+hX[fJn]
set EM=EM-1
return fKn
endfunction
function fln takes integer fLn,string fmn returns integer
local integer fMn
set ZM[EM]=fmn
set EM=EM+1
if OG[fLn]==0 then
if fLn==0 then
call Cdv("Nullpointer exception when calling OrderedStringBuffer.peekType","when calling error in OrderedStringBuffer, line 169")
else
call Cdv("Called OrderedStringBuffer.peekType on invalid object.","when calling error in OrderedStringBuffer, line 169")
endif
endif
set fMn=fjn(fLn,"when calling peekType in OrderedStringBuffer, line 169")
set EM=EM-1
return fMn
endfunction
function fpn takes integer fPn,string fqn returns string
local string fQn
set ZM[EM]=fqn
set EM=EM+1
call SNa(fPn,"when calling checkDataAvailable in StringBuffer, line 126")
set fQn=hX[fPn]
set hX[fPn]=""
call Sla(fPn,"when calling nextChunk in StringBuffer, line 129")
set EM=EM-1
return fQn
endfunction
function fsn takes integer fSn,string ftn returns string
local string fTn
set ZM[EM]=ftn
set EM=EM+1
if OG[fSn]==0 then
if fSn==0 then
call Cdv("Nullpointer exception when calling AbstractStringBuffer.popAll","when calling error in StringBuffer, line 125")
else
call Cdv("Called AbstractStringBuffer.popAll on invalid object.","when calling error in StringBuffer, line 125")
endif
endif
set fTn=fpn(fSn,"when calling popAll in StringBuffer, line 125")
set EM=EM-1
return fTn
endfunction
function fun takes integer fUn,string fwn,string fWn returns string
local string fyn
local integer fYn
set ZM[EM]=fWn
set EM=EM+1
set fyn=""
set fYn=-1
loop
exitwhen not(fYn<0)
if GZv(fyn)>kR then
call s9a(fUn,3,"failed to find terminator character","when calling fail in StringBuffer, line 140")
set EM=EM-1
return null
endif
set fYn=h9e(hX[fUn],fwn)
if fYn<0 then
set fyn=fyn+fsn(fUn,"when calling popAll in StringBuffer, line 149")
else
set fyn=fyn+Psv(hX[fUn],0,fYn)
set hX[fUn]=Tgv(hX[fUn],fYn+1)
endif
endloop
set EM=EM-1
return fyn
endfunction
function fzn takes integer fZn,string f_n,string f0n returns string
local string f1n
set ZM[EM]=f0n
set EM=EM+1
if OG[fZn]==0 then
if fZn==0 then
call Cdv("Nullpointer exception when calling AbstractStringBuffer.popStringUntil","when calling error in StringBuffer, line 133")
else
call Cdv("Called AbstractStringBuffer.popStringUntil on invalid object.","when calling error in StringBuffer, line 133")
endif
endif
set f1n=fun(fZn,f_n,"when calling popStringUntil in StringBuffer, line 133")
set EM=EM-1
return f1n
endfunction
function f2n takes integer f3n,string f4n returns real
local real f5n
local real f6n
set ZM[EM]=f4n
set EM=EM+1
call tna(f3n,"when calling checkRead in OrderedStringBuffer, line 150")
if tla(f3n,1,"when calling checkType in OrderedStringBuffer, line 151")then
set f5n=d7v(fzn(f3n,mq,"when calling popStringUntil in OrderedStringBuffer, line 151"))
else
set f5n=.0
endif
set f6n=f5n
set EM=EM-1
return f6n
endfunction
function f7n takes integer f8n,string f9n returns real
local real Fvn
set ZM[EM]=f9n
set EM=EM+1
if OG[f8n]==0 then
if f8n==0 then
call Cdv("Nullpointer exception when calling OrderedStringBuffer.readReal","when calling error in OrderedStringBuffer, line 149")
else
call Cdv("Called OrderedStringBuffer.readReal on invalid object.","when calling error in OrderedStringBuffer, line 149")
endif
endif
set Fvn=f2n(f8n,"when calling readReal in OrderedStringBuffer, line 149")
set EM=EM-1
return Fvn
endfunction
function Fen takes integer Fxn,string Fon returns integer
local integer Frn
set ZM[EM]=Fon
set EM=EM+1
set Frn=uqv(fzn(Fxn,mq,"when calling popStringUntil in OrderedStringBuffer, line 143"))
set EM=EM-1
return Frn
endfunction
function Fin takes integer Fan,string Fnn returns integer
local integer FVn
set ZM[EM]=Fnn
set EM=EM+1
if OG[Fan]==0 then
if Fan==0 then
call Cdv("Nullpointer exception when calling OrderedStringBuffer.readIntInternal","when calling error in OrderedStringBuffer, line 142")
else
call Cdv("Called OrderedStringBuffer.readIntInternal on invalid object.","when calling error in OrderedStringBuffer, line 142")
endif
endif
set FVn=Fen(Fan,"when calling readIntInternal in OrderedStringBuffer, line 142")
set EM=EM-1
return FVn
endfunction
function FEn takes integer FXn,string FOn returns integer
local integer FRn
local integer FIn
set ZM[EM]=FOn
set EM=EM+1
call tna(FXn,"when calling checkRead in OrderedStringBuffer, line 146")
if tla(FXn,0,"when calling checkType in OrderedStringBuffer, line 147")then
set FRn=Fin(FXn,"when calling readIntInternal in OrderedStringBuffer, line 147")
else
set FRn=0
endif
set FIn=FRn
set EM=EM-1
return FIn
endfunction
function FAn takes integer FNn,string Fbn returns integer
local integer FBn
set ZM[EM]=Fbn
set EM=EM+1
if OG[FNn]==0 then
if FNn==0 then
call Cdv("Nullpointer exception when calling OrderedStringBuffer.readInt","when calling error in OrderedStringBuffer, line 145")
else
call Cdv("Called OrderedStringBuffer.readInt on invalid object.","when calling error in OrderedStringBuffer, line 145")
endif
endif
set FBn=FEn(FNn,"when calling readInt in OrderedStringBuffer, line 145")
set EM=EM-1
return FBn
endfunction
function Fcn takes integer FCn,string Fdn returns string
local string FDn
local integer Ffn
set ZM[EM]=Fdn
set EM=EM+1
call tna(FCn,"when calling checkRead in OrderedStringBuffer, line 154")
set FDn=null
if tla(FCn,2,"when calling checkType in OrderedStringBuffer, line 156")then
set Ffn=Fin(FCn,"when calling readIntInternal in OrderedStringBuffer, line 157")
if Ffn<0 or Ffn>kR then
call s9a(FCn,3,"tried to read string of length "+SMv(Ffn)+", but max is "+SMv(kR),"when calling fail in OrderedStringBuffer, line 159")
else
set FDn=Swa(FCn,Ffn,"when calling popString in OrderedStringBuffer, line 162")
endif
endif
set EM=EM-1
return FDn
endfunction
function FFn takes integer Fgn,string FGn returns string
local string Fhn
set ZM[EM]=FGn
set EM=EM+1
if OG[Fgn]==0 then
if Fgn==0 then
call Cdv("Nullpointer exception when calling OrderedStringBuffer.readString","when calling error in OrderedStringBuffer, line 153")
else
call Cdv("Called OrderedStringBuffer.readString on invalid object.","when calling error in OrderedStringBuffer, line 153")
endif
endif
set Fhn=Fcn(Fgn,"when calling readString in OrderedStringBuffer, line 153")
set EM=EM-1
return Fhn
endfunction
function FHn takes integer Fjn,string FJn returns boolean
local boolean Fkn
set ZM[EM]=FJn
set EM=EM+1
if OG[Fjn]==0 then
if Fjn==0 then
call Cdv("Nullpointer exception when calling OrderedStringBuffer.readBoolean","when calling error in OrderedStringBuffer, line 165")
else
call Cdv("Called OrderedStringBuffer.readBoolean on invalid object.","when calling error in OrderedStringBuffer, line 165")
endif
endif
set Fkn=tPa(Fjn,"when calling readBoolean in OrderedStringBuffer, line 165")
set EM=EM-1
return Fkn
endfunction
function FKn takes integer Fln,real FLn,string Fmn returns nothing
set ZM[EM]=Fmn
set EM=EM+1
call Rzn(Fln,"when calling checkWrite in HashBuffer, line 36")
set ZZ[Fln]=ZZ[Fln]+1
call yle(WZ[Fln],ZZ[Fln],FLn,"when calling saveReal in HashBuffer, line 38")
set EM=EM-1
endfunction
function FMn takes integer Fpn,real FPn,string Fqn returns nothing
set ZM[EM]=Fqn
set EM=EM+1
if OG[Fpn]==0 then
if Fpn==0 then
call Cdv("Nullpointer exception when calling HashBuffer.writeReal","when calling error in HashBuffer, line 35")
else
call Cdv("Called HashBuffer.writeReal on invalid object.","when calling error in HashBuffer, line 35")
endif
endif
call FKn(Fpn,FPn,"when calling writeReal in HashBuffer, line 35")
set EM=EM-1
endfunction
function FQn takes integer Fsn,integer FSn,string Ftn returns nothing
set ZM[EM]=Ftn
set EM=EM+1
call Rzn(Fsn,"when calling checkWrite in HashBuffer, line 31")
set EZ[Fsn]=EZ[Fsn]+1
call Dyv(WZ[Fsn],EZ[Fsn],FSn,"when calling saveInt in HashBuffer, line 33")
set EM=EM-1
endfunction
function FTn takes integer Fun,integer FUn,string Fwn returns nothing
set ZM[EM]=Fwn
set EM=EM+1
if OG[Fun]==0 then
if Fun==0 then
call Cdv("Nullpointer exception when calling HashBuffer.writeInt","when calling error in HashBuffer, line 30")
else
call Cdv("Called HashBuffer.writeInt on invalid object.","when calling error in HashBuffer, line 30")
endif
endif
call FQn(Fun,FUn,"when calling writeInt in HashBuffer, line 30")
set EM=EM-1
endfunction
function FWn takes integer Fyn,integer FYn,string Fzn returns nothing
local integer FZn
local integer F_n
set ZM[EM]=Fzn
set EM=EM+1
set FZn=fln(Fyn,"when calling peekType in BufferAdapters, line 7")
set F_n=FZn
if F_n==0 then
call FTn(FYn,FAn(Fyn,"when calling readInt in BufferAdapters, line 11"),"when calling writeInt in BufferAdapters, line 11")
elseif F_n==1 then
call FMn(FYn,f7n(Fyn,"when calling readReal in BufferAdapters, line 13"),"when calling writeReal in BufferAdapters, line 13")
elseif F_n==2 then
call R4n(FYn,FFn(Fyn,"when calling readString in BufferAdapters, line 15"),"when calling writeString in BufferAdapters, line 15")
elseif F_n==3 then
call Ayn(FYn,FHn(Fyn,"when calling readBoolean in BufferAdapters, line 17"),"when calling writeBoolean in BufferAdapters, line 17")
endif
set EM=EM-1
endfunction
function F0n takes integer F1n,string F2n returns nothing
set ZM[EM]=F2n
set EM=EM+1
call FWn(WQ[F1n],EQ[F1n],"when calling transferValueTo in BufferAdapters, line 22")
set EM=EM-1
endfunction
function F3n takes gamecache F4n,string F5n,string F6n returns real
return GetStoredReal(F4n,F5n,F6n)
endfunction
function F7n takes gamecache F8n,string F9n,string gvn returns boolean
return HaveStoredReal(F8n,F9n,gvn)
endfunction
function gen takes integer gxn,string gon returns real
local real grn
set ZM[EM]=gon
set EM=EM+1
call CUn(gxn,"when calling advanceReadIndex in GamecacheBuffer, line 83")
call C_n(gxn,1,"when calling checkType in GamecacheBuffer, line 84")
if not F7n(nZ[gxn],dZ[gxn],Tbx(RZ[gxn],"when calling get in GamecacheBuffer, line 85"))then
call Cdv("GamecacheBuffer: trying to read non-present real #"+SMv(RZ[gxn]),"when calling error in GamecacheBuffer, line 86")
endif
set grn=F3n(nZ[gxn],dZ[gxn],Tbx(RZ[gxn],"when calling get in GamecacheBuffer, line 87"))
set EM=EM-1
return grn
endfunction
function gin takes integer gan,string gnn returns real
local real gVn
set ZM[EM]=gnn
set EM=EM+1
if Bg[gan]==0 then
if gan==0 then
call Cdv("Nullpointer exception when calling GamecacheBuffer.readReal","when calling error in GamecacheBuffer, line 82")
else
call Cdv("Called GamecacheBuffer.readReal on invalid object.","when calling error in GamecacheBuffer, line 82")
endif
endif
set gVn=gen(gan,"when calling readReal in GamecacheBuffer, line 82")
set EM=EM-1
return gVn
endfunction
function gEn takes integer gXn,string gOn returns nothing
set ZM[EM]=gOn
set EM=EM+1
call FMn(vA[oD[gXn]],gin(WA[oD[gXn]],"when calling readReal in Network, line 355"),"when calling writeReal in Network, line 355")
set XA[oD[gXn]]=XA[oD[gXn]]+1
set EM=EM-1
endfunction
function gRn takes integer gIn,string gAn returns string
local string gNn
set ZM[EM]=gAn
set EM=EM+1
set gNn=AVn(fP[gIn],"when calling readString in MultifileIO, line 253")
set EM=EM-1
return gNn
endfunction
function gbn takes integer gBn,string gcn returns string
local string gCn
set ZM[EM]=gcn
set EM=EM+1
if PF[gBn]==0 then
if gBn==0 then
call Cdv("Nullpointer exception when calling FileReader.readLine","when calling error in MultifileIO, line 252")
else
call Cdv("Called FileReader.readLine on invalid object.","when calling error in MultifileIO, line 252")
endif
endif
set gCn=gRn(gBn,"when calling readLine in MultifileIO, line 252")
set EM=EM-1
return gCn
endfunction
function gdn takes string gDn returns integer
local integer gfn
set ZM[EM]=gDn
set EM=EM+1
if sv==0 then
if tv<$8000 then
set tv=tv+1
set gfn=tv
set iv[gfn]=$4D5
else
call Cdv("Out of memory: Could not create ChunkElement.","when calling error in StringBuffer, line 7")
set gfn=0
endif
else
set sv=sv-1
set gfn=rv[sv]
set iv[gfn]=$4D5
endif
set EM=EM-1
return gfn
endfunction
function gFn takes integer ggn returns nothing
set jX[ggn]=""
endfunction
function gGn takes integer ghn,string gHn returns nothing
call gFn(ghn)
set jX[ghn]=gHn
endfunction
function gjn takes string gJn,string gkn returns integer
local integer gKn
set ZM[EM]=gkn
set EM=EM+1
set gKn=gdn("when calling alloc_ChunkElement in StringBuffer, line 10")
call gGn(gKn,gJn)
set EM=EM-1
return gKn
endfunction
function gln takes integer gLn,string gmn,string gMn returns nothing
set ZM[EM]=gMn
set EM=EM+1
call lIe(gX[gLn],gjn(gmn,"when calling new_ChunkElement in StringBuffer, line 186"),"when calling push in StringBuffer, line 186")
set EM=EM-1
endfunction
function gpn takes integer gPn,string gqn,string gQn returns nothing
set ZM[EM]=gQn
set EM=EM+1
if OG[gPn]==0 then
if gPn==0 then
call Cdv("Nullpointer exception when calling AbstractStringBuffer.pushChunk","when calling error in StringBuffer, line 185")
else
call Cdv("Called AbstractStringBuffer.pushChunk on invalid object.","when calling error in StringBuffer, line 185")
endif
endif
call gln(gPn,gqn,"when calling pushChunk in StringBuffer, line 185")
set EM=EM-1
endfunction
function gsn takes integer gSn,string gtn returns nothing
set ZM[EM]=gtn
set EM=EM+1
call gpn(UQ[gSn],gbn(IQ[gSn],"when calling readLine in BufferAdapters, line 26"),"when calling pushChunk in BufferAdapters, line 26")
set EM=EM-1
endfunction
function gTn takes integer gun,string gUn returns nothing
local real gwn
local real gWn
local integer gyn
local integer gYn
local real gzn
local real gZn
local integer g_n
set ZM[EM]=gUn
set EM=EM+1
set gzn=DLn(hC[gun],"when calling next in TerrainData, line 59")
set gZn=zc
set gwn=gzn
set gWn=gZn
set gYn=YC[FC[gun]]
set g_n=Fav(aC[FC[gun]],GetTerrainType(gwn,gWn),"when calling addRawcode in TerrainData, line 60")
set gyn=g_n
call dlv(gYn,gyn,"when calling add in TerrainData, line 60")
if kC[gun]then
call dlv(GC[FC[gun]],GetTerrainVariance(gwn,gWn),"when calling add in TerrainData, line 62")
endif
set EM=EM-1
endfunction
function g0n takes gamecache g1n,string g2n,string g3n,boolean g4n returns nothing
call StoreBoolean(g1n,g2n,g3n,g4n)
endfunction
function g5n takes integer g6n,boolean g7n,string g8n returns nothing
set ZM[EM]=g8n
set EM=EM+1
call dbn(g6n,"when calling advanceWriteIndex in GamecacheBuffer, line 71")
call C_n(g6n,2,"when calling checkType in GamecacheBuffer, line 72")
call g0n(nZ[g6n],dZ[g6n],Tbx(fZ[g6n],"when calling get in GamecacheBuffer, line 73"),g7n)
set EM=EM-1
endfunction
function g9n takes integer Gvn,boolean Gen,string Gxn returns nothing
set ZM[EM]=Gxn
set EM=EM+1
if Bg[Gvn]==0 then
if Gvn==0 then
call Cdv("Nullpointer exception when calling GamecacheBuffer.writeBoolean","when calling error in GamecacheBuffer, line 70")
else
call Cdv("Called GamecacheBuffer.writeBoolean on invalid object.","when calling error in GamecacheBuffer, line 70")
endif
endif
call g5n(Gvn,Gen,"when calling writeBoolean in GamecacheBuffer, line 70")
set EM=EM-1
endfunction
function Gon takes integer Grn,string Gin returns nothing
set ZM[EM]=Gin
set EM=EM+1
call g9n(IP[nA[Grn]],Csx(WP[nA[Grn]],"when calling readBooleanUnchecked in NetworkData, line 370"),"when calling writeBoolean in NetworkData, line 370")
set NP[nA[Grn]]=NP[nA[Grn]]+1
set EM=EM-1
endfunction
function Gan takes integer Gnn,integer GVn returns integer
return Ita(Gnn,GVn)
endfunction
function GEn takes integer GXn,string GOn,string GRn returns nothing
set ZM[EM]=GRn
set EM=EM+1
set vQ[GXn]=vQ[GXn]+1
if GZv(kQ[GXn])>=xQ[GXn]then
call lIe(FQ[GXn],Xjn(kQ[GXn],"when calling new_BigStringElement in BigString, line 108"),"when calling push in BigString, line 108")
set kQ[GXn]=GOn
else
set kQ[GXn]=kQ[GXn]+GOn
endif
set EM=EM-1
endfunction
function GIn takes integer GAn,string GNn,string Gbn returns nothing
set ZM[EM]=Gbn
set EM=EM+1
if uG[GAn]==0 then
if GAn==0 then
call Cdv("Nullpointer exception when calling BigString.appendChar","when calling error in BigString, line 104")
else
call Cdv("Called BigString.appendChar on invalid object.","when calling error in BigString, line 104")
endif
endif
call GEn(GAn,GNn,"when calling appendChar in BigString, line 104")
set EM=EM-1
endfunction
function GBn takes integer Gcn,string GCn,string Gdn returns nothing
set ZM[EM]=Gdn
set EM=EM+1
call GIn(YQ[Gcn],GCn,"when calling appendChar in Base64, line 103")
set EM=EM-1
endfunction
function GDn takes integer Gfn,string GFn,string Ggn returns nothing
set ZM[EM]=Ggn
set EM=EM+1
if LY[Gfn]==0 then
if Gfn==0 then
call Cdv("Nullpointer exception when calling Base64Encoder.append","when calling error in Base64, line 102")
else
call Cdv("Called Base64Encoder.append on invalid object.","when calling error in Base64, line 102")
endif
endif
call GBn(Gfn,GFn,"when calling append in Base64, line 102")
set EM=EM-1
endfunction
function GGn takes integer Ghn,integer GHn returns integer
return jy[Ghn*16+GHn]
endfunction
function Gjn takes integer GJn,integer Gkn returns integer
return GGn(Fy[GJn],Fy[Gkn])*16+GGn(ky[GJn],ky[Gkn])
endfunction
function GKn takes integer Gln,integer GLn returns integer
local integer Gmn=Uee(Gln)
local integer GMn=BM
local integer Gpn=NM
local integer GPn=MM
local integer Gqn=Gmn
local integer GQn=GMn
local integer Gsn=Gpn
local integer GSn=GPn
local integer Gtn=Uee(GLn)
local integer GTn=BM
local integer Gun=NM
local integer GUn=MM
local integer Gwn=Gtn
local integer GWn=GTn
local integer Gyn=Gun
local integer GYn=GUn
return t1e(Gjn(Gqn,Gwn),Gjn(GQn,GWn),Gjn(Gsn,Gyn),Gjn(GSn,GYn))
endfunction
function Gzn takes integer GZn,integer G_n returns integer
return GKn(GZn,G_n)
endfunction
function G0n takes integer G1n,integer G2n,integer G3n,string G4n returns nothing
local integer G5n
local integer G6n
local integer G7n
local integer G8n
set ZM[EM]=G4n
set EM=EM+1
set G5n=G2n
set G6n=0
set G7n=G3n
loop
exitwhen G6n>G7n
set G8n=Gan(Gzn(G5n,$FC0000),18)
call GDn(G1n,ay[G8n],"when calling append in Base64, line 110")
set G5n=C4x(G5n,6)
set G6n=G6n+1
endloop
set EM=EM-1
endfunction
function G9n takes integer hvn,integer hen,integer hxn,string hon returns nothing
set ZM[EM]=hon
set EM=EM+1
if LY[hvn]==0 then
if hvn==0 then
call Cdv("Nullpointer exception when calling Base64Encoder.encodeSingle","when calling error in Base64, line 105")
else
call Cdv("Called Base64Encoder.encodeSingle on invalid object.","when calling error in Base64, line 105")
endif
endif
call G0n(hvn,hen,hxn,"when calling encodeSingle in Base64, line 105")
set EM=EM-1
endfunction
function hrn takes integer hin,string han returns nothing
local integer hnn
local integer hVn
local integer hEn
local integer hXn
set ZM[EM]=han
set EM=EM+1
set hnn=Cbx(GQ[hin],"when calling readByte in Base64, line 114")
set hVn=Cbx(GQ[hin],"when calling readByte in Base64, line 115")
set hEn=Cbx(GQ[hin],"when calling readByte in Base64, line 116")
set hXn=C4x(hnn,16)+C4x(hVn,8)+hEn
call G9n(hin,hXn,3,"when calling encodeSingle in Base64, line 118")
set EM=EM-1
endfunction
function hOn takes integer hRn,string hIn returns nothing
set ZM[EM]=hIn
set EM=EM+1
if LY[hRn]==0 then
if hRn==0 then
call Cdv("Nullpointer exception when calling Base64Encoder.encode3","when calling error in Base64, line 113")
else
call Cdv("Called Base64Encoder.encode3 on invalid object.","when calling error in Base64, line 113")
endif
endif
call hrn(hRn,"when calling encode3 in Base64, line 113")
set EM=EM-1
endfunction
function hAn takes integer hNn,string hbn returns nothing
set ZM[EM]=hbn
set EM=EM+1
call hOn(hQ[hNn],"when calling encode3 in Base64, line 150")
set ey=ey+1
set EM=EM-1
endfunction
function hBn takes integer hcn,string hCn returns nothing
set ZM[EM]=hCn
set EM=EM+1
call d8n(ZP[OA[hcn]],cpx(WP[OA[hcn]],"when calling readIntUnchecked in NetworkData, line 346"),"when calling writeInt in NetworkData, line 346")
set VP[OA[hcn]]=VP[OA[hcn]]+1
set EM=EM-1
endfunction
function hdn takes string hDn returns integer
local integer hfn
set ZM[EM]=hDn
set EM=EM+1
if PY==0 then
if AY<$8000 then
set AY=AY+1
set hfn=AY
set DY[hfn]=$CF6
else
call Cdv("Out of memory: Could not create LimitedExecuteAction_executeWhile_StringEncoder_StringEncoder.","when calling error in StringEncoder, line 96")
set hfn=0
endif
else
set PY=PY-1
set hfn=IY[PY]
set DY[hfn]=$CF6
endif
set EM=EM-1
return hfn
endfunction
function hFn takes string hgn returns integer
local integer hGn
set ZM[EM]=hgn
set EM=EM+1
if EY==0 then
if ZY<$8000 then
set ZY=ZY+1
set hGn=ZY
set UY[hGn]=$D1A
else
call Cdv("Out of memory: Could not create LimitedExecuteCondition_executeWhile_StringEncoder_StringEncoder.","when calling error in StringEncoder, line 96")
set hGn=0
endif
else
set EY=EY-1
set hGn=WY[EY]
set UY[hGn]=$D1A
endif
set EM=EM-1
return hGn
endfunction
function hhn takes integer hHn,string hjn returns string
local integer hJn
local integer hkn
local integer hKn
local integer hln
local integer hLn
set ZM[EM]=hjn
set EM=EM+1
set xX[hHn]=""
set hJn=cpx(QX[hHn],"when calling readIntUnchecked in StringEncoder, line 93")
set vX[hHn]=0
set hln=cq
set hkn=hFn("when calling alloc_LimitedExecuteCondition_executeWhile_StringEncoder_StringEncoder in StringEncoder, line 96")
set AX[hkn]=hHn
set DX[hkn]=hJn
set hLn=hkn
set hKn=hdn("when calling alloc_LimitedExecuteAction_executeWhile_StringEncoder_StringEncoder in StringEncoder, line 96")
set HX[hKn]=hHn
call WOe(hln,hLn,hKn,"when calling executeWhile in StringEncoder, line 96")
set EM=EM-1
return xX[hHn]
endfunction
function hmn takes integer hMn,string hpn returns string
local string hPn
set ZM[EM]=hpn
set EM=EM+1
if Ov[hMn]==0 then
if hMn==0 then
call Cdv("Nullpointer exception when calling StringEncoder.decodeString","when calling error in StringEncoder, line 91")
else
call Cdv("Called StringEncoder.decodeString on invalid object.","when calling error in StringEncoder, line 91")
endif
endif
set hPn=hhn(hMn,"when calling decodeString in StringEncoder, line 91")
set EM=EM-1
return hPn
endfunction
function hqn takes integer hQn,string hsn returns nothing
set ZM[EM]=hsn
set EM=EM+1
call fDn(WX[XX[hQn]],hmn(XX[hQn],"when calling decodeString in StringEncoder, line 112"),"when calling writeString in StringEncoder, line 112")
set EM=EM-1
endfunction
function hSn takes integer htn returns integer
return IZ[htn]+1
endfunction
function hTn takes integer hun,string hUn returns integer
local integer hwn
set ZM[EM]=hUn
set EM=EM+1
if OG[hun]==0 then
if hun==0 then
call Cdv("Nullpointer exception when calling HashBuffer.getStringCount","when calling error in HashBuffer, line 134")
else
call Cdv("Called HashBuffer.getStringCount on invalid object.","when calling error in HashBuffer, line 134")
endif
endif
set hwn=hSn(hun)
set EM=EM-1
return hwn
endfunction
function hWn takes integer hyn,string hYn,string hzn returns nothing
set ZM[EM]=hzn
set EM=EM+1
if(not RP[hyn])and hTn(fP[hyn],"when calling getStringCount in MultifileIO, line 121")==la then
call Cdv("FileWriter: exceeded max packet count","when calling error in MultifileIO, line 122")
endif
call R4n(fP[hyn],hYn,"when calling writeString in MultifileIO, line 123")
set EM=EM-1
endfunction
function hZn takes integer h_n,string h0n,string h1n returns nothing
set ZM[EM]=h1n
set EM=EM+1
if PF[h_n]==0 then
if h_n==0 then
call Cdv("Nullpointer exception when calling FileWriter.writeLine","when calling error in MultifileIO, line 120")
else
call Cdv("Called FileWriter.writeLine on invalid object.","when calling error in MultifileIO, line 120")
endif
endif
call hWn(h_n,h0n,"when calling writeLine in MultifileIO, line 120")
set EM=EM-1
endfunction
function h2n takes integer h3n,string h4n returns boolean
local boolean h5n
set ZM[EM]=h4n
set EM=EM+1
set h5n=hye(gX[h3n],"when calling size in StringBuffer, line 189")>0
set EM=EM-1
return h5n
endfunction
function h6n takes integer h7n,string h8n returns boolean
local boolean h9n
set ZM[EM]=h8n
set EM=EM+1
if OG[h7n]==0 then
if h7n==0 then
call Cdv("Nullpointer exception when calling AbstractStringBuffer.hasChunk","when calling error in StringBuffer, line 188")
else
call Cdv("Called AbstractStringBuffer.hasChunk on invalid object.","when calling error in StringBuffer, line 188")
endif
endif
set h9n=h2n(h7n,"when calling hasChunk in StringBuffer, line 188")
set EM=EM-1
return h9n
endfunction
function Hvn takes integer Hen,string Hxn returns string
local integer Hon
local string Hrn
set ZM[EM]=Hxn
set EM=EM+1
if not h6n(Hen,"when calling hasChunk in StringBuffer, line 192")then
call Cdv("OrderedStringBuffer: trying to pop non-existent chunk","when calling error in StringBuffer, line 193")
endif
set Hon=Gqe(gX[Hen],"when calling dequeue in StringBuffer, line 194")
set Hrn=jX[Hon]
call SGa(Hon,"when calling dispatch_ChunkElement_destroyChunkElement in StringBuffer, line 196")
set EM=EM-1
return Hrn
endfunction
function Hin takes integer Han,string Hnn returns string
local string HVn
set ZM[EM]=Hnn
set EM=EM+1
if OG[Han]==0 then
if Han==0 then
call Cdv("Nullpointer exception when calling AbstractStringBuffer.popChunk","when calling error in StringBuffer, line 191")
else
call Cdv("Called AbstractStringBuffer.popChunk on invalid object.","when calling error in StringBuffer, line 191")
endif
endif
set HVn=Hvn(Han,"when calling popChunk in StringBuffer, line 191")
set EM=EM-1
return HVn
endfunction
function HEn takes integer HXn,string HOn returns nothing
set ZM[EM]=HOn
set EM=EM+1
call hZn(AQ[HXn],Hin(DQ[HXn],"when calling popChunk in BufferAdapters, line 30"),"when calling writeLine in BufferAdapters, line 30")
set EM=EM-1
endfunction
function HRn takes integer HIn,integer HAn,string HNn returns nothing
set ZM[EM]=HNn
set EM=EM+1
call uae(mX[HIn],HAn,"when calling writeInt in StringEncoder, line 123")
set EM=EM-1
endfunction
function Hbn takes integer HBn,integer Hcn,string HCn returns nothing
set ZM[EM]=HCn
set EM=EM+1
if Ov[HBn]==0 then
if HBn==0 then
call Cdv("Nullpointer exception when calling StringEncoder.pushInt","when calling error in StringEncoder, line 122")
else
call Cdv("Called StringEncoder.pushInt on invalid object.","when calling error in StringEncoder, line 122")
endif
endif
call HRn(HBn,Hcn,"when calling pushInt in StringEncoder, line 122")
set EM=EM-1
endfunction
function Hdn takes integer HDn,string Hfn returns nothing
set ZM[EM]=Hfn
set EM=EM+1
call Hbn(mA[aD[HDn]],den(ZA[aD[HDn]],"when calling readInt in Network, line 379"),"when calling pushInt in Network, line 379")
set VA[aD[HDn]]=VA[aD[HDn]]+1
set EM=EM-1
endfunction
function HFn takes integer Hgn,string HGn,string Hhn returns nothing
set ZM[EM]=Hhn
set EM=EM+1
call fDn(mX[Hgn],HGn,"when calling writeString in StringEncoder, line 117")
set EM=EM-1
endfunction
function HHn takes integer Hjn,string HJn,string Hkn returns nothing
set ZM[EM]=Hkn
set EM=EM+1
if Ov[Hjn]==0 then
if Hjn==0 then
call Cdv("Nullpointer exception when calling StringEncoder.pushString","when calling error in StringEncoder, line 116")
else
call Cdv("Called StringEncoder.pushString on invalid object.","when calling error in StringEncoder, line 116")
endif
endif
call HFn(Hjn,HJn,"when calling pushString in StringEncoder, line 116")
set EM=EM-1
endfunction
function HKn takes integer Hln,string HLn returns nothing
set ZM[EM]=HLn
set EM=EM+1
call HHn(mA[wD[Hln]],AVn(vA[wD[Hln]],"when calling readString in Network, line 283"),"when calling pushString in Network, line 283")
set EM=EM-1
endfunction
function Hmn takes gamecache HMn,string Hpn,string HPn returns boolean
return HaveStoredBoolean(HMn,Hpn,HPn)
endfunction
function Hqn takes gamecache HQn,string Hsn,string HSn returns boolean
return GetStoredBoolean(HQn,Hsn,HSn)
endfunction
function Htn takes integer HTn,string Hun returns boolean
local boolean HUn
set ZM[EM]=Hun
set EM=EM+1
call CUn(HTn,"when calling advanceReadIndex in GamecacheBuffer, line 90")
call C_n(HTn,2,"when calling checkType in GamecacheBuffer, line 91")
if not Hmn(nZ[HTn],dZ[HTn],Tbx(RZ[HTn],"when calling get in GamecacheBuffer, line 92"))then
call Cdv("GamecacheBuffer: trying to read non-present bool #"+SMv(RZ[HTn]),"when calling error in GamecacheBuffer, line 93")
endif
set HUn=Hqn(nZ[HTn],dZ[HTn],Tbx(RZ[HTn],"when calling get in GamecacheBuffer, line 95"))
set EM=EM-1
return HUn
endfunction
function Hwn takes integer HWn,string Hyn returns boolean
local boolean HYn
set ZM[EM]=Hyn
set EM=EM+1
if Bg[HWn]==0 then
if HWn==0 then
call Cdv("Nullpointer exception when calling GamecacheBuffer.readBoolean","when calling error in GamecacheBuffer, line 89")
else
call Cdv("Called GamecacheBuffer.readBoolean on invalid object.","when calling error in GamecacheBuffer, line 89")
endif
endif
set HYn=Htn(HWn,"when calling readBoolean in GamecacheBuffer, line 89")
set EM=EM-1
return HYn
endfunction
function Hzn takes integer HZn,string H_n returns nothing
set ZM[EM]=H_n
set EM=EM+1
call Cgx(QP[fA[HZn]],Hwn(IP[fA[HZn]],"when calling readBoolean in NetworkData, line 376"),"when calling writeBoolean in NetworkData, line 376")
set NP[fA[HZn]]=NP[fA[HZn]]+1
set EM=EM-1
endfunction
function H0n takes gamecache H1n,string H2n,string H3n returns nothing
call SyncStoredBoolean(H1n,H2n,H3n)
endfunction
function H4n takes integer H5n,string H6n returns nothing
call H0n(nZ[hZ[H5n]],dZ[hZ[H5n]],H6n)
endfunction
function H7n takes gamecache H8n,string H9n,string jvn returns nothing
call SyncStoredReal(H8n,H9n,jvn)
endfunction
function jen takes integer jxn,string jon returns nothing
call H7n(nZ[gZ[jxn]],dZ[gZ[jxn]],jon)
endfunction
function jrn takes integer jin,string jan returns nothing
call TCx(nZ[GZ[jin]],dZ[GZ[jin]],jan)
endfunction
function jnn takes integer jVn,string jEn,string jXn returns nothing
set ZM[EM]=jXn
set EM=EM+1
if uh[jVn]==0 then
if jVn==0 then
call Cdv("Nullpointer exception when calling SynchronizerFunction.sync","when calling error in GamecacheBuffer, line 9")
else
call Cdv("Called SynchronizerFunction.sync on invalid object.","when calling error in GamecacheBuffer, line 9")
endif
endif
if uh[jVn]<=4880 then
if uh[jVn]<=4879 then
call jrn(jVn,jEn)
else
call jen(jVn,jEn)
endif
else
call H4n(jVn,jEn)
endif
set EM=EM-1
endfunction
function jOn takes integer jRn,string jIn returns nothing
set ZM[EM]=jIn
set EM=EM+1
call jnn(kZ[jRn],Tbx(YZ[jZ[jRn]],"when calling get in GamecacheBuffer, line 121"),"when calling sync in GamecacheBuffer, line 121")
set YZ[jZ[jRn]]=YZ[jZ[jRn]]+1
set EM=EM-1
endfunction
function jAn takes integer jNn,string jbn returns nothing
set ZM[EM]=jbn
set EM=EM+1
call Ayn(vA[yD[jNn]],Hwn(EA[yD[jNn]],"when calling readBoolean in Network, line 367"),"when calling writeBoolean in Network, line 367")
set CA[yD[jNn]]=CA[yD[jNn]]+1
set EM=EM-1
endfunction
function jBn takes integer jcn,string jCn returns nothing
set ZM[EM]=jCn
set EM=EM+1
set xX[HX[jcn]]=xX[HX[jcn]]+bCn(cpx(QX[HX[jcn]],"when calling readIntUnchecked in StringEncoder, line 97"),"when calling getCharFromIndex in StringEncoder, line 97")
set vX[HX[jcn]]=vX[HX[jcn]]+1
set EM=EM-1
endfunction
function jdn takes integer jDn,string jfn returns nothing
set ZM[EM]=jfn
set EM=EM+1
call d8n(ZA[eD[jDn]],D1n(mA[eD[jDn]],"when calling popInt in Network, line 373"),"when calling writeInt in Network, line 373")
set VA[eD[jDn]]=VA[eD[jDn]]+1
set EM=EM-1
endfunction
function jFn takes integer jgn,string jGn returns nothing
set ZM[EM]=jGn
set EM=EM+1
call HHn(EP[cA[jgn]],dtn(WP[cA[jgn]],"when calling readString in NetworkData, line 299"),"when calling pushString in NetworkData, line 299")
set EM=EM-1
endfunction
function jhn takes string jHn returns integer
local integer jjn
set ZM[EM]=jHn
set EM=EM+1
if PY==0 then
if AY<$8000 then
set AY=AY+1
set jjn=AY
set DY[jjn]=$CF5
else
call Cdv("Out of memory: Could not create LimitedExecuteAction_executeWhile_StringEncoder_StringEncoder.","when calling error in StringEncoder, line 87")
set jjn=0
endif
else
set PY=PY-1
set jjn=IY[PY]
set DY[jjn]=$CF5
endif
set EM=EM-1
return jjn
endfunction
function jJn takes string jkn returns integer
local integer jKn
set ZM[EM]=jkn
set EM=EM+1
if EY==0 then
if ZY<$8000 then
set ZY=ZY+1
set jKn=ZY
set UY[jKn]=$D19
else
call Cdv("Out of memory: Could not create LimitedExecuteCondition_executeWhile_StringEncoder_StringEncoder.","when calling error in StringEncoder, line 87")
set jKn=0
endif
else
set EY=EY-1
set jKn=WY[EY]
set UY[jKn]=$D19
endif
set EM=EM-1
return jKn
endfunction
function jln takes integer jLn,string jmn,string jMn returns nothing
local integer jpn
local integer jPn
local integer jqn
local integer jQn
local integer jsn
set ZM[EM]=jMn
set EM=EM+1
set jpn=GZv(jmn)
set vX[jLn]=0
call uae(WX[jLn],jpn,"when calling writeInt in StringEncoder, line 85")
set jQn=cq
set jPn=jJn("when calling alloc_LimitedExecuteCondition_executeWhile_StringEncoder_StringEncoder in StringEncoder, line 87")
set ZX[jPn]=jLn
set UX[jPn]=jpn
set jsn=jPn
set jqn=jhn("when calling alloc_LimitedExecuteAction_executeWhile_StringEncoder_StringEncoder in StringEncoder, line 87")
set IX[jqn]=jLn
set PX[jqn]=jmn
call WOe(jQn,jsn,jqn,"when calling executeWhile in StringEncoder, line 87")
set EM=EM-1
endfunction
function jSn takes integer jtn,string jTn,string jun returns nothing
set ZM[EM]=jun
set EM=EM+1
if Ov[jtn]==0 then
if jtn==0 then
call Cdv("Nullpointer exception when calling StringEncoder.encodeString","when calling error in StringEncoder, line 82")
else
call Cdv("Called StringEncoder.encodeString on invalid object.","when calling error in StringEncoder, line 82")
endif
endif
call jln(jtn,jTn,"when calling encodeString in StringEncoder, line 82")
set EM=EM-1
endfunction
function jUn takes integer jwn,string jWn returns nothing
set ZM[EM]=jWn
set EM=EM+1
call jSn(KX[jwn],dtn(QX[KX[jwn]],"when calling readString in StringEncoder, line 105"),"when calling encodeString in StringEncoder, line 105")
set EM=EM-1
endfunction
function jyn takes integer jYn returns integer
return jYn-jYn/$1000000*$1000000
endfunction
function jzn takes integer jZn returns integer
local integer j_n
if jZn<0 then
set j_n=--$80000000+jZn
else
set j_n=jZn
endif
return j_n
endfunction
function j0n takes string j1n returns integer
local integer j2n
if j1n=="/" then
set s4=47
return s4
elseif"\\"==j1n then
set s4=92
return s4
endif
set j2n=QR[Ccv(j1n)/$1F0748+$3EA]
if j1n!=mR[j2n]then
set s4=j2n+32
return s4
endif
set s4=j2n
return s4
endfunction
function j3n takes string j4n returns integer
set t4=j0n(j4n)
return t4
endfunction
function j5n takes integer j6n returns integer
return j6n
endfunction
function j7n takes integer j8n,integer j9n,string Jvn returns string
local integer Jen
local string Jxn
local integer Jon
local string Jrn
local integer Jin
local integer Jan
set ZM[EM]=Jvn
set EM=EM+1
if j9n>Yy then
call Cdv("BigString: trying to read a string larger than BIGSTRING_MAX_CHUNK_LENGTH","when calling error in BigString, line 143")
endif
set Jen=j9n
if GZv(jQ[j8n])<j9n then
set Jxn=jQ[j8n]
set Jen=Jen-GZv(jQ[j8n])
set jQ[j8n]=""
else
set Jxn=Psv(jQ[j8n],0,j9n)
set Jen=0
set jQ[j8n]=Tgv(jQ[j8n],j9n)
endif
loop
exitwhen not(hye(FQ[j8n],"when calling size in BigString, line 161")>0 and Jen>0)
set Jon=Gqe(FQ[j8n],"when calling dequeue in BigString, line 162")
set Jrn=mQ[Jon]
call rqx(Jon,"when calling dispatch_BigStringElement_destroyBigStringElement in BigString, line 164")
if GZv(Jrn)>Jen then
set Jin=bUe(GZv(Jrn),Jen)
set Jxn=Jxn+Psv(Jrn,0,Jin)
set jQ[j8n]=Tgv(Jrn,Jin)
set Jen=0
exitwhen true
else
set Jxn=Jxn+Jrn
set Jen=Jen-GZv(Jrn)
endif
endloop
if Jen>0 then
set Jan=bUe(Jen,GZv(kQ[j8n]))
set Jxn=Jxn+Psv(kQ[j8n],0,Jan)
set kQ[j8n]=Tgv(kQ[j8n],Jan)
endif
set EM=EM-1
return Jxn
endfunction
function Jnn takes integer JVn,integer JEn,string JXn returns string
local string JOn
set ZM[EM]=JXn
set EM=EM+1
if uG[JVn]==0 then
if JVn==0 then
call Cdv("Nullpointer exception when calling BigString.readSome","when calling error in BigString, line 141")
else
call Cdv("Called BigString.readSome on invalid object.","when calling error in BigString, line 141")
endif
endif
set JOn=j7n(JVn,JEn,"when calling readSome in BigString, line 141")
set EM=EM-1
return JOn
endfunction
function JRn takes integer JIn,string JAn returns integer
local integer JNn
set ZM[EM]=JAn
set EM=EM+1
set JNn=j5n(j3n(Jnn(dQ[JIn],1,"when calling readSome in Base64, line 211")))
set EM=EM-1
return JNn
endfunction
function Jbn takes integer JBn,string Jcn returns integer
local integer JCn
set ZM[EM]=Jcn
set EM=EM+1
if QY[JBn]==0 then
if JBn==0 then
call Cdv("Nullpointer exception when calling Base64Decoder.nextChar","when calling error in Base64, line 210")
else
call Cdv("Called Base64Decoder.nextChar on invalid object.","when calling error in Base64, line 210")
endif
endif
set JCn=JRn(JBn,"when calling nextChar in Base64, line 210")
set EM=EM-1
return JCn
endfunction
function Jdn takes integer JDn,string Jfn returns nothing
local integer JFn
local integer Jgn
local integer JGn
set ZM[EM]=Jfn
set EM=EM+1
set JFn=Jbn(JDn,"when calling nextChar in Base64, line 214")
set Jgn=0
set JGn=0
if ny[JFn]!=-1 then
set Jgn=C4x(ny[JFn],18)
endif
set JFn=Jbn(JDn,"when calling nextChar in Base64, line 221")
if ny[JFn]!=-1 then
set Jgn=Jgn+C4x(ny[JFn],$C)
set JGn=JGn+1
endif
set JFn=Jbn(JDn,"when calling nextChar in Base64, line 226")
if ny[JFn]!=-1 then
set Jgn=Jgn+C4x(ny[JFn],6)
set JGn=JGn+1
endif
set JFn=Jbn(JDn,"when calling nextChar in Base64, line 231")
if ny[JFn]!=-1 then
set Jgn=Jgn+ny[JFn]
set JGn=JGn+1
endif
loop
exitwhen not(JGn>0)
call TYe(RQ[JDn],Gan(jyn(jzn(Jgn)),16),"when calling writeByte in Base64, line 237")
set Jgn=C4x(Jgn,8)
set JGn=JGn-1
endloop
set EM=EM-1
endfunction
function Jhn takes integer JHn,string Jjn returns nothing
set ZM[EM]=Jjn
set EM=EM+1
if QY[JHn]==0 then
if JHn==0 then
call Cdv("Nullpointer exception when calling Base64Decoder.next3Bytes","when calling error in Base64, line 213")
else
call Cdv("Called Base64Decoder.next3Bytes on invalid object.","when calling error in Base64, line 213")
endif
endif
call Jdn(JHn,"when calling next3Bytes in Base64, line 213")
set EM=EM-1
endfunction
function JJn takes integer Jkn,string JKn returns nothing
set ZM[EM]=JKn
set EM=EM+1
call Jhn(TQ[Jkn],"when calling next3Bytes in Base64, line 256")
set ey=ey+1
set EM=EM-1
endfunction
function Jln takes integer JLn returns nothing
local real Jmn=F7v()
local real JMn=a1
set dV[JLn]=Jmn
set fV[JLn]=JMn
set RV[JLn]=.0
endfunction
function Jpn takes integer JPn,integer Jqn,string JQn returns nothing
set ZM[EM]=JQn
set EM=EM+1
call Ypv(JPn,Jqn,"when calling construct_SingleUnitData in UnitData, line 1339")
call Jln(JPn)
set EM=EM-1
endfunction
function Jsn takes string JSn returns integer
local integer Jtn
set ZM[EM]=JSn
set EM=EM+1
if Pv==0 then
if Av<$8000 then
set Av=Av+1
set Jtn=Av
set Dv[Jtn]=4647
else
call Cdv("Out of memory: Could not create SinglePositionedUnitData.","when calling error in UnitData, line 1334")
set Jtn=0
endif
else
set Pv=Pv-1
set Jtn=Iv[Pv]
set Dv[Jtn]=4647
endif
set EM=EM-1
return Jtn
endfunction
function JTn takes integer Jun,string JUn returns integer
local integer Jwn
set ZM[EM]=JUn
set EM=EM+1
set Jwn=Jsn("when calling alloc_SinglePositionedUnitData in UnitData, line 1339")
call Jpn(Jwn,Jun,"when calling construct_SinglePositionedUnitData in UnitData, line 1339")
set EM=EM-1
return Jwn
endfunction
function JWn takes integer Jyn,string JYn returns integer
local integer Jzn
local integer JZn
local real J_n
local integer J0n
local integer J1n
local integer J2n
set ZM[EM]=JYn
set EM=EM+1
call fVx(0,Jyn,"when calling readByte in UnitData, line 831")
set J2n=RJv
set Jzn=J2n
set JZn=0
set J_n=.0
set J0n=0
set J1n=0
if N_e(Jzn,0)then
if N_e(Jzn,1)then
call dEx(0,Jyn,"when calling readInt in UnitData, line 840")
set JZn=RJv
else
call fVx(0,Jyn,"when calling readByte in UnitData, line 842")
set JZn=RJv
endif
endif
if N_e(Jzn,2)then
if N_e(Jzn,3)then
call fVx(0,Jyn,"when calling readByte in UnitData, line 845")
set J_n=RJv*1./'d'
else
call d7x(0,Jyn,"when calling readReal in UnitData, line 847")
set J_n=Rkv
endif
endif
if N_e(Jzn,4)then
if N_e(Jzn,5)then
call dEx(0,Jyn,"when calling readInt in UnitData, line 850")
set J0n=RJv
else
call fVx(0,Jyn,"when calling readByte in UnitData, line 852")
set J0n=RJv
endif
endif
if N_e(Jzn,6)then
if N_e(Jzn,7)then
call dEx(0,Jyn,"when calling readInt in UnitData, line 855")
set J1n=RJv
else
call fVx(0,Jyn,"when calling readByte in UnitData, line 857")
set J1n=RJv
endif
endif
set EM=EM-1
set F5=Jzn
set k5=JZn
set j5=J_n
set x5=J0n
set v5=J1n
return F5
endfunction
function J3n takes integer J4n,string J5n returns integer
local integer J6n
local integer J7n
local integer J8n
local integer J9n
local real kvn
local integer ken
local integer kxn
local integer kon
local integer krn
local real kin
local integer kan
local integer knn
local integer kVn
local integer kEn
local integer kXn
local integer kOn
local integer kRn
local integer kIn
local integer kAn
local integer kNn
local real kbn
local integer kBn
local integer kcn
local integer kCn
local integer kdn
local real kDn
local integer kfn
local integer kFn
local integer kgn
local integer kGn
local real khn
local integer kHn
local integer kjn
local integer kJn
local integer kkn
local real kKn
local integer kln
local integer kLn
local integer kmn
local integer kMn
local integer kpn
local integer kPn
set ZM[EM]=J5n
set EM=EM+1
call fhx(1,J4n,"when calling readShort in UnitData, line 700")
set kIn=RJv
set J6n=kIn
set J7n=0
if O5e(J6n,0)then
call fVx(0,J4n,"when calling readByte in UnitData, line 704")
set J7n=RJv
endif
set kAn=yYv()
set kNn=W2
set kbn=E2
set kBn=Z2
set kcn=U2
set J8n=kAn
set J9n=kNn
set kvn=kbn
set ken=kBn
set kxn=kcn
if O5e(J6n,4)then
set kCn=JWn(J4n,"when calling readAttackParameters in UnitData, line 708")
set kdn=k5
set kDn=j5
set kfn=x5
set kFn=v5
set J8n=kCn
set J9n=kdn
set kvn=kDn
set ken=kfn
set kxn=kFn
endif
set kgn=yYv()
set kGn=W2
set khn=E2
set kHn=Z2
set kjn=U2
set kon=kgn
set krn=kGn
set kin=khn
set kan=kHn
set knn=kjn
if O5e(J6n,5)then
set kJn=JWn(J4n,"when calling readAttackParameters in UnitData, line 711")
set kkn=k5
set kKn=j5
set kln=x5
set kLn=v5
set kon=kJn
set krn=kkn
set kin=kKn
set kan=kln
set knn=kLn
endif
set kVn=0
if O5e(J6n,6)then
if O5e(J6n,7)then
call fVx(0,J4n,"when calling readByte in UnitData, line 715")
set kVn=RJv
else
call dEx(0,J4n,"when calling readInt in UnitData, line 717")
set kVn=RJv
endif
endif
set kEn=0
if O5e(J6n,8)then
if O5e(J6n,9)then
call fhx(1,J4n,"when calling readShort in UnitData, line 721")
set kEn=RJv
else
call dEx(0,J4n,"when calling readInt in UnitData, line 723")
set kEn=RJv
endif
endif
set kXn=0
if O5e(J6n,$A)then
if O5e(J6n,$B)then
call fhx(1,J4n,"when calling readShort in UnitData, line 727")
set kXn=RJv
else
call dEx(0,J4n,"when calling readInt in UnitData, line 729")
set kXn=RJv
endif
endif
set kmn=0
set kOn=kmn
if O5e(J6n,$E)then
call fVx(0,J4n,"when calling readByte in UnitData, line 733")
set kMn=RJv
set kOn=kMn
endif
set kpn=0
set kRn=kpn
if O5e(J6n,$F)then
call fVx(0,J4n,"when calling readByte in UnitData, line 736")
set kPn=RJv
set kRn=kPn
endif
set EM=EM-1
set m5=J6n
set Q5=J7n
set W5=J8n
set E5=J9n
set Z5=kvn
set U5=ken
set I5=kxn
set P5=kon
set A5=krn
set D5=kin
set H5=kan
set J5=knn
set K5=kVn
set L5=kEn
set X5=kXn
set C5=kOn
set V5=kRn
return m5
endfunction
function kqn takes integer kQn,integer ksn,string kSn returns nothing
local integer ktn
set ZM[EM]=kSn
set EM=EM+1
call fVx(0,ksn,"when calling readByte in UnitData, line 939")
set ktn=RJv
set pV[kQn]=ktn
call dEx(0,ksn,"when calling readInt in UnitData, line 940")
set eV[kQn]=RJv
if Vxe(pV[kQn],0)then
set qV[kQn]=1
elseif Vxe(pV[kQn],1)then
set qV[kQn]=2
elseif Vxe(pV[kQn],2)then
set qV[kQn]=3
elseif Vxe(pV[kQn],3)then
set qV[kQn]=4
else
call fhx(1,ksn,"when calling readShort in UnitData, line 951")
set qV[kQn]=RJv
endif
if Vxe(pV[kQn],4)then
if Vxe(pV[kQn],6)then
call fVx(0,ksn,"when calling readByte in UnitData, line 954")
set aV[kQn]=RJv
else
call dEx(0,ksn,"when calling readInt in UnitData, line 956")
set aV[kQn]=RJv
endif
endif
if Vxe(pV[kQn],5)then
if Vxe(pV[kQn],6)then
call fVx(0,ksn,"when calling readByte in UnitData, line 959")
set nV[kQn]=RJv*1./2
else
call d7x(0,ksn,"when calling readReal in UnitData, line 961")
set nV[kQn]=Rkv
endif
endif
set EM=EM-1
endfunction
function kTn takes integer kun,integer kUn,string kwn returns nothing
set ZM[EM]=kwn
set EM=EM+1
if Uv[kun]==0 then
if kun==0 then
call Cdv("Nullpointer exception when calling SingleAbilityData.deserialize","when calling error in UnitData, line 938")
else
call Cdv("Called SingleAbilityData.deserialize on invalid object.","when calling error in UnitData, line 938")
endif
endif
call kqn(kun,kUn,"when calling deserialize in UnitData, line 938")
set EM=EM-1
endfunction
function kWn takes integer kyn,integer kYn,string kzn returns nothing
local integer kZn
local integer k_n
local integer k0n
local integer k1n
local integer k2n
local integer k3n
local integer k4n
set ZM[EM]=kzn
set EM=EM+1
call fVx(0,kYn,"when calling readByte in ItemData, line 166")
set kZn=RJv
set hU[kyn]=kZn
if Ide(hU[kyn],7)then
call fVx(0,kYn,"when calling readByte in ItemData, line 168")
set k_n=RJv
set FU[kyn]=k_n
endif
call dEx(0,kYn,"when calling readInt in ItemData, line 169")
set kU[kyn]=RJv
if Ide(hU[kyn],6)then
if Ide(hU[kyn],4)then
call dEx(0,kYn,"when calling readInt in ItemData, line 173")
set jU[kyn]=RJv
else
call fhx(1,kYn,"when calling readShort in ItemData, line 175")
set jU[kyn]=RJv
endif
elseif Ide(hU[kyn],4)then
set jU[kyn]=0
elseif Ide(hU[kyn],5)then
set jU[kyn]=1
else
call fVx(0,kYn,"when calling readByte in ItemData, line 181")
set jU[kyn]=RJv
endif
if IVe(FU[kyn],0)then
call d7x(0,kYn,"when calling readReal in ItemData, line 184")
set xU[kyn]=Rkv
endif
if IVe(FU[kyn],1)then
set k0n=FKx(kYn,gU[kyn],"when calling readStringTableIndex in ItemData, line 187")
set vU[kyn]=k0n
endif
if IVe(FU[kyn],2)then
set k1n=FKx(kYn,gU[kyn],"when calling readStringTableIndex in ItemData, line 189")
set mU[kyn]=k1n
endif
if IVe(FU[kyn],3)then
set k2n=FKx(kYn,gU[kyn],"when calling readStringTableIndex in ItemData, line 191")
set QU[kyn]=k2n
endif
if IVe(FU[kyn],4)then
set k3n=FKx(kYn,gU[kyn],"when calling readStringTableIndex in ItemData, line 193")
set WU[kyn]=k3n
endif
if IVe(FU[kyn],5)then
set k4n=FKx(kYn,gU[kyn],"when calling readStringTableIndex in ItemData, line 195")
set EU[kyn]=k4n
endif
set EM=EM-1
endfunction
function k5n takes integer k6n,integer k7n,string k8n returns nothing
local real k9n
local real Kvn
set ZM[EM]=k8n
set EM=EM+1
set k9n=gbx(k7n,"when calling readPointData in ItemData, line 218")
set Kvn=Y1
set ZU[k6n]=k9n
set UU[k6n]=Kvn
call kWn(k6n,k7n,"when calling deserialize in ItemData, line 220")
set EM=EM-1
endfunction
function Ken takes integer Kxn,integer Kon,string Krn returns nothing
set ZM[EM]=Krn
set EM=EM+1
if vh[Kxn]==0 then
if Kxn==0 then
call Cdv("Nullpointer exception when calling SingleItemData.deserialize","when calling error in ItemData, line 165")
else
call Cdv("Called SingleItemData.deserialize on invalid object.","when calling error in ItemData, line 165")
endif
endif
if vh[Kxn]<=4642 then
call kWn(Kxn,Kon,"when calling deserialize in ItemData, line 165")
else
call k5n(Kxn,Kon,"when calling deserialize in ItemData, line 165")
endif
set EM=EM-1
endfunction
function Kin takes integer Kan,string Knn returns integer
local integer KVn
local real KEn
local real KXn
local real KOn
local real KRn
local real KIn
local integer KAn
set ZM[EM]=Knn
set EM=EM+1
call fVx(0,Kan,"when calling readByte in UnitData, line 405")
set KAn=RJv
set KVn=KAn
set KEn=.0
if ADe(KVn,0)then
if ADe(KVn,1)then
call fhx(1,Kan,"when calling readShort in UnitData, line 410")
set KEn=RJv*1./$A
else
call d7x(0,Kan,"when calling readReal in UnitData, line 412")
set KEn=Rkv
endif
endif
set KXn=.0
if ADe(KVn,2)then
call fhx(1,Kan,"when calling readShort in UnitData, line 415")
set KXn=RJv*1./$2710
endif
set KOn=.0
if ADe(KVn,3)then
if ADe(KVn,4)then
call fVx(0,Kan,"when calling readByte in UnitData, line 419")
set KOn=RJv*1./'d'
elseif ADe(KVn,5)then
call fhx(1,Kan,"when calling readShort in UnitData, line 421")
set KOn=RJv*1./$3E8
else
call d7x(0,Kan,"when calling readReal in UnitData, line 423")
set KOn=Rkv
endif
endif
set KRn=.0
if ADe(KVn,6)then
call d7x(0,Kan,"when calling readReal in UnitData, line 426")
set KRn=Rkv
endif
set KIn=.0
if ADe(KVn,7)then
call fhx(1,Kan,"when calling readShort in UnitData, line 429")
set KIn=RJv*1./$2710
endif
set EM=EM-1
set f2=KVn
set R2=KEn
set T2=KXn
set Y2=KOn
set G2=KRn
set g2=KIn
return f2
endfunction
function KNn takes integer Kbn,string KBn returns integer
local integer Kcn
local real KCn
local integer Kdn
local integer KDn
local integer Kfn
local integer KFn
local integer Kgn
local real KGn
local integer Khn
local integer KHn
local integer Kjn
local integer KJn
local integer Kkn
local integer KKn
local integer Kln
local integer KLn
local integer Kmn
set ZM[EM]=KBn
set EM=EM+1
call fVx(0,Kbn,"when calling readByte in UnitData, line 282")
set Khn=RJv
set Kcn=Khn
set KCn=.0
if NFe(Kcn,0)then
if NFe(Kcn,1)then
call fVx(0,Kbn,"when calling readByte in UnitData, line 287")
set KCn=DQv(RJv)
elseif NFe(Kcn,2)then
call fhx(1,Kbn,"when calling readShort in UnitData, line 289")
set KCn=RJv*1./$A
else
call d7x(0,Kbn,"when calling readReal in UnitData, line 291")
set KCn=Rkv
endif
endif
set Kdn=0
if NFe(Kcn,3)then
call fVx(0,Kbn,"when calling readByte in UnitData, line 294")
set Kdn=RJv
endif
set KHn=0
set Kjn=0
set KJn=0
set Kkn=0
set KDn=KHn
set Kfn=Kjn
set KFn=KJn
set Kgn=Kkn
if NFe(Kcn,4)then
call fVx(0,Kbn,"when calling readByte in UnitData, line 297")
set KKn=RJv
call fVx(0,Kbn,"when calling readByte in UnitData, line 297")
set Kln=RJv
call fVx(0,Kbn,"when calling readByte in UnitData, line 297")
set KLn=RJv
call fVx(0,Kbn,"when calling readByte in UnitData, line 297")
set Kmn=RJv
set KDn=KKn
set Kfn=Kln
set KFn=KLn
set Kgn=Kmn
endif
set KGn=.0
if NFe(Kcn,5)then
if NFe(Kcn,6)then
call fVx(0,Kbn,"when calling readByte in UnitData, line 301")
set KGn=RJv*1./'d'
elseif NFe(Kcn,7)then
call fhx(1,Kbn,"when calling readShort in UnitData, line 303")
set KGn=(RJv-$7FFF)*1./$3E8
else
call d7x(0,Kbn,"when calling readReal in UnitData, line 305")
set KGn=Rkv
endif
endif
set EM=EM-1
set V4=Kcn
set B4=KCn
set N4=Kdn
set M4=KDn
set w2=Kfn
set u2=KFn
set r2=Kgn
set s2=KGn
return V4
endfunction
function KMn takes integer Kpn,integer KPn returns boolean
return n9e(Kpn,KPn)
endfunction
function Kqn takes integer KQn,integer Ksn,string KSn returns integer
local integer Ktn
local integer KTn
local integer Kun
local integer KUn
local integer Kwn
local integer KWn
local integer Kyn
local integer KYn
local integer Kzn
local integer KZn
local integer K_n
set ZM[EM]=KSn
set EM=EM+1
call fVx(0,KQn,"when calling readByte in UnitData, line 149")
set Kzn=RJv
set Ktn=Kzn
if RCe(Ktn,7)then
call fVx(0,KQn,"when calling readByte in UnitData, line 150")
set Kun=RJv
else
set Kun=0
endif
set KZn=Kun
set KTn=KZn
call dEx(0,KQn,"when calling readInt in UnitData, line 152")
set KUn=RJv
set Kwn=0
if RCe(Ktn,1)then
if RCe(Ktn,2)then
if KMn(KTn,0)then
call dEx(0,KQn,"when calling readInt in UnitData, line 158")
set Kwn=RJv
else
call fhx(1,KQn,"when calling readShort in UnitData, line 160")
set Kwn=RJv
endif
else
call fVx(0,KQn,"when calling readByte in UnitData, line 162")
set Kwn=RJv
endif
endif
set KWn=0
if RCe(Ktn,3)then
if RCe(Ktn,4)then
if KMn(KTn,1)then
call dEx(0,KQn,"when calling readInt in UnitData, line 167")
set KWn=RJv
else
call fhx(1,KQn,"when calling readShort in UnitData, line 169")
set KWn=RJv
endif
else
call fVx(0,KQn,"when calling readByte in UnitData, line 171")
set KWn=RJv
endif
endif
set Kyn=0
if RCe(Ktn,5)then
if RCe(Ktn,6)then
if KMn(KTn,2)then
call dEx(0,KQn,"when calling readInt in UnitData, line 176")
set Kyn=RJv
else
call fhx(1,KQn,"when calling readShort in UnitData, line 178")
set Kyn=RJv
endif
else
call fVx(0,KQn,"when calling readByte in UnitData, line 180")
set Kyn=RJv
endif
endif
set K_n=FKx(KQn,Ksn,"when calling readStringTableIndex in UnitData, line 182")
set KYn=K_n
set EM=EM-1
set G4=Ktn
set g4=KTn
set h4=KUn
set F4=Kwn
set k4=KWn
set j4=Kyn
set x4=KYn
return G4
endfunction
function K0n takes integer K1n,integer K2n,string K3n returns nothing
local integer K4n
local integer K5n
local integer K6n
local integer K7n
local integer K8n
local integer K9n
local integer lvn
local integer len
local integer lxn
local integer lon
local integer lrn
local integer lin
local integer lan
local integer lnn
local integer lVn
local integer lEn
local integer lXn
local integer lOn
local integer lRn
local integer lIn
local integer lAn
local integer lNn
local integer lbn
local integer lBn
local integer lcn
local integer lCn
local integer ldn
local integer lDn
local real lfn
local integer lFn
local integer lgn
local integer lGn
local integer lhn
local integer lHn
local real ljn
local integer lJn
local real lkn
local real lKn
local real lln
local real lLn
local real lmn
local integer lMn
local integer lpn
local integer lPn
local integer lqn
local real lQn
local integer lsn
local integer lSn
local integer ltn
local integer lTn
local real lun
local integer lUn
local integer lwn
local integer lWn
local integer lyn
local integer lYn
local integer lzn
local integer lZn
local integer l_n
local integer l0n
local real l1n
local real l2n
local integer l3n
local integer l4n
set ZM[EM]=K3n
set EM=EM+1
call fVx(0,K2n,"when calling readByte in UnitData, line 1270")
set lOn=RJv
set YV[K1n]=lOn
if Ace(YV[K1n],7)then
call fVx(0,K2n,"when calling readByte in UnitData, line 1272")
set lRn=RJv
set GV[K1n]=lRn
endif
call dEx(0,K2n,"when calling readInt in UnitData, line 1273")
set gV[K1n]=RJv
if Ace(YV[K1n],2)then
set lIn=Kqn(K2n,TV[K1n],"when calling readHeroParameters in UnitData, line 1276")
set lAn=g4
set lNn=h4
set lbn=F4
set lBn=k4
set lcn=j4
set lCn=x4
set hV[K1n]=lIn
set FV[K1n]=lAn
set kV[K1n]=lNn
set jV[K1n]=lbn
set xV[K1n]=lBn
set vV[K1n]=lcn
set mV[K1n]=lCn
endif
if Ace(YV[K1n],3)then
set ldn=FKx(K2n,TV[K1n],"when calling readStringTableIndex in UnitData, line 1279")
set QV[K1n]=ldn
endif
if Ace(YV[K1n],4)then
set lDn=KNn(K2n,"when calling readArtParameters in UnitData, line 1282")
set lfn=B4
set lFn=N4
set lgn=M4
set lGn=w2
set lhn=u2
set lHn=r2
set ljn=s2
set WV[K1n]=lDn
set EV[K1n]=lfn
set ZV[K1n]=lFn
set UV[K1n]=lgn
set IV[K1n]=lGn
set PV[K1n]=lhn
set AV[K1n]=lHn
set DV[K1n]=ljn
endif
if Ace(YV[K1n],5)then
set lJn=Kin(K2n,"when calling readAnimationParameters in UnitData, line 1284")
set lkn=R2
set lKn=T2
set lln=Y2
set lLn=G2
set lmn=g2
set HV[K1n]=lJn
set JV[K1n]=lkn
set KV[K1n]=lKn
set LV[K1n]=lln
set XV[K1n]=lLn
set CV[K1n]=lmn
endif
if Ace(YV[K1n],6)then
set lMn=J3n(K2n,"when calling readStats in UnitData, line 1287")
set lpn=Q5
set lPn=W5
set lqn=E5
set lQn=Z5
set lsn=U5
set lSn=I5
set ltn=P5
set lTn=A5
set lun=D5
set lUn=H5
set lwn=J5
set lWn=K5
set lyn=L5
set lYn=X5
set lzn=C5
set lZn=V5
set VV[K1n]=lMn
set BV[K1n]=lpn
set NV[K1n]=lPn
set MV[K1n]=lqn
set wB[K1n]=lQn
set uB[K1n]=lsn
set rB[K1n]=lSn
set sB[K1n]=ltn
set tB[K1n]=lTn
set iB[K1n]=lun
set SB[K1n]=lUn
set cB[K1n]=lwn
set oB[K1n]=lWn
set OB[K1n]=lyn
set lB[K1n]=lYn
set bB[K1n]=lzn
set yB[K1n]=lZn
if O5e(VV[K1n],0)then
call fVx(0,K2n,"when calling readByte in UnitData, line 1289")
set l_n=RJv
set K4n=l_n
set K5n=0
set K6n=BV[K1n]-1
loop
exitwhen K5n>K6n
if n9e(K4n,K5n)then
set K7n=zXv(TV[K1n],"when calling new_SingleItemData in UnitData, line 1292")
call Ken(K7n,K2n,"when calling deserialize in UnitData, line 1292")
call xMe(K1n,K5n,K7n,"when writing array SingleUnitData_items in UnitData, line 1292")
else
call xMe(K1n,K5n,0,"when writing array SingleUnitData_items in UnitData, line 1294")
endif
set K5n=K5n+1
endloop
endif
if O5e(VV[K1n],$C)then
call fVx(0,K2n,"when calling readByte in UnitData, line 1296")
set K8n=RJv
set K9n=0
set lvn=K8n-1
loop
exitwhen K9n>lvn
set l4n=pB[K1n]
call dEx(0,K2n,"when calling readInt in UnitData, line 1298")
call zGv(l4n,RJv,"when calling add in UnitData, line 1298")
set K9n=K9n+1
endloop
endif
if O5e(VV[K1n],$D)then
call fVx(0,K2n,"when calling readByte in UnitData, line 1300")
set len=RJv
set lxn=0
set lon=len-1
loop
exitwhen lxn>lon
set lEn=eB[K1n]
set lrn=nTe("when calling new_SingleAbilityData in UnitData, line 1302")
call kTn(lrn,K2n,"when calling deserialize in UnitData, line 1302")
call zGv(lEn,lrn,"when calling add in UnitData, line 1302")
set lxn=lxn+1
endloop
endif
endif
if R3e(GV[K1n],0)then
call fVx(0,K2n,"when calling readByte in UnitData, line 1305")
set l0n=RJv
set qB[K1n]=l0n
if A5e(qB[K1n],0)then
if not A5e(qB[K1n],1)then
call dEx(0,K2n,"when calling readInt in UnitData, line 1308")
set aB[K1n]=RJv
else
call fhx(1,K2n,"when calling readShort in UnitData, line 1310")
set aB[K1n]=RJv
endif
elseif A5e(qB[K1n],1)then
call fVx(0,K2n,"when calling readByte in UnitData, line 1312")
set aB[K1n]=RJv
endif
if A5e(qB[K1n],2)then
if not A5e(qB[K1n],3)then
call dEx(0,K2n,"when calling readInt in UnitData, line 1315")
set nB[K1n]=RJv
else
call fhx(1,K2n,"when calling readShort in UnitData, line 1317")
set nB[K1n]=RJv
endif
elseif A5e(qB[K1n],3)then
call fVx(0,K2n,"when calling readByte in UnitData, line 1319")
set nB[K1n]=RJv
endif
endif
if R3e(GV[K1n],2)then
set l1n=gbx(K2n,"when calling readPointData in UnitData, line 1322")
set l2n=Y1
set dB[K1n]=l1n
set fB[K1n]=l2n
endif
if R3e(GV[K1n],3)then
call fVx(0,K2n,"when calling readByte in UnitData, line 1325")
set RB[K1n]=RJv
endif
if R3e(GV[K1n],4)then
call fVx(0,K2n,"when calling readByte in UnitData, line 1327")
set TB[K1n]=RJv
endif
if R3e(GV[K1n],5)then
call fVx(0,K2n,"when calling readByte in UnitData, line 1330")
set lin=RJv
set lan=0
set lnn=lin-1
loop
exitwhen lan>lnn
set lXn=YB[K1n]
set l3n=FKx(K2n,TV[K1n],"when calling readStringTableIndex in UnitData, line 1332")
set lVn=l3n
call zGv(lXn,lVn,"when calling add in UnitData, line 1332")
set lan=lan+1
endloop
endif
set EM=EM-1
endfunction
function l5n takes integer l6n,integer l7n,string l8n returns nothing
local real l9n
local real Lvn
set ZM[EM]=l8n
set EM=EM+1
set l9n=gbx(l7n,"when calling readPointData in UnitData, line 1358")
set Lvn=Y1
set dV[l6n]=l9n
set fV[l6n]=Lvn
call fhx(1,l7n,"when calling readShort in UnitData, line 1359")
set RV[l6n]=RJv*1./$B4
call K0n(l6n,l7n,"when calling deserialize in UnitData, line 1361")
set EM=EM-1
endfunction
function Len takes integer Lxn,integer Lon,string Lrn returns nothing
set ZM[EM]=Lrn
set EM=EM+1
if Dv[Lxn]==0 then
if Lxn==0 then
call Cdv("Nullpointer exception when calling SinglePositionedUnitData.deserialize","when calling error in UnitData, line 1357")
else
call Cdv("Called SinglePositionedUnitData.deserialize on invalid object.","when calling error in UnitData, line 1357")
endif
endif
call l5n(Lxn,Lon,"when calling deserialize in UnitData, line 1357")
set EM=EM-1
endfunction
function Lin takes integer Lan,string Lnn returns nothing
local integer LVn
local integer LEn
set ZM[EM]=Lnn
set EM=EM+1
set LEn=XC[wV[Lan]]
set LVn=JTn(KC[wV[Lan]],"when calling new_SinglePositionedUnitData in UnitData, line 1422")
call Len(LVn,uV[Lan],"when calling deserialize in UnitData, line 1422")
call dlv(LEn,LVn,"when calling add in UnitData, line 1422")
set vM[rV[Lan]]=vM[rV[Lan]]+1
set EM=EM-1
endfunction
function LXn takes integer LOn,string LRn returns nothing
set ZM[EM]=LRn
set EM=EM+1
call uae(WX[IX[LOn]],bAn(duv(PX[LOn],vX[IX[LOn]]),"when calling getIndexFromChar in StringEncoder, line 88"),"when calling writeInt in StringEncoder, line 88")
set vX[IX[LOn]]=vX[IX[LOn]]+1
set EM=EM-1
endfunction
function LIn takes integer LAn,string LNn returns nothing
set ZM[EM]=LNn
set EM=EM+1
call lIe(gX[LAn],gjn(FX[LAn],"when calling new_ChunkElement in StringBuffer, line 80"),"when calling push in StringBuffer, line 80")
set FX[LAn]=""
set EM=EM-1
endfunction
function Lbn takes integer LBn,string Lcn returns nothing
set ZM[EM]=Lcn
set EM=EM+1
if OG[LBn]==0 then
if LBn==0 then
call Cdv("Nullpointer exception when calling AbstractStringBuffer.flushBuffer","when calling error in StringBuffer, line 79")
else
call Cdv("Called AbstractStringBuffer.flushBuffer on invalid object.","when calling error in StringBuffer, line 79")
endif
endif
call LIn(LBn,"when calling flushBuffer in StringBuffer, line 79")
set EM=EM-1
endfunction
function LCn takes integer Ldn,string LDn,string Lfn returns nothing
local string LFn
local integer Lgn
local integer LGn
set ZM[EM]=Lfn
set EM=EM+1
set LFn=LDn
if GZv(LDn)>kR then
call Cdv("AbstractStringBuffer: trying to push a string above MAX_BUFFER_SIZE","when calling error in StringBuffer, line 87")
endif
set Lgn=GZv(LDn)+GZv(FX[Ldn])-kX[Ldn]
loop
exitwhen not(Lgn>0)
set LGn=bUe(GZv(LFn),kX[Ldn]-GZv(FX[Ldn]))
set FX[Ldn]=FX[Ldn]+Psv(LFn,0,LGn)
set LFn=Tgv(LFn,LGn)
set Lgn=Lgn-kX[Ldn]
call Lbn(Ldn,"when calling flushBuffer in StringBuffer, line 96")
endloop
set FX[Ldn]=FX[Ldn]+LFn
set EM=EM-1
endfunction
function Lhn takes integer LHn,string Ljn,string LJn returns nothing
set ZM[EM]=LJn
set EM=EM+1
if OG[LHn]==0 then
if LHn==0 then
call Cdv("Nullpointer exception when calling AbstractStringBuffer.pushString","when calling error in StringBuffer, line 84")
else
call Cdv("Called AbstractStringBuffer.pushString on invalid object.","when calling error in StringBuffer, line 84")
endif
endif
call LCn(LHn,Ljn,"when calling pushString in StringBuffer, line 84")
set EM=EM-1
endfunction
function Lkn takes integer LKn,string Lln returns nothing
set ZM[EM]=Lln
set EM=EM+1
call Lhn(LKn,mq,"when calling pushString in OrderedStringBuffer, line 89")
set EM=EM-1
endfunction
function LLn takes integer Lmn,string LMn returns nothing
set ZM[EM]=LMn
set EM=EM+1
if OG[Lmn]==0 then
if Lmn==0 then
call Cdv("Nullpointer exception when calling OrderedStringBuffer.pushTerminator","when calling error in OrderedStringBuffer, line 88")
else
call Cdv("Called OrderedStringBuffer.pushTerminator on invalid object.","when calling error in OrderedStringBuffer, line 88")
endif
endif
call Lkn(Lmn,"when calling pushTerminator in OrderedStringBuffer, line 88")
set EM=EM-1
endfunction
function Lpn takes integer LPn,integer Lqn,string LQn returns nothing
set ZM[EM]=LQn
set EM=EM+1
call Lhn(LPn,tXa(Lqn,"when calling toString in OrderedStringBuffer, line 92"),"when calling pushString in OrderedStringBuffer, line 92")
set EM=EM-1
endfunction
function Lsn takes integer LSn,integer Ltn,string LTn returns nothing
set ZM[EM]=LTn
set EM=EM+1
if OG[LSn]==0 then
if LSn==0 then
call Cdv("Nullpointer exception when calling OrderedStringBuffer.pushTypeIdentifier","when calling error in OrderedStringBuffer, line 91")
else
call Cdv("Called OrderedStringBuffer.pushTypeIdentifier on invalid object.","when calling error in OrderedStringBuffer, line 91")
endif
endif
call Lpn(LSn,Ltn,"when calling pushTypeIdentifier in OrderedStringBuffer, line 91")
set EM=EM-1
endfunction
function Lun takes integer LUn,real Lwn,string LWn returns nothing
set ZM[EM]=LWn
set EM=EM+1
call Rzn(LUn,"when calling checkWrite in OrderedStringBuffer, line 123")
call Lsn(LUn,1,"when calling pushTypeIdentifier in OrderedStringBuffer, line 124")
call Lhn(LUn,qwv(Lwn),"when calling pushString in OrderedStringBuffer, line 125")
call LLn(LUn,"when calling pushTerminator in OrderedStringBuffer, line 126")
set EM=EM-1
endfunction
function Lyn takes integer LYn,real Lzn,string LZn returns nothing
set ZM[EM]=LZn
set EM=EM+1
if OG[LYn]==0 then
if LYn==0 then
call Cdv("Nullpointer exception when calling Buffer.writeReal","when calling error in BufferInterface, line 72")
else
call Cdv("Called Buffer.writeReal on invalid object.","when calling error in BufferInterface, line 72")
endif
endif
if OG[LYn]<=$441 then
call Lun(LYn,Lzn,"when calling writeReal in BufferInterface, line 72")
else
call FKn(LYn,Lzn,"when calling writeReal in BufferInterface, line 72")
endif
set EM=EM-1
endfunction
function L_n takes integer L0n,integer L1n,string L2n returns nothing
set ZM[EM]=L2n
set EM=EM+1
call Rzn(L0n,"when calling checkWrite in OrderedStringBuffer, line 117")
call Lsn(L0n,0,"when calling pushTypeIdentifier in OrderedStringBuffer, line 118")
call Lhn(L0n,SMv(L1n),"when calling pushString in OrderedStringBuffer, line 119")
call LLn(L0n,"when calling pushTerminator in OrderedStringBuffer, line 120")
set EM=EM-1
endfunction
function L3n takes integer L4n,integer L5n,string L6n returns nothing
set ZM[EM]=L6n
set EM=EM+1
if OG[L4n]==0 then
if L4n==0 then
call Cdv("Nullpointer exception when calling Buffer.writeInt","when calling error in BufferInterface, line 68")
else
call Cdv("Called Buffer.writeInt on invalid object.","when calling error in BufferInterface, line 68")
endif
endif
if OG[L4n]<=$441 then
call L_n(L4n,L5n,"when calling writeInt in BufferInterface, line 68")
else
call FQn(L4n,L5n,"when calling writeInt in BufferInterface, line 68")
endif
set EM=EM-1
endfunction
function L7n takes integer L8n,string L9n,string mvn returns nothing
set ZM[EM]=mvn
set EM=EM+1
if GZv(L9n)>kR then
call Cdv("OrderedStringBuffer: trying to write string above MAX_BUFFER_SIZE","when calling error in OrderedStringBuffer, line 130")
endif
call Rzn(L8n,"when calling checkWrite in OrderedStringBuffer, line 131")
call Lsn(L8n,2,"when calling pushTypeIdentifier in OrderedStringBuffer, line 132")
call Lhn(L8n,SMv(GZv(L9n)),"when calling pushString in OrderedStringBuffer, line 133")
call LLn(L8n,"when calling pushTerminator in OrderedStringBuffer, line 134")
call Lhn(L8n,L9n,"when calling pushString in OrderedStringBuffer, line 135")
set EM=EM-1
endfunction
function men takes integer mxn,string mon,string mrn returns nothing
set ZM[EM]=mrn
set EM=EM+1
if OG[mxn]==0 then
if mxn==0 then
call Cdv("Nullpointer exception when calling Buffer.writeString","when calling error in BufferInterface, line 74")
else
call Cdv("Called Buffer.writeString on invalid object.","when calling error in BufferInterface, line 74")
endif
endif
if OG[mxn]<=$441 then
call L7n(mxn,mon,"when calling writeString in BufferInterface, line 74")
else
call R0n(mxn,mon,"when calling writeString in BufferInterface, line 74")
endif
set EM=EM-1
endfunction
function min takes integer man,boolean mnn,string mVn returns nothing
set ZM[EM]=mVn
set EM=EM+1
call Rzn(man,"when calling checkWrite in OrderedStringBuffer, line 138")
call Lsn(man,3,"when calling pushTypeIdentifier in OrderedStringBuffer, line 139")
call Lhn(man,SMv(yRe(mnn)),"when calling pushString in OrderedStringBuffer, line 140")
set EM=EM-1
endfunction
function mEn takes integer mXn,boolean mOn,string mRn returns nothing
set ZM[EM]=mRn
set EM=EM+1
if OG[mXn]==0 then
if mXn==0 then
call Cdv("Nullpointer exception when calling Buffer.writeBoolean","when calling error in BufferInterface, line 70")
else
call Cdv("Called Buffer.writeBoolean on invalid object.","when calling error in BufferInterface, line 70")
endif
endif
if OG[mXn]<=$441 then
call min(mXn,mOn,"when calling writeBoolean in BufferInterface, line 70")
else
call Aun(mXn,mOn,"when calling writeBoolean in BufferInterface, line 70")
endif
set EM=EM-1
endfunction
function mIn takes integer mAn,integer mNn,string mbn returns nothing
local integer mBn
local integer mcn
set ZM[EM]=mbn
set EM=EM+1
set mBn=fln(mAn,"when calling peekType in OrderedStringBuffer, line 176")
set mcn=mBn
if mcn==0 then
call L3n(mNn,FAn(mAn,"when calling readInt in OrderedStringBuffer, line 180"),"when calling writeInt in OrderedStringBuffer, line 180")
elseif mcn==1 then
call Lyn(mNn,f7n(mAn,"when calling readReal in OrderedStringBuffer, line 182"),"when calling writeReal in OrderedStringBuffer, line 182")
elseif mcn==2 then
call men(mNn,FFn(mAn,"when calling readString in OrderedStringBuffer, line 184"),"when calling writeString in OrderedStringBuffer, line 184")
elseif mcn==3 then
call mEn(mNn,FHn(mAn,"when calling readBoolean in OrderedStringBuffer, line 186"),"when calling writeBoolean in OrderedStringBuffer, line 186")
endif
set EM=EM-1
endfunction
function mCn takes integer mdn,integer mDn,string mfn returns nothing
set ZM[EM]=mfn
set EM=EM+1
if OG[mdn]==0 then
if mdn==0 then
call Cdv("Nullpointer exception when calling OrderedStringBuffer.transferValueTo","when calling error in OrderedStringBuffer, line 175")
else
call Cdv("Called OrderedStringBuffer.transferValueTo on invalid object.","when calling error in OrderedStringBuffer, line 175")
endif
endif
call mIn(mdn,mDn,"when calling transferValueTo in OrderedStringBuffer, line 175")
set EM=EM-1
endfunction
function mFn takes integer mgn,string mGn returns nothing
set ZM[EM]=mGn
set EM=EM+1
call mCn(kD[mgn],jD[mgn],"when calling transferValueTo in OrderedStringBuffer, line 191")
set EM=EM-1
endfunction
function mhn takes integer mHn,string mjn returns nothing
set ZM[EM]=mjn
set EM=EM+1
call d3x(QP[qA[mHn]],gin(UP[qA[mHn]],"when calling readReal in NetworkData, line 364"),"when calling writeReal in NetworkData, line 364")
set BP[qA[mHn]]=BP[qA[mHn]]+1
set EM=EM-1
endfunction
function mJn takes integer mkn,integer mKn,string mln returns nothing
set ZM[EM]=mln
set EM=EM+1
call uAe(mKn,hU[mkn],"when calling writeByte in ItemData, line 138")
if Ide(hU[mkn],7)then
call uAe(mKn,FU[mkn],"when calling writeByte in ItemData, line 140")
endif
call UPe(mKn,kU[mkn],"when calling writeInt in ItemData, line 141")
if Ide(hU[mkn],6)then
if Ide(hU[mkn],4)then
call UPe(mKn,jU[mkn],"when calling writeInt in ItemData, line 145")
else
call uYe(mKn,jU[mkn],"when calling writeShort in ItemData, line 147")
endif
elseif(not Ide(hU[mkn],4))and(not Ide(hU[mkn],5))then
call uAe(mKn,jU[mkn],"when calling writeByte in ItemData, line 149")
endif
if IVe(FU[mkn],0)then
call y3e(mKn,xU[mkn],"when calling writeReal in ItemData, line 152")
endif
if IVe(FU[mkn],1)then
call USe(mKn,gU[mkn],vU[mkn],"when calling writeStringTableIndex in ItemData, line 155")
endif
if IVe(FU[mkn],2)then
call USe(mKn,gU[mkn],mU[mkn],"when calling writeStringTableIndex in ItemData, line 157")
endif
if IVe(FU[mkn],3)then
call USe(mKn,gU[mkn],QU[mkn],"when calling writeStringTableIndex in ItemData, line 159")
endif
if IVe(FU[mkn],4)then
call USe(mKn,gU[mkn],WU[mkn],"when calling writeStringTableIndex in ItemData, line 161")
endif
if IVe(FU[mkn],5)then
call USe(mKn,gU[mkn],EU[mkn],"when calling writeStringTableIndex in ItemData, line 163")
endif
set EM=EM-1
endfunction
function mLn takes integer mmn,integer mMn,string mpn returns nothing
set ZM[EM]=mpn
set EM=EM+1
call Y7e(mMn,ZU[mmn],UU[mmn],"when calling writePointData in ItemData, line 213")
call mJn(mmn,mMn,"when calling serialize in ItemData, line 215")
set EM=EM-1
endfunction
function mPn takes integer mqn,integer mQn,string msn returns nothing
set ZM[EM]=msn
set EM=EM+1
if vh[mqn]==0 then
if mqn==0 then
call Cdv("Nullpointer exception when calling SingleItemData.serialize","when calling error in ItemData, line 137")
else
call Cdv("Called SingleItemData.serialize on invalid object.","when calling error in ItemData, line 137")
endif
endif
if vh[mqn]<=4642 then
call mJn(mqn,mQn,"when calling serialize in ItemData, line 137")
else
call mLn(mqn,mQn,"when calling serialize in ItemData, line 137")
endif
set EM=EM-1
endfunction
function mSn takes integer mtn,integer mTn,integer mun,real mUn,integer mwn,integer mWn,string myn returns nothing
set ZM[EM]=myn
set EM=EM+1
call uAe(mtn,mTn,"when calling writeByte in UnitData, line 807")
if N_e(mTn,0)then
if N_e(mTn,1)then
call UPe(mtn,mun,"when calling writeInt in UnitData, line 811")
else
call uAe(mtn,mun,"when calling writeByte in UnitData, line 813")
endif
endif
if N_e(mTn,2)then
if N_e(mTn,3)then
call uAe(mtn,c6v(mUn*100.),"when calling writeByte in UnitData, line 816")
else
call y3e(mtn,mUn,"when calling writeReal in UnitData, line 818")
endif
endif
if N_e(mTn,4)then
if N_e(mTn,5)then
call UPe(mtn,mwn,"when calling writeInt in UnitData, line 821")
else
call uAe(mtn,mwn,"when calling writeByte in UnitData, line 823")
endif
endif
if N_e(mTn,6)then
if N_e(mTn,7)then
call UPe(mtn,mWn,"when calling writeInt in UnitData, line 826")
else
call uAe(mtn,mWn,"when calling writeByte in UnitData, line 828")
endif
endif
set EM=EM-1
endfunction
function mYn takes integer mzn,integer mZn,integer m_n,integer m0n,integer m1n,real m2n,integer m3n,integer m4n,integer m5n,integer m6n,real m7n,integer m8n,integer m9n,integer Mvn,integer Men,integer Mxn,integer Mon,integer Mrn,string Min returns nothing
set ZM[EM]=Min
set EM=EM+1
call uYe(mzn,mZn,"when calling writeShort in UnitData, line 668")
if O5e(mZn,0)then
call uAe(mzn,m_n,"when calling writeByte in UnitData, line 671")
endif
if O5e(mZn,4)then
call mSn(mzn,m0n,m1n,m2n,m3n,m4n,"when calling writeAttackParameters in UnitData, line 674")
endif
if O5e(mZn,5)then
call mSn(mzn,m5n,m6n,m7n,m8n,m9n,"when calling writeAttackParameters in UnitData, line 676")
endif
if O5e(mZn,6)then
if O5e(mZn,7)then
call uAe(mzn,Mvn,"when calling writeByte in UnitData, line 679")
else
call UPe(mzn,Mvn,"when calling writeInt in UnitData, line 681")
endif
endif
if O5e(mZn,8)then
if O5e(mZn,9)then
call uYe(mzn,Men,"when calling writeShort in UnitData, line 684")
else
call UPe(mzn,Men,"when calling writeInt in UnitData, line 686")
endif
endif
if O5e(mZn,$A)then
if O5e(mZn,$B)then
call uYe(mzn,Mxn,"when calling writeShort in UnitData, line 689")
else
call UPe(mzn,Mxn,"when calling writeInt in UnitData, line 691")
endif
endif
if O5e(mZn,$E)then
call uAe(mzn,Mon,"when calling writeByte in UnitData, line 694")
endif
if O5e(mZn,$F)then
call uAe(mzn,Mrn,"when calling writeByte in UnitData, line 696")
endif
set EM=EM-1
endfunction
function Man takes integer Mnn,integer MVn,integer MEn,integer MXn,integer MOn,integer MRn,integer MIn,integer MAn,integer MNn,string Mbn returns nothing
set ZM[EM]=Mbn
set EM=EM+1
call uAe(Mnn,MVn,"when calling writeByte in UnitData, line 115")
if RCe(MVn,7)then
call uAe(Mnn,MEn,"when calling writeByte in UnitData, line 117")
endif
call UPe(Mnn,MXn,"when calling writeInt in UnitData, line 119")
if RCe(MVn,1)then
if RCe(MVn,2)then
if KMn(MEn,0)then
call UPe(Mnn,MOn,"when calling writeInt in UnitData, line 124")
else
call uYe(Mnn,MOn,"when calling writeShort in UnitData, line 126")
endif
else
call uAe(Mnn,MOn,"when calling writeByte in UnitData, line 128")
endif
endif
if RCe(MVn,3)then
if RCe(MVn,4)then
if KMn(MEn,1)then
call UPe(Mnn,MRn,"when calling writeInt in UnitData, line 132")
else
call uYe(Mnn,MRn,"when calling writeShort in UnitData, line 134")
endif
else
call uAe(Mnn,MRn,"when calling writeByte in UnitData, line 136")
endif
endif
if RCe(MVn,5)then
if RCe(MVn,6)then
if KMn(MEn,2)then
call UPe(Mnn,MIn,"when calling writeInt in UnitData, line 140")
else
call uYe(Mnn,MIn,"when calling writeShort in UnitData, line 142")
endif
else
call uAe(Mnn,MIn,"when calling writeByte in UnitData, line 144")
endif
endif
call USe(Mnn,MNn,MAn,"when calling writeStringTableIndex in UnitData, line 146")
set EM=EM-1
endfunction
function MBn takes integer Mcn,integer MCn,string Mdn returns nothing
set ZM[EM]=Mdn
set EM=EM+1
call uAe(MCn,pV[Mcn],"when calling writeByte in UnitData, line 922")
call UPe(MCn,eV[Mcn],"when calling writeInt in UnitData, line 923")
if not(Vxe(pV[Mcn],0)or Vxe(pV[Mcn],1)or Vxe(pV[Mcn],2)or Vxe(pV[Mcn],3))then
call uYe(MCn,qV[Mcn],"when calling writeShort in UnitData, line 926")
endif
if Vxe(pV[Mcn],4)then
if Vxe(pV[Mcn],6)then
call uAe(MCn,aV[Mcn],"when calling writeByte in UnitData, line 929")
else
call UPe(MCn,aV[Mcn],"when calling writeInt in UnitData, line 931")
endif
endif
if Vxe(pV[Mcn],5)then
if Vxe(pV[Mcn],6)then
call uAe(MCn,c6v(nV[Mcn]*2.),"when calling writeByte in UnitData, line 934")
else
call y3e(MCn,nV[Mcn],"when calling writeReal in UnitData, line 936")
endif
endif
set EM=EM-1
endfunction
function MDn takes integer Mfn,integer MFn,string Mgn returns nothing
set ZM[EM]=Mgn
set EM=EM+1
if Uv[Mfn]==0 then
if Mfn==0 then
call Cdv("Nullpointer exception when calling SingleAbilityData.serialize","when calling error in UnitData, line 921")
else
call Cdv("Called SingleAbilityData.serialize on invalid object.","when calling error in UnitData, line 921")
endif
endif
call MBn(Mfn,MFn,"when calling serialize in UnitData, line 921")
set EM=EM-1
endfunction
function MGn takes integer Mhn,integer MHn,real Mjn,real MJn,real Mkn,real MKn,real Mln,string MLn returns nothing
set ZM[EM]=MLn
set EM=EM+1
call uAe(Mhn,MHn,"when calling writeByte in UnitData, line 383")
if ADe(MHn,0)then
if ADe(MHn,1)then
call uYe(Mhn,c6v(Mjn*10.),"when calling writeShort in UnitData, line 387")
else
call y3e(Mhn,Mjn,"when calling writeReal in UnitData, line 389")
endif
endif
if ADe(MHn,2)then
call uYe(Mhn,c6v(MJn*10000.),"when calling writeShort in UnitData, line 391")
endif
if ADe(MHn,3)then
if ADe(MHn,4)then
call uAe(Mhn,c6v(Mkn*100.),"when calling writeByte in UnitData, line 394")
elseif ADe(MHn,5)then
call uYe(Mhn,c6v(Mkn*1000.),"when calling writeShort in UnitData, line 396")
else
call y3e(Mhn,Mkn,"when calling writeReal in UnitData, line 398")
endif
endif
if ADe(MHn,6)then
call y3e(Mhn,MKn,"when calling writeReal in UnitData, line 400")
endif
if ADe(MHn,7)then
call uYe(Mhn,c6v(Mln*10000.),"when calling writeShort in UnitData, line 402")
endif
set EM=EM-1
endfunction
function Mmn takes integer MMn,integer Mpn,real MPn,integer Mqn,integer MQn,integer Msn,integer MSn,integer Mtn,real MTn,string Mun returns nothing
set ZM[EM]=Mun
set EM=EM+1
call uAe(MMn,Mpn,"when calling writeByte in UnitData, line 257")
if NFe(Mpn,0)then
if NFe(Mpn,1)then
call uAe(MMn,c6v(MPn),"when calling writeByte in UnitData, line 261")
elseif NFe(Mpn,2)then
call uYe(MMn,c6v(MPn*10.),"when calling writeShort in UnitData, line 263")
else
call y3e(MMn,MPn,"when calling writeReal in UnitData, line 265")
endif
endif
if NFe(Mpn,3)then
call uAe(MMn,Mqn,"when calling writeByte in UnitData, line 267")
endif
if NFe(Mpn,4)then
call uAe(MMn,MQn,"when calling writeByte in UnitData, line 269")
call uAe(MMn,Msn,"when calling writeByte in UnitData, line 270")
call uAe(MMn,MSn,"when calling writeByte in UnitData, line 271")
call uAe(MMn,Mtn,"when calling writeByte in UnitData, line 272")
endif
if NFe(Mpn,5)then
if NFe(Mpn,6)then
call uAe(MMn,c6v(MTn*100.),"when calling writeByte in UnitData, line 275")
elseif NFe(Mpn,7)then
call uYe(MMn,c6v(MTn*1000.)+$7FFF,"when calling writeShort in UnitData, line 277")
else
call y3e(MMn,MTn,"when calling writeReal in UnitData, line 279")
endif
endif
set EM=EM-1
endfunction
function MUn takes integer Mwn,integer MWn,string Myn returns nothing
local integer MYn
local integer Mzn
local integer MZn
local integer M_n
local integer M0n
local integer M1n
local integer M2n
local integer M3n
local integer M4n
local integer M5n
local integer M6n
local integer M7n
local integer M8n
set ZM[EM]=Myn
set EM=EM+1
call uAe(MWn,YV[Mwn],"when calling writeByte in UnitData, line 1203")
if Ace(YV[Mwn],7)then
call uAe(MWn,GV[Mwn],"when calling writeByte in UnitData, line 1205")
endif
call UPe(MWn,gV[Mwn],"when calling writeInt in UnitData, line 1206")
if Ace(YV[Mwn],2)then
call Man(MWn,hV[Mwn],FV[Mwn],kV[Mwn],jV[Mwn],xV[Mwn],vV[Mwn],mV[Mwn],TV[Mwn],"when calling writeHeroParameters in UnitData, line 1209")
endif
if Ace(YV[Mwn],3)then
call USe(MWn,TV[Mwn],QV[Mwn],"when calling writeStringTableIndex in UnitData, line 1212")
endif
if Ace(YV[Mwn],4)then
call Mmn(MWn,WV[Mwn],EV[Mwn],ZV[Mwn],UV[Mwn],IV[Mwn],PV[Mwn],AV[Mwn],DV[Mwn],"when calling writeArtParameters in UnitData, line 1215")
endif
if Ace(YV[Mwn],5)then
call MGn(MWn,HV[Mwn],JV[Mwn],KV[Mwn],LV[Mwn],XV[Mwn],CV[Mwn],"when calling writeAnimationParameters in UnitData, line 1217")
endif
if Ace(YV[Mwn],6)then
call mYn(MWn,VV[Mwn],BV[Mwn],NV[Mwn],MV[Mwn],wB[Mwn],uB[Mwn],rB[Mwn],sB[Mwn],tB[Mwn],iB[Mwn],SB[Mwn],cB[Mwn],oB[Mwn],OB[Mwn],lB[Mwn],bB[Mwn],yB[Mwn],"when calling writeStats in UnitData, line 1220")
if O5e(VV[Mwn],0)then
set M7n=0
set MYn=M7n
set Mzn=0
set MZn=BV[Mwn]-1
loop
exitwhen Mzn>MZn
if Bce(Mwn,Mzn,"when reading array SingleUnitData_items in  in UnitData, line 1224")!=0 then
set M8n=dpv(MYn,Mzn)
set MYn=M8n
endif
set Mzn=Mzn+1
endloop
call uAe(MWn,MYn,"when calling writeByte in UnitData, line 1226")
set M_n=0
set M0n=BV[Mwn]-1
loop
exitwhen M_n>M0n
if Bce(Mwn,M_n,"when reading array SingleUnitData_items in  in UnitData, line 1228")!=0 then
call mPn(Bce(Mwn,M_n,"when reading array SingleUnitData_items in  in UnitData, line 1229"),MWn,"when calling serialize in UnitData, line 1229")
endif
set M_n=M_n+1
endloop
endif
if O5e(VV[Mwn],$C)then
call uAe(MWn,hye(pB[Mwn],"when calling size in UnitData, line 1231"),"when calling writeByte in UnitData, line 1231")
set M1n=Xle(pB[Mwn],"when calling iterator in UnitData, line 1232")
loop
exitwhen not Xie(M1n)
set M2n=E3e(M1n)
call UPe(MWn,M2n,"when calling writeInt in UnitData, line 1233")
endloop
call Xpe(M1n,"when calling close in UnitData, line 1232")
endif
if O5e(VV[Mwn],$D)then
call uAe(MWn,hye(eB[Mwn],"when calling size in UnitData, line 1235"),"when calling writeByte in UnitData, line 1235")
set M3n=Xle(eB[Mwn],"when calling iterator in UnitData, line 1236")
loop
exitwhen not Xie(M3n)
set M4n=E3e(M3n)
call MDn(M4n,MWn,"when calling serialize in UnitData, line 1237")
endloop
call Xpe(M3n,"when calling close in UnitData, line 1236")
endif
endif
if R3e(GV[Mwn],0)then
call uAe(MWn,qB[Mwn],"when calling writeByte in UnitData, line 1240")
if A5e(qB[Mwn],0)then
if not A5e(qB[Mwn],1)then
call UPe(MWn,aB[Mwn],"when calling writeInt in UnitData, line 1243")
else
call uYe(MWn,aB[Mwn],"when calling writeShort in UnitData, line 1245")
endif
elseif A5e(qB[Mwn],1)then
call uAe(MWn,aB[Mwn],"when calling writeByte in UnitData, line 1247")
endif
if A5e(qB[Mwn],2)then
if not A5e(qB[Mwn],3)then
call UPe(MWn,nB[Mwn],"when calling writeInt in UnitData, line 1250")
else
call uYe(MWn,nB[Mwn],"when calling writeShort in UnitData, line 1252")
endif
elseif A5e(qB[Mwn],3)then
call uAe(MWn,nB[Mwn],"when calling writeByte in UnitData, line 1254")
endif
endif
if R3e(GV[Mwn],2)then
call Y7e(MWn,dB[Mwn],fB[Mwn],"when calling writePointData in UnitData, line 1257")
endif
if R3e(GV[Mwn],3)then
call uAe(MWn,RB[Mwn],"when calling writeByte in UnitData, line 1260")
endif
if R3e(GV[Mwn],4)then
call uAe(MWn,TB[Mwn],"when calling writeByte in UnitData, line 1262")
endif
if R3e(GV[Mwn],5)then
call uAe(MWn,hye(YB[Mwn],"when calling size in UnitData, line 1265"),"when calling writeByte in UnitData, line 1265")
set M5n=Xle(YB[Mwn],"when calling iterator in UnitData, line 1266")
loop
exitwhen not Xie(M5n)
set M6n=E3e(M5n)
call USe(MWn,TV[Mwn],M6n,"when calling writeStringTableIndex in UnitData, line 1267")
endloop
call Xpe(M5n,"when calling close in UnitData, line 1266")
endif
set EM=EM-1
endfunction
function M9n takes integer pvn,integer pen,string pxn returns nothing
set ZM[EM]=pxn
set EM=EM+1
call Y7e(pen,dV[pvn],fV[pvn],"when calling writePointData in UnitData, line 1352")
call uYe(pen,c6v(RV[pvn]*180.),"when calling writeShort in UnitData, line 1353")
call MUn(pvn,pen,"when calling serialize in UnitData, line 1355")
set EM=EM-1
endfunction
function pon takes integer prn,integer pin,string pan returns nothing
set ZM[EM]=pan
set EM=EM+1
if Dv[prn]==0 then
if prn==0 then
call Cdv("Nullpointer exception when calling SinglePositionedUnitData.serialize","when calling error in UnitData, line 1351")
else
call Cdv("Called SinglePositionedUnitData.serialize on invalid object.","when calling error in UnitData, line 1351")
endif
endif
call M9n(prn,pin,"when calling serialize in UnitData, line 1351")
set EM=EM-1
endfunction
function pnn takes integer pVn,string pEn returns nothing
set ZM[EM]=pEn
set EM=EM+1
call pon(DIn(VC[pVn],"when calling next in UnitData, line 1405"),BC[pVn],"when calling serialize in UnitData, line 1405")
set EM=EM-1
endfunction
function pXn takes integer pOn,string pRn returns nothing
set ZM[EM]=pRn
set EM=EM+1
call FTn(vA[tD[pOn]],den(QA[tD[pOn]],"when calling readInt in Network, line 343"),"when calling writeInt in Network, line 343")
set LA[tD[pOn]]=LA[tD[pOn]]+1
set EM=EM-1
endfunction
function pIn takes integer pAn,string pNn returns nothing
set ZM[EM]=pNn
set EM=EM+1
call Hbn(EP[GA[pAn]],den(PP[GA[pAn]],"when calling readInt in NetworkData, line 388"),"when calling pushInt in NetworkData, line 388")
set MP[GA[pAn]]=MP[GA[pAn]]+1
set EM=EM-1
endfunction
function pbn takes integer pBn,string pcn returns boolean
local boolean pCn
set ZM[EM]=pcn
set EM=EM+1
call tna(pBn,"when calling checkRead in HashBuffer, line 110")
set DZ[pBn]=DZ[pBn]+1
if Ca and(not tUa(WZ[pBn],DZ[pBn],"when calling hasBoolean in HashBuffer, line 112"))then
call Cdv("HashBuffer: trying to read non-present boolean at pos#"+SMv(DZ[pBn]),"when calling error in HashBuffer, line 113")
endif
set pCn=CKx(WZ[pBn],DZ[pBn],"when calling loadBoolean in HashBuffer, line 114")
set EM=EM-1
return pCn
endfunction
function pdn takes integer pDn,string pfn returns boolean
local boolean pFn
set ZM[EM]=pfn
set EM=EM+1
if OG[pDn]==0 then
if pDn==0 then
call Cdv("Nullpointer exception when calling HashBuffer.readBooleanUnsafe","when calling error in HashBuffer, line 109")
else
call Cdv("Called HashBuffer.readBooleanUnsafe on invalid object.","when calling error in HashBuffer, line 109")
endif
endif
set pFn=pbn(pDn,"when calling readBooleanUnsafe in HashBuffer, line 109")
set EM=EM-1
return pFn
endfunction
function pgn takes integer pGn,string phn returns nothing
set ZM[EM]=phn
set EM=EM+1
call g9n(EA[lD[pGn]],pdn(vA[lD[pGn]],"when calling readBooleanUnsafe in Network, line 361"),"when calling writeBoolean in Network, line 361")
set CA[lD[pGn]]=CA[lD[pGn]]+1
set EM=EM-1
endfunction
function pHn takes integer pjn,string pJn returns nothing
set ZM[EM]=pJn
set EM=EM+1
if DY[pjn]==0 then
if pjn==0 then
call Cdv("Nullpointer exception when calling LimitedExecuteAction.run","when calling error in Execute, line 108")
else
call Cdv("Called LimitedExecuteAction.run on invalid object.","when calling error in Execute, line 108")
endif
endif
if DY[pjn]<=$CEA then
if DY[pjn]<=$CE1 then
if DY[pjn]<=$CDD then
if DY[pjn]<=$CDB then
if DY[pjn]<=$CDA then
if DY[pjn]<=$CD9 then
call JJn(pjn,"when calling run_executeWhile_Base64Decoder_Base64 in Execute, line 108")
else
call F0n(pjn,"when calling run_executeWhile_BufferAdapters in Execute, line 108")
endif
else
call gsn(pjn,"when calling run_executeWhile_BufferAdapters in Execute, line 108")
endif
elseif DY[pjn]<=$CDC then
call HEn(pjn,"when calling run_executeWhile_BufferAdapters in Execute, line 108")
else
call jOn(pjn,"when calling run_executeWhile_GamecacheBuffer_GamecacheBuffer in Execute, line 108")
endif
elseif DY[pjn]<=$CDF then
if DY[pjn]<=$CDE then
call HKn(pjn,"when calling run_executeWhile_Network_Network in Execute, line 108")
else
call DXn(pjn,"when calling run_executeWhile_Network_Network in Execute, line 108")
endif
elseif DY[pjn]<=$CE0 then
call pXn(pjn,"when calling run_executeWhile_Network_Network in Execute, line 108")
else
call fAn(pjn,"when calling run_executeWhile_Network_Network in Execute, line 108")
endif
elseif DY[pjn]<=$CE6 then
if DY[pjn]<=$CE4 then
if DY[pjn]<=$CE3 then
if DY[pjn]<=$CE2 then
call gEn(pjn,"when calling run_executeWhile_Network_Network in Execute, line 108")
else
call pgn(pjn,"when calling run_executeWhile_Network_Network in Execute, line 108")
endif
else
call jAn(pjn,"when calling run_executeWhile_Network_Network in Execute, line 108")
endif
elseif DY[pjn]<=$CE5 then
call jdn(pjn,"when calling run_executeWhile_Network_Network in Execute, line 108")
else
call Hdn(pjn,"when calling run_executeWhile_Network_Network in Execute, line 108")
endif
elseif DY[pjn]<=$CE8 then
if DY[pjn]<=$CE7 then
call d1n(pjn,"when calling run_executeWhile_Network_Network in Execute, line 108")
else
call jFn(pjn,"when calling run_executeWhile_Network_NetworkData in Execute, line 108")
endif
elseif DY[pjn]<=$CE9 then
call hBn(pjn,"when calling run_executeWhile_Network_NetworkData in Execute, line 108")
else
call din(pjn,"when calling run_executeWhile_Network_NetworkData in Execute, line 108")
endif
elseif DY[pjn]<=$CF3 then
if DY[pjn]<=$CEF then
if DY[pjn]<=$CED then
if DY[pjn]<=$CEC then
if DY[pjn]<=$CEB then
call dHn(pjn,"when calling run_executeWhile_Network_NetworkData in Execute, line 108")
else
call mhn(pjn,"when calling run_executeWhile_Network_NetworkData in Execute, line 108")
endif
else
call Gon(pjn,"when calling run_executeWhile_Network_NetworkData in Execute, line 108")
endif
elseif DY[pjn]<=$CEE then
call Hzn(pjn,"when calling run_executeWhile_Network_NetworkData in Execute, line 108")
else
call D5n(pjn,"when calling run_executeWhile_Network_NetworkData in Execute, line 108")
endif
elseif DY[pjn]<=$CF1 then
if DY[pjn]<=$CF0 then
call pIn(pjn,"when calling run_executeWhile_Network_NetworkData in Execute, line 108")
else
call fGn(pjn,"when calling run_executeWhile_Network_NetworkData in Execute, line 108")
endif
elseif DY[pjn]<=$CF2 then
call mFn(pjn,"when calling run_executeWhile_OrderedStringBuffer_OrderedStringBuffer in Execute, line 108")
else
call pnn(pjn,"when calling run_executeWhile_PositionedUnitData_UnitData in Execute, line 108")
endif
elseif DY[pjn]<=$CF7 then
if DY[pjn]<=$CF5 then
if DY[pjn]<=$CF4 then
call Lin(pjn,"when calling run_executeWhile_PositionedUnitData_UnitData in Execute, line 108")
else
call LXn(pjn,"when calling run_executeWhile_StringEncoder_StringEncoder in Execute, line 108")
endif
elseif DY[pjn]<=$CF6 then
call jBn(pjn,"when calling run_executeWhile_StringEncoder_StringEncoder in Execute, line 108")
else
call jUn(pjn,"when calling run_executeWhile_StringEncoder_StringEncoder in Execute, line 108")
endif
elseif DY[pjn]<=$CF9 then
if DY[pjn]<=$CF8 then
call hqn(pjn,"when calling run_executeWhile_StringEncoder_StringEncoder in Execute, line 108")
else
call gTn(pjn,"when calling run_executeWhile_SubRectTileData_TerrainData in Execute, line 108")
endif
elseif DY[pjn]<=$CFA then
call Dsn(pjn,"when calling run_executeWhile_SubRectTileData_TerrainData in Execute, line 108")
else
call hAn(pjn,"when calling run_executeWhile_execute_Base64Encoder_Base64 in Execute, line 108")
endif
set EM=EM-1
endfunction
function pkn takes integer pKn returns integer
return ee-fZ[pKn]-1
endfunction
function pln takes integer pLn,string pmn returns integer
local integer pMn
set ZM[EM]=pmn
set EM=EM+1
if Bg[pLn]==0 then
if pLn==0 then
call Cdv("Nullpointer exception when calling GamecacheBuffer.getRemainingWrite","when calling error in GamecacheBuffer, line 35")
else
call Cdv("Called GamecacheBuffer.getRemainingWrite on invalid object.","when calling error in GamecacheBuffer, line 35")
endif
endif
set pMn=pkn(pLn)
set EM=EM-1
return pMn
endfunction
function ppn takes integer pPn,string pqn returns boolean
local boolean pQn
set ZM[EM]=pqn
set EM=EM+1
set pQn=CA[OD[pPn]]<DA[OD[pPn]]and pln(EA[OD[pPn]],"when calling getRemainingWrite in Network, line 360")>0
set EM=EM-1
return pQn
endfunction
function psn takes integer pSn,string ptn returns boolean
local boolean pTn
set ZM[EM]=ptn
set EM=EM+1
set pTn=cCx(pSn,2,"when calling hasRemainingData in HashData, line 217")
set EM=EM-1
return pTn
endfunction
function pun takes integer pUn,string pwn returns boolean
local boolean pWn
set ZM[EM]=pwn
set EM=EM+1
if gY[pUn]==0 then
if pUn==0 then
call Cdv("Nullpointer exception when calling HashReader.hasString","when calling error in HashData, line 216")
else
call Cdv("Called HashReader.hasString on invalid object.","when calling error in HashData, line 216")
endif
endif
set pWn=psn(pUn,"when calling hasString in HashData, line 216")
set EM=EM-1
return pWn
endfunction
function pyn takes integer pYn,string pzn returns boolean
local boolean pZn
set ZM[EM]=pzn
set EM=EM+1
set pZn=pun(EX[pYn],"when calling hasString in StringEncoder, line 135")
set EM=EM-1
return pZn
endfunction
function p_n takes integer p0n,string p1n returns boolean
local boolean p2n
set ZM[EM]=p1n
set EM=EM+1
if Ov[p0n]==0 then
if p0n==0 then
call Cdv("Nullpointer exception when calling StringEncoder.hasString","when calling error in StringEncoder, line 134")
else
call Cdv("Called StringEncoder.hasString on invalid object.","when calling error in StringEncoder, line 134")
endif
endif
set p2n=pyn(p0n,"when calling hasString in StringEncoder, line 134")
set EM=EM-1
return p2n
endfunction
function p3n takes integer p4n,string p5n returns boolean
local boolean p6n
set ZM[EM]=p5n
set EM=EM+1
set p6n=p_n(EP[FA[p4n]],"when calling hasString in NetworkData, line 450")
set EM=EM-1
return p6n
endfunction
function p7n takes integer p8n,string p9n returns boolean
local boolean Pvn
set ZM[EM]=p9n
set EM=EM+1
set Pvn=SVa(p8n,"when calling isDataAvailable in StringBuffer, line 108")
set EM=EM-1
return Pvn
endfunction
function Pen takes integer Pxn,string Pon returns boolean
local boolean Prn
set ZM[EM]=Pon
set EM=EM+1
if OG[Pxn]==0 then
if Pxn==0 then
call Cdv("Nullpointer exception when calling AbstractStringBuffer.canRead","when calling error in StringBuffer, line 107")
else
call Cdv("Called AbstractStringBuffer.canRead on invalid object.","when calling error in StringBuffer, line 107")
endif
endif
set Prn=p7n(Pxn,"when calling canRead in StringBuffer, line 107")
set EM=EM-1
return Prn
endfunction
function Pin takes integer Pan,string Pnn returns boolean
local boolean PVn
set ZM[EM]=Pnn
set EM=EM+1
set PVn=Pen(QQ[Pan],"when calling canRead in BufferAdapters, line 21")
set EM=EM-1
return PVn
endfunction
function PEn takes integer PXn,string POn returns boolean
local boolean PRn
set ZM[EM]=POn
set EM=EM+1
set PRn=XA[iD[PXn]]<AA[iD[PXn]]and pln(WA[iD[PXn]],"when calling getRemainingWrite in Network, line 348")>0
set EM=EM-1
return PRn
endfunction
function PIn takes integer PAn returns integer
return ee-RZ[PAn]-1
endfunction
function PNn takes integer Pbn,string PBn returns integer
local integer Pcn
set ZM[EM]=PBn
set EM=EM+1
if Bg[Pbn]==0 then
if Pbn==0 then
call Cdv("Nullpointer exception when calling GamecacheBuffer.getRemainingRead","when calling error in GamecacheBuffer, line 39")
else
call Cdv("Called GamecacheBuffer.getRemainingRead on invalid object.","when calling error in GamecacheBuffer, line 39")
endif
endif
set Pcn=PIn(Pbn)
set EM=EM-1
return Pcn
endfunction
function PCn takes integer Pdn,string PDn returns boolean
local boolean Pfn
set ZM[EM]=PDn
set EM=EM+1
set Pfn=XA[cD[Pdn]]<AA[cD[Pdn]]and PNn(WA[cD[Pdn]],"when calling getRemainingRead in Network, line 354")>0
set EM=EM-1
return Pfn
endfunction
function PFn takes integer Pgn,string PGn returns boolean
local boolean Phn
set ZM[EM]=PGn
set EM=EM+1
set Phn=BP[yA[Pgn]]<JP[yA[Pgn]]and pln(UP[yA[Pgn]],"when calling getRemainingWrite in NetworkData, line 357")>0
set EM=EM-1
return Phn
endfunction
function PHn takes integer Pjn returns boolean
return gH[Pjn]<=YH[Pjn]
endfunction
function PJn takes integer Pkn,string PKn returns boolean
local boolean Pln
set ZM[EM]=PKn
set EM=EM+1
if Pk[Pkn]==0 then
if Pkn==0 then
call Cdv("Nullpointer exception when calling RectCellIterator.hasNext","when calling error in RectCellIterator, line 31")
else
call Cdv("Called RectCellIterator.hasNext on invalid object.","when calling error in RectCellIterator, line 31")
endif
endif
set Pln=PHn(Pkn)
set EM=EM-1
return Pln
endfunction
function PLn takes integer Pmn,string PMn returns boolean
local boolean Ppn
set ZM[EM]=PMn
set EM=EM+1
set Ppn=PJn(gC[Pmn],"when calling hasNext in TerrainData, line 58")
set EM=EM-1
return Ppn
endfunction
function PPn takes integer Pqn,string PQn returns boolean
local boolean Psn
set ZM[EM]=PQn
set EM=EM+1
set Psn=BP[eA[Pqn]]<JP[eA[Pqn]]and PNn(UP[eA[Pqn]],"when calling getRemainingRead in NetworkData, line 363")>0
set EM=EM-1
return Psn
endfunction
function PSn takes integer Ptn,string PTn returns boolean
local boolean Pun
set ZM[EM]=PTn
set EM=EM+1
set Pun=LA[uD[Ptn]]<PA[uD[Ptn]]and pln(QA[uD[Ptn]],"when calling getRemainingWrite in Network, line 336")>0
set EM=EM-1
return Pun
endfunction
function PUn takes integer Pwn,string PWn returns boolean
local boolean Pyn
set ZM[EM]=PWn
set EM=EM+1
set Pyn=MP[RA[Pwn]]<LP[RA[Pwn]]and pln(PP[RA[Pwn]],"when calling getRemainingWrite in NetworkData, line 381")>0
set EM=EM-1
return Pyn
endfunction
function PYn takes integer Pzn,string PZn returns boolean
local boolean P_n
set ZM[EM]=PZn
set EM=EM+1
set P_n=NP[aA[Pzn]]<KP[aA[Pzn]]and pln(IP[aA[Pzn]],"when calling getRemainingWrite in NetworkData, line 369")>0
set EM=EM-1
return P_n
endfunction
function P0n takes integer ibs returns boolean
return ey<=qy
endfunction
function P1n takes integer P2n,string P3n returns boolean
local boolean P4n
set ZM[EM]=P3n
set EM=EM+1
set P4n=VP[lA[P2n]]<HP[lA[P2n]]and PNn(ZP[lA[P2n]],"when calling getRemainingRead in NetworkData, line 351")>0
set EM=EM-1
return P4n
endfunction
function P5n takes integer P6n,string P7n returns boolean
local boolean P8n
set ZM[EM]=P7n
set EM=EM+1
set P8n=Avn(fP[P6n],"when calling hasString in MultifileIO, line 249")
set EM=EM-1
return P8n
endfunction
function P9n takes integer qvn,string qen returns boolean
local boolean qxn
set ZM[EM]=qen
set EM=EM+1
if PF[qvn]==0 then
if qvn==0 then
call Cdv("Nullpointer exception when calling FileReader.canRead","when calling error in MultifileIO, line 248")
else
call Cdv("Called FileReader.canRead on invalid object.","when calling error in MultifileIO, line 248")
endif
endif
set qxn=P5n(qvn,"when calling canRead in MultifileIO, line 248")
set EM=EM-1
return qxn
endfunction
function qon takes integer qrn,string qin returns boolean
local boolean qan
set ZM[EM]=qin
set EM=EM+1
set qan=P9n(ZQ[qrn],"when calling canRead in BufferAdapters, line 25")
set EM=EM-1
return qan
endfunction
function qnn takes integer qVn,string qEn returns boolean
local boolean qXn
set ZM[EM]=qEn
set EM=EM+1
set qXn=pun(WP[SA[qVn]],"when calling hasString in NetworkData, line 298")
set EM=EM-1
return qXn
endfunction
function qOn takes integer qRn,string qIn returns boolean
local boolean qAn
set ZM[EM]=qIn
set EM=EM+1
set qAn=pun(QX[JX[qRn]],"when calling hasString in StringEncoder, line 105")
set EM=EM-1
return qAn
endfunction
function qNn takes integer qbn,string qBn returns boolean
local boolean qcn
set ZM[EM]=qBn
set EM=EM+1
set qcn=VA[pD[qbn]]<HA[pD[qbn]]and pln(ZA[pD[qbn]],"when calling getRemainingWrite in Network, line 372")>0
set EM=EM-1
return qcn
endfunction
function qCn takes integer qdn,string qDn returns boolean
local boolean qfn
set ZM[EM]=qDn
set EM=EM+1
set qfn=VA[qD[qdn]]<HA[qD[qdn]]and PNn(ZA[qD[qdn]],"when calling getRemainingRead in Network, line 378")>0
set EM=EM-1
return qfn
endfunction
function qFn takes integer gOs returns boolean
return ey<=qy
endfunction
function qgn takes integer qGn returns boolean
return vM[NC[qGn]]<MC[qGn]
endfunction
function qhn takes integer qHn,string qjn returns boolean
local boolean qJn
set ZM[EM]=qjn
set EM=EM+1
set qJn=LA[sD[qHn]]<PA[sD[qHn]]and PNn(QA[sD[qHn]],"when calling getRemainingRead in Network, line 342")>0
set EM=EM-1
return qJn
endfunction
function qkn takes integer qKn,string qln returns boolean
local boolean qLn
set ZM[EM]=qln
set EM=EM+1
set qLn=MP[YA[qKn]]<LP[YA[qKn]]and PNn(PP[YA[qKn]],"when calling getRemainingRead in NetworkData, line 387")>0
set EM=EM-1
return qLn
endfunction
function qmn takes integer qMn returns boolean
return vX[ZX[qMn]]<UX[qMn]
endfunction
function qpn takes integer qPn,string qqn returns integer
local integer qQn
set ZM[EM]=qqn
set EM=EM+1
set qQn=B5x(qPn,2,"when calling getCount in HashData, line 208")
set EM=EM-1
return qQn
endfunction
function qsn takes integer qSn,string qtn returns integer
local integer qTn
set ZM[EM]=qtn
set EM=EM+1
if gY[qSn]==0 then
if qSn==0 then
call Cdv("Nullpointer exception when calling HashReader.getStringCount","when calling error in HashData, line 207")
else
call Cdv("Called HashReader.getStringCount on invalid object.","when calling error in HashData, line 207")
endif
endif
set qTn=qpn(qSn,"when calling getStringCount in HashData, line 207")
set EM=EM-1
return qTn
endfunction
function qun takes integer qUn,string qwn returns integer
local integer qWn
set ZM[EM]=qwn
set EM=EM+1
set qWn=qsn(EX[qUn],"when calling getStringCount in StringEncoder, line 132")
set EM=EM-1
return qWn
endfunction
function qyn takes integer qYn,string qzn returns integer
local integer qZn
set ZM[EM]=qzn
set EM=EM+1
if Ov[qYn]==0 then
if qYn==0 then
call Cdv("Nullpointer exception when calling StringEncoder.getStringCount","when calling error in StringEncoder, line 131")
else
call Cdv("Called StringEncoder.getStringCount on invalid object.","when calling error in StringEncoder, line 131")
endif
endif
set qZn=qun(qYn,"when calling getStringCount in StringEncoder, line 131")
set EM=EM-1
return qZn
endfunction
function q_n takes integer q0n,string q1n returns boolean
local boolean q2n
set ZM[EM]=q1n
set EM=EM+1
set q2n=qyn(mA[fD[q0n]],"when calling getStringCount in Network, line 460")>0
set EM=EM-1
return q2n
endfunction
function q3n takes integer q4n returns boolean
return YZ[FZ[q4n]]<=fZ[FZ[q4n]]
endfunction
function q5n takes integer q6n,string q7n returns boolean
local boolean q8n
set ZM[EM]=q7n
set EM=EM+1
set q8n=Avn(vA[MA[q6n]],"when calling hasString in Network, line 282")
set EM=EM-1
return q8n
endfunction
function q9n takes integer Qvn,string Qen returns boolean
local boolean Qxn
set ZM[EM]=Qen
set EM=EM+1
set Qxn=PJn(jC[Qvn],"when calling hasNext in TerrainData, line 76")
set EM=EM-1
return Qxn
endfunction
function Qon takes integer Qrn,string Qin returns boolean
local boolean Qan
set ZM[EM]=Qin
set EM=EM+1
set Qan=NP[dA[Qrn]]<KP[dA[Qrn]]and PNn(IP[dA[Qrn]],"when calling getRemainingRead in NetworkData, line 375")>0
set EM=EM-1
return Qan
endfunction
function Qnn takes integer QVn returns boolean
return vX[AX[QVn]]<DX[QVn]
endfunction
function QEn takes integer QXn,string QOn returns boolean
local boolean QRn
set ZM[EM]=QOn
set EM=EM+1
set QRn=h6n(PQ[QXn],"when calling hasChunk in BufferAdapters, line 29")
set EM=EM-1
return QRn
endfunction
function QIn takes integer QAn,string QNn returns boolean
local boolean Qbn
set ZM[EM]=QNn
set EM=EM+1
set Qbn=CA[bD[QAn]]<DA[bD[QAn]]and PNn(EA[bD[QAn]],"when calling getRemainingRead in Network, line 366")>0
set EM=EM-1
return Qbn
endfunction
function QBn takes integer Qcn,string QCn returns boolean
local boolean Qdn
set ZM[EM]=QCn
set EM=EM+1
if ih[Qcn]==0 then
if Qcn==0 then
call Cdv("Nullpointer exception when calling HLIterator.hasNext","when calling error in HashList, line 132")
else
call Cdv("Called HLIterator.hasNext on invalid object.","when calling error in HashList, line 132")
endif
endif
set Qdn=Jgv(Qcn,"when calling hasNext in HashList, line 132")
set EM=EM-1
return Qdn
endfunction
function QDn takes integer Qfn,string QFn returns boolean
local boolean Qgn
set ZM[EM]=QFn
set EM=EM+1
set Qgn=QBn(CC[Qfn],"when calling hasNext in UnitData, line 1404")
set EM=EM-1
return Qgn
endfunction
function QGn takes integer Qhn,string QHn returns boolean
local boolean Qjn
set ZM[EM]=QHn
set EM=EM+1
set Qjn=VP[oA[Qhn]]<HP[oA[Qhn]]and pln(ZP[oA[Qhn]],"when calling getRemainingWrite in NetworkData, line 345")>0
set EM=EM-1
return Qjn
endfunction
function QJn takes integer Qkn,string QKn returns boolean
local boolean Qln
set ZM[EM]=QKn
set EM=EM+1
set Qln=cCx(Qkn,0,"when calling hasRemainingData in HashData, line 211")
set EM=EM-1
return Qln
endfunction
function QLn takes integer Qmn,string QMn returns boolean
local boolean Qpn
set ZM[EM]=QMn
set EM=EM+1
if gY[Qmn]==0 then
if Qmn==0 then
call Cdv("Nullpointer exception when calling HashReader.hasInt","when calling error in HashData, line 210")
else
call Cdv("Called HashReader.hasInt on invalid object.","when calling error in HashData, line 210")
endif
endif
set Qpn=QJn(Qmn,"when calling hasInt in HashData, line 210")
set EM=EM-1
return Qpn
endfunction
function QPn takes integer Qqn,string QQn returns boolean
local boolean Qsn
set ZM[EM]=QQn
set EM=EM+1
set Qsn=QLn(QX[LX[Qqn]],"when calling hasInt in StringEncoder, line 112")
set EM=EM-1
return Qsn
endfunction
function QSn takes integer Qtn,string QTn returns boolean
local boolean Qun
set ZM[EM]=QTn
set EM=EM+1
set Qun=Pen(FD[Qtn],"when calling canRead in OrderedStringBuffer, line 190")
set EM=EM-1
return Qun
endfunction
function QUn takes integer Qwn,string QWn returns boolean
local boolean Qyn
set ZM[EM]=QWn
set EM=EM+1
if UY[Qwn]==0 then
if Qwn==0 then
call Cdv("Nullpointer exception when calling LimitedExecuteCondition.check","when calling error in Execute, line 105")
else
call Cdv("Called LimitedExecuteCondition.check on invalid object.","when calling error in Execute, line 105")
endif
endif
if UY[Qwn]<=$D0E then
if UY[Qwn]<=$D05 then
if UY[Qwn]<=$D01 then
if UY[Qwn]<=$CFF then
if UY[Qwn]<=$CFE then
if UY[Qwn]<=$CFD then
set Qyn=qFn(Qwn)
else
set Qyn=Pin(Qwn,"when calling check_executeWhile_BufferAdapters in Execute, line 105")
endif
else
set Qyn=qon(Qwn,"when calling check_executeWhile_BufferAdapters in Execute, line 105")
endif
elseif UY[Qwn]<=$D00 then
set Qyn=QEn(Qwn,"when calling check_executeWhile_BufferAdapters in Execute, line 105")
else
set Qyn=q3n(Qwn)
endif
elseif UY[Qwn]<=$D03 then
if UY[Qwn]<=$D02 then
set Qyn=q5n(Qwn,"when calling check_executeWhile_Network_Network in Execute, line 105")
else
set Qyn=PSn(Qwn,"when calling check_executeWhile_Network_Network in Execute, line 105")
endif
elseif UY[Qwn]<=$D04 then
set Qyn=qhn(Qwn,"when calling check_executeWhile_Network_Network in Execute, line 105")
else
set Qyn=PEn(Qwn,"when calling check_executeWhile_Network_Network in Execute, line 105")
endif
elseif UY[Qwn]<=$D0A then
if UY[Qwn]<=$D08 then
if UY[Qwn]<=$D07 then
if UY[Qwn]<=$D06 then
set Qyn=PCn(Qwn,"when calling check_executeWhile_Network_Network in Execute, line 105")
else
set Qyn=ppn(Qwn,"when calling check_executeWhile_Network_Network in Execute, line 105")
endif
else
set Qyn=QIn(Qwn,"when calling check_executeWhile_Network_Network in Execute, line 105")
endif
elseif UY[Qwn]<=$D09 then
set Qyn=qNn(Qwn,"when calling check_executeWhile_Network_Network in Execute, line 105")
else
set Qyn=qCn(Qwn,"when calling check_executeWhile_Network_Network in Execute, line 105")
endif
elseif UY[Qwn]<=$D0C then
if UY[Qwn]<=$D0B then
set Qyn=q_n(Qwn,"when calling check_executeWhile_Network_Network in Execute, line 105")
else
set Qyn=qnn(Qwn,"when calling check_executeWhile_Network_NetworkData in Execute, line 105")
endif
elseif UY[Qwn]<=$D0D then
set Qyn=QGn(Qwn,"when calling check_executeWhile_Network_NetworkData in Execute, line 105")
else
set Qyn=P1n(Qwn,"when calling check_executeWhile_Network_NetworkData in Execute, line 105")
endif
elseif UY[Qwn]<=$D17 then
if UY[Qwn]<=$D13 then
if UY[Qwn]<=$D11 then
if UY[Qwn]<=$D10 then
if UY[Qwn]<=$D0F then
set Qyn=PFn(Qwn,"when calling check_executeWhile_Network_NetworkData in Execute, line 105")
else
set Qyn=PPn(Qwn,"when calling check_executeWhile_Network_NetworkData in Execute, line 105")
endif
else
set Qyn=PYn(Qwn,"when calling check_executeWhile_Network_NetworkData in Execute, line 105")
endif
elseif UY[Qwn]<=$D12 then
set Qyn=Qon(Qwn,"when calling check_executeWhile_Network_NetworkData in Execute, line 105")
else
set Qyn=PUn(Qwn,"when calling check_executeWhile_Network_NetworkData in Execute, line 105")
endif
elseif UY[Qwn]<=$D15 then
if UY[Qwn]<=$D14 then
set Qyn=qkn(Qwn,"when calling check_executeWhile_Network_NetworkData in Execute, line 105")
else
set Qyn=p3n(Qwn,"when calling check_executeWhile_Network_NetworkData in Execute, line 105")
endif
elseif UY[Qwn]<=$D16 then
set Qyn=QSn(Qwn,"when calling check_executeWhile_OrderedStringBuffer_OrderedStringBuffer in Execute, line 105")
else
set Qyn=QDn(Qwn,"when calling check_executeWhile_PositionedUnitData_UnitData in Execute, line 105")
endif
elseif UY[Qwn]<=$D1B then
if UY[Qwn]<=$D19 then
if UY[Qwn]<=$D18 then
set Qyn=qgn(Qwn)
else
set Qyn=qmn(Qwn)
endif
elseif UY[Qwn]<=$D1A then
set Qyn=Qnn(Qwn)
else
set Qyn=qOn(Qwn,"when calling check_executeWhile_StringEncoder_StringEncoder in Execute, line 105")
endif
elseif UY[Qwn]<=$D1D then
if UY[Qwn]<=$D1C then
set Qyn=QPn(Qwn,"when calling check_executeWhile_StringEncoder_StringEncoder in Execute, line 105")
else
set Qyn=PLn(Qwn,"when calling check_executeWhile_SubRectTileData_TerrainData in Execute, line 105")
endif
elseif UY[Qwn]<=$D1E then
set Qyn=q9n(Qwn,"when calling check_executeWhile_SubRectTileData_TerrainData in Execute, line 105")
else
set Qyn=P0n(Qwn)
endif
set EM=EM-1
return Qyn
endfunction
function QYn takes integer Qzn,string QZn returns nothing
local integer Q_n
set ZM[EM]=QZn
set EM=EM+1
set Q_n=0
loop
exitwhen not(QUn(BE[Qzn],"when calling check in Execute, line 113")and Q_n<NE[Qzn])
call pHn(ME[Qzn],"when calling run in Execute, line 114")
set Q_n=Q_n+1
endloop
if QUn(BE[Qzn],"when calling check in Execute, line 118")then
call Wie(NE[Qzn],BE[Qzn],ME[Qzn],"when calling executeWhileInternal in Execute, line 119")
endif
set EM=EM-1
endfunction
function Q0n takes integer Xst,integer Q1n,string Q2n returns nothing
set ZM[EM]=Q2n
set EM=EM+1
call uae(Q1n,0,"when calling writeInt in PersistableData, line 96")
set EM=EM-1
endfunction
function Q3n takes integer Q4n,string Q5n returns nothing
set ZM[EM]=Q5n
set EM=EM+1
call lgv(rU[Q4n],"when calling flush in HashData, line 56")
set EM=EM-1
endfunction
function Q6n takes integer Q7n,string Q8n returns nothing
set ZM[EM]=Q8n
set EM=EM+1
if jY[Q7n]==0 then
if Q7n==0 then
call Cdv("Nullpointer exception when calling HashWriter.clear","when calling error in HashData, line 55")
else
call Cdv("Called HashWriter.clear on invalid object.","when calling error in HashData, line 55")
endif
endif
call Q3n(Q7n,"when calling clear in HashData, line 55")
set EM=EM-1
endfunction
function Q9n takes integer svn,integer sen,string sxn returns nothing
set ZM[EM]=sxn
set EM=EM+1
call Q6n(sen,"when calling clear in PersistableData, line 114")
call uae(sen,vM[UD[svn]],"when calling writeInt in PersistableData, line 115")
set EM=EM-1
endfunction
function son takes integer srn,integer sin,string san returns nothing
set ZM[EM]=san
set EM=EM+1
if uk[srn]==0 then
if srn==0 then
call Cdv("Nullpointer exception when calling NetworkWriteCallback.onWrite","when calling error in NetworkData, line 202")
else
call Cdv("Called NetworkWriteCallback.onWrite on invalid object.","when calling error in NetworkData, line 202")
endif
endif
if uk[srn]<=$E5A then
call Q0n(srn,sin,"when calling onWrite_write_Persistable_PersistableData in NetworkData, line 202")
else
call Q9n(srn,sin,"when calling onWrite_write_Persistable_PersistableData in NetworkData, line 202")
endif
set EM=EM-1
endfunction
function snn takes integer sVn,string sEn returns nothing
set ZM[EM]=sEn
set EM=EM+1
call son(tA[sVn],QP[iA[sVn]],"when calling onWrite in NetworkData, line 276")
set EM=EM-1
endfunction
function sXn takes integer art returns nothing
local integer sOn=1
local integer sRn=Iq
loop
exitwhen sOn>sRn
call BlzSetAbilityTooltip(Uq,"END OF FILE",sOn)
set sOn=sOn+1
endloop
endfunction
function sIn takes integer sAn,string sNn returns nothing
local integer sbn
local integer sBn
set ZM[EM]=sNn
set EM=EM+1
call m7v(VK[sAn],BK[sAn],"when calling setEnumUnit in ScmdUnitBuiltins, line 211")
call xda(22,M7v(NK[sAn],0,"when calling get in ScmdUnitBuiltins, line 212"),VK[sAn],"when calling evaluate in ScmdUnitBuiltins, line 212",0,null,0,null)
set sbn=RJv
set sBn=ox[m0v(sbn,"when calling get in ScmdUnitBuiltins, line 213")]
if sBn>=$EF1 and sBn<=$EF2 then
call bxn(MK[sAn],sbn,"when calling swap in ScmdUnitBuiltins, line 214")
endif
call mfv(20,sbn,"when calling dispatch_GenericSharedPointer_destroyGenericSharedPointer in ScmdUnitBuiltins, line 215")
set EM=EM-1
endfunction
function scn takes integer sCn,string sdn returns nothing
set ZM[EM]=sdn
set EM=EM+1
call sIa(dD[sCn],"when calling sendRound in Network, line 451")
set EM=EM-1
endfunction
function sDn takes integer sfn,string sFn returns nothing
set ZM[EM]=sFn
set EM=EM+1
call Nyn("",sfn-1,"when calling precompute in GamecacheKeys, line 36")
set EM=EM-1
endfunction
function sgn takes integer sGn,string shn returns nothing
set ZM[EM]=shn
set EM=EM+1
call sDn(xZ[sGn],"when calling precompute in GamecacheKeys, line 40")
set EM=EM-1
endfunction
function sHn takes unit sjn,real fXu,real RXu returns string
call v3e(sjn)
call IsHeroUnitId(umv(sjn))
return""
endfunction
function sJn takes integer skn returns nothing
call rBn(sHn(fL[skn],DQv(DSv((jse(RL[skn])-64.)/128.))*128.+64.,DQv(DSv((jte(RL[skn])-64.)/128.))*128.+64.))
endfunction
function sKn takes integer sln,integer sLn,string smn returns nothing
local integer sMn
local integer spn
local integer sPn
local real sqn
local real sQn
set ZM[EM]=smn
set EM=EM+1
call fVx(0,sLn,"when calling readByte in DestructableData, line 173")
set sMn=RJv
set RE[sln]=sMn
if bUn(RE[sln],7)then
call fVx(0,sLn,"when calling readByte in DestructableData, line 175")
set spn=RJv
set TE[sln]=spn
endif
set sPn=flx(sLn,fE[sln],"when calling readRawcodeTableIndex in DestructableData, line 176")
set YE[sln]=sPn
set sqn=gbx(sLn,"when calling readPointData in DestructableData, line 178")
set sQn=Y1
set GE[sln]=sqn
set gE[sln]=sQn
if bUn(RE[sln],2)then
if bUn(RE[sln],1)then
call d7x(0,sLn,"when calling readReal in DestructableData, line 181")
set hE[sln]=Rkv
else
call fhx(1,sLn,"when calling readShort in DestructableData, line 183")
set hE[sln]=(RJv-$7FFF)*1./$A
endif
elseif bUn(RE[sln],1)then
call fVx(0,sLn,"when calling readByte in DestructableData, line 185")
set hE[sln]=DQv(RJv)
else
set hE[sln]=.0
endif
call fhx(1,sLn,"when calling readShort in DestructableData, line 188")
set FE[sln]=RJv*1./$B4
if bUn(RE[sln],4)then
if bUn(RE[sln],3)then
call d7x(0,sLn,"when calling readReal in DestructableData, line 192")
set kE[sln]=Rkv
else
call fhx(1,sLn,"when calling readShort in DestructableData, line 194")
set kE[sln]=(RJv-$7FFF)*1./$A
endif
elseif bUn(RE[sln],3)then
call fVx(0,sLn,"when calling readByte in DestructableData, line 196")
set kE[sln]=DQv(RJv)
else
set kE[sln]=1.
endif
if bUn(RE[sln],6)then
if bUn(RE[sln],5)then
set jE[sln]=3
else
set jE[sln]=2
endif
elseif bUn(RE[sln],5)then
set jE[sln]=1
else
call fVx(0,sLn,"when calling readByte in DestructableData, line 208")
set jE[sln]=RJv
endif
set EM=EM-1
endfunction
function ssn takes integer sSn,integer stn,string sTn returns nothing
set ZM[EM]=sTn
set EM=EM+1
if mg[sSn]==0 then
if sSn==0 then
call Cdv("Nullpointer exception when calling SingleDestructableData.deserialize","when calling error in DestructableData, line 172")
else
call Cdv("Called SingleDestructableData.deserialize on invalid object.","when calling error in DestructableData, line 172")
endif
endif
call sKn(sSn,stn,"when calling deserialize in DestructableData, line 172")
set EM=EM-1
endfunction
function sun takes integer sUn,string swn returns nothing
local integer sWn
local integer syn
set ZM[EM]=swn
set EM=EM+1
set syn=rE[cE[sUn]]
set sWn=gOv(uE[cE[sUn]],"when calling new_SingleDestructableData in DestructableData, line 267")
call ssn(sWn,oE[sUn],"when calling deserialize in DestructableData, line 267")
call dlv(syn,sWn,"when calling add in DestructableData, line 267")
set EM=EM-1
endfunction
function sYn takes string szn returns integer
local integer sZn
set ZM[EM]=szn
set EM=EM+1
if CY==0 then
if VY<$8000 then
set VY=VY+1
set sZn=VY
set BY[sZn]=$868
else
call Cdv("Out of memory: Could not create ForForceCallback_execute_execute_Network_NetworkData.","when calling error in NetworkData, line 275")
set sZn=0
endif
else
set CY=CY-1
set sZn=XY[CY]
set BY[sZn]=$868
endif
set EM=EM-1
return sZn
endfunction
function s_n takes integer s0n,string s1n returns nothing
local integer s2n
set ZM[EM]=s1n
set EM=EM+1
if ta==DP[rA[s0n]]then
set s2n=sYn("when calling alloc_ForForceCallback_execute_execute_Network_NetworkData in NetworkData, line 275")
set tA[s2n]=sA[s0n]
set iA[s2n]=rA[s0n]
call Fte(s2n,"when calling execute in NetworkData, line 275")
endif
set EM=EM-1
endfunction
function s3n takes string s4n returns integer
local integer s5n
set ZM[EM]=s4n
set EM=EM+1
if CY==0 then
if VY<$8000 then
set VY=VY+1
set s5n=VY
set BY[s5n]=$869
else
call Cdv("Out of memory: Could not create ForForceCallback_execute_execute_PositionedDestructableData_DestructableData.","when calling error in DestructableData, line 266")
set s5n=0
endif
else
set CY=CY-1
set s5n=XY[CY]
set BY[s5n]=$869
endif
set EM=EM-1
return s5n
endfunction
function s6n takes integer s7n,string s8n returns nothing
local integer s9n
local integer Svn
local integer Sen
local integer Sxn
set ZM[EM]=s8n
set EM=EM+1
if Yje(wE[iE[s7n]],0)then
if Yje(wE[iE[s7n]],1)then
call dEx(0,SE[s7n],"when calling readInt in DestructableData, line 260")
set s9n=RJv
else
call fhx(1,SE[s7n],"when calling readShort in DestructableData, line 262")
set s9n=RJv
endif
else
call fVx(0,SE[s7n],"when calling readByte in DestructableData, line 264")
set s9n=RJv
endif
set Svn=0
set Sen=s9n-1
loop
exitwhen Svn>Sen
set Sxn=s3n("when calling alloc_ForForceCallback_execute_execute_PositionedDestructableData_DestructableData in DestructableData, line 266")
set cE[Sxn]=iE[s7n]
set oE[Sxn]=SE[s7n]
call Fte(Sxn,"when calling execute in DestructableData, line 266")
set Svn=Svn+1
endloop
set EM=EM-1
endfunction
function Son takes integer Srn,string San returns nothing
local integer Snn
local integer SVn
local string SEn
set ZM[EM]=San
set EM=EM+1
set Snn=0
set SVn=sC[Srn]-1
loop
exitwhen Snn>SVn
set SEn=QM[tC[Srn]]
call fVx(0,iC[Srn],"when calling readByte in StringTable, line 75")
set QM[tC[Srn]]=SEn+EDo(V_n(RJv,"when calling toUtf8CodeUnit in StringTable, line 75"))
set Snn=Snn+1
endloop
set EM=EM-1
endfunction
function SXn takes integer SOn returns integer
return eW[SOn]
endfunction
function SRn takes integer SIn,string SAn returns integer
local integer SNn
set ZM[EM]=SAn
set EM=EM+1
if EG[SIn]==0 then
if SIn==0 then
call Cdv("Nullpointer exception when calling ByteBuffer.getByteCount","when calling error in ByteBuffer, line 96")
else
call Cdv("Called ByteBuffer.getByteCount on invalid object.","when calling error in ByteBuffer, line 96")
endif
endif
set SNn=SXn(SIn)
set EM=EM-1
return SNn
endfunction
function Sbn takes integer SBn,string Scn returns nothing
local integer SCn
local integer Sdn
set ZM[EM]=Scn
set EM=EM+1
set SCn=Cbx(GQ[SBn],"when calling readByte in Base64, line 128")
set Sdn=C4x(SCn,16)
call G9n(SBn,Sdn,1,"when calling encodeSingle in Base64, line 130")
call GDn(SBn,"=","when calling append in Base64, line 131")
call GDn(SBn,"=","when calling append in Base64, line 132")
set EM=EM-1
endfunction
function SDn takes integer Sfn,string SFn returns nothing
set ZM[EM]=SFn
set EM=EM+1
if LY[Sfn]==0 then
if Sfn==0 then
call Cdv("Nullpointer exception when calling Base64Encoder.encode1","when calling error in Base64, line 127")
else
call Cdv("Called Base64Encoder.encode1 on invalid object.","when calling error in Base64, line 127")
endif
endif
call Sbn(Sfn,"when calling encode1 in Base64, line 127")
set EM=EM-1
endfunction
function Sgn takes string SGn returns integer
local integer Shn
set ZM[EM]=SGn
set EM=EM+1
if EY==0 then
if ZY<$8000 then
set ZY=ZY+1
set Shn=ZY
set UY[Shn]=$D1F
else
call Cdv("Out of memory: Could not create LimitedExecuteCondition_executeWhile_execute_Base64Encoder_Base64.","when calling error in Base64, line 149")
set Shn=0
endif
else
set EY=EY-1
set Shn=WY[EY]
set UY[Shn]=$D1F
endif
set EM=EM-1
return Shn
endfunction
function SHn takes string Sjn returns integer
local integer SJn
set ZM[EM]=Sjn
set EM=EM+1
if PY==0 then
if AY<$8000 then
set AY=AY+1
set SJn=AY
set DY[SJn]=$CFB
else
call Cdv("Out of memory: Could not create LimitedExecuteAction_executeWhile_execute_Base64Encoder_Base64.","when calling error in Base64, line 149")
set SJn=0
endif
else
set PY=PY-1
set SJn=IY[PY]
set DY[SJn]=$CFB
endif
set EM=EM-1
return SJn
endfunction
function Skn takes integer SKn,string Sln returns nothing
local integer SLn
local integer Smn
local integer SMn
set ZM[EM]=Sln
set EM=EM+1
set SLn=Cbx(GQ[SKn],"when calling readByte in Base64, line 121")
set Smn=Cbx(GQ[SKn],"when calling readByte in Base64, line 122")
set SMn=C4x(SLn,16)+C4x(Smn,8)
call G9n(SKn,SMn,2,"when calling encodeSingle in Base64, line 124")
call GDn(SKn,"=","when calling append in Base64, line 125")
set EM=EM-1
endfunction
function Spn takes integer SPn,string Sqn returns nothing
set ZM[EM]=Sqn
set EM=EM+1
if LY[SPn]==0 then
if SPn==0 then
call Cdv("Nullpointer exception when calling Base64Encoder.encode2","when calling error in Base64, line 120")
else
call Cdv("Called Base64Encoder.encode2 on invalid object.","when calling error in Base64, line 120")
endif
endif
call Skn(SPn,"when calling encode2 in Base64, line 120")
set EM=EM-1
endfunction
function SQn takes integer Ssn,string SSn returns nothing
local integer Stn
local integer STn
local integer Sun
local integer SUn
local integer Swn
local integer SWn
local integer Syn
set ZM[EM]=SSn
set EM=EM+1
call ONn(GQ[gQ[Ssn]],"when calling toReadMode in Base64, line 139")
set Stn=SRn(GQ[gQ[Ssn]],"when calling getByteCount in Base64, line 141")
set STn=SRn(GQ[gQ[Ssn]],"when calling getByteCount in Base64, line 143")/3-1
set Sun=ModuloInteger(Stn,3)
set qy=STn
set ey=0
set SWn=yy
set SUn=Sgn("when calling alloc_LimitedExecuteCondition_executeWhile_execute_Base64Encoder_Base64 in Base64, line 149")
set Syn=SUn
set Swn=SHn("when calling alloc_LimitedExecuteAction_executeWhile_execute_Base64Encoder_Base64 in Base64, line 149")
set hQ[Swn]=gQ[Ssn]
call WOe(SWn,Syn,Swn,"when calling executeWhile in Base64, line 149")
if Sun==2 then
call Spn(gQ[Ssn],"when calling encode2 in Base64, line 154")
endif
if Sun==1 then
call SDn(gQ[Ssn],"when calling encode1 in Base64, line 157")
endif
set EM=EM-1
endfunction
function SYn takes integer Anc,integer Dnc returns nothing
endfunction
function Szn takes integer SZn,integer S_n,string S0n returns nothing
set ZM[EM]=S0n
set EM=EM+1
call Rzn(SZn,"when calling checkWrite in BufferInterface, line 171")
call SYn(S_n,SZn)
set EM=EM-1
endfunction
function S1n takes integer S2n,integer S3n,string S4n returns nothing
set ZM[EM]=S4n
set EM=EM+1
if OG[S2n]==0 then
if S2n==0 then
call Cdv("Nullpointer exception when calling AbstractBuffer.write","when calling error in BufferInterface, line 170")
else
call Cdv("Called AbstractBuffer.write on invalid object.","when calling error in BufferInterface, line 170")
endif
endif
call Szn(S2n,S3n,"when calling write in BufferInterface, line 170")
set EM=EM-1
endfunction
function S5n takes integer S6n,string S7n returns nothing
set ZM[EM]=S7n
set EM=EM+1
call S1n(iH[S6n],DD[SH[S6n]],"when calling write in Persistable, line 202")
set EM=EM-1
endfunction
function S8n takes integer S9n,string tvn returns nothing
set ZM[EM]=tvn
set EM=EM+1
call NLn(eU[nU[S9n]],"when calling run in IOTaskExecutor, line 68")
set EM=EM-1
endfunction
function ten takes integer Jnc,integer Knc returns nothing
endfunction
function txn takes integer ton returns nothing
call ten(DD[sH[ton]],tH[ton])
endfunction
function trn takes integer tin returns integer
return QP[tin]
endfunction
function tan takes integer tnn,string tVn returns integer
local integer tEn
set ZM[EM]=tVn
set EM=EM+1
if LF[tnn]==0 then
if tnn==0 then
call Cdv("Nullpointer exception when calling Network.getWriter","when calling error in NetworkData, line 268")
else
call Cdv("Called Network.getWriter on invalid object.","when calling error in NetworkData, line 268")
endif
endif
set tEn=trn(tnn)
set EM=EM-1
return tEn
endfunction
function tXn takes integer EQs returns nothing
endfunction
function tOn takes integer tRn,integer tIn,integer tAn returns nothing
call tXn(tRn)
set JZ[tRn]=tIn
set KZ[tRn]=tAn
endfunction
function tNn takes string tbn returns integer
local integer tBn
set ZM[EM]=tbn
set EM=EM+1
if YY==0 then
if GY<$8000 then
set GY=GY+1
set tBn=GY
set gY[tBn]=$6CF
else
call Cdv("Out of memory: Could not create HashDataProxyReader.","when calling error in HashData, line 228")
set tBn=0
endif
else
set YY=YY-1
set tBn=TY[YY]
set gY[tBn]=$6CF
endif
set EM=EM-1
return tBn
endfunction
function tcn takes integer tCn,integer tdn,string tDn returns integer
local integer tfn
set ZM[EM]=tDn
set EM=EM+1
set tfn=tNn("when calling alloc_HashDataProxyReader in HashData, line 232")
call tOn(tfn,tCn,tdn)
set EM=EM-1
return tfn
endfunction
function tFn takes integer tgn,integer tGn,string thn returns nothing
set ZM[EM]=thn
set EM=EM+1
call Lvx(tGn,tgn,"when calling deserialize in HashData, line 274")
set EM=EM-1
endfunction
function tHn takes integer tjn,integer tJn,string tkn returns nothing
set ZM[EM]=tkn
set EM=EM+1
if gY[tjn]==0 then
if tjn==0 then
call Cdv("Nullpointer exception when calling HashDataProxyReader.readSerializable","when calling error in HashData, line 273")
else
call Cdv("Called HashDataProxyReader.readSerializable on invalid object.","when calling error in HashData, line 273")
endif
endif
call tFn(tjn,tJn,"when calling readSerializable in HashData, line 273")
set EM=EM-1
endfunction
function tKn takes integer tln,string tLn returns nothing
set ZM[EM]=tLn
set EM=EM+1
if gY[tln]==0 then
if tln==0 then
call Cdv("Nullpointer exception when calling HashDataProxyReader.HashDataProxyReader","when calling error in HashData, line 228")
else
call Cdv("Called HashDataProxyReader.HashDataProxyReader on invalid object.","when calling error in HashData, line 228")
endif
endif
call bmx(tln,"when calling destroyHashDataProxyReader in HashData, line 228")
set EM=EM-1
endfunction
function tmn takes integer tMn,string tpn returns nothing
local integer tPn
set ZM[EM]=tpn
set EM=EM+1
set tPn=tcn(tan(WD[tMn],"when calling getWriter in PersistableData, line 99"),ED[tMn],"when calling new_HashDataProxyReader in PersistableData, line 99")
call tHn(tPn,ZD[tMn],"when calling readSerializable in PersistableData, line 100")
call tKn(tPn,"when calling dispatch_HashDataProxyReader_destroyHashDataProxyReader in PersistableData, line 101")
set EM=EM-1
endfunction
function tqn takes integer tQn,integer tsn returns integer
set V7=dpv(tQn,tsn)
return V7
endfunction
function tSn takes unit ttn,integer tTn returns integer
local integer tun=umv(ttn)
local integer tUn=Ufv(ttn,tTn)
local real twn=oAe(ttn,tTn)
local integer tWn=oVe(ttn,tTn)
local integer tyn=oBe(ttn,tTn)
local integer tYn=0
local integer tzn=tYn
local integer tZn
local integer t_n
local integer t0n
local integer t1n
local integer t2n
local integer t3n
local integer t4n
local integer t5n
local integer t6n
if tUn!=oFe(tun,tTn)then
set t_n=tqn(tzn,0)
set tzn=t_n
if tUn>$FF or tUn<0 then
set t0n=tqn(tzn,1)
set tzn=t0n
endif
endif
if twn!=oOe(tun,tTn)then
set t1n=tqn(tzn,2)
set tzn=t1n
set tZn=c6v(twn*100.)
if tZn*1./'d'==twn and tZn<=$FF then
set t2n=tqn(tzn,3)
set tzn=t2n
endif
endif
if tWn!=ode(tun,tTn)then
set t3n=tqn(tzn,4)
set tzn=t3n
if tWn>$FF then
set t4n=tqn(tzn,5)
set tzn=t4n
endif
endif
if tyn!=oie(tun,tTn)then
set t5n=tqn(tzn,6)
set tzn=t5n
if tyn>$FF then
set t6n=tqn(tzn,7)
set tzn=t6n
endif
endif
set r8=tzn
set s8=tUn
set t8=twn
set i8=tWn
set S8=tyn
return r8
endfunction
function t7n takes integer t8n,integer t9n returns integer
set y8=dpv(t8n,t9n)
return y8
endfunction
function Tvn takes unit Ten returns integer
local integer Txn=umv(Ten)
local integer Ton=0
local integer Trn=Ton
local integer Tin=Hfx()
local integer Tnn=N7
local real TVn=M7
local integer TEn=w8
local integer TXn=u8
local integer TOn=Tin
local integer TRn=Tnn
local real TIn=TVn
local integer TAn=TEn
local integer TNn=TXn
local integer Tbn=tSn(Ten,1)
local integer TBn=s8
local real Tcn=t8
local integer TCn=i8
local integer Tdn=S8
local integer TDn=Tbn
local integer Tfn=TBn
local real TFn=Tcn
local integer Tgn=TCn
local integer TGn=Tdn
local integer Thn
local integer THn
local real Tjn
local integer TJn
local integer Tkn
local integer TKn
local integer Tln
local integer TLn
local integer Tmn
local integer TMn
local integer Tpn
local integer TPn
local real Tqn
local integer TQn
local integer Tsn
local integer TSn
local integer Ttn
local real TTn
local integer Tun
local integer TUn
local integer Twn
local integer TWn
local integer Tyn
local integer TYn
local real Tzn
local integer TZn
local integer T_n
local integer T0n
local integer T1n
local integer T2n
local integer T3n
local integer T4n
local integer T5n
if TDn!=0 then
set TMn=t7n(Trn,0)
set Trn=TMn
set Tpn=TDn
set TPn=Tfn
set Tqn=TFn
set TQn=Tgn
set Tsn=TGn
set TOn=Tpn
set TRn=TPn
set TIn=Tqn
set TAn=TQn
set TNn=Tsn
endif
set TSn=Hfx()
set Ttn=N7
set TTn=M7
set Tun=w8
set TUn=u8
set Thn=TSn
set THn=Ttn
set Tjn=TTn
set TJn=Tun
set Tkn=TUn
set Twn=tSn(Ten,2)
set TKn=Twn
if TKn!=0 then
set TWn=t7n(Trn,1)
set Trn=TWn
set Tyn=TDn
set TYn=Tfn
set Tzn=TFn
set TZn=Tgn
set T_n=TGn
set Thn=Tyn
set THn=TYn
set Tjn=Tzn
set TJn=TZn
set Tkn=T_n
endif
set Tln=0
if upv(Ten)then
set T0n=t7n(Trn,2)
set Trn=T0n
set Tln=uUv(Ten)
if Tln>=0 and Tln<=$FF then
set T1n=t7n(Trn,3)
set Trn=T1n
endif
endif
set TLn=zJv(Ten)
if TLn!=rle(Txn)then
set T2n=t7n(Trn,4)
set Trn=T2n
if TLn<=$FFFF then
set T3n=t7n(Trn,5)
set Trn=T3n
endif
endif
set Tmn=Shv(Ten)
if Tmn!=rhe(Txn)then
set T4n=t7n(Trn,6)
set Trn=T4n
if Tmn<=$FFFF then
set T5n=t7n(Trn,7)
set Trn=T5n
endif
endif
set k8=Trn
set j8=TOn
set x8=TRn
set v8=TIn
set m8=TAn
set Q8=TNn
set W8=Thn
set E8=THn
set Z8=Tjn
set U8=TJn
set I8=Tkn
set P8=Tln
set A8=TLn
set D8=Tmn
return k8
endfunction
function T6n takes integer T7n,integer T8n returns integer
set o9=dpv(T7n,T8n)
return o9
endfunction
function T9n takes unit uvn returns integer
local integer uen=0
local integer uxn=uen
local integer uon
if xze(uvn,UNIT_TYPE_TOWNHALL)then
set uon=T6n(uxn,0)
set uxn=uon
endif
set l9=uxn
return l9
endfunction
function urn takes integer uin,integer uan returns integer
set i9=dpv(uin,uan)
return i9
endfunction
function unn takes integer uVn returns integer
local integer uEn=0
local integer uXn=uEn
local integer uOn
local integer uRn
local integer uIn
local integer uAn
local integer uNn
local integer ubn
local integer uBn
local integer ucn
if IsUnitIdType(uVn,UNIT_TYPE_GIANT)then
set uOn=urn(uXn,0)
set uXn=uOn
endif
if IsUnitIdType(uVn,UNIT_TYPE_SUMMONED)then
set uRn=urn(uXn,1)
set uXn=uRn
endif
if IsUnitIdType(uVn,UNIT_TYPE_UNDEAD)then
set uIn=urn(uXn,2)
set uXn=uIn
endif
if IsUnitIdType(uVn,UNIT_TYPE_MECHANICAL)then
set uAn=urn(uXn,3)
set uXn=uAn
endif
if IsUnitIdType(uVn,UNIT_TYPE_PEON)then
set uNn=urn(uXn,4)
set uXn=uNn
endif
if IsUnitIdType(uVn,UNIT_TYPE_SAPPER)then
set ubn=urn(uXn,5)
set uXn=ubn
endif
if IsUnitIdType(uVn,UNIT_TYPE_ANCIENT)then
set uBn=urn(uXn,6)
set uXn=uBn
endif
if IsUnitIdType(uVn,UNIT_TYPE_TAUREN)then
set ucn=urn(uXn,7)
set uXn=ucn
endif
set S9=uXn
return S9
endfunction
function uCn takes integer udn,integer uDn returns integer
set E6=dpv(udn,uDn)
return E6
endfunction
function ufn takes unit uFn returns integer
local integer ugn=0
local integer uGn=ugn
local real uhn=.0
local integer uHn
local real ujn
local real uJn
local integer ukn
local integer uKn
local real uln
local real uLn
local integer umn
local integer uMn
local integer upn
local integer uPn
local integer uqn
local integer uQn
local integer usn
local integer uSn
if xve(uFn)then
set umn=uCn(uGn,0)
set uGn=umn
set uhn=e1e(uFn)
set uHn=c6v(uhn*10.)
if uHn*1./$A==uhn and uHn<=$FFFF then
set uMn=uCn(uGn,1)
set uGn=uMn
endif
endif
set ujn=.0
if e8e(uFn)!=eze(uFn)then
set upn=uCn(uGn,2)
set uGn=upn
set ujn=e8e(uFn)
endif
set uJn=.0
if q6v(uFn)then
set uPn=uCn(uGn,3)
set uGn=uPn
set uJn=q8v(uFn)
set ukn=c6v(uJn*100.)
if ukn*1./'d'==uJn and ukn<=$FF then
set uqn=uCn(uGn,4)
set uGn=uqn
else
set uKn=c6v(uJn*1000.)
if uKn*1./$3E8==uJn and uKn<=$FFFF then
set uQn=uCn(uGn,5)
set uGn=uQn
endif
endif
endif
set uln=.0
if ete(uFn)then
set usn=uCn(uGn,6)
set uGn=usn
set uln=eye(uFn)
endif
set uLn=.0
if e_e(uFn)!=ewe(uFn)then
set uSn=uCn(uGn,7)
set uGn=uSn
set uLn=e6e(e_e(uFn))
endif
set H6=uGn
set J6=uhn
set K6=ujn
set L6=uJn
set X6=uln
set C6=uLn
return H6
endfunction
function utn takes integer uTn,integer uun returns integer
set y9=dpv(uTn,uun)
return y9
endfunction
function uUn takes integer uwn returns integer
local integer uWn=0
local integer uyn=uWn
local integer uYn
if IsUnitIdType(uwn,UNIT_TYPE_TOWNHALL)then
set uYn=T6n(uyn,0)
set uyn=uYn
endif
set O9=uyn
return O9
endfunction
function uzn takes integer uZn,integer u_n returns integer
set r7=dpv(uZn,u_n)
return r7
endfunction
function u0n takes integer u1n,integer u2n returns integer
set s7=dpv(u1n,u2n)
return s7
endfunction
function u3n takes unit u4n returns integer
local integer u5n=umv(u4n)
local integer u6n=0
local integer u7n=u6n
local integer u8n=0
local integer u9n=u8n
local integer Uvn=vXe(u4n)
local unit Uen
local unit Uxn
local integer Uon
local integer Urn
local integer Uin
local integer Uan
local integer Unn
local integer UVn
local integer UEn
local integer UXn
local integer UOn
local integer URn
local integer UIn
local integer UAn
local integer UNn
local integer Ubn
local integer UBn
local integer Ucn
if vRe(u4n)then
set Uan=uzn(u7n,0)
set u7n=Uan
endif
set Uxn=vAe(Ty,u5n,.0,.0,vde(.0))
call ZNv(Uxn,Uvn,false)
set Uen=Uxn
set Uon=Zav(u4n,false)
if Uon!=Zav(Uen,false)then
set Unn=uzn(u7n,1)
set u7n=Unn
if Uon>$FF then
set UVn=uzn(u7n,2)
set u7n=UVn
if Uon>$FFFF then
set UEn=uzn(u7n,7)
set u7n=UEn
set UXn=u0n(u9n,0)
set u9n=UXn
endif
endif
endif
set Urn=WAv(u4n,false)
if Urn!=WAv(Uen,false)then
set UOn=uzn(u7n,3)
set u7n=UOn
if Urn>$FF then
set URn=uzn(u7n,4)
set u7n=URn
if Urn>$FFFF then
set UIn=uzn(u7n,7)
set u7n=UIn
set UAn=u0n(u9n,1)
set u9n=UAn
endif
endif
endif
set Uin=Zov(u4n,false)
if Uin!=Zov(Uen,false)then
set UNn=uzn(u7n,5)
set u7n=UNn
if Uin>$FF then
set Ubn=uzn(u7n,6)
set u7n=Ubn
if Uin>$FFFF then
set UBn=uzn(u7n,7)
set u7n=UBn
set Ucn=u0n(u9n,2)
set u9n=Ucn
endif
endif
endif
call PFv(Uen)
set l7=u7n
set b7=u9n
set y7=Uvn
set p7=Uon
set e7=Urn
set q7=Uin
set Uen=null
set Uxn=null
return l7
endfunction
function UCn takes integer Udn,integer UDn returns integer
set Y7=dpv(Udn,UDn)
return Y7
endfunction
function Ufn takes unit UFn,string Ugn returns integer
local integer UGn
local integer Uhn
local integer UHn
local integer Ujn
local integer UJn
local integer Ukn
local integer UKn
local integer Uln
local integer ULn
local integer Umn
local integer UMn
local integer Upn
local integer UPn
local integer Uqn
local integer UQn
local integer Usn
local integer USn
local integer Utn
local integer UTn
local integer Uun
local integer UUn
local integer Uwn
local integer UWn
local integer Uyn
local integer UYn
local integer Uzn
local integer UZn
local integer U_n
local integer U0n
local integer U1n
local integer U2n
local integer U3n
local integer U4n
set ZM[EM]=Ugn
set EM=EM+1
set UGn=umv(UFn)
set UPn=0
set Uhn=UPn
set Uqn=hcx()
set UQn=i7
set Usn=S7
set USn=c7
set Utn=o7
set UTn=O7
set UHn=Uqn
set Ujn=UQn
set UJn=Usn
set Ukn=USn
set UKn=Utn
set Uln=UTn
if IsHeroUnitId(UGn)then
set Uun=UCn(Uhn,0)
set Uhn=Uun
set UUn=u3n(UFn)
set Uwn=b7
set UWn=y7
set Uyn=p7
set UYn=e7
set Uzn=q7
set UHn=UUn
set Ujn=Uwn
set UJn=UWn
set Ukn=Uyn
set UKn=UYn
set Uln=Uzn
endif
set ULn=0
if rde(UFn)!=0 then
set UZn=UCn(Uhn,1)
set Uhn=UZn
set ULn=rde(UFn)
endif
if oee(UFn,0)then
set U_n=UCn(Uhn,2)
set Uhn=U_n
endif
if oee(UFn,1)then
set U0n=UCn(Uhn,3)
set Uhn=U0n
endif
if oee(UFn,2)then
set U1n=UCn(Uhn,4)
set Uhn=U1n
endif
set Umn=rfe(UFn,"when calling removedAbilities in UnitTypeData, line 490")
if rme(Umn,"when calling hasNext in UnitTypeData, line 491")then
set U2n=UCn(Uhn,5)
set Uhn=U2n
endif
call rve(Umn,"when calling close in UnitTypeData, line 493")
set UMn=zuv(UFn,"when calling modifiedAbilities in UnitTypeData, line 494")
if rme(UMn,"when calling hasNext in UnitTypeData, line 495")then
set U3n=UCn(Uhn,6)
set Uhn=U3n
else
set Upn=rje(UFn,"when calling addedAbilities in UnitTypeData, line 498")
if rme(Upn,"when calling hasNext in UnitTypeData, line 499")then
set U4n=UCn(Uhn,6)
set Uhn=U4n
endif
call rve(Upn,"when calling close in UnitTypeData, line 501")
endif
call rve(UMn,"when calling close in UnitTypeData, line 502")
set EM=EM-1
set m7=Uhn
set Q7=UHn
set W7=Ujn
set E7=UJn
set Z7=Ukn
set U7=UKn
set I7=Uln
set P7=ULn
return m7
endfunction
function U5n takes integer U6n,integer U7n returns integer
set O6=dpv(U6n,U7n)
return O6
endfunction
function U8n takes unit U9n returns integer
local integer wvn=0
local integer wen=wvn
local real wxn=.0
local integer won
local integer wrn
local integer win
local integer wan
local integer wnn
local integer wVn
local integer wEn
local real wXn
local integer wOn
local integer wRn
local integer wIn
local integer wAn
local integer wNn
local integer wbn
local integer wBn
local integer wcn
local integer wCn
local integer wdn
local integer wDn
local integer wfn
local integer wFn
local integer wgn
local integer wGn
local integer whn
local integer wHn
local integer wjn
if exe(U9n)then
set wIn=U5n(wen,0)
set wen=wIn
set wxn=eEe(U9n)
set won=c6v(wxn)
if DQv(won)==wxn and won<=$FF then
set wAn=U5n(wen,1)
set wen=wAn
else
set wrn=c6v(wxn*10.)
if wrn*1./$A==wxn and wrn<=$FFFF then
set wNn=U5n(wen,2)
set wen=wNn
endif
endif
endif
set win=0
if eve(U9n)then
set wbn=U5n(wen,3)
set wen=wbn
set win=tpv(v8e(U9n))
endif
set wBn=0
set wcn=0
set wCn=0
set wdn=0
set wan=wBn
set wnn=wcn
set wVn=wCn
set wEn=wdn
if v6e(U9n)then
set wDn=U5n(wen,4)
set wen=wDn
set wfn=v3e(U9n)
set wFn=Q1
set wgn=W1
set wGn=E1
set wan=wfn
set wnn=wFn
set wVn=wgn
set wEn=wGn
endif
set wXn=.0
if v1e(U9n)then
set whn=U5n(wen,5)
set wen=whn
set wXn=ere(U9n)
set wOn=c6v(wXn*100.)
if wOn*1./'d'==wXn and wOn>=0 and wOn<=$FF then
set wHn=U5n(wen,6)
set wen=wHn
else
set wRn=c6v(wXn*1000.)+$7FFF
if(wRn-$7FFF)*1./$3E8==wXn and wRn>=0 and wRn<=$FFFF then
set wjn=U5n(wen,7)
set wen=wjn
endif
endif
endif
set d6=wen
set f6=wxn
set R6=win
set T6=wan
set Y6=wnn
set G6=wVn
set g6=wEn
set h6=wXn
return d6
endfunction
function wJn takes integer wkn,integer wKn returns integer
set t9=dpv(wkn,wKn)
return t9
endfunction
function wln takes integer wLn,unit wmn,integer wMn returns nothing
local integer wpn
local integer wPn
local integer wqn
local integer wQn
local integer wsn
local integer wSn
local integer wtn
local integer wTn
set ZB[wLn]=wMn
set UB[wLn]=USv(wmn,ZB[wLn])
set wpn=UB[wLn]
if wpn==1 then
set wPn=wJn(EB[wLn],0)
set EB[wLn]=wPn
elseif wpn==2 then
set wqn=wJn(EB[wLn],1)
set EB[wLn]=wqn
elseif wpn==3 then
set wQn=wJn(EB[wLn],2)
set EB[wLn]=wQn
elseif wpn==4 then
set wsn=wJn(EB[wLn],3)
set EB[wLn]=wsn
endif
set IB[wLn]=n5e(wmn,wMn,UB[wLn])
if IB[wLn]!=BlzGetAbilityManaCost(wMn,UB[wLn])then
set wSn=wJn(EB[wLn],4)
set EB[wLn]=wSn
endif
set PB[wLn]=nZe(wmn,wMn,UB[wLn])
if PB[wLn]!=BlzGetAbilityCooldown(wMn,UB[wLn])then
set wtn=wJn(EB[wLn],5)
set EB[wLn]=wtn
endif
if(not vhx(EB[wLn],4))or IB[wLn]<=$FF and(not vhx(EB[wLn],4))or(c6v(PB[wLn]*2.)*1./2==PB[wLn]and PB[wLn]*2.<=255.)then
set wTn=wJn(EB[wLn],6)
set EB[wLn]=wTn
endif
endfunction
function wun takes integer wUn,unit wwn,integer wWn,string wyn returns nothing
set ZM[EM]=wyn
set EM=EM+1
if wm[wUn]==0 then
if wUn==0 then
call Cdv("Nullpointer exception when calling SingleAbilityData.build","when calling error in UnitTypeData, line 830")
else
call Cdv("Called SingleAbilityData.build on invalid object.","when calling error in UnitTypeData, line 830")
endif
endif
call wln(wUn,wwn,wWn)
set EM=EM-1
endfunction
function wYn takes unit wzn returns integer
local integer wZn=0
local integer w_n=wZn
local integer w0n
local integer w1n
local integer w2n
local integer w3n
local integer w4n
local integer w5n
local integer w6n
local integer w7n
if xze(wzn,UNIT_TYPE_GIANT)then
set w0n=urn(w_n,0)
set w_n=w0n
endif
if xze(wzn,UNIT_TYPE_SUMMONED)then
set w1n=urn(w_n,1)
set w_n=w1n
endif
if xze(wzn,UNIT_TYPE_UNDEAD)then
set w2n=urn(w_n,2)
set w_n=w2n
endif
if xze(wzn,UNIT_TYPE_MECHANICAL)then
set w3n=urn(w_n,3)
set w_n=w3n
endif
if xze(wzn,UNIT_TYPE_PEON)then
set w4n=urn(w_n,4)
set w_n=w4n
endif
if xze(wzn,UNIT_TYPE_SAPPER)then
set w5n=urn(w_n,5)
set w_n=w5n
endif
if xze(wzn,UNIT_TYPE_ANCIENT)then
set w6n=urn(w_n,6)
set w_n=w6n
endif
if xze(wzn,UNIT_TYPE_TAUREN)then
set w7n=urn(w_n,7)
set w_n=w7n
endif
set c9=w_n
return c9
endfunction
function w8n takes integer w9n,integer Wvn returns integer
set b9=dpv(w9n,Wvn)
return b9
endfunction
function Wen takes integer Wxn,unit Won,string Wrn returns nothing
local integer Win
local integer Wan
local integer Wnn
local integer WVn
local integer WEn
local integer WXn
local integer WOn
local integer WRn
local integer WIn
local integer WAn
local integer WNn
local integer Wbn
local integer WBn
local integer Wcn
local integer WCn
local real Wdn
local integer WDn
local integer Wfn
local integer WFn
local integer Wgn
local integer WGn
local real Whn
local integer WHn
local integer Wjn
local real WJn
local real Wkn
local real WKn
local real Wln
local real WLn
local integer Wmn
local integer WMn
local integer Wpn
local integer WPn
local integer Wqn
local integer WQn
local integer Wsn
local integer WSn
local integer Wtn
local integer WTn
local integer Wun
local integer WUn
local integer Wwn
local real WWn
local integer Wyn
local integer WYn
local integer Wzn
local integer WZn
local real W_n
local integer W0n
local integer W1n
local integer W2n
local integer W3n
local integer W4n
local integer W5n
local integer W6n
local integer W7n
local integer W8n
local integer W9n
local integer yvn
local integer yen
local integer yxn
set ZM[EM]=Wrn
set EM=EM+1
set RN[Wxn]=umv(Won)
if x8e(Won,Sy)then
set WNn=w8n(dN[Wxn],0)
set dN[Wxn]=WNn
endif
if zcv(Won)then
set Wbn=w8n(dN[Wxn],1)
set dN[Wxn]=Wbn
endif
if zAv(Won)!=GetObjectName(RN[Wxn])then
set WBn=w8n(dN[Wxn],2)
set dN[Wxn]=WBn
set Wcn=vre(nN[Wxn],zAv(Won),"when calling addString in UnitTypeData, line 1090")
set TN[Wxn]=Wcn
endif
set WCn=U8n(Won)
set Wdn=f6
set WDn=R6
set Wfn=T6
set WFn=Y6
set Wgn=G6
set WGn=g6
set Whn=h6
set YN[Wxn]=WCn
set GN[Wxn]=Wdn
set gN[Wxn]=WDn
set hN[Wxn]=Wfn
set FN[Wxn]=WFn
set kN[Wxn]=Wgn
set jN[Wxn]=WGn
set xN[Wxn]=Whn
if YN[Wxn]!=0 then
set WHn=w8n(dN[Wxn],3)
set dN[Wxn]=WHn
endif
set Wjn=ufn(Won)
set WJn=J6
set Wkn=K6
set WKn=L6
set Wln=X6
set WLn=C6
set vN[Wxn]=Wjn
set mN[Wxn]=WJn
set QN[Wxn]=Wkn
set WN[Wxn]=WKn
set EN[Wxn]=Wln
set ZN[Wxn]=WLn
if vN[Wxn]!=0 then
set Wmn=w8n(dN[Wxn],4)
set dN[Wxn]=Wmn
endif
set WMn=Ufn(Won,"when calling getGeneralStats in UnitTypeData, line 1099")
set Wpn=Q7
set WPn=W7
set Wqn=E7
set WQn=Z7
set Wsn=U7
set WSn=I7
set Wtn=P7
set UN[Wxn]=WMn
set IN[Wxn]=Wpn
set PN[Wxn]=WPn
set AN[Wxn]=Wqn
set DN[Wxn]=WQn
set HN[Wxn]=Wsn
set JN[Wxn]=WSn
set KN[Wxn]=Wtn
if UN[Wxn]!=0 then
set WTn=w8n(dN[Wxn],5)
set dN[Wxn]=WTn
endif
set Wun=Tvn(Won)
set WUn=j8
set Wwn=x8
set WWn=v8
set Wyn=m8
set WYn=Q8
set Wzn=W8
set WZn=E8
set W_n=Z8
set W0n=U8
set W1n=I8
set W2n=P8
set W3n=A8
set W4n=D8
set LN[Wxn]=Wun
set XN[Wxn]=WUn
set CN[Wxn]=Wwn
set VN[Wxn]=WWn
set BN[Wxn]=Wyn
set NN[Wxn]=WYn
set MN[Wxn]=Wzn
set wM[Wxn]=WZn
set uM[Wxn]=W_n
set rM[Wxn]=W0n
set sM[Wxn]=W1n
set tM[Wxn]=W2n
set iM[Wxn]=W3n
set SM[Wxn]=W4n
if LN[Wxn]!=0 then
set W5n=w8n(dN[Wxn],6)
set dN[Wxn]=W5n
endif
if nLe(Won)and(not nje(Won))then
set W6n=utn(fN[Wxn],0)
set fN[Wxn]=W6n
endif
set Win=zbv(rfe(Won,"when calling removedAbilities in UnitTypeData, line 1109"))
loop
exitwhen not Y3v(Win)
set Wan=Vge(Win)
if Wan!=Sy then
call zGv(cM[Wxn],Wan,"when calling add in UnitTypeData, line 1111")
endif
endloop
call z5v(Win,"when calling close in UnitTypeData, line 1109")
set Wnn=zbv(zuv(Won,"when calling modifiedAbilities in UnitTypeData, line 1112"))
loop
exitwhen not Y3v(Wnn)
set WVn=Vge(Wnn)
set WIn=oM[Wxn]
set WEn=HCx("when calling new_SingleAbilityData in UnitTypeData, line 1113")
call wun(WEn,Won,WVn,"when calling build in UnitTypeData, line 1113")
call zGv(WIn,WEn,"when calling add in UnitTypeData, line 1113")
endloop
call z5v(Wnn,"when calling close in UnitTypeData, line 1112")
set WXn=zbv(rje(Won,"when calling addedAbilities in UnitTypeData, line 1114"))
loop
exitwhen not Y3v(WXn)
set WOn=Vge(WXn)
if WOn!=Sy then
set WAn=oM[Wxn]
set WRn=HCx("when calling new_SingleAbilityData in UnitTypeData, line 1116")
call wun(WRn,Won,WOn,"when calling build in UnitTypeData, line 1116")
call zGv(WAn,WRn,"when calling add in UnitTypeData, line 1116")
endif
endloop
call z5v(WXn,"when calling close in UnitTypeData, line 1114")
set W7n=wYn(Won)
set OM[Wxn]=W7n
if OM[Wxn]!=unn(RN[Wxn])then
set W8n=utn(fN[Wxn],1)
set fN[Wxn]=W8n
endif
set W9n=T9n(Won)
set lM[Wxn]=W9n
if lM[Wxn]!=uUn(RN[Wxn])then
set yvn=utn(fN[Wxn],2)
set fN[Wxn]=yvn
endif
if WaygateIsActive(Won)then
set yen=utn(fN[Wxn],3)
set fN[Wxn]=yen
endif
if fN[Wxn]!=0 then
set yxn=w8n(dN[Wxn],7)
set dN[Wxn]=yxn
endif
set EM=EM-1
endfunction
function yon takes integer yrn,unit yin,string yan returns nothing
set ZM[EM]=yan
set EM=EM+1
if lm[yrn]==0 then
if yrn==0 then
call Cdv("Nullpointer exception when calling UnitTypeData.build","when calling error in UnitTypeData, line 1080")
else
call Cdv("Called UnitTypeData.build on invalid object.","when calling error in UnitTypeData, line 1080")
endif
endif
call Wen(yrn,yin,"when calling build in UnitTypeData, line 1080")
set EM=EM-1
endfunction
function ynn takes integer ZeS returns nothing
endfunction
function yVn takes integer yEn,integer yXn,integer yOn returns nothing
call ynn(yEn)
set pM[yEn]=yXn
set eM[yEn]=yOn
endfunction
function yRn takes string yIn returns integer
local integer yAn
set ZM[EM]=yIn
set EM=EM+1
if pm==0 then
if em<$8000 then
set em=em+1
set yAn=em
else
call Cdv("Out of memory: Could not create KeyValueWrapper.","when calling error in UnitTypeData, line 1245")
set yAn=0
endif
else
set pm=pm-1
set yAn=ym[pm]
endif
set EM=EM-1
return yAn
endfunction
function yNn takes integer ybn,integer yBn,string ycn returns integer
local integer yCn
set ZM[EM]=ycn
set EM=EM+1
set yCn=yRn("when calling alloc_KeyValueWrapper in UnitTypeData, line 1249")
call yVn(yCn,ybn,yBn)
set EM=EM-1
return yCn
endfunction
function ydn takes integer yDn,integer yfn,string yFn returns integer
local integer ygn
local integer yGn
local integer yhn
local integer yHn
local integer yjn
local integer yJn
set ZM[EM]=yFn
set EM=EM+1
set ygn=k9x(yfn,"when calling hashCode in UnitTypeData, line 1267")
set yGn=f3v(bM[yDn],ygn,"when calling get in UnitTypeData, line 1268")
if yGn==0 then
set yGn=yTv("when calling new_LinkedList in UnitTypeData, line 1270")
call WTv(bM[yDn],ygn,yGn,"when calling put in UnitTypeData, line 1271")
endif
set yhn=Xle(yGn,"when calling iterator in UnitTypeData, line 1272")
loop
exitwhen not Xie(yhn)
set yHn=E3e(yhn)
if KBx(pM[yHn],yfn,"when calling equals in UnitTypeData, line 1273")then
call kCx(yfn,"when calling dispatch_UnitTypeData_destroyUnitTypeData in UnitTypeData, line 1274")
call Xpe(yhn,"when calling close in UnitTypeData, line 1272")
set EM=EM-1
set zf=eM[yHn]
return zf
endif
endloop
call Xpe(yhn,"when calling close in UnitTypeData, line 1272")
call zGv(yGn,yNn(yfn,dgv(yM[yDn],"when calling size in UnitTypeData, line 1276"),"when calling new_KeyValueWrapper in UnitTypeData, line 1276"),"when calling add in UnitTypeData, line 1276")
call dlv(yM[yDn],yfn,"when calling add in UnitTypeData, line 1277")
set yJn=dgv(yM[yDn],"when calling size in UnitTypeData, line 1278")-1
set yjn=yJn
set EM=EM-1
set zf=yjn
return zf
endfunction
function ykn takes integer yKn,integer yln,string yLn returns integer
local integer ymn
local integer yMn
set ZM[EM]=yLn
set EM=EM+1
if bm[yKn]==0 then
if yKn==0 then
call Cdv("Nullpointer exception when calling UnitTypeTable.addUnitType","when calling error in UnitTypeData, line 1266")
else
call Cdv("Called UnitTypeTable.addUnitType on invalid object.","when calling error in UnitTypeData, line 1266")
endif
endif
set yMn=ydn(yKn,yln,"when calling addUnitType in UnitTypeData, line 1266")
set ymn=yMn
set EM=EM-1
set zD=ymn
return zD
endfunction
function ypn takes integer yPn,unit yqn,real yQn,real ysn,string ySn returns nothing
local integer ytn
local integer yTn
local real yun
local real yUn
local integer ywn
set ZM[EM]=ySn
set EM=EM+1
set yun=FRv(DRv(uov(yqn),c3,yQn,ysn),d9)
set yUn=R1
set JB[yPn]=yun
set KB[yPn]=yUn
set LB[yPn]=GetUnitFacing(yqn)
set yTn=DB[yPn]
set ytn=J4x(AB[yPn],"when calling new_UnitTypeData in UnitTypeData, line 1326")
call yon(ytn,yqn,"when calling build in UnitTypeData, line 1326")
set ywn=ykn(yTn,ytn,"when calling addUnitType in UnitTypeData, line 1326")
set HB[yPn]=ywn
set EM=EM-1
endfunction
function yWn takes integer yyn,unit yYn,real yzn,real yZn,string y_n returns nothing
set ZM[EM]=y_n
set EM=EM+1
if tm[yyn]==0 then
if yyn==0 then
call Cdv("Nullpointer exception when calling SingleUnitData.build","when calling error in UnitTypeData, line 1322")
else
call Cdv("Called SingleUnitData.build on invalid object.","when calling error in UnitTypeData, line 1322")
endif
endif
call ypn(yyn,yYn,yzn,yZn,"when calling build in UnitTypeData, line 1322")
set EM=EM-1
endfunction
function y0n takes integer y1n,string y2n returns nothing
local integer y3n
local integer y4n
set ZM[EM]=y2n
set EM=EM+1
if HVo(SN[y1n])==cN[y1n]then
set y4n=MB[oN[y1n]]
set y3n=EOn(VB[oN[y1n]],NB[oN[y1n]],"when calling new_SingleUnitData in UnitTypeData, line 1412")
call yWn(y3n,SN[y1n],ON[y1n],lN[y1n],"when calling build in UnitTypeData, line 1412")
call dlv(y4n,y3n,"when calling add in UnitTypeData, line 1412")
endif
set EM=EM-1
endfunction
function y5n takes integer y6n,string y7n returns nothing
set ZM[EM]=y7n
set EM=EM+1
if BY[y6n]==0 then
if y6n==0 then
call Cdv("Nullpointer exception when calling ForForceCallback.run","when calling error in Execute, line 10")
else
call Cdv("Called ForForceCallback.run on invalid object.","when calling error in Execute, line 10")
endif
endif
if BY[y6n]<=$860 then
if BY[y6n]<=$857 then
if BY[y6n]<=$853 then
if BY[y6n]<=$851 then
if BY[y6n]<=$850 then
if BY[y6n]<=$84F then
call Npn(y6n,"when calling run_execute_AbstractIOTaskExecutor_IOTaskExecutor in Execute, line 10")
else
call S8n(y6n,"when calling run_execute_AbstractIOTaskExecutor_IOTaskExecutor in Execute, line 10")
endif
else
call SQn(y6n,"when calling run_execute_Base64Encoder_Base64 in Execute, line 10")
endif
elseif BY[y6n]<=$852 then
call QYn(y6n,"when calling run_execute_Execute in Execute, line 10")
else
call sgn(y6n,"when calling run_execute_GamecacheKeys in Execute, line 10")
endif
elseif BY[y6n]<=$855 then
if BY[y6n]<=$854 then
call N4n(y6n,"when calling run_execute_GamecacheKeys_GamecacheKeys in Execute, line 10")
else
call Emn(y6n,"when calling run_execute_LegacyPositionedUnitData_LegacyUnitData in Execute, line 10")
endif
elseif BY[y6n]<=$856 then
call scn(y6n,"when calling run_execute_Network_Network in Execute, line 10")
else
call s_n(y6n,"when calling run_execute_Network_NetworkData in Execute, line 10")
endif
elseif BY[y6n]<=$85C then
if BY[y6n]<=$85A then
if BY[y6n]<=$859 then
if BY[y6n]<=$858 then
call bOn(y6n,"when calling run_execute_Network_NetworkData in Execute, line 10")
else
call sXn(y6n)
endif
else
call S5n(y6n,"when calling run_execute_PersistentStore_Persistable in Execute, line 10")
endif
elseif BY[y6n]<=$85B then
call b3n(y6n,"when calling run_execute_PositionedDestructableData_DestructableData in Execute, line 10")
else
call s6n(y6n,"when calling run_execute_PositionedDestructableData_DestructableData in Execute, line 10")
endif
elseif BY[y6n]<=$85E then
if BY[y6n]<=$85D then
call sJn(y6n)
else
call Ben(y6n,"when calling run_execute_StringEncoder in Execute, line 10")
endif
elseif BY[y6n]<=$85F then
call bHn(y6n,"when calling run_execute_StringEncoder in Execute, line 10")
else
call Xen(y6n,"when calling run_execute_StringTable_LegacyStringTable in Execute, line 10")
endif
elseif BY[y6n]<=$869 then
if BY[y6n]<=$865 then
if BY[y6n]<=$863 then
if BY[y6n]<=$862 then
if BY[y6n]<=$861 then
call V2n(y6n,"when calling run_execute_StringTable_LegacyStringTable in Execute, line 10")
else
call Nsn(y6n,"when calling run_execute_StringTable_StringTable in Execute, line 10")
endif
else
call Son(y6n,"when calling run_execute_StringTable_StringTable in Execute, line 10")
endif
elseif BY[y6n]<=$864 then
call EYn(y6n,"when calling run_execute_UnitData_UnitTypeData in Execute, line 10")
else
call E2n(y6n,"when calling run_execute_UnitData_UnitTypeData in Execute, line 10")
endif
elseif BY[y6n]<=$867 then
if BY[y6n]<=$866 then
call y0n(y6n,"when calling run_execute_UnitData_UnitTypeData in Execute, line 10")
else
call Cln(y6n,"when calling run_execute_execute_LegacyPositionedUnitData_LegacyUnitData in Execute, line 10")
endif
elseif BY[y6n]<=$868 then
call snn(y6n,"when calling run_execute_execute_Network_NetworkData in Execute, line 10")
else
call sun(y6n,"when calling run_execute_execute_PositionedDestructableData_DestructableData in Execute, line 10")
endif
elseif BY[y6n]<=$86E then
if BY[y6n]<=$86C then
if BY[y6n]<=$86B then
if BY[y6n]<=$86A then
call Ehn(y6n,"when calling run_execute_execute_UnitData_UnitTypeData in Execute, line 10")
else
call CPn(y6n,"when calling run_execute_setArgumentsTypes_setProvidingEnumUnit_registerProtectedBuiltin_ScmdUnitBuiltins in Execute, line 10")
endif
else
call sIn(y6n,"when calling run_execute_setArgumentsTypes_setProvidingEnumUnit_registerProtectedBuiltin_ScmdUnitBuiltins in Execute, line 10")
endif
elseif BY[y6n]<=$86D then
call ban(y6n,"when calling run_execute_setArgumentsTypes_setProvidingEnumUnit_registerProtectedBuiltin_SotfrpGuiRegions in Execute, line 10")
else
call RLn(y6n,"when calling run_try_Persistable_PersistableData in Execute, line 10")
endif
elseif BY[y6n]<=$870 then
if BY[y6n]<=$86F then
call tmn(y6n,"when calling run_try_Persistable_PersistableData in Execute, line 10")
else
call Bbn(y6n,"when calling run_try_load_PersistentStore_Persistable in Execute, line 10")
endif
elseif BY[y6n]<=$871 then
call btn(y6n,"when calling run_try_load_PersistentStore_Persistable in Execute, line 10")
else
call txn(y6n)
endif
set EM=EM-1
endfunction
function y8n takes string y9n returns nothing
set ZM[EM]=y9n
set EM=EM+1
set Bp=""
call y5n(VYn(),"when calling run in Execute, line 19")
call Vzn(true)
set EM=EM-1
endfunction
function Yvn takes nothing returns nothing
set EM=0
call y8n("Execute, line 99")
endfunction
function Yen takes trigger Yxn,playerunitevent Yon returns nothing
call TriggerRegisterAnyUnitEventBJ(Yxn,Yon)
endfunction
function Yrn takes nothing returns boolean
local trigger Yin
local trigger Yan
set my='Aclv'
set Qy='AM07'
set Wy='BM01'
set Ey='BM02'
set Zy=70
set Uy=3
set Iy=2
set Py=5
set Ay=.25
set Dy=256.
set Hy=60
set Jy="W"
set Yin=CreateTrigger()
call Yen(Yin,EVENT_PLAYER_UNIT_SPELL_EFFECT)
set Yan=Yin
call GPo(Yan,Filter(Olv))
set Yin=null
set Yan=null
return true
endfunction
function Ynn takes nothing returns boolean
set Zq=$D0003
set Qq=$D0011
set Wq=$D0012
set Eq=$D0004
return true
endfunction
function YVn takes nothing returns boolean
return(Yu)
endfunction
function YEn takes nothing returns boolean
return(LoadBooleanBJ(2,GetHandleIdBJ(GetEnumUnit()),Au))
endfunction
function YXn takes nothing returns boolean
return(CountUnitsInGroup(Lu)==0)
endfunction
function YOn takes nothing returns boolean
return(DistanceBetweenPoints(Ju[$C],Ju[$A])<=Zu+10.)
endfunction
function YRn takes nothing returns boolean
return(CountUnitsInGroup(cr[rr])==0)and(CountUnitsInGroup(lr[rr])==0)
endfunction
function YIn takes nothing returns boolean
return(RectContainsLoc(GetPlayableMapRect(),Ju[$C]))
endfunction
function YAn takes nothing returns nothing
set Ju[$A]=LoadLocationHandleBJ(1,GetHandleIdBJ(GetEnumUnit()),Au)
set Ju[$B]=GetUnitLoc(GetEnumUnit())
if YEn()then
set Ju[$C]=PolarProjectionBJ(Ju[$B],Zu,AngleBetweenPoints(Ju[4],Ju[$A]))
set tr=DistanceBetweenPoints(Ju[4],Ju[$A])
set yr=DistanceBetweenPoints(Ju[4],Ju[$C])
else
set Ju[$C]=PolarProjectionBJ(Ju[$B],Zu,AngleBetweenPoints(Ju[5],Ju[$A]))
set tr=DistanceBetweenPoints(Ju[5],Ju[$A])
set yr=DistanceBetweenPoints(Ju[5],Ju[$C])
endif
call SetUnitPositionLoc(GetEnumUnit(),Ju[$C])
call SetUnitFlyHeightBJ(GetEnumUnit(),4.*(Eu/tr)*yr*((-(1.*yr))/tr+1.),.0)
if YIn()then
if YOn()then
call KillUnit(GetEnumUnit())
call GroupRemoveUnitSimple(GetEnumUnit(),cr[rr])
call GroupAddUnitSimple(GetEnumUnit(),Ku)
call SaveIntegerBJ(Du+3,0,GetHandleIdBJ(GetEnumUnit()),Au)
set bj_wantDestroyGroup=true
call ForGroupBJ(GetUnitsInRangeOfLocMatching(Iu,Ju[$C],Condition(z6)),z7)
call RemoveLocation(Ju[$A])
endif
else
call GroupRemoveUnitSimple(GetEnumUnit(),cr[rr])
call GroupAddUnitSimple(GetEnumUnit(),Ku)
call SaveIntegerBJ(Du+1,0,GetHandleIdBJ(GetEnumUnit()),Au)
call RemoveLocation(Ju[$A])
endif
if YRn()then
if YVn()then
call ForForce(GetPlayersAll(),z8)
endif
call GroupRemoveUnitSimple(Nu,Lu)
call FlushChildHashtableBJ(Bu,Au)
if YXn()then
call DisableTrigger(GetTriggeringTrigger())
set Vu=0
endif
call RemoveLocation(Ju[4])
call RemoveLocation(Ju[5])
endif
call RemoveLocation(Ju[$B])
call RemoveLocation(Ju[$C])
endfunction
function YNn takes nothing returns boolean
return(GetSpellAbilityId()=='A03H')or(GetSpellAbilityId()=='A03W')or(GetSpellAbilityId()=='A03I')
endfunction
function Ybn takes nothing returns boolean
return(YNn())
endfunction
function YBn takes nothing returns boolean
return(GetSpellAbilityId()=='A0CL')
endfunction
function Ycn takes nothing returns boolean
return(GetSpellAbilityId()=='A06H')
endfunction
function YCn takes nothing returns boolean
return GetSpellAbilityId()=='A04K'
endfunction
function Ydn takes nothing returns boolean
return GetSpellAbilityId()=='A0KU'
endfunction
function YDn takes nothing returns nothing
set Yw=1
set Yw=Yw+1
set Yw=Yw+1
set Yw=Yw+1
set Yw=Yw+1
set Yw=Yw+1
set Yw=Yw+1
set Yw=Yw+1
set Yw=Yw+1
set Yw=Yw+1
set Yw=Yw+1
set Yw=Yw+1
set Yw=Yw+1
set Yw=Yw+1
set Yw=Yw+1
set Yw=Yw+1
set Yw=Yw+1
set Yw=0
call DestroyTrigger(GetTriggeringTrigger())
endfunction
function Yfn takes nothing returns nothing
set g[GetConvertedPlayerId(GetTriggerPlayer())]=GetUnitsOfPlayerAndTypeId(GetTriggerPlayer(),'h000')
call GetConvertedPlayerId(GetTriggerPlayer())
call GetUnitLoc(null)
call ForGroupBJ(g[GetConvertedPlayerId(GetTriggerPlayer())],oov)
call DestroyGroup(g[GetPlayerId(GetTriggerPlayer())+1])
endfunction
function YFn takes nothing returns boolean
return(GetSpellAbilityId()=='A09J')
endfunction
function Ygn takes nothing returns nothing
set Lr=.25
set Jr=false
set mr=GetSpellTargetLoc()
set xr=GetTriggerUnit()
set mt=GetUnitAbilityLevelSwapped('A0EJ',GetTriggerUnit())
set Er=15.
set Pr="Abilities\\Weapons\\FaerieDragonMissile\\FaerieDragonMissile.mdl"
set Dr="slam"
set Xr=.3
call ConditionalTriggerExecute(IS)
endfunction
function YGn takes nothing returns boolean
return(GetUnitTypeId(GetEnumUnit())!='h000')and(IsUnitSelected(GetEnumUnit(),GetTriggerPlayer()))and(GetUnitTypeId(GetEnumUnit())!='h0KW')
endfunction
function Yhn takes nothing returns nothing
if YGn()then
call UnitAddTypeBJ(UNIT_TYPE_MECHANICAL,GetEnumUnit())
endif
endfunction
function YHn takes nothing returns nothing
call GroupRemoveUnit(Ot,GetSpellAbilityUnit())
endfunction
function Yjn takes nothing returns nothing
local integer YJn=0
loop
exitwhen YJn>Cs
call UnitRemoveAbility(GetEnumUnit(),Vs[YJn])
set YJn=YJn+1
endloop
set YJn=0
endfunction
function Ykn takes nothing returns boolean
return(GetSpellAbilityId()=='A07I')
endfunction
function YKn takes nothing returns boolean
return true
endfunction
function Yln takes string YLn returns boolean
local integer Ymn
local integer YMn
local integer Ypn
local integer YPn
local integer Yqn
set ZM[EM]=YLn
set EM=EM+1
set Ymn=0
set YMn=0
set Ypn=0
set YPn=0
set Yqn=0
set Ce=Ymn
set Ve=YMn
set Be=Ypn
set Ne=YPn
set Me=Yqn
set wq=InitGameCache("m.w3v")
set uq=Tbx(0,"when calling get in Metadata, line 16")
set rq=Tbx(1,"when calling get in Metadata, line 17")
set sq=Tbx(2,"when calling get in Metadata, line 18")
set tq=Tbx(3,"when calling get in Metadata, line 19")
set iq=Tbx(4,"when calling get in Metadata, line 20")
set Sq=5
set EM=EM-1
return true
endfunction
function YQn takes nothing returns boolean
set EM=0
return Yln("Metadata, line 1")
endfunction
function Ysn takes nothing returns nothing
local unit YSn
if GetUnitAbilityLevel(GetTriggerUnit(),'B05K')==0 then
set YSn=null
return
endif
set YSn=GetTriggerUnit()
call UnitRemoveAbility(YSn,'BSTN')
call UnitRemoveAbility(YSn,'BPSE')
call BlzSetEventDamage(GetEventDamage()*.7)
set YSn=null
set YSn=null
endfunction
function Ytn takes nothing returns boolean
return(RectContainsLoc(GetPlayableMapRect(),Ju[$C]))
endfunction
function YTn takes nothing returns boolean
return(Yu)
endfunction
function Yun takes nothing returns boolean
return(CountUnitsInGroup(Lu)==0)
endfunction
function YUn takes nothing returns boolean
return(CountUnitsInGroup(cr[rr])==0)and(CountUnitsInGroup(lr[rr])==0)
endfunction
function Ywn takes nothing returns boolean
return(DistanceBetweenPoints(Ju[$C],Ju[$A])<=Zu+10.)
endfunction
function YWn takes nothing returns boolean
return(LoadBooleanBJ(2,GetHandleIdBJ(GetEnumUnit()),Au))
endfunction
function Yyn takes nothing returns nothing
set Ju[$A]=LoadLocationHandleBJ(1,GetHandleIdBJ(GetEnumUnit()),Au)
set Ju[$B]=GetUnitLoc(GetEnumUnit())
if YWn()then
set Ju[$C]=PolarProjectionBJ(Ju[$B],Zu,AngleBetweenPoints(Ju[4],Ju[$A]))
set tr=DistanceBetweenPoints(Ju[4],Ju[$A])
set yr=DistanceBetweenPoints(Ju[4],Ju[$C])
else
set Ju[$C]=PolarProjectionBJ(Ju[$B],Zu,AngleBetweenPoints(Ju[5],Ju[$A]))
set tr=DistanceBetweenPoints(Ju[5],Ju[$A])
set yr=DistanceBetweenPoints(Ju[5],Ju[$C])
endif
call SetUnitPositionLoc(GetEnumUnit(),Ju[$C])
call SetUnitFlyHeightBJ(GetEnumUnit(),4.*(Eu/tr)*yr*((-(1.*yr))/tr+1.),.0)
if Ytn()then
if Ywn()then
call KillUnit(GetEnumUnit())
call GroupRemoveUnitSimple(GetEnumUnit(),cr[rr])
call GroupAddUnitSimple(GetEnumUnit(),Ku)
call SaveIntegerBJ(Du+3,0,GetHandleIdBJ(GetEnumUnit()),Au)
set bj_wantDestroyGroup=true
call ForGroupBJ(GetUnitsInRangeOfLocMatching(Iu,Ju[$C],Condition(D0)),f0)
call RemoveLocation(Ju[$A])
endif
else
call GroupRemoveUnitSimple(GetEnumUnit(),cr[rr])
call GroupAddUnitSimple(GetEnumUnit(),Ku)
call SaveIntegerBJ(Du+1,0,GetHandleIdBJ(GetEnumUnit()),Au)
call RemoveLocation(Ju[$A])
endif
if YUn()then
if YTn()then
call ForForce(GetPlayersAll(),F0)
endif
call GroupRemoveUnitSimple(Nu,Lu)
call FlushChildHashtableBJ(Bu,Au)
if Yun()then
call DisableTrigger(GetTriggeringTrigger())
set Vu=0
endif
call RemoveLocation(Ju[4])
call RemoveLocation(Ju[5])
endif
call RemoveLocation(Ju[$B])
call RemoveLocation(Ju[$C])
endfunction
function YYn takes string Yzn returns integer
local integer YZn
set ZM[EM]=Yzn
set EM=EM+1
set YZn=Vln(true,"when calling new_Iterator in LinkedListModule, line 53")
set EM=EM-1
return YZn
endfunction
function Y_n takes integer Y0n,string Y1n returns nothing
set ZM[EM]=Y1n
set EM=EM+1
if Fh[Y0n]==0 then
call Cdv("Double free: object of type Iterator","when calling error in LinkedListModule, line 71")
else
set Gh[gh]=Y0n
set gh=gh+1
set Fh[Y0n]=0
endif
set EM=EM-1
endfunction
function Y2n takes integer sHs returns nothing
endfunction
function Y3n takes integer Y4n,string Y5n returns nothing
set ZM[EM]=Y5n
set EM=EM+1
call Y2n(Y4n)
call Y_n(Y4n,"when calling dealloc_Iterator in LinkedListModule, line 71")
set EM=EM-1
endfunction
function Y6n takes integer Y7n,string Y8n returns nothing
set ZM[EM]=Y8n
set EM=EM+1
if Fh[Y7n]==0 then
if Y7n==0 then
call Cdv("Nullpointer exception when calling Iterator.Iterator","when calling error in LinkedListModule, line 71")
else
call Cdv("Called Iterator.Iterator on invalid object.","when calling error in LinkedListModule, line 71")
endif
endif
call Y3n(Y7n,"when calling destroyIterator in LinkedListModule, line 71")
set EM=EM-1
endfunction
function Y9n takes integer zvn,string zen returns nothing
set ZM[EM]=zen
set EM=EM+1
if GU[zvn]then
call Y6n(zvn,"when calling dispatch_Iterator_destroyIterator in LinkedListModule, line 91")
endif
set EM=EM-1
endfunction
function zxn takes integer zon returns boolean
return YU[zon]!=0
endfunction
function zrn takes integer zin returns integer
local integer zan=YU[zin]
set YU[zin]=TU[YU[zin]]
return zan
endfunction
function znn takes nothing returns nothing
if Ye and Te==0 then
call apn(Re)
endif
endfunction
function zVn takes string zEn returns integer
local integer zXn
set ZM[EM]=zEn
set EM=EM+1
if CY==0 then
if VY<$8000 then
set VY=VY+1
set zXn=VY
set BY[zXn]=$84F
else
call Cdv("Out of memory: Could not create ForForceCallback_execute_AbstractIOTaskExecutor_IOTaskExecutor.","when calling error in IOTaskExecutor, line 62")
set zXn=0
endif
else
set CY=CY-1
set zXn=XY[CY]
set BY[zXn]=$84F
endif
set EM=EM-1
return zXn
endfunction
function zOn takes string zRn returns integer
local integer zIn
set ZM[EM]=zRn
set EM=EM+1
if CY==0 then
if VY<$8000 then
set VY=VY+1
set zIn=VY
set BY[zIn]=$850
else
call Cdv("Out of memory: Could not create ForForceCallback_execute_AbstractIOTaskExecutor_IOTaskExecutor.","when calling error in IOTaskExecutor, line 68")
set zIn=0
endif
else
set CY=CY-1
set zIn=XY[CY]
set BY[zIn]=$850
endif
set EM=EM-1
return zIn
endfunction
function zAn takes integer zNn,string zbn returns nothing
local integer zBn
local integer zcn
set ZM[EM]=zbn
set EM=EM+1
if qU[zNn]then
call Cdv("AbstractIOTaskExecutor: trying to execute in a finished executor","when calling error in IOTaskExecutor, line 59")
endif
if not YYv(pU[zNn],"when calling isEmpty in IOTaskExecutor, line 61")then
set zBn=zVn("when calling alloc_ForForceCallback_execute_AbstractIOTaskExecutor_IOTaskExecutor in IOTaskExecutor, line 62")
set aU[zBn]=zNn
call Fte(zBn,"when calling execute in IOTaskExecutor, line 62")
else
if eU[zNn]!=0 then
set zcn=zOn("when calling alloc_ForForceCallback_execute_AbstractIOTaskExecutor_IOTaskExecutor in IOTaskExecutor, line 68")
set nU[zcn]=zNn
call Fte(zcn,"when calling execute in IOTaskExecutor, line 68")
call uKa(eU[zNn],"when calling dispatch_IOTask_destroyIOTask in IOTaskExecutor, line 69")
set eU[zNn]=0
endif
set qU[zNn]=true
endif
set EM=EM-1
endfunction
function zCn takes integer zdn,string zDn returns nothing
set ZM[EM]=zDn
set EM=EM+1
if qh[zdn]==0 then
if zdn==0 then
call Cdv("Nullpointer exception when calling AbstractIOTaskExecutor.executeNext","when calling error in IOTaskExecutor, line 57")
else
call Cdv("Called AbstractIOTaskExecutor.executeNext on invalid object.","when calling error in IOTaskExecutor, line 57")
endif
endif
call zAn(zdn,"when calling executeNext in IOTaskExecutor, line 57")
set EM=EM-1
endfunction
function zfn takes integer zFn,string zgn returns nothing
set ZM[EM]=zgn
set EM=EM+1
if(not qU[zFn])and fU[zFn]+dU[zFn]<=Oe then
call zCn(zFn,"when calling executeNext in IOTaskExecutor, line 127")
set fU[zFn]=Oe
if qU[zFn]then
set Te=Te-1
call znn()
endif
endif
set EM=EM-1
endfunction
function zGn takes integer zhn,string zHn returns nothing
set ZM[EM]=zHn
set EM=EM+1
if qh[zhn]==0 then
if zhn==0 then
call Cdv("Nullpointer exception when calling TimedIOTaskExecutor.update","when calling error in IOTaskExecutor, line 125")
else
call Cdv("Called TimedIOTaskExecutor.update on invalid object.","when calling error in IOTaskExecutor, line 125")
endif
endif
call zfn(zhn,"when calling update in IOTaskExecutor, line 125")
set EM=EM-1
endfunction
function zjn takes string zJn returns nothing
local integer zkn
local integer zKn
set ZM[EM]=zJn
set EM=EM+1
set zkn=YYn("when calling iterator in IOTaskExecutor, line 110")
loop
exitwhen not zxn(zkn)
set zKn=zrn(zkn)
call zGn(zKn,"when calling update in IOTaskExecutor, line 111")
endloop
call Y9n(zkn,"when calling close in IOTaskExecutor, line 110")
set EM=EM-1
endfunction
function zln takes nothing returns nothing
set EM=0
call zjn("IOTaskExecutor, line 143")
endfunction
function zLn takes nothing returns boolean
set Xp=60
set Cp=-1
set Vp=InitHashtable()
set Bp=""
set Np=false
return true
endfunction
function zmn takes nothing returns boolean
set Uq='AXDT'
set Iq=Cq
set Pq="AXDT"
set Aq="\")
\tcall BlzSetAbilityTooltip('"+Pq+"',\""
set Dq="\",$"
set Hq=")
//"
set Jq="\" )
endfunction
function AAA takes nothing returns nothing 
//"
set Kq=$CB
set Xq=1
set Lq=1
return true
endfunction
function zMn takes nothing returns boolean
return GetBooleanAnd(IsUnitAliveBJ(GetFilterUnit()),IsUnitEnemy(GetFilterUnit(),GetOwningPlayer(Nu)))
endfunction
function zpn takes nothing returns boolean
return GetBooleanAnd(IsUnitAliveBJ(GetFilterUnit()),IsUnitEnemy(GetFilterUnit(),GetOwningPlayer(Nu)))
endfunction
function zPn takes nothing returns nothing
local integer zqn=0
local integer zQn=0
local integer zsn=GetUnitAbilityLevel(GetSpellAbilityUnit(),'A09H')
local unit zSn=GetSpellTargetUnit()
local unit ztn=GetSpellAbilityUnit()
local unit zTn=null
loop
exitwhen zQn>V
if GetUnitAbilityLevel(zSn,C[zQn])!=0 then
set zqn=zqn+1
endif
set zQn=zQn+1
endloop
set zQn=0
loop
exitwhen zQn>fw
if GetUnitAbilityLevel(zSn,Rw[zQn])!=0 then
set zqn=zqn+1
endif
set zQn=zQn+1
endloop
call DestroyEffect(AddSpecialEffectTarget("Abilities\\Spells\\Demon\\DarkPortal\\DarkPortalTarget.mdl",zSn,"origin"))
call SetUnitExploded(zSn,true)
call KillUnit(zSn)
if IsUnitType(zSn,UNIT_TYPE_FLYING) then
if zsn==3 then
set zTn=CreateUnitAtLoc(GetOwningPlayer(ztn),'n01F',GetUnitLoc(zSn),GetUnitFacing(zSn))
elseif zsn==2 then
set zTn=CreateUnitAtLoc(GetOwningPlayer(ztn),'n01G',GetUnitLoc(zSn),GetUnitFacing(zSn))
elseif zsn==1 then
set zTn=CreateUnitAtLoc(GetOwningPlayer(ztn),'n01H',GetUnitLoc(zSn),GetUnitFacing(zSn))
endif
elseif GetRandomInt(1,3)<=2 then
if zsn==3 then
set zTn=CreateUnitAtLoc(GetOwningPlayer(ztn),'n01N',GetUnitLoc(zSn),GetUnitFacing(zSn))
else
if zsn==2 then
set zTn=CreateUnitAtLoc(GetOwningPlayer(ztn),'n01M',GetUnitLoc(zSn),GetUnitFacing(zSn))
elseif zsn==1 then
set zTn=CreateUnitAtLoc(GetOwningPlayer(ztn),'n01L',GetUnitLoc(zSn),GetUnitFacing(zSn))
endif
if GetUnitState(zSn,UNIT_STATE_MAX_LIFE)>=2000. then
call UnitAddAbility(zTn,'A0BH')
call UnitAddAbility(zTn,'A0BG')
call UnitAddAbility(zTn,'A0BE')
call UnitAddAbility(zTn,'A0BI')
call UnitAddAbility(zTn,'A0BD')
elseif GetUnitState(zSn,UNIT_STATE_MAX_LIFE)>=1800. then
call UnitAddAbility(zTn,'A0BC')
call UnitAddAbility(zTn,'A0B6')
call UnitAddAbility(zTn,'A0BE')
call UnitAddAbility(zTn,'A0BF')
call UnitAddAbility(zTn,'A06K')
elseif GetUnitState(zSn,UNIT_STATE_MAX_LIFE)>=1600. then
call UnitAddAbility(zTn,'A0BC')
call UnitAddAbility(zTn,'A0B6')
call UnitAddAbility(zTn,'A0B8')
call UnitAddAbility(zTn,'A0BB')
call UnitAddAbility(zTn,'A06K')
elseif GetUnitState(zSn,UNIT_STATE_MAX_LIFE)>=1400. then
call UnitAddAbility(zTn,'A0B9')
call UnitAddAbility(zTn,'A0B6')
call UnitAddAbility(zTn,'A0B8')
call UnitAddAbility(zTn,'A06K')
elseif GetUnitState(zSn,UNIT_STATE_MAX_LIFE)>=1200. then
call UnitAddAbility(zTn,'A0B7')
call UnitAddAbility(zTn,'A0B6')
call UnitAddAbility(zTn,'A0B8')
elseif GetUnitState(zSn,UNIT_STATE_MAX_LIFE)>=1000. then
call UnitAddAbility(zTn,'A0B5')
call UnitAddAbility(zTn,'A0B6')
call UnitAddAbility(zTn,'A0B2')
elseif GetUnitState(zSn,UNIT_STATE_MAX_LIFE)>=800. then
call UnitAddAbility(zTn,'A0B4')
call UnitAddAbility(zTn,'A0B3')
call UnitAddAbility(zTn,'A0B2')
elseif GetUnitState(zSn,UNIT_STATE_MAX_LIFE)>=600. then
call UnitAddAbility(zTn,'A0B0')
call UnitAddAbility(zTn,'A0AZ')
call UnitAddAbility(zTn,'A0B1')
endif
if zqn>=1 then
call UnitAddAbility(zTn,'A0BK')
if zqn>=2 then
call UnitAddAbility(zTn,'A0BJ')
if zqn>=3 then
call UnitAddAbility(zTn,'A0BL')
endif
endif
endif
endif
elseif zsn==3 then
set zTn=CreateUnitAtLoc(GetOwningPlayer(ztn),'n01K',GetUnitLoc(zSn),GetUnitFacing(zSn))
elseif zsn==2 then
set zTn=CreateUnitAtLoc(GetOwningPlayer(ztn),'n01J',GetUnitLoc(zSn),GetUnitFacing(zSn))
elseif zsn==1 then
set zTn=CreateUnitAtLoc(GetOwningPlayer(ztn),'n01I',GetUnitLoc(zSn),GetUnitFacing(zSn))
endif
call UnitApplyTimedLife(zTn,'BFig',180.)
set zqn=0
set zQn=0
set zsn=0
set zSn=null
set ztn=null
set zTn=null
set zSn=null
set ztn=null
set zTn=null
endfunction
function zun takes nothing returns boolean
return(IsPlayerEnemy(GetOwningPlayer(GetFilterUnit()),GetOwningPlayer(GetSpellAbilityUnit())))
endfunction
function zUn takes nothing returns boolean
return IsUnitSelected(GetFilterUnit(),GetTriggerPlayer())
endfunction
function zwn takes nothing returns boolean
return(GetEventPlayerChatString()=="time lock")
endfunction
function zWn takes nothing returns boolean
return(GetEventPlayerChatString()=="time unlock")
endfunction
function zyn takes nothing returns nothing
if zwn()then
if GetEventPlayerChatString()=="time lock" then
call SetTimeOfDayScalePercentBJ(.0)
endif
return
endif
if zWn()then
if GetEventPlayerChatString()=="time unlock" then
call SetTimeOfDayScalePercentBJ(100.)
endif
return
endif
call SetTimeOfDay(S2R(SubStringBJ(GetEventPlayerChatString(),6,$B)))
if GetEventPlayerChatString()=="time morning" then
call SetTimeOfDay(6.)
endif
if GetEventPlayerChatString()=="time midnight" then
call SetTimeOfDay(24.)
endif
if GetEventPlayerChatString()=="time evening" then
call SetTimeOfDay(18.)
endif
if GetEventPlayerChatString()=="time noon" then
call SetTimeOfDay(12.)
endif
endfunction
function zYn takes nothing returns boolean
return not Zt[GetPlayerId(GetTriggerPlayer())]
endfunction
function zzn takes nothing returns boolean
set yq=InitGameCache("1")
set pq=InitGameCache("2")
return true
endfunction
function zZn takes nothing returns boolean
return(IsDestructableInvulnerableBJ(GetEnumDestructable()))
endfunction
function z_n takes nothing returns nothing
if zZn()then
call SetDestructableInvulnerableBJ(GetEnumDestructable(),false)
else
call SetDestructableInvulnerableBJ(GetEnumDestructable(),true)
endif
endfunction
function z0n takes nothing returns nothing
call KillDestructable(GetEnumDestructable())
endfunction
function z1n takes nothing returns nothing
local unit z2n=GetSpellAbilityUnit()
local integer z3n=GetUnitAbilityLevel(z2n,'A0JW')
local integer z4n=0
if IsUnitInGroup(z2n,lt) then
call GroupRemoveUnit(lt,z2n)
call pAa(1.)
endif
call GroupAddUnit(lt,z2n)
call UnitAddAbility(z2n,'A0JV')
call UnitMakeAbilityPermanent(z2n,true,'A0JV')
call SetUnitAbilityLevel(z2n,'A0JV',z3n)
call SetUnitInvulnerable(z2n,true)
loop
exitwhen IsUnitInGroup(z2n,lt)==false
call pAa(1.)
call SetUnitState(z2n,UNIT_STATE_LIFE,GetUnitState(z2n,UNIT_STATE_LIFE)+50.)
call DestroyEffect(AddSpecialEffectTarget("Abilities\\Spells\\Human\\Heal\\HealTarget.mdl",z2n,"origin"))
set z4n=z4n+1
if z4n==z3n*4 or GetUnitState(z2n,UNIT_STATE_LIFE)<=.0 then
call GroupRemoveUnit(lt,z2n)
endif
endloop
call SetUnitInvulnerable(z2n,false)
call SetUnitAnimation(z2n,"stand")
call UnitRemoveAbility(z2n,'A0JV')
call UnitRemoveAbility(z2n,'B04I')
call IssueImmediateOrderById(z2n,$D0004)
set z2n=null
set z3n=0
set z4n=0
set z2n=null
endfunction
function z5n takes nothing returns nothing
call ForGroup(Bs,iYv)
endfunction
function z6n takes nothing returns nothing
call UnitRemoveAbility(GetEnumUnit(),'Asw1')
call UnitRemoveAbility(GetEnumUnit(),'Asw2')
endfunction
function z7n takes nothing returns boolean
return(IsUnitSelected(GetEnumUnit(),GetTriggerPlayer()))and(GetUnitTypeId(GetEnumUnit())!='h000')
endfunction
function z8n takes nothing returns nothing
set bj_forLoopAIndex=0
set bj_forLoopAIndexEnd=dw
loop
exitwhen bj_forLoopAIndex>bj_forLoopAIndexEnd
if z7n()then
call UnitRemoveAbilityBJ(aw[GetForLoopIndexA()],GetEnumUnit())
endif
set bj_forLoopAIndex=bj_forLoopAIndex+1
endloop
endfunction
function z9n takes integer Zvn returns nothing
set YW[Zvn]=0
set GW[Zvn]=0
set gW[Zvn]=0
endfunction
function Zen takes integer Zxn returns nothing
call z9n(Zxn)
endfunction
function Zon takes integer IMi returns nothing
endfunction
function Zrn takes integer Zin,boolean DMi returns nothing
call Zon(Zin)
endfunction
function Zan takes string Znn returns integer
local integer ZVn
set ZM[EM]=Znn
set EM=EM+1
if fv==0 then
if Rv<$8000 then
set Rv=Rv+1
set ZVn=Rv
else
call Cdv("Out of memory: Could not create BackIterator.","when calling error in LinkedListModule, line 93")
set ZVn=0
endif
else
set fv=fv-1
set ZVn=dv[fv]
endif
set EM=EM-1
return ZVn
endfunction
function ZEn takes boolean ZXn,string ZOn returns integer
local integer ZRn
set ZM[EM]=ZOn
set EM=EM+1
set ZRn=Zan("when calling alloc_BackIterator in LinkedListModule, line 97")
call Zrn(ZRn,ZXn)
set EM=EM-1
return ZRn
endfunction
function ZIn takes string ZAn returns integer
local integer ZNn
set ZM[EM]=ZAn
set EM=EM+1
if LG==0 then
if XG<$8000 then
set XG=XG+1
set ZNn=XG
set CG[ZNn]=$7BC
else
call Cdv("Out of memory: Could not create EventListener_add_SyncSimple.","when calling error in SyncSimple, line 165")
set ZNn=0
endif
else
set LG=LG-1
set ZNn=KG[LG]
set CG[ZNn]=$7BC
endif
set EM=EM-1
return ZNn
endfunction
function Zbn takes string ZBn returns integer
local integer Zcn
set ZM[EM]=ZBn
set EM=EM+1
if LG==0 then
if XG<$8000 then
set XG=XG+1
set Zcn=XG
set CG[Zcn]=$7BD
else
call Cdv("Out of memory: Could not create EventListener_add_SyncSimple.","when calling error in SyncSimple, line 171")
set Zcn=0
endif
else
set LG=LG-1
set Zcn=KG[LG]
set CG[Zcn]=$7BD
endif
set EM=EM-1
return Zcn
endfunction
function ZCn takes eventid Zdn,integer ZDn,string Zfn returns integer
set ZM[EM]=Zfn
set EM=EM+1
set YW[ZDn]=q1a(Zdn,"when calling toIntId in ClosureEvents, line 112")
if wp[YW[ZDn]]!=0 then
set gW[wp[YW[ZDn]]]=ZDn
set GW[ZDn]=wp[YW[ZDn]]
endif
set wp[YW[ZDn]]=ZDn
set EM=EM-1
return ZDn
endfunction
function ZFn takes string Zgn returns boolean
local integer ZGn
local integer Zhn
local playerunitevent ZHn
local playerevent Zjn
local integer ZJn
set ZM[EM]=Zgn
set EM=EM+1
set UR=null
set IR=0
set DR=0
set HR=0
set JR=0
call Zta(false,"when calling new_Iterator in LinkedListModule, line 55")
call ZEn(false,"when calling new_BackIterator in LinkedListModule, line 65")
set ZJn=$FFFFFFF
set AR=ZJn
set ZHn=EVENT_PLAYER_UNIT_SELECTED
set ZGn=ZIn("when calling alloc_EventListener_add_SyncSimple in SyncSimple, line 165")
call Zen(ZGn)
call ZCn(ZHn,ZGn,"when calling add in SyncSimple, line 165")
set Zjn=EVENT_PLAYER_LEAVE
set Zhn=Zbn("when calling alloc_EventListener_add_SyncSimple in SyncSimple, line 171")
call Zen(Zhn)
call ZCn(Zjn,Zhn,"when calling add in SyncSimple, line 171")
call oyn(Rov)
set EM=EM-1
set ZHn=null
set Zjn=null
return true
endfunction
function Zkn takes nothing returns boolean
set EM=0
return ZFn("SyncSimple, line 68")
endfunction
function ZKn takes string Zln returns nothing
local unit ZLn
set ZM[EM]=Zln
set EM=EM+1
if GetSpellAbilityId()==Ed then
set ZLn=GetSpellAbilityUnit()
call nfn(Id,ZLn,12.,"when calling apply in ShieldWall, line 29")
call nPn(GetOwningPlayer(ZLn),Ud,1,"attackonce",ZLn,GetUnitX(ZLn),GetUnitY(ZLn))
endif
set EM=EM-1
set ZLn=null
endfunction
function Zmn takes nothing returns nothing
set EM=0
call ZKn("ShieldWall, line 44")
endfunction
function ZMn takes string Zpn returns framehandle
return BlzGetFrameByName(Zpn,0)
endfunction
function ZPn takes nothing returns boolean
call DTa(ZMn("ResourceBarFrame"))
return true
endfunction
function Zqn takes nothing returns boolean
return GetBooleanAnd(IsUnitAliveBJ(GetFilterUnit()),IsUnitEnemy(GetFilterUnit(),GetOwningPlayer(Nu)))
endfunction
function ZQn takes nothing returns nothing
local group Zsn=CreateGroup()
call GroupEnumUnitsInRangeOfLoc(Zsn,GetSpellTargetLoc(),800.,Condition(n7v))
call ForGroup(Zsn,n8v)
call DestroyGroup(Zsn)
set Zsn=null
set Zsn=null
endfunction
function ZSn takes unit Ztn returns nothing
if GetUnitAbilityLevel(Ztn,'AaIB')==0 then
call UnitAddAbility(Ztn,'AAI2')
endif
set Ztn=null
endfunction
function ZTn takes unit Zun returns nothing
local real ZUn=GetUnitX(Zun)
local real Zwn=GetUnitY(Zun)
local real ZWn=GetUnitFacing(Zun)
call SetUnitPosition(Zun,ZUn,Zwn)
call SetUnitFacing(Zun,ZWn)
set ZWn=ZWn*bj_DEGTORAD
set ZUn=ZUn+10.*Cos(ZWn)
set Zwn=Zwn+10.*Sin(ZWn)
set ZWn=.0
set bj_lastCreatedDestructable=CreateDestructable('Dumm',ZUn,Zwn,.0,1.,0)
set ZUn=.0
set Zwn=.0
call UnitAddAbility(Zun,'AAI0')
call IssueTargetOrderById(Zun,$D021F,bj_lastCreatedDestructable)
call UnitRemoveAbility(Zun,'AAI0')
call UnitRemoveAbility(Zun,'AaI1')
call UnitAddAbility(Zun,'AaI0')
set Zun=null
call RemoveDestructable(bj_lastCreatedDestructable)
set bj_lastCreatedDestructable=null
endfunction
function Zyn takes unit ZYn returns nothing
local real Zzn=GetUnitX(ZYn)
local real ZZn=GetUnitY(ZYn)
local real Z_n=GetUnitFacing(ZYn)
call SetUnitPosition(ZYn,Zzn,ZZn)
call SetUnitFacing(ZYn,Z_n)
set Z_n=Z_n*bj_DEGTORAD
set Zzn=Zzn+10.*Cos(Z_n)
set ZZn=ZZn+10.*Sin(Z_n)
set Z_n=.0
set bj_lastCreatedDestructable=CreateDestructable('Dumm',Zzn,ZZn,.0,1.,0)
set Zzn=.0
set ZZn=.0
call UnitAddAbility(ZYn,'AAI1')
call IssueTargetOrderById(ZYn,$D021F,bj_lastCreatedDestructable)
call UnitRemoveAbility(ZYn,'AAI1')
call UnitRemoveAbility(ZYn,'AaI0')
call UnitAddAbility(ZYn,'AaI1')
set ZYn=null
call RemoveDestructable(bj_lastCreatedDestructable)
set bj_lastCreatedDestructable=null
endfunction
function Z0n takes nothing returns nothing
local unit Z1n=GetSpellAbilityUnit()
if GetSpellAbilityId()=='Asw1' then
call UnitRemoveAbility(Z1n,'Asw1')
call UnitAddAbility(Z1n,'Asw2')
call UnitMakeAbilityPermanent(Z1n,true,'Asw2')
call AddUnitAnimationProperties(Z1n,"alternate",true)
call ZTn(Z1n)
call ZSn(Z1n)
else
call UnitRemoveAbility(Z1n,'Asw2')
call UnitAddAbility(Z1n,'Asw1')
call UnitMakeAbilityPermanent(Z1n,true,'Asw1')
call AddUnitAnimationProperties(Z1n,"alternate",false)
call MGa(Z1n)
call Zyn(Z1n)
endif
set Z1n=null
set Z1n=null
endfunction
function Z2n takes nothing returns boolean
set Fa=704643072.
set ka=-704643072.
return true
endfunction
function Z3n takes nothing returns boolean
return GetSpellAbilityId()=='A009'
endfunction
function Z4n takes nothing returns boolean
return IsUnitSelected(GetFilterUnit(),GetTriggerPlayer())
endfunction
function Z5n takes nothing returns boolean
return(GetEventPlayerChatString()=="~mechanical")
endfunction
function Z6n takes nothing returns boolean
return(GetEventPlayerChatString()=="@mechanical")
endfunction
function Z7n takes nothing returns nothing
set g[GetConvertedPlayerId(GetTriggerPlayer())]=GetUnitsOfPlayerMatching(GetTriggerPlayer(),Condition(rov))
if Z5n()then
call ForGroupBJ(g[GetConvertedPlayerId(GetTriggerPlayer())],rrv)
elseif Z6n()then
call ForGroupBJ(g[GetConvertedPlayerId(GetTriggerPlayer())],riv)
endif
call DestroyGroup(g[GetPlayerId(GetTriggerPlayer())+1])
endfunction
function Z8n takes nothing returns nothing
local integer Z9n=0
loop
exitwhen Z9n>Cs
call UnitRemoveAbility(GetEnumUnit(),Vs[Z9n])
set Z9n=Z9n+1
endloop
set Z9n=0
endfunction
function vvV takes nothing returns nothing
call clv(GetEnumUnit(),'Abun',1)
endfunction
function veV takes nothing returns boolean
set ga=2
set ha=45.
return true
endfunction
function vxV takes string voV returns boolean
set ZM[EM]=voV
set EM=EM+1
set KR='x001'
call LHa(KR,"when calling protectUnitType in SyncSimple_config, line 41")
set EM=EM-1
return true
endfunction
function vrV takes nothing returns boolean
set EM=0
return vxV("SyncSimple_config, line 1")
endfunction
function viV takes integer vaV,integer vnV,string vVV returns nothing
local integer vEV
local integer vXV
set ZM[EM]=vVV
set EM=EM+1
set vEV=0
set vXV=OU[vaV]-1
loop
exitwhen vEV>vXV
if vnV==c8v(ne,vaV,vEV)then
call gCo(vaV,vEV,"when calling removeAt in HashList, line 63")
exitwhen true
endif
set vEV=vEV+1
endloop
set EM=EM-1
endfunction
function vOV takes integer vRV,integer vIV,string vAV returns nothing
set ZM[EM]=vAV
set EM=EM+1
if Oh[vRV]==0 then
if vRV==0 then
call Cdv("Nullpointer exception when calling HashList.remove","when calling error in HashList, line 60")
else
call Cdv("Called HashList.remove on invalid object.","when calling error in HashList, line 60")
endif
endif
if Oh[vRV]<=$966 then
call viV(vRV,vIV,"when calling remove in HashList, line 60")
else
call vxn(vRV,vIV,"when calling remove in HashList, line 60")
endif
set EM=EM-1
endfunction
function vNV takes integer vbV,integer vBV returns nothing
call RemoveSavedInteger(XR,vbV,vBV)
endfunction
function vcV takes integer vCV,integer vdV,string vDV returns nothing
set ZM[EM]=vDV
set EM=EM+1
if ph[vCV]==0 then
if vCV==0 then
call Cdv("Nullpointer exception when calling Table.removeInt","when calling error in Table, line 24")
else
call Cdv("Called Table.removeInt on invalid object.","when calling error in Table, line 24")
endif
endif
call vNV(vCV,vdV)
set EM=EM-1
endfunction
function vfV takes integer vFV,integer vgV,string vGV returns nothing
set ZM[EM]=vGV
set EM=EM+1
if fov(vFV,vgV,"when calling has in HashMap, line 28")then
set lU[vFV]=lU[vFV]-1
endif
call vcV(vFV,vgV,"when calling removeInt in HashMap, line 30")
set EM=EM-1
endfunction
function vhV takes integer vHV,integer vjV,string vJV returns nothing
set ZM[EM]=vJV
set EM=EM+1
call vfV(vHV,vjV,"when calling remove in HashMap, line 66")
if fjv(vHV,vjV,"when calling hasKey in HashMap, line 67")then
call vOV(bU[vHV],vjV,"when calling remove in HashMap, line 68")
endif
set EM=EM-1
endfunction
function vkV takes integer vKV,integer vlV,string vLV returns nothing
set ZM[EM]=vLV
set EM=EM+1
if ph[vKV]==0 then
if vKV==0 then
call Cdv("Nullpointer exception when calling IterableMap.remove","when calling error in HashMap, line 65")
else
call Cdv("Called IterableMap.remove on invalid object.","when calling error in HashMap, line 65")
endif
endif
call vhV(vKV,vlV,"when calling remove in HashMap, line 65")
set EM=EM-1
endfunction
function vmV takes integer vMV,unit vpV,string vPV returns nothing
local group vqV
set ZM[EM]=vPV
set EM=EM+1
set vqV=jho(f3v(aL[vMV],Hzo(vpV),"when calling get in ScmdUnitParamLinkingBuiltins, line 48"),"when calling groupFromIndex in ScmdUnitParamLinkingBuiltins, line 48")
if vqV!=null then
call HQo(vqV,vpV)
if d5e(vqV)==0 then
call kcv(vqV)
endif
call vkV(aL[vMV],Hzo(vpV),"when calling remove in ScmdUnitParamLinkingBuiltins, line 53")
endif
set EM=EM-1
set vqV=null
endfunction
function vQV takes integer vsV,unit vSV,string vtV returns nothing
set ZM[EM]=vtV
set EM=EM+1
if Bx[vsV]==0 then
if vsV==0 then
call Cdv("Nullpointer exception when calling DisjointGroups.delete","when calling error in ScmdUnitParamLinkingBuiltins, line 47")
else
call Cdv("Called DisjointGroups.delete on invalid object.","when calling error in ScmdUnitParamLinkingBuiltins, line 47")
endif
endif
call vmV(vsV,vSV,"when calling delete in ScmdUnitParamLinkingBuiltins, line 47")
set EM=EM-1
endfunction
function vTV takes nothing returns unit
return kq[jq-1]
endfunction
function vuV takes string vUV returns nothing
local integer vwV
local integer vWV
set ZM[EM]=vUV
set EM=EM+1
set vwV=jjv(Wd,"when calling iterator in ScmdUnitParamLinkingBuiltins, line 66")
loop
exitwhen not Jgv(vwV,"when calling hasNext in ScmdUnitParamLinkingBuiltins, line 66")
set vWV=jTv(vwV,"when calling next in ScmdUnitParamLinkingBuiltins, line 66")
call vQV(f3v(Wd,vWV,"when calling get in ScmdUnitParamLinkingBuiltins, line 67"),vTV(),"when calling delete in ScmdUnitParamLinkingBuiltins, line 67")
endloop
call Jqv(vwV,"when calling close in ScmdUnitParamLinkingBuiltins, line 66")
set EM=EM-1
endfunction
function vyV takes nothing returns nothing
set EM=0
call vuV("ScmdUnitParamLinkingBuiltins, line 65")
endfunction
function vYV takes nothing returns nothing
call DestroyEffect(AddSpecialEffect("Objects\\Spawnmodels\\Undead\\ImpaleTargetDust\\ImpaleTargetDust.mdl",GetUnitX(GetDyingUnit())+17.5,GetUnitY(GetDyingUnit())-17.5))
endfunction
function vzV takes nothing returns nothing
local unit vZV=GetEnumUnit()
local unit v_V=CreateUnitAtLoc(Player($F),'h0JO',GetUnitLoc(vZV),270.)
call UnitAddAbility(v_V,'A08X')
call SetUnitAbilityLevel(v_V,'A08X',GetUnitAbilityLevel(GetSpellAbilityUnit(),'A08W'))
call IssueTargetOrderById(v_V,$D00CB,vZV)
call oLn(v_V,3.)
set vZV=null
set v_V=null
set vZV=null
set v_V=null
endfunction
function v0V takes nothing returns boolean
return GetSpellAbilityId()=='AOds'
endfunction
function v1V takes nothing returns boolean
return(GetEventPlayerChatString()=="nightstalk on")
endfunction
function v2V takes nothing returns boolean
return(GetEventPlayerChatString()=="fog off")
endfunction
function v3V takes nothing returns boolean
return(GetEventPlayerChatString()=="fog on")
endfunction
function v4V takes nothing returns boolean
return(GetEventPlayerChatString()=="blackmask on")
endfunction
function v5V takes nothing returns boolean
return(GetEventPlayerChatString()=="nightstalk off")
endfunction
function v6V takes nothing returns boolean
return(GetEventPlayerChatString()=="dreammode off")
endfunction
function v7V takes nothing returns boolean
return(GetEventPlayerChatString()=="blackmask off")
endfunction
function v8V takes nothing returns boolean
return(GetEventPlayerChatString()=="dreammode on")
endfunction
function v9V takes nothing returns boolean
return(GetEventPlayerChatString()=="whitemask on")
endfunction
function evV takes nothing returns boolean
return(GetEventPlayerChatString()=="whitemask off")
endfunction
function eeV takes nothing returns boolean
return(GetEventPlayerChatString()=="whitemask on")
endfunction
function exV takes nothing returns boolean
return(GetEventPlayerChatString()=="hazeandfog off")
endfunction
function eoV takes nothing returns boolean
return(GetEventPlayerChatString()=="hazeandfog on")
endfunction
function erV takes nothing returns nothing
if v8V()then
call CinematicFadeBJ(bj_CINEFADETYPE_FADEOUT,2.,"ReplaceableTextures\\CameraMasks\\DreamFilter_Mask.blp",100.,.0,.0,1.)
elseif v6V()then
call CinematicFadeBJ(bj_CINEFADETYPE_FADEIN,2.,"ReplaceableTextures\\CameraMasks\\DreamFilter_Mask.blp",100.,.0,.0,1.)
elseif v4V()then
call CinematicFadeBJ(bj_CINEFADETYPE_FADEOUT,2.,"ReplaceableTextures\\CameraMasks\\Black_mask.blp",100.,100.,100.,60.)
elseif v7V()then
call CinematicFadeBJ(bj_CINEFADETYPE_FADEIN,2.,"ReplaceableTextures\\CameraMasks\\Black_mask.blp",100.,100.,100.,60.)
elseif eeV()then
call CinematicFadeBJ(bj_CINEFADETYPE_FADEOUT,2.,"ReplaceableTextures\\CameraMasks\\White_mask.blp",100.,100.,100.,65.)
elseif evV()then
call CinematicFadeBJ(bj_CINEFADETYPE_FADEIN,2.,"ReplaceableTextures\\CameraMasks\\White_mask.blp",100.,100.,100.,65.)
elseif v9V()then
call CinematicFadeBJ(bj_CINEFADETYPE_FADEOUT,2.,"ReplaceableTextures\\CameraMasks\\White_mask.blp",100.,100.,100.,65.)
elseif exV()then
call CinematicFadeBJ(bj_CINEFADETYPE_FADEIN,2.,"ReplaceableTextures\\CameraMasks\\HazeAndFogFilter_Mask.blp",100.,100.,100.,65.)
elseif eoV()then
call CinematicFadeBJ(bj_CINEFADETYPE_FADEOUT,2.,"ReplaceableTextures\\CameraMasks\\HazeAndFogFilter_Mask.blp",100.,100.,100.,65.)
elseif v2V()then
call CinematicFadeBJ(bj_CINEFADETYPE_FADEIN,2.,"ReplaceableTextures\\CameraMasks\\GroundFog_mask.blp",100.,100.,100.,65.)
elseif v3V()then
call CinematicFadeBJ(bj_CINEFADETYPE_FADEOUT,2.,"ReplaceableTextures\\CameraMasks\\GroundFog_mask.blp",100.,100.,100.,65.)
elseif v1V()then
call CinematicFadeBJ(bj_CINEFADETYPE_FADEOUT,2.,"ReplaceableTextures\\CameraMasks\\DreamFilter_Mask.blp",50.,50.,100.,65.)
elseif v5V()then
call CinematicFadeBJ(bj_CINEFADETYPE_FADEIN,2.,"ReplaceableTextures\\CameraMasks\\DreamFilter_Mask.blp",50.,50.,100.,65.)
endif
endfunction
function eiV takes nothing returns boolean
return(GetBooleanAnd(GetBooleanAnd(IsUnitInGroup(GetEnumUnit(),dr)==false,IsUnitInGroup(GetEnumUnit(),Rr)==false),IsUnitInGroup(GetEnumUnit(),fr)==false))
endfunction
function eaV takes nothing returns boolean
return(GetUnitTypeId(GetEnumUnit())!='h000')and(IsUnitSelected(GetEnumUnit(),GetTriggerPlayer()))
endfunction
function enV takes nothing returns nothing
if eaV()then
call SetUnitAbilityLevelSwapped('A08V',GetEnumUnit(),GetUnitAbilityLevelSwapped('A08V',GetEnumUnit())+1)
call SetUnitAbilityLevelSwapped('A08T',GetEnumUnit(),GetUnitAbilityLevelSwapped('A08V',GetEnumUnit()))
call SetUnitAbilityLevelSwapped('A08U',GetEnumUnit(),GetUnitAbilityLevelSwapped('A08V',GetEnumUnit()))
call SetUnitAbilityLevelSwapped('A08S',GetEnumUnit(),GetUnitAbilityLevelSwapped('A08V',GetEnumUnit()))
if eiV()then
call GroupAddUnitSimple(GetEnumUnit(),dr)
call UnitAddAbilityBJ('A08V',GetEnumUnit())
call UnitMakeAbilityPermanent(GetEnumUnit(),true,'A08V')
call UnitAddAbilityBJ('A08T',GetEnumUnit())
call UnitMakeAbilityPermanent(GetEnumUnit(),true,'A08T')
endif
endif
endfunction
function eVV takes nothing returns boolean
return true
endfunction
function eEV takes nothing returns boolean
if GetSpellAbilityId()=='A0HB' or GetSpellAbilityId()=='A0HC' or GetSpellAbilityId()=='A0HH' and GetUnitTypeId(GetSpellTargetUnit())!='h000' and GetOwningPlayer(GetSpellTargetUnit())!=Player(bj_PLAYER_NEUTRAL_VICTIM)then
return true
else
return false
endif
endfunction
function eXV takes nothing returns nothing
local unit eOV=GetManipulatingUnit()
local item eRV=GetManipulatedItem()
local item eIV=null
local integer eAV=0
local integer eNV=0
loop
exitwhen eRV==UnitItemInSlot(eOV,eAV)or eAV==6
set eAV=eAV+1
endloop
if eAV==6 or GetItemCharges(eRV)==0 then
set eAV=0
set eRV=null
set eOV=null
set eOV=null
set eRV=null
set eIV=null
return
endif
loop
set eIV=UnitItemInSlot(eOV,eNV)
if eNV!=eAV and GetItemTypeId(eIV)==GetItemTypeId(eRV)and GetItemCharges(eIV)>0 and GetItemCharges(eIV)<999 and(GetItemUserData(eRV)==1 and GetItemUserData(eIV)==1)or(GetItemUserData(eRV)!=1 and GetItemUserData(eIV)!=1)then
call SetItemCharges(eIV,GetItemCharges(eIV)+GetItemCharges(eRV))
if GetItemCharges(eIV)<=999 then
call RemoveItem(eRV)
else
call SetItemCharges(eRV,GetItemCharges(eIV)-999)
call SetItemCharges(eIV,999)
endif
set eNV=0
set eAV=0
set eIV=null
set eRV=null
set eOV=null
set eOV=null
set eRV=null
set eIV=null
return
endif
set eNV=eNV+1
exitwhen eNV==6
endloop
set eNV=0
set eAV=0
set eIV=null
set eRV=null
set eOV=null
set eOV=null
set eRV=null
set eIV=null
endfunction
function ebV takes integer eBV,string ecV returns nothing
set Hd[Dd]=eBV
set Jd[Dd]=ecV
set Dd=Dd+1
endfunction
function eCV takes nothing returns boolean
set Dd=0
call ebV('Aexh',"exhumecorpses")
call ebV('Amls',"aerialshackles")
call ebV('Aroc',"barrage")
call ebV('Aclf',"cloud")
call ebV('Acmg',"controlmagic")
call ebV('Adef',"defend")
call ebV('Adis',"dispelmagic")
call ebV('Afbt',"feedback")
call ebV('Afbt',"feedback2")
call ebV('Afbk',"feedback3")
call ebV('Aflk',"flakcannons")
call ebV('Afla',"flare")
call ebV('Agyb',"flyingmachinebombs")
call ebV('Afsh',"fragmentationshards")
call ebV('Ahea',"heal")
call ebV('Ainf',"innerfire")
call ebV('Aivs',"invisibility")
call ebV('Amdf',"magicdefense")
call ebV('Adts',"magicsentry")
call ebV('Apxf',"phoenixfire")
call ebV('Aply',"polymorph")
call ebV('Ahrp',"repair")
call ebV('AHta',"reveal")
call ebV('Aslo',"slow")
call ebV('Asps',"spellsteal")
call ebV('Asth',"stormhammers")
call ebV('Ahsb',"sunderingblades")
call ebV('Agyv',"truesight2")
call ebV('Amnz',"aoedamageupondeath")
call ebV('Aast',"ancestralspirit")
call ebV('Absk',"berserk")
call ebV('Ablo',"bloodlust")
call ebV('Abof',"burningoil")
call ebV('Adev',"devour")
call ebV('Advc',"devour")
call ebV('Adcn',"disenchant")
call ebV('Adch',"disenchant2")
call ebV('Aens',"ensnare")
call ebV('Aven',"envenomedspears")
call ebV('Ahwd',"healingward")
call ebV('Ahwd',"healingward2")
call ebV('Aoar',"healingwardaura")
call ebV('Aoar',"healingwardaura2")
call ebV('Alsh',"lightningshield")
call ebV('Aliq',"liquidfire")
call ebV('Asal',"pillage")
call ebV('Awar',"pulverize")
call ebV('Apg2',"purge(stun)")
call ebV('Aprg',"purge")
call ebV('Arbr',"reinforcedburrowsupgrade")
call ebV('Arep',"repair2")
call ebV('Aeye',"sentryward")
call ebV('Aspi',"spikedbarricades")
call ebV('Aspl',"spiritlink")
call ebV('Auco',"unstableconcoction")
call ebV('Aakb',"wardrums")
call ebV('Aabs',"absorbmana")
call ebV('Aams',"antimagicshell")
call ebV('Aam2',"antimagicshell2")
call ebV('ACvp',"vampiricaura")
call ebV('Acn2',"cannibalize")
call ebV('Acan',"cannibalize2")
call ebV('Acri',"cripple")
call ebV('Scri',"cripple2")
call ebV('Acrs',"curse")
call ebV('Advm',"devourmagic")
call ebV('Aap1',"diseasecloud3")
call ebV('Apts',"diseasecloud2")
call ebV('Aap2',"diseasecloud")
call ebV('Arpl',"essenceofblight")
call ebV('Afrz',"freezingbreath")
call ebV('Afr2',"frostattack2")
call ebV('Afra',"frostattack")
call ebV('Afak',"orbofannihilation")
call ebV('Apos',"possession")
call ebV('Aps2',"possession2")
call ebV('Arai',"raisedead")
call ebV('Arpb',"replenish")
call ebV('Amb2',"replenishmana")
call ebV('Aspa',"spiderattack")
call ebV('Arpm',"spirittouch")
call ebV('Atru',"truesight")
call ebV('Auhf',"unholyfrenzy")
call ebV('Aweb',"web")
call ebV('Aadm',"abolishmagic")
call ebV('Acor',"corrosivebreath")
call ebV('Acyc',"cyclone")
call ebV('Adtn',"detonate")
call ebV('Aeat',"eattree")
call ebV('Aegr',"elune'sgrace")
call ebV('Aetl',"ethereal")
call ebV('Afae',"faeriefire")
call ebV('afa2',"faeriefire2")
call ebV('Assk',"hardenedskin")
call ebV('Alit',"lightningattack")
call ebV('Amfl',"manaflare")
call ebV('Amgl',"moonglaive")
call ebV('Amgr',"moonglaive2")
call ebV('Apsh',"phaseshift")
call ebV('Arej',"rejuvenation")
call ebV('Aren',"renew")
call ebV('Ambt',"replenishmanaandlife")
call ebV('Arsk',"resistantskin3")
call ebV('Aroa',"roar")
call ebV('Ara2',"roar2")
call ebV('Aesn',"sentinel")
call ebV('Aesr',"sentinel2")
call ebV('Ashm',"shadowmeld")
call ebV('Sshm',"shadowmeld(instant)")
call ebV('Aspo',"slowpoison")
call ebV('Amim',"spellimmunity4")
call ebV('Avng',"spiritofvengeance")
call ebV('Atau',"taunt")
call ebV('Aimp',"vorpalblades")
call ebV('Agra',"warclub")
call ebV('ACbn',"banish")
call ebV('ACmo',"monsoon")
call ebV('ACwe',"summonseaelemental")
call ebV('ACdm',"abolishmagic2")
call ebV('ACad',"animatedead")
call ebV('ACam',"antimagicshell3")
call ebV('ACbh',"bash")
call ebV('ANbh',"bash2")
call ebV('ACbk',"blackarrow")
call ebV('ACbz',"blizzard")
call ebV('ACbl',"bloodlust2")
call ebV('ACbb',"bloodlust3")
call ebV('ACbc',"breathoffire")
call ebV('ACbf',"breathoffrost")
call ebV('ACba',"brillianceaura")
call ebV('ACcn',"cannibalize3")
call ebV('ACca',"carrionswarm")
call ebV('ACcl',"chainlightning")
call ebV('ACch',"charm")
call ebV('ACce',"cleavingattack")
call ebV('ACcw',"coldarrows")
call ebV('ACac',"commandaura")
call ebV('ACcr',"cripple3")
call ebV('ACct',"criticalstrike")
call ebV('ACcv',"crushingwave")
call ebV('ACc3',"crushingwave2")
call ebV('ACc2',"crushingwave3")
call ebV('ACcs',"curse2")
call ebV('SCc1',"cyclone2")
call ebV('ACcy',"cyclone3")
call ebV('ACdc',"deathcoil")
call ebV('ACav',"devotionaura")
call ebV('ACdv',"devour2")
call ebV('ACde',"devourmagic2")
call ebV('Aap4',"diseasecloud4")
call ebV('Aap3',"diseasecloud5")
call ebV('Adsm',"dispelmagic2")
call ebV('ACds',"divineshield")
call ebV('SCae',"enduranceaura")
call ebV('ACen',"ensnare2")
call ebV('Aenr',"entanglingroots")
call ebV('Aenw',"entanglingroots2")
call ebV('ACvs',"envenomedweapons")
call ebV('ACev',"evasion")
call ebV('ANfy',"factory")
call ebV('ACff',"faeriefire3")
call ebV('Afbb',"feedback4")
call ebV('ACsf',"feralspirit")
call ebV('ACs9',"feralspirit2")
call ebV('Afod',"fingerofdeath")
call ebV('ACf3',"fingerofpain")
call ebV('ACfd',"fingerofpain2")
call ebV('ACfb',"firebolt")
call ebV('Awfb',"firebolt2")
call ebV('ANfs',"flamestrike")
call ebV('ACfs',"flamestrike2")
call ebV('ACfr',"forceofnature")
call ebV('ACfl',"forkedlightning")
call ebV('Afzy',"frenzy")
call ebV('ACf2',"frostarmor")
call ebV('ACfa',"frostarmor2")
call ebV('ACcb',"frostbolt")
call ebV('ACfn',"frostnova")
call ebV('Anhe',"heal1")
call ebV('Anh1',"heal2")
call ebV('Anh2',"heal3")
call ebV('AChw',"healingward3")
call ebV('AChv',"healingwave")
call ebV('AChx',"hex")
call ebV('Acht',"howlofterror")
call ebV('ACtb',"hurlboulder")
call ebV('ACim',"immolation")
call ebV('ACmp',"impale")
call ebV('ACif',"innerfire2")
call ebV('Asdg',"kaboom!1")
call ebV('Asd2',"kaboom!2")
call ebV('Asd3',"kaboom!3")
call ebV('Asds',"kaboom!")
call ebV('ACdr',"lifedrain")
call ebV('ACnr',"liferegenerationaura")
call ebV('SCva',"lifesteal")
call ebV('ACls',"lightningshield2")
call ebV('Ambd',"manaburn")
call ebV('Amnb',"manaburn2")
call ebV('Ambb',"manaburn3")
call ebV('ANre',"manaregenerationaura")
call ebV('ACmf',"manashield")
call ebV('ANb2',"maul")
call ebV('ANmr',"mindrot")
call ebV('ACpa',"parasite")
call ebV('ACpy',"polymorph2")
call ebV('ACps',"possession3")
call ebV('ACpv',"pulverize2")
call ebV('ACpu',"purge3")
call ebV('ANak',"quillspray")
call ebV('ACrg',"rainoffire")
call ebV('ACrf',"rainoffire2")
call ebV('ACrd',"raisedead2")
call ebV('Ache',"rayofdisruption")
call ebV('ACrn',"reincarnation")
call ebV('ACr2',"rejuvenation2")
call ebV('ACrj',"rejuvenation3")
call ebV('ACrk',"resistantskin")
call ebV('ACsk',"resistantskin2")
call ebV('Andt',"reveal2")
call ebV('ACro',"roar3")
call ebV('ACr1',"roar4")
call ebV('ACsa',"searingarrows")
call ebV('Ahid',"shadowmeld(akama)")
call ebV('ACss',"shadowstrike")
call ebV('ACs4',"shockwave")
call ebV('ACs3',"shockwave2")
call ebV('ACsi',"silence")
call ebV('ACsm',"siphonmana")
call ebV('ACtc',"slam")
call ebV('ACt2',"slam2")
call ebV('ACsp',"sleep")
call ebV('ACsl',"sleep2")
call ebV('ACsw',"slow2")
call ebV('Aspy',"spawnhydra")
call ebV('Aspt',"spawnhydrahatchling")
call ebV('Asod',"spawnskeleton")
call ebV('Assp',"spawnspiderlings")
call ebV('Aspd',"spawnspiders")
call ebV('ACtn',"spawntentacle")
call ebV('ACm2',"spellimmunity")
call ebV('ACm3',"spellimmunity2")
call ebV('ACmi',"spellimmunity3")
call ebV('ANth',"spikedshell")
call ebV('ANt2',"spikedshell2")
call ebV('Ansp',"spy")
call ebV('ANta',"taunt2")
call ebV('ACah',"thornsaura")
call ebV('ACat',"trueshotaura")
call ebV('ACua',"unholyaura")
call ebV('ACuf',"unholyfrenzy2")
call ebV('Suhf',"unholyfrenzy3")
call ebV('Awrs',"warstomp")
call ebV('Awrh',"warstomp2")
call ebV('Awrg',"warstomp3")
call ebV('ACwb',"web2")
call ebV('Andm',"abolishmagic3")
call ebV('ACd2',"abolishmagic4")
call ebV('Acny',"cyclone4")
call ebV('ANen',"ensnare3")
call ebV('ACfu',"frostarmor3")
call ebV('Ansk',"hardenedskin2")
call ebV('ANpa',"parasite2")
call ebV('Aasl',"slowaura")
call ebV('Ahnl',"summoningritual")
call ebV('Amnz',"aoedamageupondeath2")
call ebV('Amnx',"aoedamageupondeath3")
call ebV('Adda',"aoedamageupondeath4")
call ebV('ANpi',"permanentimmolation")
call ebV('Apig',"permanentimmolation2")
call ebV('Apiv',"permanentinvisibility")
call ebV('Apmf',"phoenixfire2")
call ebV('Apoi',"poisonsting")
call ebV('Adtg',"truesight3")
call ebV('ANtr',"truesight4")
call ebV('Awan',"wander")
call ebV('A03F',"blink")
call ebV('ANbl',"blink2")
call ebV('Avul',"invulnerable")
call ebV('Ared',"redemption")
call ebV('A08G',"manaregeneration")
call ebV('A00G',"superblink")
call ebV('A03L',"magicshackles")
call ebV('A03M',"raisezombie")
call ebV('A03R',"pacifism")
call ebV('A03S',"eggs")
call ebV('A03K',"deadlythrow")
call ebV('Ahar',"harvester")
call ebV('A04Z',"darkend")
call ebV('A04Y',"divinehand")
call ebV('A051',"mindblast")
call ebV('A050',"soulstorm")
call ebV('A053',"iceball")
call ebV('A056',"magicmissile")
call ebV('A057',"naturenova")
call ebV('A058',"powerorb")
call ebV('A059',"darkstar")
call ebV('A05A',"shockwavebarrage")
call ebV('A05B',"immortality")
call ebV('A05C',"regeneration")
call ebV('A0AT',"infinitemana")
call ebV('A05D',"shadowbarrage")
call ebV('A05E',"starshards")
call ebV('A05G',"holyrequiem")
call ebV('A05L',"arcaneray")
call ebV('A05H',"darklightning")
call ebV('A05J',"slamwave")
call ebV('Argl',"returnrecourses")
call ebV('A05R',"holywave")
call ebV('A05Q',"deathwave")
call ebV('A05I',"arcanewave")
call ebV('A05T',"arcanedestruction")
call ebV('A05U',"arcanewrath")
call ebV('A05V',"energyblast")
call ebV('A05Y',"greatearthquake")
call ebV('A05I',"flamingdoom")
call ebV('A05V',"energyblast")
call ebV('A05M',"thunderspear")
call ebV('A05X',"burn")
call ebV('A05Z',"rampage")
call ebV('A063',"spikedaura")
call ebV('A06B',"grogblade")
call ebV('A080',"darkteleport")
call ebV('A09G',"fortitude")
call ebV('A09I',"teleport")
call ebV('Aabr',"auraofblight")
call ebV('Asta',"stasistrap")
call ebV('A04S',"raisedead3")
call ebV('A0D2',"barkskin")
call ebV('A0DO',"wrappingflame")
call ebV('A0CT',"explode")
call ebV('A0EK',"dimensionalshift")
call ebV('A0ER',"undergroundtunnels")
call ebV('A0M1',"darkblaze")
call ebV('A0KN',"spell")
call ebV('A0KO',"channel")
call ebV('A0GA',"insuperableobstacle")
call ebV('A0FW',"insuperableobstacle2")
call ebV('A0GB',"insuperableobstacle3")
call ebV('A0HG',"sinsuperableobstacle")
call ebV('A0HF',"sinsuperableobstacle2")
call ebV('A0HE',"sinsuperableobstacle3")
call ebV('A0HB',"assassinate")
call ebV('A0HC',"assassinate2")
call ebV('A0HH',"assassinate3")
call ebV('A0HI',"stealth")
call ebV('A0IE',"magicdefense2")
call ebV('A0IM',"cancelautomatictargetfinding")
call ebV('A06U',"corruption")
call ebV('A0A7',"concentration")
call ebV('Aloc',"locust")
call ebV('Aatk',"attack")
call ebV('Amov',"move")
call ebV('Aalr',"alarm")
call ebV('Afir',"onfire")
call ebV('Afih',"humanonfire")
call ebV('Afin',"nightelfonfire")
call ebV('Afio',"orconfire")
call ebV('Afiu',"undeadonfire")
call ebV('Aher',"hero")
call ebV('Asla',"creepsleep")
call ebV('ARal',"rallypoint")
call ebV('Apit',"buyitems")
call ebV('Arev',"revive")
call ebV('Aawa',"awaken")
call ebV('AGbu',"build")
call ebV('AHbu',"humanbuild")
call ebV('AObu',"orcbuild")
call ebV('AEbu',"nightelfbuild")
call ebV('AUbu',"undeadbuild")
call ebV('ANbu',"neutralbuild")
call ebV('Awrp',"waygate")
call ebV('A009',"waygate")
call ebV('A0JG',"translocation")
call ebV('A0H0',"felburningoil")
call ebV('A0H1',"felliquidfire")
return true
endfunction
function edV takes string eDV returns nothing
local timer efV
local integer eFV
set ZM[EM]=eDV
set EM=EM+1
set efV=GetExpiredTimer()
set eFV=aqn(efV,"when calling getData in BuffsJurst, line 72")
call atn(efV,"when calling release in BuffsJurst, line 73")
call iin(XQ[KQ[eFV]],GetHandleId(LQ[eFV]),"when calling removeHandle in BuffsJurst, line 74")
if NQ[KQ[eFV]]!=0 then
call aln(NQ[KQ[eFV]],LQ[eFV],"when calling evaluate in BuffsJurst, line 76")
endif
if MQ[KQ[eFV]]!=0 then
call aln(MQ[KQ[eFV]],LQ[eFV],"when calling evaluate in BuffsJurst, line 79")
endif
call ifn(eFV,"when calling destroy in BuffsJurst, line 81")
set EM=EM-1
set efV=null
endfunction
function egV takes nothing returns nothing
set EM=0
call edV("BuffsJurst, line 136")
endfunction
function eGV takes nothing returns nothing
set Yu=false
set Gu=300.
set gu=1000.
set hu=600.
set Fu=10.
set ku=20
set ju=$E
set xu=20.
set vu=16.
set mu=60.
set Qu=600.
set Wu=600.
set Eu=400.
set Zu=10.
set Uu=50.
set Iu=200.
set Pu=600.
call InitHashtableBJ()
set Au=GetLastCreatedHashtableBJ()
endfunction
function ehV takes string eHV returns integer
local integer ejV
set ZM[EM]=eHV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set ejV=Yj
set Gj[ejV]=$A28
else
call Cdv("Out of memory: Could not create IBuiltin_registerProtectedBuiltin_SLangTriggerFunctions.","when calling error in SLangTriggerFunctions, line 108")
set ejV=0
endif
else
set Tj=Tj-1
set ejV=Rj[Tj]
set Gj[ejV]=$A28
endif
set EM=EM-1
return ejV
endfunction
function eJV takes nothing returns integer
return Td
endfunction
function ekV takes string eKV returns integer
local integer elV
set ZM[EM]=eKV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set elV=Yj
set Gj[elV]=$A26
else
call Cdv("Out of memory: Could not create IBuiltin_registerProtectedBuiltin_SLangTriggerFunctions.","when calling error in SLangTriggerFunctions, line 102")
set elV=0
endif
else
set Tj=Tj-1
set elV=Rj[Tj]
set Gj[elV]=$A26
endif
set EM=EM-1
return elV
endfunction
function eLV takes string emV returns integer
local integer eMV
set ZM[EM]=emV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set eMV=Yj
set Gj[eMV]=$A24
else
call Cdv("Out of memory: Could not create IBuiltin_registerProtectedBuiltin_SLangTriggerFunctions.","when calling error in SLangTriggerFunctions, line 96")
set eMV=0
endif
else
set Tj=Tj-1
set eMV=Rj[Tj]
set Gj[eMV]=$A24
endif
set EM=EM-1
return eMV
endfunction
function epV takes integer ePV,integer eqV,integer eQV,integer esV,string eSV returns nothing
set ZM[EM]=eSV
set EM=EM+1
set xJ[ePV]=0
call zGv(jJ[ePV],eqV,"when calling add in ScmdDataTypes, line 1394")
set xJ[ePV]=xJ[ePV]+1
call zGv(jJ[ePV],eQV,"when calling add in ScmdDataTypes, line 1394")
set xJ[ePV]=xJ[ePV]+1
call zGv(jJ[ePV],esV,"when calling add in ScmdDataTypes, line 1394")
set xJ[ePV]=xJ[ePV]+1
set EM=EM-1
endfunction
function etV takes integer eTV,integer euV,integer eUV,integer ewV,string eWV returns nothing
set ZM[EM]=eWV
set EM=EM+1
if ax[eTV]==0 then
if eTV==0 then
call Cdv("Nullpointer exception when calling BuiltinData.setArgumentsTypes","when calling error in ScmdDataTypes, line 1391")
else
call Cdv("Called BuiltinData.setArgumentsTypes on invalid object.","when calling error in ScmdDataTypes, line 1391")
endif
endif
call epV(eTV,euV,eUV,ewV,"when calling setArgumentsTypes in ScmdDataTypes, line 1391")
set EM=EM-1
endfunction
function eyV takes string eYV returns integer
local integer ezV
set ZM[EM]=eYV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set ezV=Yj
set Gj[ezV]=$A25
else
call Cdv("Out of memory: Could not create IBuiltin_registerProtectedBuiltin_SLangTriggerFunctions.","when calling error in SLangTriggerFunctions, line 99")
set ezV=0
endif
else
set Tj=Tj-1
set ezV=Rj[Tj]
set Gj[ezV]=$A25
endif
set EM=EM-1
return ezV
endfunction
function eZV takes string e_V returns integer
local integer e0V
set ZM[EM]=e_V
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set e0V=Yj
set Gj[e0V]=$A27
else
call Cdv("Out of memory: Could not create IBuiltin_registerProtectedBuiltin_SLangTriggerFunctions.","when calling error in SLangTriggerFunctions, line 105")
set e0V=0
endif
else
set Tj=Tj-1
set e0V=Rj[Tj]
set Gj[e0V]=$A27
endif
set EM=EM-1
return e0V
endfunction
function e1V takes string e2V returns integer
local integer e3V
set ZM[EM]=e2V
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set e3V=Yj
set Gj[e3V]=$A29
else
call Cdv("Out of memory: Could not create IBuiltin_registerProtectedBuiltin_SLangTriggerFunctions.","when calling error in SLangTriggerFunctions, line 111")
set e3V=0
endif
else
set Tj=Tj-1
set e3V=Rj[Tj]
set Gj[e3V]=$A29
endif
set EM=EM-1
return e3V
endfunction
function e4V takes nothing returns integer
return dd
endfunction
function e5V takes nothing returns integer
return rd
endfunction
function e6V takes string e7V returns integer
local integer e8V
set ZM[EM]=e7V
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set e8V=Yj
set Gj[e8V]=$ACD
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_SLangTriggerFunctions.","when calling error in SLangTriggerFunctions, line 48")
set e8V=0
endif
else
set Tj=Tj-1
set e8V=Rj[Tj]
set Gj[e8V]=$ACD
endif
set EM=EM-1
return e8V
endfunction
function e9V takes string xvV returns integer
local integer xeV
set ZM[EM]=xvV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set xeV=Yj
set Gj[xeV]=$ACB
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_SLangTriggerFunctions.","when calling error in SLangTriggerFunctions, line 33")
set xeV=0
endif
else
set Tj=Tj-1
set xeV=Rj[Tj]
set Gj[xeV]=$ACB
endif
set EM=EM-1
return xeV
endfunction
function xxV takes string xoV returns integer
local integer xrV
set ZM[EM]=xoV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set xrV=Yj
set Gj[xrV]=$AC8
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_SLangTriggerFunctions.","when calling error in SLangTriggerFunctions, line 15")
set xrV=0
endif
else
set Tj=Tj-1
set xrV=Rj[Tj]
set Gj[xrV]=$AC8
endif
set EM=EM-1
return xrV
endfunction
function xiV takes string xaV returns integer
local integer xnV
set ZM[EM]=xaV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set xnV=Yj
set Gj[xnV]=$ACC
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_SLangTriggerFunctions.","when calling error in SLangTriggerFunctions, line 44")
set xnV=0
endif
else
set Tj=Tj-1
set xnV=Rj[Tj]
set Gj[xnV]=$ACC
endif
set EM=EM-1
return xnV
endfunction
function xVV takes string xEV returns integer
local integer xXV
set ZM[EM]=xEV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set xXV=Yj
set Gj[xXV]=$ACE
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_SLangTriggerFunctions.","when calling error in SLangTriggerFunctions, line 75")
set xXV=0
endif
else
set Tj=Tj-1
set xXV=Rj[Tj]
set Gj[xXV]=$ACE
endif
set EM=EM-1
return xXV
endfunction
function xOV takes string xRV returns integer
local integer xIV
set ZM[EM]=xRV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set xIV=Yj
set Gj[xIV]=$A22
else
call Cdv("Out of memory: Could not create IBuiltin_registerProtectedBuiltin_SLangTriggerFunctions.","when calling error in SLangTriggerFunctions, line 90")
set xIV=0
endif
else
set Tj=Tj-1
set xIV=Rj[Tj]
set Gj[xIV]=$A22
endif
set EM=EM-1
return xIV
endfunction
function xAV takes string xNV returns integer
local integer xbV
set ZM[EM]=xNV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set xbV=Yj
set Gj[xbV]=$AC9
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_SLangTriggerFunctions.","when calling error in SLangTriggerFunctions, line 19")
set xbV=0
endif
else
set Tj=Tj-1
set xbV=Rj[Tj]
set Gj[xbV]=$AC9
endif
set EM=EM-1
return xbV
endfunction
function xBV takes string xcV returns integer
local integer xCV
set ZM[EM]=xcV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set xCV=Yj
set Gj[xCV]=$A23
else
call Cdv("Out of memory: Could not create IBuiltin_registerProtectedBuiltin_SLangTriggerFunctions.","when calling error in SLangTriggerFunctions, line 93")
set xCV=0
endif
else
set Tj=Tj-1
set xCV=Rj[Tj]
set Gj[xCV]=$A23
endif
set EM=EM-1
return xCV
endfunction
function xdV takes nothing returns integer
return xn
endfunction
function xDV takes string xfV returns integer
local integer xFV
set ZM[EM]=xfV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set xFV=Yj
set Gj[xFV]=$ACA
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_SLangTriggerFunctions.","when calling error in SLangTriggerFunctions, line 22")
set xFV=0
endif
else
set Tj=Tj-1
set xFV=Rj[Tj]
set Gj[xFV]=$ACA
endif
set EM=EM-1
return xFV
endfunction
function xgV takes string xGV returns integer
local integer xhV
set ZM[EM]=xGV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set xhV=Yj
set Gj[xhV]=$AC7
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_SLangTriggerFunctions.","when calling error in SLangTriggerFunctions, line 11")
set xhV=0
endif
else
set Tj=Tj-1
set xhV=Rj[Tj]
set Gj[xhV]=$AC7
endif
set EM=EM-1
return xhV
endfunction
function xHV takes string xjV returns integer
local integer xJV
set ZM[EM]=xjV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set xJV=Yj
set Gj[xJV]=$A2A
else
call Cdv("Out of memory: Could not create IBuiltin_registerProtectedBuiltin_SLangTriggerFunctions.","when calling error in SLangTriggerFunctions, line 114")
set xJV=0
endif
else
set Tj=Tj-1
set xJV=Rj[Tj]
set Gj[xJV]=$A2A
endif
set EM=EM-1
return xJV
endfunction
function xkV takes string xKV returns integer
local integer xlV
set ZM[EM]=xKV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set xlV=Yj
set Gj[xlV]=$A21
else
call Cdv("Out of memory: Could not create IBuiltin_registerProtectedBuiltin_SLangTriggerFunctions.","when calling error in SLangTriggerFunctions, line 8")
set xlV=0
endif
else
set Tj=Tj-1
set xlV=Rj[Tj]
set Gj[xlV]=$A21
endif
set EM=EM-1
return xlV
endfunction
function xLV takes nothing returns integer
return ld
endfunction
function xmV takes string xMV returns boolean
local integer xpV
local integer xPV
local integer xqV
local integer xQV
local integer xsV
local integer xSV
local integer xtV
local integer xTV
local integer xuV
local integer xUV
local integer xwV
local integer xWV
local integer xyV
local integer xYV
local integer xzV
local integer xZV
local integer x_V
local integer x0V
local integer x1V
local integer x2V
local integer x3V
local integer x4V
local integer x5V
local integer x6V
local integer x7V
local integer x8V
set ZM[EM]=xMV
set EM=EM+1
set xpV=xkV("when calling alloc_IBuiltin_registerProtectedBuiltin_SLangTriggerFunctions in SLangTriggerFunctions, line 8")
call Foa(ILo(OPo(xpV,"when calling new_BuiltinData in SLangTriggerFunctions, line 8"),"when calling new_BuiltinFunction in SLangTriggerFunctions, line 8"),"trigger","when calling registerProtectedBuiltin in SLangTriggerFunctions, line 8")
set xPV=xgV("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_SLangTriggerFunctions in SLangTriggerFunctions, line 11")
set xqV=OPo(xPV,"when calling new_BuiltinData in SLangTriggerFunctions, line 11")
call Rxo(xqV,xLV(),"when calling setArgumentsTypes in SLangTriggerFunctions, line 14")
call Foa(ILo(xqV,"when calling new_BuiltinFunction in SLangTriggerFunctions, line 11"),"enabletrigger","when calling registerProtectedBuiltin in SLangTriggerFunctions, line 11")
set xQV=xxV("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_SLangTriggerFunctions in SLangTriggerFunctions, line 15")
set xsV=OPo(xQV,"when calling new_BuiltinData in SLangTriggerFunctions, line 15")
call Rxo(xsV,xLV(),"when calling setArgumentsTypes in SLangTriggerFunctions, line 18")
call Foa(ILo(xsV,"when calling new_BuiltinFunction in SLangTriggerFunctions, line 15"),"disabletrigger","when calling registerProtectedBuiltin in SLangTriggerFunctions, line 15")
set xSV=xAV("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_SLangTriggerFunctions in SLangTriggerFunctions, line 19")
set xtV=OPo(xSV,"when calling new_BuiltinData in SLangTriggerFunctions, line 19")
call Rxo(xtV,xLV(),"when calling setArgumentsTypes in SLangTriggerFunctions, line 21")
call Foa(ILo(xtV,"when calling new_BuiltinFunction in SLangTriggerFunctions, line 19"),"istriggerenabled","when calling registerProtectedBuiltin in SLangTriggerFunctions, line 19")
set xTV=xDV("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_SLangTriggerFunctions in SLangTriggerFunctions, line 22")
set xuV=OPo(xTV,"when calling new_BuiltinData in SLangTriggerFunctions, line 22")
call FRa(xuV,xdV(),xdV(),"when calling setArgumentsTypes in SLangTriggerFunctions, line 32")
call Foa(G3a(xuV,"when calling new_BuiltinSpecialForm in SLangTriggerFunctions, line 22"),"triggeraddcondition","when calling registerProtectedBuiltin in SLangTriggerFunctions, line 22")
set xUV=e9V("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_SLangTriggerFunctions in SLangTriggerFunctions, line 33")
set xwV=OPo(xUV,"when calling new_BuiltinData in SLangTriggerFunctions, line 33")
call FRa(xwV,xdV(),xdV(),"when calling setArgumentsTypes in SLangTriggerFunctions, line 43")
call Foa(G3a(xwV,"when calling new_BuiltinSpecialForm in SLangTriggerFunctions, line 33"),"triggeraddaction","when calling registerProtectedBuiltin in SLangTriggerFunctions, line 33")
set xWV=xiV("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_SLangTriggerFunctions in SLangTriggerFunctions, line 44")
set xyV=OPo(xWV,"when calling new_BuiltinData in SLangTriggerFunctions, line 44")
call FRa(xyV,xLV(),eJV(),"when calling setArgumentsTypes in SLangTriggerFunctions, line 47")
call Foa(ILo(xyV,"when calling new_BuiltinFunction in SLangTriggerFunctions, line 44"),"triggerregisterdeathevent","when calling registerProtectedBuiltin in SLangTriggerFunctions, line 44")
set xYV=e6V("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_SLangTriggerFunctions in SLangTriggerFunctions, line 48")
set xzV=OPo(xYV,"when calling new_BuiltinData in SLangTriggerFunctions, line 48")
call etV(xzV,xLV(),e4V(),OFo(),"when calling setArgumentsTypes in SLangTriggerFunctions, line 74")
call Foa(ILo(xzV,"when calling new_BuiltinFunction in SLangTriggerFunctions, line 48"),"triggerregisterunitevent","when calling registerProtectedBuiltin in SLangTriggerFunctions, line 48")
set xZV=xVV("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_SLangTriggerFunctions in SLangTriggerFunctions, line 75")
set x_V=OPo(xZV,"when calling new_BuiltinData in SLangTriggerFunctions, line 75")
call FRa(x_V,xLV(),e5V(),"when calling setArgumentsTypes in SLangTriggerFunctions, line 89")
call Foa(ILo(x_V,"when calling new_BuiltinFunction in SLangTriggerFunctions, line 75"),"triggerregisterenterregion","when calling registerProtectedBuiltin in SLangTriggerFunctions, line 75")
set x0V=xOV("when calling alloc_IBuiltin_registerProtectedBuiltin_SLangTriggerFunctions in SLangTriggerFunctions, line 90")
call Foa(ILo(OPo(x0V,"when calling new_BuiltinData in SLangTriggerFunctions, line 90"),"when calling new_BuiltinFunction in SLangTriggerFunctions, line 90"),"gettriggerunit","when calling registerProtectedBuiltin in SLangTriggerFunctions, line 90")
set x1V=xBV("when calling alloc_IBuiltin_registerProtectedBuiltin_SLangTriggerFunctions in SLangTriggerFunctions, line 93")
call Foa(ILo(OPo(x1V,"when calling new_BuiltinData in SLangTriggerFunctions, line 93"),"when calling new_BuiltinFunction in SLangTriggerFunctions, line 93"),"getspellabilityid","when calling registerProtectedBuiltin in SLangTriggerFunctions, line 93")
set x2V=eLV("when calling alloc_IBuiltin_registerProtectedBuiltin_SLangTriggerFunctions in SLangTriggerFunctions, line 96")
call Foa(ILo(OPo(x2V,"when calling new_BuiltinData in SLangTriggerFunctions, line 96"),"when calling new_BuiltinFunction in SLangTriggerFunctions, line 96"),"getspellabilityunit","when calling registerProtectedBuiltin in SLangTriggerFunctions, line 96")
set x3V=eyV("when calling alloc_IBuiltin_registerProtectedBuiltin_SLangTriggerFunctions in SLangTriggerFunctions, line 99")
call Foa(ILo(OPo(x3V,"when calling new_BuiltinData in SLangTriggerFunctions, line 99"),"when calling new_BuiltinFunction in SLangTriggerFunctions, line 99"),"getspelltargetunit","when calling registerProtectedBuiltin in SLangTriggerFunctions, line 99")
set x4V=ekV("when calling alloc_IBuiltin_registerProtectedBuiltin_SLangTriggerFunctions in SLangTriggerFunctions, line 102")
call Foa(ILo(OPo(x4V,"when calling new_BuiltinData in SLangTriggerFunctions, line 102"),"when calling new_BuiltinFunction in SLangTriggerFunctions, line 102"),"getspelltargetx","when calling registerProtectedBuiltin in SLangTriggerFunctions, line 102")
set x5V=eZV("when calling alloc_IBuiltin_registerProtectedBuiltin_SLangTriggerFunctions in SLangTriggerFunctions, line 105")
call Foa(ILo(OPo(x5V,"when calling new_BuiltinData in SLangTriggerFunctions, line 105"),"when calling new_BuiltinFunction in SLangTriggerFunctions, line 105"),"getspelltargety","when calling registerProtectedBuiltin in SLangTriggerFunctions, line 105")
set x6V=ehV("when calling alloc_IBuiltin_registerProtectedBuiltin_SLangTriggerFunctions in SLangTriggerFunctions, line 108")
call Foa(ILo(OPo(x6V,"when calling new_BuiltinData in SLangTriggerFunctions, line 108"),"when calling new_BuiltinFunction in SLangTriggerFunctions, line 108"),"getspelltargetdestructable","when calling registerProtectedBuiltin in SLangTriggerFunctions, line 108")
set x7V=e1V("when calling alloc_IBuiltin_registerProtectedBuiltin_SLangTriggerFunctions in SLangTriggerFunctions, line 111")
call Foa(ILo(OPo(x7V,"when calling new_BuiltinData in SLangTriggerFunctions, line 111"),"when calling new_BuiltinFunction in SLangTriggerFunctions, line 111"),"getspelltargetitem","when calling registerProtectedBuiltin in SLangTriggerFunctions, line 111")
set x8V=xHV("when calling alloc_IBuiltin_registerProtectedBuiltin_SLangTriggerFunctions in SLangTriggerFunctions, line 114")
call Foa(ILo(OPo(x8V,"when calling new_BuiltinData in SLangTriggerFunctions, line 114"),"when calling new_BuiltinFunction in SLangTriggerFunctions, line 114"),"getmanipulateditem","when calling registerProtectedBuiltin in SLangTriggerFunctions, line 114")
set EM=EM-1
return true
endfunction
function x9V takes nothing returns boolean
set EM=0
return xmV("SLangTriggerFunctions, line 1")
endfunction
function ovV takes nothing returns boolean
call own(OTv)
return true
endfunction
function oeV takes nothing returns nothing
call TriggerRegisterUnitEvent(Yq,GetFilterUnit(),EVENT_UNIT_DAMAGED)
endfunction
function oxV takes nothing returns nothing
call SetUnitLifeBJ(GetSpellAbilityUnit(),GetUnitStateSwap(UNIT_STATE_LIFE,GetSpellAbilityUnit())+GetUnitStateSwap(UNIT_STATE_LIFE,GetSpellTargetUnit()))
call ExplodeUnitBJ(GetSpellTargetUnit())
endfunction
function ooV takes nothing returns nothing
local unit orV=GetSpellAbilityUnit()
local effect oiV=null
local integer oaV=0
local integer onV=GetUnitAbilityLevel(orV,'A0HQ')
if IsUnitInGroup(orV,ct) then
call GroupRemoveUnit(ct,orV)
call pAa(1.)
endif
call GroupAddUnit(ct,orV)
set oiV=AddSpecialEffectTarget("Abilities\\Spells\\Orc\\SpiritLink\\SpiritLinkTarget.mdl",orV,"chest")
call UnitAddAbility(orV,'A0HV')
call UnitMakeAbilityPermanent(orV,true,'A0HV')
call SetUnitAbilityLevel(orV,'A0HV',onV)
call UnitAddAbility(orV,'A0HU')
call UnitMakeAbilityPermanent(orV,true,'A0HU')
call SetUnitAbilityLevel(orV,'A0HU',onV)
set onV=0
loop
exitwhen IsUnitInGroup(orV,ct)==false
call pAa(1.)
set oaV=oaV+1
if oaV==2 then
call DestroyEffect(oiV)
set oiV=null
endif
if oaV==$C or GetUnitState(orV,UNIT_STATE_LIFE)<=.0 then
call GroupRemoveUnit(ct,orV)
endif
endloop
call UnitRemoveAbility(orV,'A0HV')
call UnitRemoveAbility(orV,'A0HU')
call UnitRemoveAbility(orV,'B03X')
set orV=null
set oaV=0
set orV=null
set oiV=null
endfunction
function oVV takes nothing returns boolean
return GetSpellAbilityId()=='A0G2'
endfunction
function oEV takes nothing returns nothing
local timer oXV=GetExpiredTimer()
local unit oOV=LoadUnitHandle(nr,GetHandleId(oXV),StringHash("u"))
local location oRV=LoadLocationHandle(nr,GetHandleId(oXV),StringHash("l"))
local unit oIV=CreateUnit(GetOwningPlayer(oOV),'h0JO',GetUnitX(oOV),GetUnitY(oOV),GetUnitFacing(oOV))
call FlushChildHashtable(nr,GetHandleId(oXV))
call DestroyTimer(oXV)
set oXV=null
call UnitAddAbility(oIV,'A0L3')
call IssuePointOrderByIdLoc(oIV,$D0208,oRV)
call oLn(oIV,2.5)
set oIV=null
set oRV=null
set oOV=null
set oXV=null
set oOV=null
set oRV=null
set oIV=null
endfunction
function oAV takes nothing returns boolean
return(fu)and(GetDestructableMaxLife(GetEnumDestructable())<=500.)
endfunction
function oNV takes nothing returns nothing
if oAV()then
call SetDestructableInvulnerableBJ(GetEnumDestructable(),true)
call KillDestructable(GetEnumDestructable())
call RemoveDestructable(GetEnumDestructable())
endif
endfunction
function obV takes nothing returns nothing
set Ns[wt]='A0J3'
set Ms[wt]="bronzehelmet"
set wt=wt+1
set Ns[wt]='A0J6'
set Ms[wt]="bronzechestplate"
set wt=wt+1
set Ns[wt]='A0J7'
set Ms[wt]="bronzebootrf"
set wt=wt+1
set Ns[wt]='A0J8'
set Ms[wt]="bronzebootlf"
set wt=wt+1
set Ns[wt]='A0JA'
set Ms[wt]="bronzebracerrh"
set wt=wt+1
set Ns[wt]='A0J9'
set Ms[wt]="bronzebracerlh"
set wt=wt+1
set Ns[wt]='A0JB'
set Ms[wt]="bronzebucklerrh"
set wt=wt+1
set Ns[wt]='A0JC'
set Ms[wt]="bronzebucklerlh"
set wt=wt+1
set Ns[wt]='A0JD'
set Ms[wt]="voodoomask"
set wt=wt+1
set Ns[wt]='A0JF'
set Ms[wt]="longswordrh"
set wt=wt+1
set Ns[wt]='A0JE'
set Ms[wt]="longswordlh"
set wt=wt+1
set Ns[wt]='A0JZ'
set Ms[wt]="lightassaultriflerh"
set wt=wt+1
set Ns[wt]='A0JY'
set Ms[wt]="lightassaultriflelh"
set wt=wt+1
set Ns[wt]='A0KC'
set Ms[wt]="lightsaberrh"
set wt=wt+1
set Ns[wt]='A0KB'
set Ms[wt]="lightsaberlh"
set wt=wt+1
set Ns[wt]='A0LA'
set Ms[wt]="aetherbladerh"
set wt=wt+1
set Ns[wt]='A0L9'
set Ms[wt]="aetherbladelh"
set wt=wt+1
set Ns[wt]='A0LC'
set Ms[wt]="eaglebladerh"
set wt=wt+1
set Ns[wt]='A0LB'
set Ms[wt]="eaglebladelh"
set wt=wt+1
set Ns[wt]='A0LD'
set Ms[wt]="eagleblade2rh"
set wt=wt+1
set Ns[wt]='A0LE'
set Ms[wt]="eagleblade2lh"
set wt=wt+1
set Ns[wt]='A0LF'
set Ms[wt]="scepterofthetidesrh"
set wt=wt+1
set Ns[wt]='A0LG'
set Ms[wt]="scepterofthetideslh"
set wt=wt+1
set Ns[wt]='A0LI'
set Ms[wt]="bronzemaulrh"
set wt=wt+1
set Ns[wt]='A0LH'
set Ms[wt]="bronzemaullh"
set wt=wt+1
set Ns[wt]='A0LJ'
set Ms[wt]="admiral'shat"
set wt=wt+1
call DestroyTrigger(GetTriggeringTrigger())
endfunction
function oBV takes nothing returns boolean
set Ke=3.141592654
set Le=6.28318
set Xe=1.570796326
return true
endfunction
function ocV takes nothing returns boolean
return(ls[0])
endfunction
function oCV takes nothing returns nothing
local unit odV=GetSpellTargetUnit()
local unit oDV=GetSpellAbilityUnit()
local integer ofV=0
call GroupRemoveUnit(ps,odV)
call GroupRemoveUnit(es,oDV)
call DestroyEffect(AddSpecialEffectTarget("Abilities\\Spells\\Other\\TalkToMe\\TalkToMe.mdl",odV,"overhead"))
call pAa(.5)
call GroupAddUnit(ps,odV)
call GroupAddUnit(es,oDV)
call SetUnitPathing(oDV,false)
call UnitAddAbility(oDV,'A0IM')
call UnitMakeAbilityPermanent(oDV,true,'A0IM')
call UnitAddAbility(odV,'A0IO')
call UnitMakeAbilityPermanent(odV,true,'A0IO')
loop
exitwhen IsUnitInGroup(odV,ps)==false
call DestroyEffect(AddSpecialEffectLoc("Abilities\\Spells\\NightElf\\Blink\\BlinkCaster.mdl",GetUnitLoc(oDV)))
call SetUnitPosition(oDV,GetUnitX(odV)-130.+GetRandomInt(30,$E6),GetUnitY(odV)-130.+GetRandomInt(30,$E6))
call SetUnitFacing(oDV,mma(GetUnitLoc(oDV),GetUnitLoc(odV)))
call DestroyEffect(AddSpecialEffectLoc("Abilities\\Spells\\NightElf\\Blink\\BlinkTarget.mdl",GetUnitLoc(oDV)))
call DestroyEffect(AddSpecialEffectTarget("Objects\\Spawnmodels\\Critters\\Albatross\\CritterBloodAlbatross.mdl",odV,"chest"))
call SetUnitAnimation(oDV,"attack")
call UnitDamageTarget(oDV,odV,100.,true,true,ATTACK_TYPE_NORMAL,DAMAGE_TYPE_MAGIC,WEAPON_TYPE_WHOKNOWS)
call pAa(.5)
set ofV=ofV+1
if ofV==$A or BlzIsUnitInvulnerable(odV) or GetUnitState(oDV,UNIT_STATE_LIFE)<=.0 or GetUnitState(odV,UNIT_STATE_LIFE)<=.0 or IsUnitLoaded(odV) or IsUnitLoaded(oDV) or GetUnitAbilityLevel(oDV,'BEer')>0 or GetUnitAbilityLevel(oDV,'Bweb')>0 or GetUnitAbilityLevel(oDV,'Bwea')>0 or GetUnitAbilityLevel(oDV,'Bens')>0 or GetUnitAbilityLevel(oDV,'Beng')>0 or GetUnitAbilityLevel(oDV,'Bena')>0 or GetUnitAbilityLevel(odV,'Bdvv')>0 or GetUnitAbilityLevel(oDV,'Bdvv')>0 or GetUnitAbilityLevel(oDV,'Bmlt')>0 or GetUnitAbilityLevel(odV,'Binv')>0 or GetUnitAbilityLevel(odV,'Bivs')>0 or GetUnitAbilityLevel(odV,'BOwk')>0 or GetUnitAbilityLevel(oDV,'BSTN')>0 or GetUnitAbilityLevel(oDV,'BPSE')>0 or GetUnitAbilityLevel(oDV,'BUsl')>0 or GetUnitAbilityLevel(oDV,'BUst')>0 or GetUnitAbilityLevel(oDV,'BUsp')>0 or GetUnitAbilityLevel(oDV,'Bcyc')>0 or GetUnitAbilityLevel(oDV,'Bcy2')>0 then
call GroupRemoveUnit(ps,odV)
endif
endloop
call UnitRemoveAbility(oDV,'A0IM')
call SetUnitPathing(oDV,true)
call GroupRemoveUnit(es,oDV)
call SetUnitAnimation(oDV,"stand")
call UnitRemoveAbility(odV,'A0IO')
call UnitRemoveAbility(odV,'B048')
set odV=null
set oDV=null
set ofV=0
set odV=null
set oDV=null
endfunction
function oFV takes nothing returns boolean
return IsUnitSelected(GetFilterUnit(),GetTriggerPlayer())and GetUnitTypeId(GetFilterUnit())!='h000'
endfunction
function ogV takes nothing returns nothing
if GetUnitTypeId(GetEnumUnit())!='h000' and IsUnitSelected(GetEnumUnit(),GetTriggerPlayer()) then
call UnitRemoveAbility(GetEnumUnit(),'A0IS')
endif
endfunction
function oGV takes code ohV returns nothing
call GPo(GT,Condition(ohV))
endfunction
function oHV takes code ojV returns nothing
call GPo(gT,Condition(ojV))
endfunction
function oJV takes string okV returns integer
local integer oKV
set ZM[EM]=okV
set EM=EM+1
if jG==0 then
if xG<$8000 then
set xG=xG+1
set oKV=xG
set vG[oKV]=$470
else
call Cdv("Out of memory: Could not create CallbackSingle_nullTimer_ClosureEvents.","when calling error in ClosureEvents, line 292")
set oKV=0
endif
else
set jG=jG-1
set oKV=kG[jG]
set vG[oKV]=$470
endif
set EM=EM-1
return oKV
endfunction
function olV takes string oLV returns boolean
local integer omV
set ZM[EM]=oLV
set EM=EM+1
set Ky=ConvertPlayerEvent(96)
set Ny=Ctv("when calling new_HashMap in ClosureEvents, line 99")
set My=Ctv("when calling new_HashMap in ClosureEvents, line 100")
set rp=false
set Ly=CreateTrigger()
set Xy=CreateTrigger()
set Cy=CreateTrigger()
set By=0
call oGV(Omv)
call oHV(OMv)
set omV=oJV("when calling alloc_CallbackSingle_nullTimer_ClosureEvents in ClosureEvents, line 292")
call EUx(omV)
call Lsx(omV,"when calling nullTimer in ClosureEvents, line 292")
set EM=EM-1
return true
endfunction
function oMV takes nothing returns boolean
set EM=0
return olV("ClosureEvents, line 1")
endfunction
function opV takes integer oPV,unit oqV returns nothing
local timer oQV
if not HaveSavedHandle(i,ub[oPV],GetHandleId(oqV))then
set oQV=null
return
endif
set oQV=LoadTimerHandle(i,ub[oPV],GetHandleId(oqV))
call GJv(LoadInteger(i,y,GetHandleId(oQV)))
call Gmv(oQV)
call RemoveSavedHandle(i,ub[oPV],GetHandleId(oqV))
call GKv(ib[oPV],oqV)
set oQV=null
set oQV=null
endfunction
function osV takes nothing returns nothing
local unit oSV=GetEnumUnit()
local real otV=LoadReal(i,ll,GetHandleId(oSV))
call DestroyEffect(AddSpecialEffectTarget("Abilities\\Spells\\Undead\\VampiricAura\\VampiricAuraTarget.mdl",oSV,"origin"))
if pl<otV then
call SetWidgetLife(oSV,GetWidgetLife(oSV)+pl)
call SaveReal(i,ll,GetHandleId(oSV),(otV-pl)*1.)
else
call SetWidgetLife(oSV,GetWidgetLife(oSV)+otV)
call opV(ol,oSV)
call UnitRemoveAbility(oSV,tl)
endif
set oSV=null
set oSV=null
endfunction
function oTV takes nothing returns integer
return tp[ip-1]
endfunction
function ouV takes integer oUV,unit owV,string oWV returns nothing
set ZM[EM]=oWV
set EM=EM+1
call zGv(wP[oUV],Hzo(owV),"when calling add in LinkedList, line 537")
set EM=EM-1
endfunction
function oyV takes integer fSt,unit oYV returns nothing
call PFv(oYV)
endfunction
function ozV takes unit oZV,integer o_V,string o0V returns nothing
set ZM[EM]=o0V
set EM=EM+1
call vQV(f3v(Wd,o_V,"when calling get in ScmdUnitParamLinkingBuiltins, line 156"),oZV,"when calling delete in ScmdUnitParamLinkingBuiltins, line 156")
set EM=EM-1
endfunction
function o1V takes unit o2V,integer o3V,string o4V returns boolean
local player o5V
local boolean o6V
set ZM[EM]=o4V
set EM=EM+1
set o5V=HVo(o2V)
set o6V=(not Mla(umv(o2V),"when calling isUnitTypeProtected in ScmdPermissions, line 27"))and sa[o3V]==o5V or(not wRx(o5V))or gd[o3V]>gd[Hme(o5V)]
set EM=EM-1
set o5V=null
return o6V
endfunction
function o7V takes integer o8V,unit o9V,string rvV returns nothing
set ZM[EM]=rvV
set EM=EM+1
if o1V(o9V,QGv(eL[o8V],"when calling getPlayerId in ScmdUnitParamLinkingBuiltins, line 192"),"when calling isUnitAccessibleByPlayer in ScmdUnitParamLinkingBuiltins, line 192")then
call ozV(o9V,qL[o8V],"when calling unlinkParameter in ScmdUnitParamLinkingBuiltins, line 193")
endif
set EM=EM-1
endfunction
function reV takes integer mNi,unit rxV returns nothing
set IR=IR+1
set UR=rxV
endfunction
function roV takes integer rrV,unit riV,string raV returns nothing
local real rnV
local real rVV
local real rEV
local integer rXV
local integer rOV
local integer rRV
local real rIV
local real rAV
set ZM[EM]=raV
set EM=EM+1
if IsUnitInRangeXY(riV,GL[rrV],gL[rrV],200.)and x8e(riV,oy)and(not Mla(umv(riV),"when calling isUnitTypeProtected in SotfrpGuiLocust, line 26"))then
call TMv(riV,oy)
set rIV=uov(riV)
set rAV=c3
set rnV=rIV
set rVV=rAV
set rEV=GetUnitFacing(riV)
set rXV=ybv("when calling new_StringTable in SotfrpGuiLocust, line 30")
set rRV=YTv(rXV,"when calling new_SingleUnitData in SotfrpGuiLocust, line 31")
call E_e(rRV,riV,"when calling build in SotfrpGuiLocust, line 31")
set rOV=rRV
call PFv(riV)
call BSe(rOV,sa[hL[rrV]],rnV,rVV,rEV,"when calling create in SotfrpGuiLocust, line 33")
call Xze(rOV,"when calling dispatch_SingleUnitData_destroySingleUnitData in SotfrpGuiLocust, line 34")
call OJe(rXV,"when calling dispatch_StringTable_destroyStringTable in SotfrpGuiLocust, line 35")
endif
set EM=EM-1
endfunction
function rNV takes rect rbV,real rBV,real rcV returns boolean
return rBV>fee(rbV)and rBV<fie(rbV)and rcV>foe(rbV)and rcV<D9e(rbV)
endfunction
function rCV takes integer rdV,unit rDV,real rfV,real rFV,string rgV returns nothing
local real rGV
local real rhV
set ZM[EM]=rgV
set EM=EM+1
set rGV=FRv(DRv(uov(rDV),c3,rfV,rFV),d9)
set rhV=R1
set dV[rdV]=rGV
set fV[rdV]=rhV
set RV[rdV]=GetUnitFacing(rDV)
call VJe(rdV,rDV,"when calling build in UnitData, line 1346")
set EM=EM-1
endfunction
function rHV takes integer rjV,unit rJV,real rkV,real rKV,string rlV returns nothing
set ZM[EM]=rlV
set EM=EM+1
if Dv[rjV]==0 then
if rjV==0 then
call Cdv("Nullpointer exception when calling SinglePositionedUnitData.build","when calling error in UnitData, line 1342")
else
call Cdv("Called SinglePositionedUnitData.build on invalid object.","when calling error in UnitData, line 1342")
endif
endif
call rCV(rjV,rJV,rkV,rKV,"when calling build in UnitData, line 1342")
set EM=EM-1
endfunction
function rLV takes integer rmV,unit rMV,string rpV returns nothing
local integer rPV
local integer rqV
set ZM[EM]=rpV
set EM=EM+1
if rNV(sV[rmV],uov(rMV),c3)and(not Mla(umv(rMV),"when calling isUnitTypeProtected in UnitData, line 1428"))then
set rqV=XC[tV[rmV]]
set rPV=JTn(KC[tV[rmV]],"when calling new_SinglePositionedUnitData in UnitData, line 1429")
call rHV(rPV,rMV,iV[rmV],SV[rmV],"when calling build in UnitData, line 1429")
call dlv(rqV,rPV,"when calling add in UnitData, line 1429")
endif
set EM=EM-1
endfunction
function rQV takes integer rsV,unit rSV,string rtV returns nothing
set ZM[EM]=rtV
set EM=EM+1
call zGv(pH[rsV],Hzo(rSV),"when calling add in PlayerUtil, line 29")
set EM=EM-1
endfunction
function rTV takes integer ruV,unit rUV,string rwV returns nothing
set ZM[EM]=rwV
set EM=EM+1
if o1V(rUV,QGv(yL[ruV],"when calling getPlayerId in ScmdUnitParamLinkingBuiltins, line 183"),"when calling isUnitAccessibleByPlayer in ScmdUnitParamLinkingBuiltins, line 183")then
call KWe(pL[ruV],rUV)
endif
set EM=EM-1
endfunction
function rWV takes integer ryV,unit rYV,string rzV returns nothing
set ZM[EM]=rzV
set EM=EM+1
if sg[ryV]==0 then
if ryV==0 then
call Cdv("Nullpointer exception when calling ForGroupCallback.callback","when calling error in ClosureForGroups, line 4")
else
call Cdv("Called ForGroupCallback.callback on invalid object.","when calling error in ClosureForGroups, line 4")
endif
endif
if sg[ryV]<=$877 then
if sg[ryV]<=$875 then
if sg[ryV]<=$874 then
call ouV(ryV,rYV,"when calling callback_forEachFrom_LinkedList in ClosureForGroups, line 4")
else
call oyV(ryV,rYV)
endif
elseif sg[ryV]<=$876 then
call rLV(ryV,rYV,"when calling callback_forUnitsOfPlayer_PositionedUnitData_UnitData in ClosureForGroups, line 4")
else
call roV(ryV,rYV,"when calling callback_forUnitsOfPlayer_onPointCast_SotfrpGuiLocust in ClosureForGroups, line 4")
endif
elseif sg[ryV]<=$879 then
if sg[ryV]<=$878 then
call rQV(ryV,rYV,"when calling callback_forUnitsSelected_PlayerUtil in ClosureForGroups, line 4")
else
call reV(ryV,rYV)
endif
elseif sg[ryV]<=$87A then
call rTV(ryV,rYV,"when calling callback_forUnitsSelected_setArgumentsTypes_registerBuiltin_ScmdUnitParamLinkingBuiltins in ClosureForGroups, line 4")
else
call o7V(ryV,rYV,"when calling callback_forUnitsSelected_setArgumentsTypes_registerBuiltin_ScmdUnitParamLinkingBuiltins in ClosureForGroups, line 4")
endif
set EM=EM-1
endfunction
function rZV takes unit r_V,string r0V returns nothing
set ZM[EM]=r0V
set EM=EM+1
if cp<Sp then
call rWV(oTV(),r_V,"when calling callback in ClosureForGroups, line 18")
endif
set cp=cp+1
set EM=EM-1
endfunction
function r1V takes string r2V returns nothing
set ZM[EM]=r2V
set EM=EM+1
call rZV(GetFilterUnit(),"when calling filterCallback in ClosureForGroups, line 14")
set EM=EM-1
endfunction
function r3V takes nothing returns nothing
set EM=0
call r1V("ClosureForGroups, line 14")
endfunction
function r4V takes nothing returns boolean
return true
endfunction
function r5V takes nothing returns boolean
return GetSpellAbilityId()=='A0EF'
endfunction
function r6V takes nothing returns nothing
local unit r7V=GetSpellAbilityUnit()
local unit r8V=CreateUnitAtLoc(GetOwningPlayer(r7V),'h0T6',GetSpellTargetLoc(),GetUnitFacing(r7V))
local unit r9V=CreateUnitAtLoc(GetOwningPlayer(r7V),'h0JO',GetSpellTargetLoc(),GetUnitFacing(r7V))
local integer ivV=4*GetUnitAbilityLevel(r7V,'A0KM')
call SetUnitColor(r8V,PLAYER_COLOR_ORANGE)
call SetUnitAnimation(r8V,"birth")
call SetUnitScale(r8V,.4,.4,.4)
call UnitAddAbility(r9V,'A0KL')
call IssueImmediateOrderById(r9V,$D0217)
call pAa(ivV)
call KillUnit(r8V)
call RemoveUnit(r9V)
set ivV=0
set r9V=null
set r8V=null
set r7V=null
set r7V=null
set r8V=null
set r9V=null
endfunction
function ieV takes nothing returns boolean
return GetSpellAbilityId()=='A0A7'
endfunction
function ixV takes nothing returns boolean
return(GetSpellAbilityId()=='Aprg')or(GetSpellAbilityId()=='ACpu')or(GetSpellAbilityId()=='Apg2')or(GetSpellAbilityId()=='Aadm')or(GetSpellAbilityId()=='Andm')or(GetSpellAbilityId()=='ACdm')or(GetSpellAbilityId()=='ACd2')or(GetSpellAbilityId()=='Ache')
endfunction
function ioV takes nothing returns boolean
return(ixV())
endfunction
function irV takes nothing returns boolean
return(S2R(SubStringBJ(GetEventPlayerChatString(),8,$A))<=400.)and(S2R(SubStringBJ(GetEventPlayerChatString(),8,$A))>=(-400.))
endfunction
function iiV takes nothing returns boolean
return(F[GetConvertedPlayerId(GetTriggerPlayer())])and(GetEventPlayerChatString()=="height off")
endfunction
function iaV takes nothing returns boolean
return(F[GetConvertedPlayerId(GetTriggerPlayer())])and(GetEventPlayerChatString()=="height on")
endfunction
function inV takes nothing returns nothing
if iaV()then
set Vw=true
return
endif
if iiV()then
set Vw=false
return
endif
if irV()then
set Gw[GetConvertedPlayerId(GetTriggerPlayer())]=S2R(SubStringBJ(GetEventPlayerChatString(),8,$A))
call GetConvertedPlayerId(GetTriggerPlayer())
endif
endfunction
function iVV takes nothing returns nothing
local boolean iEV=false
local destructable iXV=GetTriggerDestructable()
local integer iOV=0
local integer iRV=ts
loop
exitwhen iOV>iRV
if iXV==Fw[iOV]then
if IsDestructableAliveBJ(hw[iOV]) then
call ModifyGateBJ(bj_GATEOPERATION_OPEN,hw[iOV])
else
call ModifyGateBJ(bj_GATEOPERATION_CLOSE,hw[iOV])
endif
set iEV=true
endif
set iOV=iOV+1
endloop
if iEV then
call pAa(5.)
call DestructableRestoreLife(iXV,GetDestructableMaxLife(iXV),true)
endif
set iOV=0
set iRV=0
set iEV=false
set iXV=null
set iXV=null
endfunction
function iIV takes nothing returns boolean
return(GetSpellAbilityId()=='A09I')
endfunction
function iAV takes string iNV,real ibV,real iBV returns nothing
local sound icV=CreateSound(iNV,false,true,true,$A,$A,"CombatSoundsEAX")
call SetSoundChannel(icV,40)
call SetSoundVolume(icV,$7F)
call SetSoundPitch(icV,1.)
call SetSoundDistances(icV,600.,10000.)
call SetSoundDistanceCutoff(icV,2100.)
call SetSoundConeAngles(icV,.0,.0,$7F)
call SetSoundConeOrientation(icV,.0,.0,.0)
call SetSoundPosition(icV,ibV,iBV,50.)
call StartSound(icV)
call KillSoundWhenDone(icV)
set icV=null
set icV=null
set icV=null
endfunction
function iCV takes nothing returns nothing
local unit idV=CreateUnitAtLoc(GetOwningPlayer(GetSpellAbilityUnit()),'h0QY',GetUnitLoc(GetSpellAbilityUnit()),GetUnitFacing(GetSpellAbilityUnit()))
call iAV("Abilities\\Weapons\\Axe\\AxeMissileLaunch1.wav",GetUnitX(GetSpellAbilityUnit()),GetUnitY(GetSpellAbilityUnit()))
call SetUnitTimeScale(idV,2.)
call SetUnitPathing(idV,false)
call IssuePointOrderByIdLoc(idV,$D0012,GetSpellTargetLoc())
call UnitApplyTimedLife(idV,'B03V',10.)
loop
set Os=idV
call ForGroup(GetUnitsInRangeOfLocMatching(300.,GetUnitLoc(idV),Condition(iqv)),iQv)
call iAV("Sound\\Units\\Combat\\MetalHeavySliceFlesh2.wav",GetUnitX(GetSpellAbilityUnit()),GetUnitY(GetSpellAbilityUnit()))
call pAa(1.)
exitwhen GetUnitState(idV,UNIT_STATE_LIFE)<=.0
endloop
set idV=null
set idV=null
endfunction
function iDV takes nothing returns boolean
return IsUnitSelected(GetFilterUnit(),GetTriggerPlayer())
endfunction
function ifV takes nothing returns boolean
set ia=ConvertPlayerColor(24)
set Sa=ConvertPlayerColor(25)
set ca=ConvertPlayerColor(26)
set oa=ConvertPlayerColor(27)
set Oa[0]=PLAYER_COLOR_RED
set Oa[1]=PLAYER_COLOR_BLUE
set Oa[2]=PLAYER_COLOR_CYAN
set Oa[3]=PLAYER_COLOR_PURPLE
set Oa[4]=PLAYER_COLOR_YELLOW
set Oa[5]=PLAYER_COLOR_ORANGE
set Oa[6]=PLAYER_COLOR_GREEN
set Oa[7]=PLAYER_COLOR_PINK
set Oa[8]=PLAYER_COLOR_LIGHT_GRAY
set Oa[9]=PLAYER_COLOR_LIGHT_BLUE
set Oa[$A]=PLAYER_COLOR_AQUA
set Oa[$B]=PLAYER_COLOR_BROWN
set Oa[$C]=PLAYER_COLOR_MAROON
set Oa[$D]=PLAYER_COLOR_NAVY
set Oa[$E]=PLAYER_COLOR_TURQUOISE
set Oa[$F]=PLAYER_COLOR_VIOLET
set Oa[16]=PLAYER_COLOR_WHEAT
set Oa[17]=PLAYER_COLOR_PEACH
set Oa[18]=PLAYER_COLOR_MINT
set Oa[19]=PLAYER_COLOR_LAVENDER
set Oa[20]=PLAYER_COLOR_COAL
set Oa[21]=PLAYER_COLOR_SNOW
set Oa[22]=PLAYER_COLOR_EMERALD
set Oa[23]=PLAYER_COLOR_PEANUT
set Oa[24]=ia
set Oa[25]=Sa
set Oa[26]=ca
set Oa[27]=oa
return true
endfunction
function iFV takes nothing returns nothing
if GetUnitTypeId(GetEnumUnit())!='h000' and IsUnitSelected(GetEnumUnit(),GetTriggerPlayer()) then
call GroupRemoveUnit(Yt,GetEnumUnit())
endif
endfunction
function igV takes nothing returns nothing
call SetBlightRadiusLocBJ(true,GetEnumPlayer(),G,380.)
endfunction
function iGV takes nothing returns boolean
set ja=$80*16
return true
endfunction
function ihV takes string iHV returns integer
local integer ijV
set ZM[EM]=iHV
set EM=EM+1
if jG==0 then
if xG<$8000 then
set xG=xG+1
set ijV=xG
set vG[ijV]=$472
else
call Cdv("Out of memory: Could not create CallbackSingle_nullTimer_Preloader.","when calling error in Preloader, line 55")
set ijV=0
endif
else
set jG=jG-1
set ijV=kG[jG]
set vG[ijV]=$472
endif
set EM=EM-1
return ijV
endfunction
function iJV takes string ikV returns boolean
local integer iKV
set ZM[EM]=ikV
set EM=EM+1
set Ta=true
set Ya=CreateGroup()
set Ga=vAe(Ty,Ep,.0,.0,.0)
if Ga==null then
call Cdv("DUMMY_UNITID ("+d0v(Ep)+") not added correctly to the map.","when calling error in Preloader, line 53")
endif
if Ta then
set iKV=ihV("when calling alloc_CallbackSingle_nullTimer_Preloader in Preloader, line 55")
call EUx(iKV)
call Lsx(iKV,"when calling nullTimer in Preloader, line 55")
endif
set EM=EM-1
return true
endfunction
function ilV takes nothing returns boolean
set EM=0
return iJV("Preloader, line 1")
endfunction
function iLV takes nothing returns nothing
local integer imV=GetSpellAbilityId()
if imV==GO then
set imV=gO
elseif imV==hO then
set imV=FO
elseif imV==kO then
set imV=jO
elseif imV==xO then
set imV=vO
elseif imV==mO then
set imV=QO
elseif imV==WO then
set imV=EO
else
return
endif
call GBv(imV,GetUnitAbilityLevel(GetSpellAbilityUnit(),GetSpellAbilityId()),"attackonce",GetSpellAbilityUnit())
endfunction
function iMV takes nothing returns boolean
return(GetSpellAbilityId()=='A06X')
endfunction
function ipV takes nothing returns boolean
return IsUnitInTransportBJ(GetFilterUnit(),GetSpellAbilityUnit())
endfunction
function iPV takes string iqV returns boolean
set ZM[EM]=iqV
set EM=EM+1
if me then
call BQa("when calling new_HashSet in UniqueIdValidator, line 7")
endif
set EM=EM-1
return true
endfunction
function iQV takes nothing returns boolean
set EM=0
return iPV("UniqueIdValidator, line 1")
endfunction
function isV takes trigger iSV returns boolean
return TriggerEvaluate(iSV)
endfunction
function itV takes unit iTV returns nothing
set kq[jq]=iTV
set jq=jq+1
endfunction
function iuV takes nothing returns nothing
set jq=jq-1
endfunction
function iUV takes unit iwV returns nothing
local unit iWV=iwV
local unit iyV
call wrv(iWV,xq)
set iyV=iWV
call wvv(iyV,xq,true)
call itV(iwV)
call isV(hq)
call iuV()
set iWV=null
set iyV=null
endfunction
function iYV takes nothing returns nothing
call iUV(GetEnumUnit())
endfunction
function izV takes nothing returns boolean
set aq=".................................!.#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[.]^_`abcdefghijklmnopqrstuvwxyz{|}~................................................................................................................................."
return true
endfunction
function iZV takes nothing returns boolean
return(GetSpellAbilityId()=='A0EP')
endfunction
function i_V takes nothing returns boolean
if GetSpellAbilityId()=='A094' or GetSpellAbilityId()=='A06H' or GetSpellAbilityId()=='A09Q' or GetSpellAbilityId()=='A06F' or GetSpellAbilityId()=='A088' or GetSpellAbilityId()=='A0A3' or GetSpellAbilityId()=='A09C' or GetSpellAbilityId()=='A09D' or GetSpellAbilityId()=='A0EO' or GetSpellAbilityId()=='A0EP' or GetSpellAbilityId()=='A05O' or GetSpellAbilityId()=='A05P' or GetSpellAbilityId()=='A09U' or GetSpellAbilityId()=='A06Y' or GetSpellAbilityId()=='A07H' or GetSpellAbilityId()=='A07Z' or GetSpellAbilityId()=='A095' or GetSpellAbilityId()=='AO7B' or GetSpellAbilityId()=='A0DF' or GetSpellAbilityId()=='A07G' or GetSpellAbilityId()=='A07C' or GetSpellAbilityId()=='A0EI' or GetSpellAbilityId()=='A085' or GetSpellAbilityId()=='A0D9' or GetSpellAbilityId()=='A0A0' or GetSpellAbilityId()=='A08N' or GetSpellAbilityId()=='A04K' or GetSpellAbilityId()=='A083' or GetSpellAbilityId()=='A0CR' or GetSpellAbilityId()=='A04A' or GetSpellAbilityId()=='A0CP' or GetSpellAbilityId()=='A0CQ' or GetSpellAbilityId()=='A09F' or GetSpellAbilityId()=='A09P' or GetSpellAbilityId()=='A0DA' or GetSpellAbilityId()=='A0E3' or GetSpellAbilityId()=='A09R' or GetSpellAbilityId()=='A081' then
return true
else
return false
endif
endfunction
function i0V takes nothing returns boolean
if GetSpellAbilityId()=='Ahea' or GetSpellAbilityId()=='Adis' or GetSpellAbilityId()=='AHhb' or GetSpellAbilityId()=='AHbz' or GetSpellAbilityId()=='AHwe' or GetSpellAbilityId()=='AHtb' or GetSpellAbilityId()=='AHfs' or GetSpellAbilityId()=='AHtc' or GetSpellAbilityId()=='Adcn' or GetSpellAbilityId()=='Adch' or GetSpellAbilityId()=='Aprg' or GetSpellAbilityId()=='Apg2' or GetSpellAbilityId()=='Aast' or GetSpellAbilityId()=='AOsh' or GetSpellAbilityId()=='AOs2' or GetSpellAbilityId()=='AOws' or GetSpellAbilityId()=='AOw2' or GetSpellAbilityId()=='AOsf' or GetSpellAbilityId()=='AOhw' or GetSpellAbilityId()=='ANhw' or GetSpellAbilityId()=='AOcl' or GetSpellAbilityId()=='Arpl' or GetSpellAbilityId()=='Amb2' or GetSpellAbilityId()=='Arpm' or GetSpellAbilityId()=='Arai' or GetSpellAbilityId()=='Advm' or GetSpellAbilityId()=='AUfn' or GetSpellAbilityId()=='AUdc' or GetSpellAbilityId()=='AUim' or GetSpellAbilityId()=='AUcs' or GetSpellAbilityId()=='AUcb' or GetSpellAbilityId()=='Avng' or GetSpellAbilityId()=='Aadm' or GetSpellAbilityId()=='AEfk' or GetSpellAbilityId()=='AEmb' or GetSpellAbilityId()=='AEsh' or GetSpellAbilityId()=='AEfn' or GetSpellAbilityId()=='ACmo' or GetSpellAbilityId()=='ACwe' or GetSpellAbilityId()=='ACtb' or GetSpellAbilityId()=='ACbz' or GetSpellAbilityId()=='ACsh' or GetSpellAbilityId()=='ACst' or GetSpellAbilityId()=='Awrh' or GetSpellAbilityId()=='Awrg' or GetSpellAbilityId()=='Awrs' or GetSpellAbilityId()=='ACcv' or GetSpellAbilityId()=='ACc2' or GetSpellAbilityId()=='ACc3' or GetSpellAbilityId()=='ACs9' or GetSpellAbilityId()=='ACsf' or GetSpellAbilityId()=='ACfn' or GetSpellAbilityId()=='ACcb' or GetSpellAbilityId()=='ACbf' or GetSpellAbilityId()=='Anhe' or GetSpellAbilityId()=='Anh1' or GetSpellAbilityId()=='Anh2' or GetSpellAbilityId()=='ACdc' or GetSpellAbilityId()=='Ambd' or GetSpellAbilityId()=='Amnb' or GetSpellAbilityId()=='Ambb' or GetSpellAbilityId()=='ACfb' or GetSpellAbilityId()=='Awfb' or GetSpellAbilityId()=='ACbc' or GetSpellAbilityId()=='ACrg' or GetSpellAbilityId()=='ACrf' or GetSpellAbilityId()=='ANfs' or GetSpellAbilityId()=='ACfs' or GetSpellAbilityId()=='ACrd' or GetSpellAbilityId()=='ACss' or GetSpellAbilityId()=='ACpu' or GetSpellAbilityId()=='ACde' or GetSpellAbilityId()=='ACmp' or GetSpellAbilityId()=='ACfl' or GetSpellAbilityId()=='ACdm' or GetSpellAbilityId()=='Adsm' or GetSpellAbilityId()=='ACd2' or GetSpellAbilityId()=='ACfr' or GetSpellAbilityId()=='ACca' or GetSpellAbilityId()=='ACtc' or GetSpellAbilityId()=='ACt2' or GetSpellAbilityId()=='AChv' or GetSpellAbilityId()=='ACcl' or GetSpellAbilityId()=='ACs8' or GetSpellAbilityId()=='ANmo' or GetSpellAbilityId()=='ACs7' or GetSpellAbilityId()=='ANhs' or GetSpellAbilityId()=='ANsq' or GetSpellAbilityId()=='Arsq' or GetSpellAbilityId()=='ANsg' or GetSpellAbilityId()=='Arsg' or GetSpellAbilityId()=='ANsb' or GetSpellAbilityId()=='ANfb' or GetSpellAbilityId()=='ANbf' or GetSpellAbilityId()=='ANcf' or GetSpellAbilityId()=='ANrf' or GetSpellAbilityId()=='ANwm' or GetSpellAbilityId()=='Aslp' or GetSpellAbilityId()=='ANfl' or GetSpellAbilityId()=='ANcs' or GetSpellAbilityId()=='ANc1' or GetSpellAbilityId()=='ANc2' or GetSpellAbilityId()=='ANc3' or GetSpellAbilityId()=='ANsw' or GetSpellAbilityId()=='ANlm' or GetSpellAbilityId()=='Andm' then
return true
else
return false
endif
endfunction
function i1V takes nothing returns nothing
local unit i2V=GetSpellAbilityUnit()
local unit i3V=GetSpellTargetUnit()
local integer i4V=GetUnitCurrentOrder(i2V)
local unit i5V
local effect i6V
if(GetUnitAbilityLevel(i2V,'A0EZ')==3 and GetRandomInt(1,'d')<=45)or(GetUnitAbilityLevel(i2V,'A0EZ')==2 and GetRandomInt(1,'d')<=30)or(GetUnitAbilityLevel(i2V,'A0EZ')==1 and GetRandomInt(1,'d')<=$F)and i0V()or i_V()then
set i5V=CreateUnitAtLoc(GetOwningPlayer(i2V),'h0JO',GetUnitLoc(i2V),GetUnitFacing(i2V))
set i6V=AddSpecialEffectTarget("Abilities\\Spells\\Orc\\FeralSpirit\\feralspiritdone.mdl",i2V,"chest")
call UnitAddAbility(i5V,GetSpellAbilityId())
call SetUnitAbilityLevel(i5V,GetSpellAbilityId(),GetUnitAbilityLevel(i2V,GetSpellAbilityId()))
call IssueTargetOrderById(i5V,i4V,i3V)
call IssuePointOrderByIdLoc(i5V,i4V,GetSpellTargetLoc())
call IssueImmediateOrderById(i5V,i4V)
call TriggerSleepAction(12.)
call RemoveUnit(i5V)
call DestroyEffect(i6V)
endif
set i2V=null
set i3V=null
set i4V=0
set i5V=null
set i6V=null
set i2V=null
set i3V=null
set i5V=null
set i6V=null
endfunction
function i7V takes nothing returns boolean
return(GetSpellAbilityId()=='A0CV')
endfunction
function i8V takes nothing returns nothing
local timer i9V=null
local unit avV=null
local unit aeV=GetSpellAbilityUnit()
local integer axV=GetUnitAbilityLevel(aeV,'AOds')
local integer aoV=1
local group arV=CreateGroup()
call GroupEnumUnitsInRangeOfLoc(arV,GetUnitLoc(aeV),200.,Condition(Vkv))
if IsUnitInGroup(aeV,Tt[2])then
set aoV=4
elseif IsUnitInGroup(aeV,Tt[1])then
set aoV=3
set i9V=LoadTimerHandle(nr,GetHandleId(aeV),StringHash("dsT"))
call FlushChildHashtable(nr,GetHandleId(i9V))
call DestroyTimer(i9V)
call GroupRemoveUnit(Tt[1],aeV)
call GroupAddUnit(Tt[2],aeV)
set i9V=CreateTimer()
call SaveTimerHandle(nr,GetHandleId(aeV),StringHash("dsT"),i9V)
call SaveUnitHandle(nr,GetHandleId(i9V),StringHash("u"),aeV)
call TimerStart(i9V,6.,false,VKv)
set i9V=null
elseif IsUnitInGroup(aeV,Tt[0])then
set aoV=2
set i9V=LoadTimerHandle(nr,GetHandleId(aeV),StringHash("dsT"))
call FlushChildHashtable(nr,GetHandleId(i9V))
call DestroyTimer(i9V)
call GroupRemoveUnit(Tt[0],aeV)
call GroupAddUnit(Tt[1],aeV)
set i9V=CreateTimer()
call SaveTimerHandle(nr,GetHandleId(aeV),StringHash("dsT"),i9V)
call SaveUnitHandle(nr,GetHandleId(i9V),StringHash("u"),aeV)
call TimerStart(i9V,6.,false,VKv)
set i9V=null
else
call GroupAddUnit(Tt[0],aeV)
set i9V=CreateTimer()
call SaveTimerHandle(nr,GetHandleId(aeV),StringHash("dsT"),i9V)
call SaveUnitHandle(nr,GetHandleId(i9V),StringHash("u"),aeV)
call TimerStart(i9V,6.,false,VKv)
set i9V=null
endif
loop
set avV=FirstOfGroup(arV)
call GroupRemoveUnit(arV,avV)
call UnitDamageTarget(aeV,avV,aoV*12.5*(axV+1),true,true,ATTACK_TYPE_NORMAL,DAMAGE_TYPE_MAGIC,WEAPON_TYPE_WHOKNOWS)
call DestroyEffect(AddSpecialEffectTarget("Abilities\\Spells\\Other\\HealingSpray\\HealBottleMissile.mdl",avV,"chest"))
exitwhen FirstOfGroup(arV)==null
endloop
call DestroyGroup(arV)
set arV=null
set axV=0
set avV=null
loop
call DestroyEffect(AddSpecialEffectLoc("Abilities\\Spells\\Other\\DivineStorm\\DivineStorm.mdx",GetUnitLoc(aeV)))
set aoV=aoV-1
exitwhen aoV==0
endloop
set aeV=null
set i9V=null
set avV=null
set aeV=null
set arV=null
endfunction
function aiV takes nothing returns boolean
return(GetSpellAbilityId()=='A03L')
endfunction
function aaV takes nothing returns boolean
return(GetDestructableMaxLife(GetEnumDestructable())==2501.)
endfunction
function anV takes nothing returns nothing
if aaV()then
call SetDestructableInvulnerableBJ(GetEnumDestructable(),true)
call ModifyGateBJ(bj_GATEOPERATION_OPEN,GetEnumDestructable())
call ModifyGateBJ(bj_GATEOPERATION_DESTROY,GetEnumDestructable())
call RemoveDestructable(GetEnumDestructable())
endif
endfunction
function aVV takes nothing returns nothing
local unit aEV
if GetSpellAbilityId()==T then
set aEV=GetSpellTargetUnit()
call DestroyEffect(AddSpecialEffect("Objects\\Spawnmodels\\Human\\HCancelDeath\\HCancelDeath.mdl",GetUnitX(aEV),GetUnitY(aEV)))
call RemoveUnit(aEV)
set aEV=null
endif
set aEV=null
endfunction
function aXV takes nothing returns boolean
if GetSpellAbilityId()=='A0H8' then
return true
else
return false
endif
endfunction
function aOV takes nothing returns nothing
local unit aRV=GetSpellAbilityUnit()
if GetSpellAbilityId()=='AcS3' then
call UnitRemoveAbility(aRV,'AcB3')
call UnitAddAbility(aRV,'AcB4')
call UnitMakeAbilityPermanent(aRV,true,'AcB4')
call UnitRemoveAbility(aRV,'AcHR')
else
call UnitRemoveAbility(aRV,'AcB4')
call UnitAddAbility(aRV,'AcB3')
call UnitMakeAbilityPermanent(aRV,true,'AcB3')
call UnitAddAbility(aRV,'AcHR')
call UnitMakeAbilityPermanent(aRV,true,'AcHR')
endif
set aRV=null
set aRV=null
endfunction
function aIV takes nothing returns boolean
if GetSpellAbilityId()=='A0G9' then
return true
else
return false
endif
endfunction
function aAV takes nothing returns nothing
call Zyn(GetEnumUnit())
endfunction
function aNV takes nothing returns nothing
if GetUnitTypeId(GetEnumUnit())!='h000' and IsUnitSelected(GetEnumUnit(),GetTriggerPlayer()) then
call UnitRemoveAbility(GetEnumUnit(),'A0JG')
call UnitRemoveAbility(GetEnumUnit(),'A0JH')
endif
endfunction
function abV takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),1,4)=="item")
endfunction
function aBV takes nothing returns boolean
call UnitRemoveAbility(ry,'A0AO')
return true
endfunction
function acV takes string aCV returns boolean
local boolean adV
set ZM[EM]=aCV
set EM=EM+1
set adV=not Mla(umv(GetFilterUnit()),"when calling isUnitTypeProtected in ScmdUnitBuiltins, line 207")
set EM=EM-1
return adV
endfunction
function aDV takes nothing returns boolean
set EM=0
return acV("ScmdUnitBuiltins, line 207")
endfunction
function afV takes nothing returns boolean
return GetBooleanAnd(IsUnitAliveBJ(GetFilterUnit()),IsUnitEnemy(GetFilterUnit(),GetOwningPlayer(Nu)))
endfunction
function aFV takes nothing returns boolean
return(RectContainsLoc(GetPlayableMapRect(),Ju[9])==false)
endfunction
function agV takes nothing returns nothing
set Ju[9]=GetSpellTargetLoc()
if aFV()then
call IssueImmediateOrderBJ(GetTriggerUnit(),"stop")
set Xu=GetForceOfPlayer(GetOwningPlayer(GetTriggerUnit()))
call DisplayTextToForce(Xu,"TRIGSTR_8260")
call DestroyForce(Xu)
endif
call RemoveLocation(Ju[9])
endfunction
function aGV takes string ahV returns integer
local integer aHV
set ZM[EM]=ahV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set aHV=Yj
set Gj[aHV]=$B13
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdWeatherEffectFunctions.","when calling error in ScmdWeatherEffectFunctions, line 6")
set aHV=0
endif
else
set Tj=Tj-1
set aHV=Rj[Tj]
set Gj[aHV]=$B13
endif
set EM=EM-1
return aHV
endfunction
function ajV takes string aJV returns boolean
local integer akV
local integer aKV
set ZM[EM]=aJV
set EM=EM+1
set akV=aGV("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdWeatherEffectFunctions in ScmdWeatherEffectFunctions, line 6")
set aKV=OPo(akV,"when calling new_BuiltinData in ScmdWeatherEffectFunctions, line 6")
call FRa(aKV,e5V(),f3a(),"when calling setArgumentsTypes in ScmdWeatherEffectFunctions, line 8")
call Foa(ILo(aKV,"when calling new_BuiltinFunction in ScmdWeatherEffectFunctions, line 6"),"addweathereffect","when calling registerProtectedBuiltin in ScmdWeatherEffectFunctions, line 6")
set EM=EM-1
return true
endfunction
function alV takes nothing returns boolean
set EM=0
return ajV("ScmdWeatherEffectFunctions, line 1")
endfunction
function aLV takes nothing returns nothing
set Ju[8]=GetUnitLoc(GetEnumUnit())
call CreateNUnitsAtLoc(1,'h0LE',GetOwningPlayer(Nu),Ju[8],bj_UNIT_FACING)
call UnitAddAbilityBJ('A06C',GetLastCreatedUnit())
call IssueTargetOrderBJ(GetLastCreatedUnit(),"slow",GetEnumUnit())
call GroupAddUnitSimple(GetLastCreatedUnit(),Ku)
call SaveIntegerBJ(Du+2,0,GetHandleIdBJ(GetLastCreatedUnit()),Au)
call RemoveLocation(Ju[8])
endfunction
function amV takes nothing returns boolean
return GetSpellAbilityId()=='AObm'
endfunction
function aMV takes nothing returns boolean
return(GetUnitAbilityLevelSwapped('A0CL',GetSpellAbilityUnit())==3)
endfunction
function apV takes nothing returns boolean
return(UnitHasBuffBJ(GetSpellTargetUnit(),'B022'))
endfunction
function aPV takes nothing returns boolean
return(UnitHasBuffBJ(GetSpellTargetUnit(),'B01Y'))
endfunction
function aqV takes nothing returns boolean
return(UnitHasBuffBJ(GetSpellTargetUnit(),'B020'))
endfunction
function aQV takes nothing returns boolean
return(UnitHasBuffBJ(GetSpellTargetUnit(),'B021'))
endfunction
function asV takes nothing returns boolean
return(UnitHasBuffBJ(GetSpellTargetUnit(),'B023'))
endfunction
function aSV takes nothing returns boolean
return(GetUnitAbilityLevelSwapped('A0CL',GetSpellAbilityUnit())==1)
endfunction
function atV takes nothing returns boolean
return(UnitHasBuffBJ(GetSpellTargetUnit(),'B01V'))
endfunction
function aTV takes nothing returns boolean
return(UnitHasBuffBJ(GetSpellTargetUnit(),'B01X'))
endfunction
function auV takes nothing returns boolean
return(UnitHasBuffBJ(GetSpellTargetUnit(),'B01W'))
endfunction
function aUV takes nothing returns boolean
return(GetUnitAbilityLevelSwapped('A0CL',GetSpellAbilityUnit())==2)
endfunction
function awV takes nothing returns boolean
return(UnitHasBuffBJ(GetSpellTargetUnit(),'B01Z'))
endfunction
function aWV takes nothing returns nothing
call CreateNUnitsAtLoc(1,'h0JO',GetOwningPlayer(GetSpellAbilityUnit()),GetUnitLoc(GetSpellAbilityUnit()),bj_UNIT_FACING)
call UnitApplyTimedLifeBJ(3.,'BTLF',GetLastCreatedUnit())
if aSV()then
if auV()then
call UnitAddAbilityBJ('A0CM',GetLastCreatedUnit())
call IssueTargetOrderBJ(GetLastCreatedUnit(),"innerfire",GetSpellTargetUnit())
elseif aTV()then
call UnitAddAbilityBJ('A0CO',GetLastCreatedUnit())
call IssueTargetOrderBJ(GetLastCreatedUnit(),"innerfire",GetSpellTargetUnit())
elseif atV()then
call SetUnitLifeBJ(GetSpellTargetUnit(),GetUnitStateSwap(UNIT_STATE_LIFE,GetSpellTargetUnit())-20.)
else
call UnitAddAbilityBJ('A0CN',GetLastCreatedUnit())
call IssueTargetOrderBJ(GetLastCreatedUnit(),"innerfire",GetSpellTargetUnit())
endif
elseif aUV()then
if awV()then
call UnitAddAbilityBJ('A0CM',GetLastCreatedUnit())
call SetUnitAbilityLevelSwapped('A0CM',GetLastCreatedUnit(),2)
call IssueTargetOrderBJ(GetLastCreatedUnit(),"innerfire",GetSpellTargetUnit())
elseif aPV()then
call UnitAddAbilityBJ('A0CO',GetLastCreatedUnit())
call SetUnitAbilityLevelSwapped('A0CO',GetLastCreatedUnit(),2)
call IssueTargetOrderBJ(GetLastCreatedUnit(),"innerfire",GetSpellTargetUnit())
elseif aqV()then
call SetUnitLifeBJ(GetSpellTargetUnit(),GetUnitStateSwap(UNIT_STATE_LIFE,GetSpellTargetUnit())-40.)
else
call UnitAddAbilityBJ('A0CN',GetLastCreatedUnit())
call SetUnitAbilityLevelSwapped('A0CN',GetLastCreatedUnit(),2)
call IssueTargetOrderBJ(GetLastCreatedUnit(),"innerfire",GetSpellTargetUnit())
endif
elseif aMV()then
if aQV()then
call UnitAddAbilityBJ('A0CM',GetLastCreatedUnit())
call SetUnitAbilityLevelSwapped('A0CM',GetLastCreatedUnit(),3)
call IssueTargetOrderBJ(GetLastCreatedUnit(),"innerfire",GetSpellTargetUnit())
elseif apV()then
call UnitAddAbilityBJ('A0CO',GetLastCreatedUnit())
call SetUnitAbilityLevelSwapped('A0CO',GetLastCreatedUnit(),3)
call IssueTargetOrderBJ(GetLastCreatedUnit(),"innerfire",GetSpellTargetUnit())
elseif asV()then
call SetUnitLifeBJ(GetSpellTargetUnit(),GetUnitStateSwap(UNIT_STATE_LIFE,GetSpellTargetUnit())-60.)
else
call UnitAddAbilityBJ('A0CN',GetLastCreatedUnit())
call SetUnitAbilityLevelSwapped('A0CN',GetLastCreatedUnit(),3)
call IssueTargetOrderBJ(GetLastCreatedUnit(),"innerfire",GetSpellTargetUnit())
endif
endif
endfunction
function ayV takes nothing returns nothing
local unit aYV=CreateUnitAtLoc(GetOwningPlayer(GetSpellAbilityUnit()),'o023',GetSpellTargetLoc(),270.)
call UnitApplyTimedLife(aYV,'B04D',60.)
call DestroyEffect(AddSpecialEffect("Objects\\Spawnmodels\\Other\\ToonBoom\\ToonBoom.mdl",GetUnitX(aYV)-17.5,GetUnitY(aYV)-17.5))
set aYV=null
set aYV=null
endfunction
function azV takes nothing returns boolean
return(IsPlayerEnemy(GetOwningPlayer(GetSpellAbilityUnit()),GetOwningPlayer(GetFilterUnit()))and IsUnitType(GetEnumUnit(),UNIT_TYPE_STRUCTURE)==false and BlzIsUnitInvulnerable(GetFilterUnit())==false)!=null
endfunction
function aZV takes nothing returns boolean
return GetUnitTypeId(GetOrderedUnit())=='h000' and GetIssuedOrderId()==$D0003
endfunction
function a_V takes nothing returns boolean
return(GetSpellAbilityId()=='A060')
endfunction
function a0V takes nothing returns boolean
return(GetSpellAbilityId()=='AEbl' or GetSpellAbilityId()=='ANbl' or GetSpellAbilityId()=='Albk' or GetSpellAbilityId()=='A03F')
endfunction
function a1V takes nothing returns boolean
return IsUnitSelected(GetFilterUnit(),GetTriggerPlayer())
endfunction
function a2V takes integer a3V,integer a4V returns integer
return LoadInteger(LR,a3V,a4V)
endfunction
function a5V takes integer a6V,integer a7V,string a8V returns integer
local integer a9V
set ZM[EM]=a8V
set EM=EM+1
if jv[a6V]==0 then
if a6V==0 then
call Cdv("Nullpointer exception when calling Table.loadInteger","when calling error in TableJurst, line 51")
else
call Cdv("Called Table.loadInteger on invalid object.","when calling error in TableJurst, line 51")
endif
endif
set a9V=a2V(a6V,a7V)
set EM=EM-1
return a9V
endfunction
function nvV takes integer neV,unit nxV,real noV,integer nrV,string niV returns nothing
local timer naV
set ZM[EM]=niV
set EM=EM+1
set naV=nOn(neV,nxV,"when calling prepare in BuffsJurst, line 140")
call izn(XQ[neV],GetHandleId(naV),nrV,"when calling saveInteger in BuffsJurst, line 141")
call TimerStart(naV,noV,true,REv)
set EM=EM-1
set naV=null
endfunction
function nnV takes integer nVV,unit nEV,real nXV,integer nOV,string nRV returns nothing
set ZM[EM]=nRV
set EM=EM+1
if dG[nVV]==0 then
if nVV==0 then
call Cdv("Nullpointer exception when calling BuffType.applyPeriodic","when calling error in BuffsJurst, line 139")
else
call Cdv("Called BuffType.applyPeriodic on invalid object.","when calling error in BuffsJurst, line 139")
endif
endif
call nvV(nVV,nEV,nXV,nOV,"when calling applyPeriodic in BuffsJurst, line 139")
set EM=EM-1
endfunction
function nIV takes string nAV returns nothing
local unit nNV
local integer nbV
local unit nBV
local real ncV
local real nCV
local real ndV
set ZM[EM]=nAV
set EM=EM+1
set nNV=GetTriggerUnit()
set nbV=GetHandleId(nNV)
if GetUnitAbilityLevel(nNV,cT)>0 and GetEventDamage()>.0 then
set nBV=aCn(qT,nbV,"when calling loadUnit in TouchOfKarma, line 28")
set ncV=GetEventDamage()
set nCV=aOn(pT,nbV,"when calling loadReal in TouchOfKarma, line 30")
if ncV<nCV then
set ndV=ncV
else
set ndV=nCV
endif
call BlzSetEventDamage(ncV-ndV)
call i6n(pT,nbV,nCV-ndV,"when calling saveReal in TouchOfKarma, line 37")
if ndV==nCV then
call UnitRemoveAbility(nNV,cT)
endif
set nCV=.0
if GetUnitAbilityLevel(nBV,oT)>0 then
set nCV=aOn(nT,GetHandleId(nBV),"when calling loadReal in TouchOfKarma, line 43")
endif
call i6n(nT,GetHandleId(nBV),nCV+.75*ndV,"when calling saveReal in TouchOfKarma, line 45")
call nnV(yT,nBV,1.,5,"when calling applyPeriodic in TouchOfKarma, line 46")
call nPn(GetOwningPlayer(nNV),lT,a5V(eT,nbV,"when calling loadInteger in TouchOfKarma, line 47"),"attackonce",nBV,GetUnitX(nBV),GetUnitY(nBV))
endif
set EM=EM-1
set nNV=null
set nBV=null
endfunction
function nDV takes nothing returns nothing
set EM=0
call nIV("TouchOfKarma, line 99")
endfunction
function nfV takes nothing returns integer
local integer nFV
if Pb[0]==0 then
set Ib=Ib+1
set nFV=Ib
else
set nFV=Pb[0]
set Pb[0]=Pb[Pb[0]]
endif
return nFV
endfunction
function ngV takes unit nGV,real nhV,real nHV,real njV,real WGw,integer nJV returns nothing
local timer nkV=cFv()
local real nKV=GetUnitX(nGV)
local real nlV=GetUnitY(nGV)
local real nLV=nhV-nKV
local real nmV=nHV-nlV
local integer nMV=nfV()
set Qb[nMV]=R2I(SquareRoot(nLV*nLV+nmV*nmV)/njV/.01)
set Wb[nMV]=(nhV-nKV)/Qb[nMV]
set Eb[nMV]=(nHV-nlV)/Qb[nMV]
set Zb[nMV]=nGV
set Ub[nMV]=nJV
call SetUnitFacing(nGV,Rad2Deg(Atan2(nHV-nlV,nhV-nKV)))
call SaveInteger(i,y,GetHandleId(nkV),nMV)
call TimerStart(nkV,.01,true,Dz)
set nkV=null
set nkV=null
endfunction
function npV takes unit nPV,unit nqV,real nQV,real nsV,integer nSV returns nothing
local real ntV=BlzGetUnitCollisionSize(nPV)
local real nTV=BlzGetUnitCollisionSize(nqV)
local real nuV=GetUnitX(nqV)
local real nUV=GetUnitY(nqV)
local real nwV
if ntV<32. and nTV>=32. then
set nuV=nuV+16.
set nUV=nUV+16.
elseif ntV>=32. and nTV<32. then
set nuV=nuV-16.
set nUV=nUV-16.
endif
set nwV=Atan2(nUV-GetUnitY(nPV),nuV-GetUnitX(nPV))
call ngV(nPV,nuV-(ntV+nTV)*Cos(nwV),nUV-(ntV+nTV)*Sin(nwV),nQV,nsV,nSV)
endfunction
function nWV takes nothing returns integer
local integer nyV=Fb
if nyV!=0 then
set Fb=jb[nyV]
else
set kb=kb+1
set nyV=kb
endif
if nyV>8190 then
return 0
endif
set xb[nyV]=95
set jb[nyV]=-1
return nyV
endfunction
function nYV takes unit nzV,unit nZV returns nothing
local real n_V=GetWidgetLife(nZV)/BlzGetUnitMaxHP(nZV)
local timer n0V
call DestroyEffect(AddSpecialEffectTarget("Objects\\Spawnmodels\\Human\\HumanBlood\\HumanBloodPriest.mdl",nZV,"chest"))
call UnitDamageTarget(nzV,nZV,350.,true,true,ATTACK_TYPE_MELEE,DAMAGE_TYPE_NORMAL,WEAPON_TYPE_WHOKNOWS)
if n_V<=.35 then
set n0V=cFv()
call SaveUnitHandle(i,y,GetHandleId(n0V),nzV)
call TimerStart(n0V,1.5,false,zZ)
set n0V=null
endif
set n0V=null
endfunction
function n1V takes nothing returns nothing
local unit n2V
local unit n3V
local real n4V
local real n5V
local integer n6V
if GetSpellAbilityId()!='AOex' then
set n2V=null
set n3V=null
return
endif
set n2V=GetSpellAbilityUnit()
set n3V=GetSpellTargetUnit()
set n4V=GetUnitX(n3V)-GetUnitX(n2V)
set n5V=GetUnitY(n3V)-GetUnitY(n2V)
if SquareRoot(n4V*n4V+n5V*n5V)<=128. then
call nYV(n2V,n3V)
else
set n6V=nWV()
set Db[n6V]=n2V
set Hb[n6V]=n3V
call npV(n2V,n3V,2000.,.0,n6V)
endif
set n3V=null
set n2V=null
set n2V=null
set n3V=null
endfunction
function n7V takes nothing returns boolean
return(Mu==1)
endfunction
function n8V takes nothing returns boolean
return(sr==ju)
endfunction
function n9V takes nothing returns boolean
return(Mu==1)
endfunction
function VvV takes nothing returns boolean
return(Mu==2)
endfunction
function VeV takes nothing returns boolean
return(Yu)
endfunction
function VxV takes nothing returns boolean
return(ModuloReal(I2R(wr),6.)==.0)
endfunction
function VoV takes nothing returns boolean
return(Mu==2)
endfunction
function VrV takes nothing returns boolean
return(Mu==1)
endfunction
function ViV takes nothing returns boolean
return(ur==1)and(ModuloReal(I2R(wr),2.)==.0)
endfunction
function VaV takes nothing returns boolean
return(sr==1)
endfunction
function VnV takes nothing returns boolean
return(Mu==2)
endfunction
function VVV takes nothing returns boolean
return(ur==3)and(ModuloReal(I2R(wr),2.)==.0)
endfunction
function VEV takes nothing returns boolean
return(ModuloReal(I2R(sr),2.)==.0)
endfunction
function VXV takes nothing returns boolean
return(Mu==1)
endfunction
function VOV takes nothing returns boolean
return(Mu==3)and(ModuloReal(I2R(wr),4.)==.0)
endfunction
function VRV takes nothing returns boolean
return(ur<=2)
endfunction
function VIV takes nothing returns boolean
return(sr==ku)
endfunction
function VAV takes nothing returns boolean
return(Yu)
endfunction
function VNV takes nothing returns nothing
set Bu=GetHandleIdBJ(GetEnumUnit())
set Nu=GetEnumUnit()
set Mu=1
set wr=LoadIntegerBJ(6,Bu,Au)
set ur=LoadIntegerBJ(7,Bu,Au)
set rr=LoadIntegerBJ(8,Bu,Au)
set sr=LoadIntegerBJ($A,Bu,Au)
call SaveIntegerBJ(wr+1,6,Bu,Au)
if VRV()then
if ViV()then
set Ju[2]=GetUnitLoc(Nu)
if VXV()then
call CreateNUnitsAtLoc(1,'h0ID',GetOwningPlayer(Nu),Ju[2],bj_UNIT_FACING)
call AddSpecialEffectTargetUnitBJ("overhead",Nu,"Abilities\\Weapons\\LichMissile\\LichMissile.mdl")
elseif VvV()then
call CreateNUnitsAtLoc(1,'h002',GetOwningPlayer(Nu),Ju[2],bj_UNIT_FACING)
call AddSpecialEffectTargetUnitBJ("overhead",Nu,"Abilities\\Weapons\\RedDragonBreath\\RedDragonMissile.mdl")
else
call CreateNUnitsAtLoc(1,'h0LH',GetOwningPlayer(Nu),Ju[2],bj_UNIT_FACING)
call AddSpecialEffectTargetUnitBJ("overhead",Nu,"Abilities\\Weapons\\FarseerMissile\\FarseerMissile.mdl")
endif
call DestroyEffectBJ(GetLastCreatedEffectBJ())
call GroupAddUnitSimple(GetLastCreatedUnit(),lr[rr])
call SaveRealBJ(.0,1,GetHandleIdBJ(GetLastCreatedUnit()),Au)
call SaveRealBJ(.0,2,GetHandleIdBJ(GetLastCreatedUnit()),Au)
call SaveRealBJ(10.,3,GetHandleIdBJ(GetLastCreatedUnit()),Au)
set sr=sr+1
call SaveIntegerBJ(sr,$A,Bu,Au)
if n8V()then
call SaveIntegerBJ(2,7,Bu,Au)
endif
call RemoveLocation(Ju[2])
endif
call ForGroupBJ(lr[rr],vvv)
else
set tr=LoadRealBJ(9,Bu,Au)
set Ju[4]=LoadLocationHandleBJ(0,Bu,Au)
set Ju[5]=LoadLocationHandleBJ(1,Bu,Au)
set ir=LoadRealBJ($B,Bu,Au)
set Sr=LoadBooleanBJ($C,Bu,Au)
if VVV()then
if n7V()then
call CreateNUnitsAtLoc(1,'h0ID',GetOwningPlayer(Nu),Ju[4],AngleBetweenPoints(Ju[4],Ju[5]))
call SetUnitScalePercent(GetLastCreatedUnit(),400.,400.,400.)
call AddSpecialEffectLocBJ(Ju[4],"Abilities\\Weapons\\FrostWyrmMissile\\FrostWyrmMissile.mdl")
call DestroyEffectBJ(GetLastCreatedEffectBJ())
elseif VnV()then
if VEV()then
set Ju[$A]=PolarProjectionBJ(Ju[4],GetRandomReal(Gu,Wu),GetRandomDirectionDeg())
call CreateNUnitsAtLocFacingLocBJ(1,'h00A',GetOwningPlayer(Nu),Ju[4],Ju[$A])
call GroupAddUnitSimple(GetLastCreatedUnit(),cr[rr])
call SaveLocationHandleBJ(Ju[$A],1,GetHandleIdBJ(GetLastCreatedUnit()),Au)
call SaveBooleanBJ(true,2,GetHandleIdBJ(GetLastCreatedUnit()),Au)
endif
call CreateNUnitsAtLoc(1,'h005',GetOwningPlayer(Nu),Ju[4],AngleBetweenPoints(Ju[4],Ju[5]))
call SetUnitScalePercent(GetLastCreatedUnit(),800.,800.,800.)
if VxV()then
call AddSpecialEffectLocBJ(Ju[4],"Abilities\\Spells\\Other\\Doom\\DoomDeath.mdl")
call DestroyEffectBJ(GetLastCreatedEffectBJ())
endif
else
call CreateNUnitsAtLoc(1,'h0LH',GetOwningPlayer(Nu),Ju[4],bj_UNIT_FACING)
call SetUnitScalePercent(GetLastCreatedUnit(),300.,300.,300.)
call SetUnitFlyHeightBJ(GetLastCreatedUnit(),.0,.0)
call KillUnit(GetLastCreatedUnit())
call GroupAddUnitSimple(GetLastCreatedUnit(),Ku)
call SaveIntegerBJ(Du+1,0,GetHandleIdBJ(GetLastCreatedUnit()),Au)
call CreateNUnitsAtLoc(1,'h0LH',GetOwningPlayer(Nu),Ju[4],bj_UNIT_FACING)
call SetUnitScalePercent(GetLastCreatedUnit(),300.,300.,300.)
call AddSpecialEffectLocBJ(Ju[4],"Abilities\\Weapons\\ChimaeraLightningMissile\\ChimaeraLightningMissile.mdl")
call DestroyEffectBJ(GetLastCreatedEffectBJ())
endif
call GroupAddUnitSimple(GetLastCreatedUnit(),lr[rr])
call SetUnitFlyHeightBJ(GetLastCreatedUnit(),.0,.0)
set sr=sr+1
call SaveIntegerBJ(sr,$A,Bu,Au)
if VaV()then
if VeV()then
call ForForce(GetPlayersAll(),vev)
endif
call CreateUbersplatBJ(Ju[4],"DHLB",100.,100.,100.,.0,false,true)
call FinishUbersplat(GetLastCreatedUbersplat())
call SetUbersplatRenderAlways(GetLastCreatedUbersplat(),true)
set br=1
loop
exitwhen br>5
set Ju[8]=PolarProjectionBJ(Ju[4],GetRandomReal(50.,180.),GetRandomDirectionDeg())
if VrV()then
call CreateNUnitsAtLoc(1,'h0IE',GetOwningPlayer(Nu),Ju[8],GetRandomDirectionDeg())
call SetUnitTimeScalePercent(GetLastCreatedUnit(),20.)
elseif VoV()then
call CreateNUnitsAtLoc(1,'h006',GetOwningPlayer(Nu),Ju[8],GetRandomDirectionDeg())
else
call CreateNUnitsAtLoc(1,'h0LG',GetOwningPlayer(Nu),Ju[8],GetRandomDirectionDeg())
call SetUnitTimeScalePercent(GetLastCreatedUnit(),20.)
endif
call GroupAddUnitSimple(GetLastCreatedUnit(),Ku)
call UnitApplyTimedLifeBJ(5.,'BTLF',GetLastCreatedUnit())
call SaveIntegerBJ(Du+7,0,GetHandleIdBJ(GetLastCreatedUnit()),Au)
call RemoveLocation(Ju[8])
set br=br+1
endloop
set bj_wantDestroyGroup=true
call ForGroupBJ(GetUnitsInRangeOfLocMatching(Gu,Ju[4],Condition(vxv)),vov)
if n9V()then
set br=1
loop
exitwhen br>3
call CreateNUnitsAtLoc(1,'h0E1',GetOwningPlayer(Nu),Ju[4],bj_UNIT_FACING)
call KillUnit(GetLastCreatedUnit())
call GroupAddUnitSimple(GetLastCreatedUnit(),Ku)
call SaveIntegerBJ(Du+2,0,GetHandleIdBJ(GetLastCreatedUnit()),Au)
set br=br+1
endloop
set bj_wantDestroyGroup=true
call ForGroupBJ(GetUnitsInRangeOfLocMatching(Qu,Ju[4],Condition(vrv)),viv)
endif
endif
set bj_wantDestroyGroup=true
call ForGroupBJ(GetUnitsInRangeOfLocMatching(Gu,Ju[4],Condition(vav)),vnv)
if VIV()then
if VAV()then
call ForForce(GetPlayersAll(),vVv)
endif
call SaveIntegerBJ(4,7,Bu,Au)
endif
endif
call ForGroupBJ(lr[rr],vEv)
call ForGroupBJ(cr[rr],vXv)
if VOV()then
set pr=GroupPickRandomUnit(lr[rr])
set Ju[$D]=GetUnitLoc(pr)
call CreateNUnitsAtLoc(1,'h0LE',GetOwningPlayer(Nu),Ju[$D],bj_UNIT_FACING)
call SetUnitFlyHeightBJ(GetLastCreatedUnit(),GetUnitFlyHeight(pr),.0)
call UnitAddAbilityBJ('A06R',GetLastCreatedUnit())
set bj_wantDestroyGroup=true
call IssueTargetOrderBJ(GetLastCreatedUnit(),"chainlightning",GroupPickRandomUnit(GetUnitsInRangeOfLocMatching(Pu,Ju[$D],Condition(vOv))))
call GroupAddUnitSimple(GetLastCreatedUnit(),Ku)
call SaveIntegerBJ(Du+1,0,GetHandleIdBJ(GetLastCreatedUnit()),Au)
call RemoveLocation(Ju[$D])
endif
endif
endfunction
function VbV takes string VBV returns integer
local integer VcV
set ZM[EM]=VBV
set EM=EM+1
if jG==0 then
if xG<$8000 then
set xG=xG+1
set VcV=xG
set vG[VcV]=$477
else
call Cdv("Out of memory: Could not create CallbackSingle_nullTimer_SotFRP_Locale.","when calling error in SotFRP_Locale, line 34")
set VcV=0
endif
else
set jG=jG-1
set VcV=kG[jG]
set vG[VcV]=$477
endif
set EM=EM-1
return VcV
endfunction
function VCV takes string VdV returns integer
local integer VDV
set ZM[EM]=VdV
set EM=EM+1
if vF==0 then
if mF<$8000 then
set mF=mF+1
set VDV=mF
set QF[VDV]=$D42
else
call Cdv("Out of memory: Could not create Locale.","when calling error in Locale, line 8")
set VDV=0
endif
else
set vF=vF-1
set VDV=xF[vF]
set QF[VDV]=$D42
endif
set EM=EM-1
return VDV
endfunction
function VfV takes integer R3s returns nothing
endfunction
function VFV takes string VgV returns integer
local integer VGV
set ZM[EM]=VgV
set EM=EM+1
if jm==0 then
if xm<$8000 then
set xm=xm+1
set VGV=xm
else
call Cdv("Out of memory: Could not create StringStringHashMap.","when calling error in Utility, line 139")
set VGV=0
endif
else
set jm=jm-1
set VGV=km[jm]
endif
set EM=EM-1
return VGV
endfunction
function VhV takes integer FaS returns nothing
endfunction
function VHV takes integer VjV returns nothing
call VhV(VjV)
call InitHashtable()
call InitHashtable()
endfunction
function VJV takes string VkV returns integer
local integer VKV
set ZM[EM]=VkV
set EM=EM+1
set VKV=VFV("when calling alloc_StringStringHashMap in Utility, line 144")
call VHV(VKV)
set EM=EM-1
return VKV
endfunction
function VlV takes integer VLV,string VmV returns nothing
set ZM[EM]=VmV
set EM=EM+1
call VfV(VLV)
call VJV("when calling new_StringStringHashMap in Locale, line 18")
set yP[VLV]=a6x("when calling new_Table in Locale, line 19")
set pP[VLV]=BQa("when calling new_HashSet in Locale, line 20")
set eP[VLV]=Ctv("when calling new_HashMap in Locale, line 21")
set qP[VLV]=InitHashtable()
set aP[VLV]=InitHashtable()
set EM=EM-1
endfunction
function VMV takes string VpV returns integer
local integer VPV
set ZM[EM]=VpV
set EM=EM+1
set VPV=VCV("when calling alloc_Locale in Locale, line 17")
call VlV(VPV,"when calling construct_Locale in Locale, line 17")
set EM=EM-1
return VPV
endfunction
function VqV takes string VQV returns boolean
local integer VsV
set ZM[EM]=VQV
set EM=EM+1
set ef=VMV("when calling new_Locale in SotFRP_Locale, line 8")
set qf=VMV("when calling new_Locale in SotFRP_Locale, line 9")
set VsV=VbV("when calling alloc_CallbackSingle_nullTimer_SotFRP_Locale in SotFRP_Locale, line 34")
call EUx(VsV)
call Lsx(VsV,"when calling nullTimer in SotFRP_Locale, line 34")
set EM=EM-1
return true
endfunction
function VSV takes nothing returns boolean
set EM=0
return VqV("SotFRP_Locale, line 1")
endfunction
function VtV takes nothing returns nothing
local boolean VTV=false
local unit VuV
local unit VUV
if GetSpellAbilityId()==dq then
set VuV=GetSpellAbilityUnit()
set VUV=GetSpellTargetUnit()
if GetUnitAbilityLevel(VuV,fq)>0 then
call UnitRemoveAbility(VuV,fq)
set VTV=true
endif
call DestroyEffect(AddSpecialEffectTarget("Abilities\\Spells\\Undead\\FrostArmor\\FrostArmorDamage.mdl",VUV,"chest"))
call UnitDamageTarget(VuV,VUV,GetUnitAbilityLevel(VuV,dq)*75.,true,true,ATTACK_TYPE_MELEE,DAMAGE_TYPE_NORMAL,WEAPON_TYPE_WHOKNOWS)
if VTV then
call UnitDamageTarget(VuV,VUV,GetUnitAbilityLevel(VuV,dq)*75.,true,true,ATTACK_TYPE_NORMAL,DAMAGE_TYPE_MAGIC,WEAPON_TYPE_WHOKNOWS)
endif
call iAV(Gq+I2S(GetRandomInt(1,5))+".wav",GetUnitX(VuV),GetUnitY(VuV))
call iAV(gq,GetUnitX(VUV),GetUnitY(VUV))
endif
set VuV=null
set VUV=null
endfunction
function VwV takes nothing returns nothing
local unit VWV=GetSpellAbilityUnit()
local integer VyV=0
local integer VYV=6*GetUnitAbilityLevel(VWV,'A0HX')
if IsUnitInGroup(VWV,Ls) then
call GroupRemoveUnit(Ls,VWV)
call pAa(1.)
endif
call GroupAddUnit(Ls,VWV)
call DestroyEffect(AddSpecialEffectTarget("Abilities\\Spells\\Human\\Invisibility\\InvisibilityTarget.mdl",VWV,"chest"))
call UnitAddAbility(VWV,'A0I0')
call UnitMakeAbilityPermanent(VWV,true,'A0I0')
call UnitAddAbility(VWV,'A0F7')
call UnitMakeAbilityPermanent(VWV,true,'A0F7')
call SetUnitAbilityLevel(VWV,'A0F7',VYV/6)
loop
exitwhen IsUnitInGroup(VWV,Ls)==false
call pAa(1.)
set VyV=VyV+1
if VyV==VYV or GetUnitState(VWV,UNIT_STATE_LIFE)<=.0 then
call GroupRemoveUnit(Ls,VWV)
endif
endloop
call UnitRemoveAbility(VWV,'A0I0')
call UnitRemoveAbility(VWV,'A0F7')
call UnitRemoveAbility(VWV,'B03Y')
set VWV=null
set VyV=0
set VYV=0
set VWV=null
endfunction
function VzV takes nothing returns nothing
local integer VZV=1
local unit V_V=GetSpellAbilityUnit()
local location V0V=GetSpellTargetLoc()
loop
exitwhen VZV>$3B9ACA00
if V_V==ut[VZV]then
call GroupRemoveUnit(ps,rt[VZV])
call DestroyEffect(AddSpecialEffectLoc("Abilities\\Spells\\Human\\MassTeleport\\MassTeleportCaster.mdl",GetUnitLoc(rt[VZV])))
call SetUnitPositionLoc(rt[VZV],V0V)
call DestroyEffect(AddSpecialEffectLoc("Abilities\\Spells\\Human\\MassTeleport\\MassTeleportTarget.mdl",GetUnitLoc(rt[VZV])))
call UnitRemoveAbility(ut[VZV],'A0JH')
call UnitAddAbility(ut[VZV],'A0JG')
call UnitMakeAbilityPermanent(ut[VZV],true,'A0JG')
set ut[VZV]=null
set rt[VZV]=null
set VZV=0
set V_V=null
set V0V=null
set V_V=null
set V0V=null
return
endif
set VZV=VZV+1
endloop
set VZV=0
set V_V=null
set V0V=null
set V_V=null
set V0V=null
endfunction
function V1V takes nothing returns boolean
return(GetSpellAbilityId()=='A0EU')
endfunction
function V2V takes nothing returns boolean
return GetSpellAbilityId()=='A090'
endfunction
function V3V takes nothing returns boolean
return true
endfunction
function V4V takes nothing returns nothing
call UnitAddAbilityBJ('Aspi',GetSpellAbilityUnit())
call UnitAddAbilityBJ('A0CW',GetSpellAbilityUnit())
call UnitRemoveAbilityBJ('A0CV',GetSpellAbilityUnit())
endfunction
function V5V takes nothing returns boolean
return GetSpellAbilityId()=='AOew'
endfunction
function V6V takes nothing returns boolean
return(GetEventPlayerChatString()=="'herostickygrenade")
endfunction
function V7V takes nothing returns boolean
return(GetEventPlayerChatString()=="@herostickygrenade")
endfunction
function V8V takes nothing returns nothing
set g[GetConvertedPlayerId(GetTriggerPlayer())]=GetUnitsOfPlayerMatching(GetTriggerPlayer(),Condition(rqv))
if V6V()then
call ForGroupBJ(g[GetConvertedPlayerId(GetTriggerPlayer())],rQv)
elseif V7V()then
call ForGroupBJ(g[GetConvertedPlayerId(GetTriggerPlayer())],rsv)
endif
call DestroyGroup(g[GetPlayerId(GetTriggerPlayer())+1])
endfunction
function V9V takes nothing returns nothing
set G=GetUnitLoc(GetEnumUnit())
call EnumDestructablesInCircleBJ(256.,G,xJv)
call RemoveLocation(G)
endfunction
function EvV takes nothing returns boolean
return(GetSpellAbilityId()=='TMm1')
endfunction
function EeV takes nothing returns boolean
return(GetSpellAbilityId()=='TMm5')
endfunction
function ExV takes nothing returns boolean
return(GetSpellAbilityId()=='TMm3')
endfunction
function EoV takes nothing returns boolean
return(GetSpellAbilityId()=='TMm7')
endfunction
function ErV takes nothing returns boolean
return(GetSpellAbilityId()=='TMm2')
endfunction
function EiV takes nothing returns boolean
return(GetSpellAbilityId()=='TMm4')
endfunction
function EaV takes nothing returns boolean
return(GetSpellAbilityId()=='TMm6')
endfunction
function EnV takes nothing returns nothing
if EvV()then
set vt[GetConvertedPlayerId(GetOwningPlayer(GetSpellAbilityUnit()))-1]=0
elseif ErV()then
set vt[GetConvertedPlayerId(GetOwningPlayer(GetSpellAbilityUnit()))-1]=1
elseif ExV()then
set vt[GetConvertedPlayerId(GetOwningPlayer(GetSpellAbilityUnit()))-1]=2
elseif EiV()then
set vt[GetConvertedPlayerId(GetOwningPlayer(GetSpellAbilityUnit()))-1]=3
elseif EeV()then
set vt[GetConvertedPlayerId(GetOwningPlayer(GetSpellAbilityUnit()))-1]=4
elseif EaV()then
set vt[GetConvertedPlayerId(GetOwningPlayer(GetSpellAbilityUnit()))-1]=5
elseif EoV()then
set vt[GetConvertedPlayerId(GetOwningPlayer(GetSpellAbilityUnit()))-1]=6
endif
endfunction
function EVV takes nothing returns nothing
local unit EEV
local unit EXV
if GetSpellAbilityId()!='A0MH' then
set EEV=null
set EXV=null
return
endif
set EEV=GetSpellAbilityUnit()
set EXV=GetSpellTargetUnit()
call UnitDamageTarget(EEV,EXV,50*GetUnitAbilityLevel(EEV,'A0MH'),true,true,ATTACK_TYPE_MELEE,DAMAGE_TYPE_NORMAL,WEAPON_TYPE_WHOKNOWS)
call DestroyEffect(AddSpecialEffectTarget("Objects\\Spawnmodels\\Human\\HumanBlood\\HumanBloodPriest.mdl",EXV,"chest"))
call SetWidgetLife(EEV,GetWidgetLife(EEV)+'d'*GetUnitAbilityLevel(EEV,'A0MH'))
call DestroyEffect(AddSpecialEffectTarget("Abilities\\Spells\\Undead\\VampiricAura\\VampiricAuraTarget.mdl",EEV,"origin"))
call opV(el,EEV)
call UnitRemoveAbility(EEV,'B05L')
set EXV=null
set EEV=null
set EEV=null
set EXV=null
endfunction
function EOV takes nothing returns nothing
set kw[GetPlayerId(GetTriggerPlayer())]=null
call GetPlayerId(GetTriggerPlayer())
call RemoveUnit(ss[GetPlayerId(GetTriggerPlayer())])
set ss[GetPlayerId(GetTriggerPlayer())]=CreateUnitAtLoc(GetTriggerPlayer(),'h0Q7',GetUnitLoc(GetSpellAbilityUnit()),270.)
endfunction
function ERV takes nothing returns boolean
return(GetSpellAbilityId()=='A0IT')
endfunction
function EIV takes nothing returns boolean
return(GetUnitTypeId(GetSoldUnit())=='h0N3')or(GetUnitTypeId(GetSoldUnit())=='h0N2')
endfunction
function EAV takes nothing returns boolean
return(EIV())
endfunction
function ENV takes nothing returns nothing
call ZTn(GetEnumUnit())
endfunction
function EbV takes nothing returns nothing
set G=GetUnitLoc(GetEnumUnit())
call CreateItemLoc('I06X',G)
call RemoveLocation(G)
endfunction
function EBV takes nothing returns boolean
return true
endfunction
function EcV takes string ECV returns boolean
local boolean EdV
set ZM[EM]=ECV
set EM=EM+1
set EdV=not Mla(umv(GetFilterUnit()),"when calling isUnitTypeProtected in ScmdUnitBuiltins, line 229")
set EM=EM-1
return EdV
endfunction
function EDV takes nothing returns boolean
set EM=0
return EcV("ScmdUnitBuiltins, line 229")
endfunction
function EfV takes nothing returns boolean
set ve="DRAL"
return true
endfunction
function EFV takes nothing returns nothing
set Ju[8]=GetUnitLoc(GetEnumUnit())
call CreateNUnitsAtLoc(1,'h0LE',GetOwningPlayer(Nu),Ju[8],bj_UNIT_FACING)
call UnitAddAbilityBJ('A06C',GetLastCreatedUnit())
call IssueTargetOrderBJ(GetLastCreatedUnit(),"slow",GetEnumUnit())
call GroupAddUnitSimple(GetLastCreatedUnit(),Ku)
call SaveIntegerBJ(Du+2,0,GetHandleIdBJ(GetLastCreatedUnit()),Au)
call RemoveLocation(Ju[8])
endfunction
function EgV takes integer EGV,integer EhV returns nothing
set VQ[EGV]=EhV
endfunction
function EHV takes integer EjV,integer EJV,string EkV returns nothing
set ZM[EM]=EkV
set EM=EM+1
if dG[EjV]==0 then
if EjV==0 then
call Cdv("Nullpointer exception when calling BuffType.setOnCreationHandler","when calling error in BuffsJurst, line 46")
else
call Cdv("Called BuffType.setOnCreationHandler on invalid object.","when calling error in BuffsJurst, line 46")
endif
endif
call EgV(EjV,EJV)
set EM=EM-1
endfunction
function EKV takes string ElV returns integer
local integer ELV
set ZM[EM]=ElV
set EM=EM+1
if RG==0 then
if TG<$8000 then
set TG=TG+1
set ELV=TG
set YG[ELV]=5106
else
call Cdv("Out of memory: Could not create OnBuffCreationStruct.","when calling error in ShieldWall, line 34")
set ELV=0
endif
else
set RG=RG-1
set ELV=fG[RG]
set YG[ELV]=5106
endif
set EM=EM-1
return ELV
endfunction
function EmV takes integer wvi returns nothing
endfunction
function EMV takes integer EpV returns nothing
call EmV(EpV)
endfunction
function EPV takes string EqV returns integer
local integer EQV
set ZM[EM]=EqV
set EM=EM+1
set EQV=EKV("when calling alloc_OnBuffCreationStruct in ShieldWall, line 34")
call EMV(EQV)
set EM=EM-1
return EQV
endfunction
function EsV takes string ESV returns nothing
local trigger EtV
set ZM[EM]=ESV
set EM=EM+1
set EtV=CreateTrigger()
call EHV(Id,EPV("when calling new_OnBuffCreationStruct in ShieldWall, line 42"),"when calling setOnCreationHandler in ShieldWall, line 42")
call Avv(EtV,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(EtV,Filter(O4v))
call TriggerAddCondition(Pd,Filter(O5v))
set EM=EM-1
set EtV=null
endfunction
function ETV takes string EuV returns boolean
set ZM[EM]=EuV
set EM=EM+1
set Ed='A0I5'
set Zd='B057'
set Ud='A0AU'
set Id=Dha("when calling create in ShieldWall, line 7")
set Pd=CreateTrigger()
set Ad=CreateGroup()
call EsV("when calling Init in ShieldWall, line 1")
set EM=EM-1
return true
endfunction
function EUV takes nothing returns boolean
set EM=0
return ETV("ShieldWall, line 1")
endfunction
function EwV takes nothing returns boolean
return(GetSpellAbilityId()=='A07W')
endfunction
function EWV takes nothing returns nothing
call cRv(AddSpecialEffectTarget("Abilities\\Spells\\Other\\TalkToMe\\TalkToMe.mdl",GetSpellTargetUnit(),"overhead"),GetUnitAbilityLevel(GetSpellAbilityUnit(),'A0G1'))
endfunction
function EyV takes nothing returns boolean
return GetSpellAbilityId()=='AOra'
endfunction
function EYV takes nothing returns boolean
return(GetSpellAbilityId()=='Adsm')or(GetSpellAbilityId()=='Adis')or(GetSpellAbilityId()=='Adcn')or(GetSpellAbilityId()=='Adch')or(GetSpellAbilityId()=='Advm')or(GetSpellAbilityId()=='ACde')
endfunction
function EzV takes nothing returns boolean
return(EYV())
endfunction
function EZV takes nothing returns nothing
set B[N]='afac'
set M[N]="alleria'sfluteofaccuracy"
set N=N+1
set B[N]='spsh'
set M[N]="amuletofspellshield"
set N=N+1
set B[N]='ajen'
set M[N]="ancientjanggoofendurance"
set N=N+1
set B[N]='bgst'
set M[N]="beltofgiantstrength+6"
set N=N+1
set B[N]='belv'
set M[N]="bootsofquel'thalas+6"
set N=N+1
set B[N]='bspd'
set M[N]="bootsofspeed"
set N=N+1
set B[N]='cnob'
set M[N]="circletofnobility"
set N=N+1
set B[N]='ratc'
set M[N]="clawsofattack+12"
set N=N+1
set B[N]='rat6'
set M[N]="clawsofattack+6"
set N=N+1
set B[N]='rat9'
set M[N]="clawsofattack+9"
set N=N+1
set B[N]='clfm'
set M[N]="cloakofflames"
set N=N+1
set B[N]='clsd'
set M[N]="cloakofshadows"
set N=N+1
set B[N]='crys'
set M[N]="crystalball"
set N=N+1
set B[N]='dsum'
set M[N]="diamondofsummoning"
set N=N+1
set B[N]='rst1'
set M[N]="gauntletsofogrestrength+3"
set N=N+1
set B[N]='gcel'
set M[N]="glovesofhaste"
set N=N+1
set B[N]='hval'
set M[N]="helmofvalor"
set N=N+1
set B[N]='hcun'
set M[N]="hoodofcunning"
set N=N+1
set B[N]='rhth'
set M[N]="khadgar'sgemofhealth"
set N=N+1
set B[N]='kpin'
set M[N]="khadgar'spipeofinsight"
set N=N+1
set B[N]='lgdh'
set M[N]="legiondoom-horn"
set N=N+1
set B[N]='rin1'
set M[N]="mantleofintelligence+3"
set N=N+1
set B[N]='mcou'
set M[N]="medallionofcourage"
set N=N+1
set B[N]='odef'
set M[N]="orbofdarkness"
set N=N+1
set B[N]='penr'
set M[N]="pendantofenergy"
set N=N+1
set B[N]='pmna'
set M[N]="pendantofmana"
set N=N+1
set B[N]='prvt'
set M[N]="periaptofvitality"
set N=N+1
set B[N]='rde1'
set M[N]="ringofprotection+2"
set N=N+1
set B[N]='rde2'
set M[N]="ringofprotection+3"
set N=N+1
set B[N]='rde3'
set M[N]="ringofprotection+4"
set N=N+1
set B[N]='rlif'
set M[N]="ringofregeneration"
set N=N+1
set B[N]='ciri'
set M[N]="robeofthemagi+6"
set N=N+1
set B[N]='brac'
set M[N]="runedbracers"
set N=N+1
set B[N]='sbch'
set M[N]="scourgebonechimes"
set N=N+1
set B[N]='rag1'
set M[N]="slippersofagility+3"
set N=N+1
set B[N]='rwiz'
set M[N]="sobimask"
set N=N+1
set B[N]='ssil'
set M[N]="staffofsilence"
set N=N+1
set B[N]='stel'
set M[N]="staffofteleportation"
set N=N+1
set B[N]='evtl'
set M[N]="talismanofevasion"
set N=N+1
set B[N]='lhst'
set M[N]="thelionhornofstormwind"
set N=N+1
set B[N]='ward'
set M[N]="warsongbattledrums"
set N=N+1
set B[N]='wild'
set M[N]="amuletofthewild"
set N=N+1
set B[N]='ankh'
set M[N]="ankhofreincarnation"
set N=N+1
set B[N]='fgsk'
set M[N]="bookofthedead"
set N=N+1
set B[N]='fgdg'
set M[N]="demonicfigurine"
set N=N+1
set B[N]='whwd'
set M[N]="healingwards"
set N=N+1
set B[N]='hlst'
set M[N]="healthstone"
set N=N+1
set B[N]='shar'
set M[N]="iceshard"
set N=N+1
set B[N]='infs'
set M[N]="infernostone"
set N=N+1
set B[N]='mnst'
set M[N]="manastone"
set N=N+1
set B[N]='pdiv'
set M[N]="potionofdivinity"
set N=N+1
set B[N]='pghe'
set M[N]="potionofgreaterhealing"
set N=N+1
set B[N]='pgma'
set M[N]="potionofgreatermana"
set N=N+1
set B[N]='pnvu'
set M[N]="potionofinvulnerability"
set N=N+1
set B[N]='pomn'
set M[N]="potionofomniscience"
set N=N+1
set B[N]='pres'
set M[N]="potionofrestoration"
set N=N+1
set B[N]='fgrd'
set M[N]="reddrakeegg"
set N=N+1
set B[N]='rej3'
set M[N]="replenishmentpotion"
set N=N+1
set B[N]='sand'
set M[N]="scrollofanimatedead"
set N=N+1
set B[N]='sres'
set M[N]="scrollofrestoration"
set N=N+1
set B[N]='srrc'
set M[N]="scrollofresurrection"
set N=N+1
set B[N]='sror'
set M[N]="scrollofthebeast"
set N=N+1
set B[N]='wswd'
set M[N]="sentrywards"
set N=N+1
set B[N]='fgfh'
set M[N]="spikedcollar"
set N=N+1
set B[N]='fgrg'
set M[N]="stonetoken"
set N=N+1
set B[N]='totw'
set M[N]="talismanofthewild"
set N=N+1
set B[N]='will'
set M[N]="wandofillusion"
set N=N+1
set B[N]='wlsd'
set M[N]="wandoflightningshield"
set N=N+1
set B[N]='woms'
set M[N]="wandofmanastealing"
set N=N+1
set B[N]='wshs'
set M[N]="wandofshadowsight"
set N=N+1
set B[N]='wcyc'
set M[N]="wandofthewind"
set N=N+1
set B[N]='lmbr'
set M[N]="bundleoflumber"
set N=N+1
set B[N]='gfor'
set M[N]="glyphoffortification"
set N=N+1
set B[N]='gomn'
set M[N]="glyphofomniscience"
set N=N+1
set B[N]='guvi'
set M[N]="glyphofultravision"
set N=N+1
set B[N]='gold'
set M[N]="goldcoins"
set N=N+1
set B[N]='manh'
set M[N]="manualofhealth"
set N=N+1
set B[N]='rdis'
set M[N]="runeofdispelmagic"
set N=N+1
set B[N]='rhe3'
set M[N]="runeofgreaterhealing"
set N=N+1
set B[N]='rma2'
set M[N]="runeofgreatermana"
set N=N+1
set B[N]='rre2'
set M[N]="runeofgreaterresurrection"
set N=N+1
set B[N]='rhe2'
set M[N]="runeofhealing"
set N=N+1
set B[N]='rhe1'
set M[N]="runeoflesserhealing"
set N=N+1
set B[N]='rre1'
set M[N]="runeoflesserresurrection"
set N=N+1
set B[N]='rman'
set M[N]="runeofmana"
set N=N+1
set B[N]='rreb'
set M[N]="runeofrebirth"
set N=N+1
set B[N]='rres'
set M[N]="runeofrestoration"
set N=N+1
set B[N]='rsps'
set M[N]="runeofshielding"
set N=N+1
set B[N]='rspd'
set M[N]="runeofspeed"
set N=N+1
set B[N]='rspl'
set M[N]="runeofspiritlink"
set N=N+1
set B[N]='rwat'
set M[N]="runeofthewatcher"
set N=N+1
set B[N]='ratf'
set M[N]="clawsofattack+15"
set N=N+1
set B[N]='ckng'
set M[N]="crownofkings+5"
set N=N+1
set B[N]='desc'
set M[N]="kelensdaggerofescape"
set N=N+1
set B[N]='modt'
set M[N]="maskofdeath"
set N=N+1
set B[N]='ofro'
set M[N]="orboffrost"
set N=N+1
set B[N]='rde4'
set M[N]="ringofprotection+5"
set N=N+1
set B[N]='pclr'
set M[N]="claritypotion"
set N=N+1
set B[N]='hslv'
set M[N]="healingsalve"
set N=N+1
set B[N]='tsct'
set M[N]="ivorytower"
set N=N+1
set B[N]='plcl'
set M[N]="lesserclaritypotion"
set N=N+1
set B[N]='mcri'
set M[N]="mechanicalcritter"
set N=N+1
set B[N]='moon'
set M[N]="moonstone"
set N=N+1
set B[N]='phea'
set M[N]="potionofhealing"
set N=N+1
set B[N]='pinv'
set M[N]="potionofinvisibility"
set N=N+1
set B[N]='pnvl'
set M[N]="potionoflesserinvulnerability"
set N=N+1
set B[N]='pman'
set M[N]="potionofmana"
set N=N+1
set B[N]='rnec'
set M[N]="rodofnecromancy"
set N=N+1
set B[N]='skul'
set M[N]="sacrificialskull"
set N=N+1
set B[N]='shea'
set M[N]="scrollofhealing"
set N=N+1
set B[N]='sman'
set M[N]="scrollofmana"
set N=N+1
set B[N]='spro'
set M[N]="scrollofprotection"
set N=N+1
set B[N]='sreg'
set M[N]="scrollofregeneration"
set N=N+1
set B[N]='shas'
set M[N]="scrollofspeed"
set N=N+1
set B[N]='stwp'
set M[N]="scrolloftownportal"
set N=N+1
set B[N]='silk'
set M[N]="spidersilkbroach"
set N=N+1
set B[N]='sneg'
set M[N]="staffofnegation"
set N=N+1
set B[N]='ssan'
set M[N]="staffofsanctuary"
set N=N+1
set B[N]='tcas'
set M[N]="tinycastle"
set N=N+1
set B[N]='tgrh'
set M[N]="tinygreathall"
set N=N+1
set B[N]='tret'
set M[N]="tomeofretraining"
set N=N+1
set B[N]='vamp'
set M[N]="vampiricpotion"
set N=N+1
set B[N]='wneg'
set M[N]="wandofnegation"
set N=N+1
set B[N]='wneu'
set M[N]="wandofneutralization"
set N=N+1
set B[N]='kybl'
set M[N]="bloodkey"
set N=N+1
set B[N]='ches'
set M[N]="cheese"
set N=N+1
set B[N]='bzbe'
set M[N]="emptyvial"
set N=N+1
set B[N]='engs'
set M[N]="enchantedgemstone"
set N=N+1
set B[N]='bzbf'
set M[N]="fullvial"
set N=N+1
set B[N]='gmfr'
set M[N]="gemfragment"
set N=N+1
set B[N]='ledg'
set M[N]="gerard'slostledger"
set N=N+1
set B[N]='kygh'
set M[N]="ghostkey"
set N=N+1
set B[N]='gopr'
set M[N]="glyphofpurification"
set N=N+1
set B[N]='azhr'
set M[N]="hearofaszune"
set N=N+1
set B[N]='cnhn'
set M[N]="hornofcenarius"
set N=N+1
set B[N]='dkfw'
set M[N]="kegofthunderwater"
set N=N+1
set B[N]='k3m3'
set M[N]="keyofthreemoons"
set N=N+1
set B[N]='mgtk'
set M[N]="magickeychain"
set N=N+1
set B[N]='mort'
set M[N]="mogrin'sreport"
set N=N+1
set B[N]='kymn'
set M[N]="moonkey"
set N=N+1
set B[N]='k3m1'
set M[N]="mooncrystal"
set N=N+1
set B[N]='jpnt'
set M[N]="notetojainaproudmoore"
set N=N+1
set B[N]='k3m2'
set M[N]="partialkeyofthethreemoons"
set N=N+1
set B[N]='phlt'
set M[N]="phatlewt"
set N=N+1
set B[N]='sclp'
set M[N]="secretlevelpowerup"
set N=N+1
set B[N]='sorf'
set M[N]="shadoworbfragment"
set N=N+1
set B[N]='shwd'
set M[N]="shimmerweed"
set N=N+1
set B[N]='skrt'
set M[N]="skeletalartifact"
set N=N+1
set B[N]='glsk'
set M[N]="skullofgul'dan"
set N=N+1
set B[N]='kysn'
set M[N]="sunkey"
set N=N+1
set B[N]='sehr'
set M[N]="theheartofsearinox"
set N=N+1
set B[N]='thle'
set M[N]="thunderlizardegg"
set N=N+1
set B[N]='dphe'
set M[N]="thunderphoenixegg"
set N=N+1
set B[N]='dthb'
set M[N]="thunderbloombulb"
set N=N+1
set B[N]='ktrm'
set M[N]="urnofkingterenas"
set N=N+1
set B[N]='wtlg'
set M[N]="wirt'sleg"
set N=N+1
set B[N]='wolg'
set M[N]="wirt'sotherleg"
set N=N+1
set B[N]='amrc'
set M[N]="amuletofrecall"
set N=N+1
set B[N]='axas'
set M[N]="ancestralstaff"
set N=N+1
set B[N]='anfg'
set M[N]="ancientfigurine"
set N=N+1
set B[N]='pams'
set M[N]="anti-magicpotion"
set N=N+1
set B[N]='arsc'
set M[N]="arcanescroll"
set N=N+1
set B[N]='arsh'
set M[N]="arcaniteshield"
set N=N+1
set B[N]='asbl'
set M[N]="assassin'sblade"
set N=N+1
set B[N]='btst'
set M[N]="battlestandard"
set N=N+1
set B[N]='blba'
set M[N]="bladebanearmor"
set N=N+1
set B[N]='bfhr'
set M[N]="bloodfeather'sheart"
set N=N+1
set B[N]='brag'
set M[N]="bracerofagility"
set N=N+1
set B[N]='cosl'
set M[N]="celestialorbofsouls"
set N=N+1
set B[N]='rat3'
set M[N]="clawsofattack+3"
set N=N+1
set B[N]='stpg'
set M[N]="clockworkpenguin"
set N=N+1
set B[N]='crdt'
set M[N]="crownofthedeathlord"
set N=N+1
set B[N]='dtsb'
set M[N]="drek'thar'sspellbook"
set N=N+1
set B[N]='drph'
set M[N]="druidpouch"
set N=N+1
set B[N]='dust'
set M[N]="dustofappearance"
set N=N+1
set B[N]='shen'
set M[N]="enchantedshield"
set N=N+1
set B[N]='envl'
set M[N]="enchantedvial"
set N=N+1
set B[N]='esav'
set M[N]="essenceofaszune"
set N=N+1
set B[N]='frhg'
set M[N]="firehandgauntlets"
set N=N+1
set B[N]='fgun'
set M[N]="flaregun"
set N=N+1
set B[N]='fwss'
set M[N]="frostwyrmskullshield"
set N=N+1
set B[N]='frgd'
set M[N]="frostguard"
set N=N+1
set B[N]='gemt'
set M[N]="gemoftrueseeing"
set N=N+1
set B[N]='gvsm'
set M[N]="glovesofspellmastery"
set N=N+1
set B[N]='gobm'
set M[N]="goblinlandmines"
set N=N+1
set B[N]='tels'
set M[N]="goblinnightscope"
set N=N+1
set B[N]='rej4'
set M[N]="greaterreplenishmentpotion"
set N=N+1
set B[N]='rej6'
set M[N]="greaterscrollofreplenishment"
set N=N+1
set B[N]='grsl'
set M[N]="grimoireofsouls"
set N=N+1
set B[N]='hbth'
set M[N]="helmofbattlethirst"
set N=N+1
set B[N]='sfog'
set M[N]="hornoftheclouds"
set N=N+1
set B[N]='flag'
set M[N]="humanflag"
set N=N+1
set B[N]='iwbr'
set M[N]="ironwoodbranch"
set N=N+1
set B[N]='jdrn'
set M[N]="jadering"
set N=N+1
set B[N]='kgal'
set M[N]="kegofale"
set N=N+1
set B[N]='klmm'
set M[N]="killmaim"
set N=N+1
set B[N]='rej2'
set M[N]="lesserreplenishmentpotion"
set N=N+1
set B[N]='rej5'
set M[N]="lesserscrollofreplenishment"
set N=N+1
set B[N]='lnrn'
set M[N]="lion'sring"
set N=N+1
set B[N]='mlst'
set M[N]="maulofstrength"
set N=N+1
set B[N]='mnsf'
set M[N]="mindstaff"
set N=N+1
set B[N]='rej1'
set M[N]="minorreplenishmentpotion"
set N=N+1
set B[N]='lure'
set M[N]="monsterlure"
set N=N+1
set B[N]='nspi'
set M[N]="necklaceofspellimmunity"
set N=N+1
set B[N]='nflg'
set M[N]="nightelfflag"
set N=N+1
set B[N]='ocor'
set M[N]="orbofcorruption"
set N=N+1
set B[N]='ofir'
set M[N]="orboffire"
set N=N+1
set B[N]='gldo'
set M[N]="orbofkil'jaeden"
set N=N+1
set B[N]='olig'
set M[N]="orboflightning"
set N=N+1
set B[N]='oli2'
set M[N]="orboflightning2"
set N=N+1
set B[N]='oslo'
set M[N]="orbofslow"
set N=N+1
set B[N]='oven'
set M[N]="orbofvenom"
set N=N+1
set B[N]='oflg'
set M[N]="orcflag"
set N=N+1
set B[N]='pgin'
set M[N]="potionofgreaterinvisibility"
set N=N+1
set B[N]='pspd'
set M[N]="potionofspeed"
set N=N+1
set B[N]='rde0'
set M[N]="ringofprotection+1"
set N=N+1
set B[N]='rnsp'
set M[N]="ringofsuperiority"
set N=N+1
set B[N]='ram1'
set M[N]="ringofthearchmagi+1"
set N=N+1
set B[N]='ram4'
set M[N]="ringofthearchmagi+4"
set N=N+1
set B[N]='ram2'
set M[N]="ringofthearchmagi+2"
set N=N+1
set B[N]='ram3'
set M[N]="ringofthearchmagi+3"
set N=N+1
set B[N]='ram4'
set M[N]="ringofthearchmagi"
set N=N+1
set B[N]='rugt'
set M[N]="runedgauntlets"
set N=N+1
set B[N]='rump'
set M[N]="rustyminingpick"
set N=N+1
set B[N]='horl'
set M[N]="sacredrelic"
set N=N+1
set B[N]='schl'
set M[N]="scepterofhealing"
set N=N+1
set B[N]='ccmd'
set M[N]="scepterofmastery"
set N=N+1
set B[N]='rots'
set M[N]="scepterofthesea"
set N=N+1
set B[N]='scul'
set M[N]="scrolloftheunholylegion"
set N=N+1
set B[N]='srbd'
set M[N]="searingblade"
set N=N+1
set B[N]='srtl'
set M[N]="serathil"
set N=N+1
set B[N]='sor1'
set M[N]="shadoworb+1"
set N=N+1
set B[N]='sora'
set M[N]="shadoworb+10"
set N=N+1
set B[N]='sora'
set M[N]="shadoworb"
set N=N+1
set B[N]='sor2'
set M[N]="shadoworb+2"
set N=N+1
set B[N]='sor3'
set M[N]="shadoworb+3"
set N=N+1
set B[N]='sor4'
set M[N]="shadoworb+4"
set N=N+1
set B[N]='sor5'
set M[N]="shadoworb+5"
set N=N+1
set B[N]='sor6'
set M[N]="shadoworb+6"
set N=N+1
set B[N]='sor7'
set M[N]="shadoworb+7"
set N=N+1
set B[N]='sor8'
set M[N]="shadoworb+8"
set N=N+1
set B[N]='sor9'
set M[N]="shadoworb+9"
set N=N+1
set B[N]='shcw'
set M[N]="shamanclaws"
set N=N+1
set B[N]='shtm'
set M[N]="shamanictotem"
set N=N+1
set B[N]='shhn'
set M[N]="shieldofhonor"
set N=N+1
set B[N]='shdt'
set M[N]="shieldofthedeathlord"
set N=N+1
set B[N]='shrs'
set M[N]="shimmerglazeroast"
set N=N+1
set B[N]='sksh'
set M[N]="skullshield"
set N=N+1
set B[N]='soul'
set M[N]="soul"
set N=N+1
set B[N]='gsou'
set M[N]="soulgem"
set N=N+1
set B[N]='sbok'
set M[N]="spellbook"
set N=N+1
set B[N]='sprn'
set M[N]="spiderring"
set N=N+1
set B[N]='spre'
set M[N]="staffofpreservation"
set N=N+1
set B[N]='stre'
set M[N]="staffofreanimation"
set N=N+1
set B[N]='stwa'
set M[N]="sturdywaraxe"
set N=N+1
set B[N]='thdm'
set M[N]="thunderlizarddiamond"
set N=N+1
set B[N]='tbak'
set M[N]="tinyaltarofkings"
set N=N+1
set B[N]='tbar'
set M[N]="tinybarracks"
set N=N+1
set B[N]='tbsm'
set M[N]="tinyblacksmith"
set N=N+1
set B[N]='tfar'
set M[N]="tinyfarm"
set N=N+1
set B[N]='tlum'
set M[N]="tinylumbermill"
set N=N+1
set B[N]='tmsc'
set M[N]="tomeofsacrifices"
set N=N+1
set B[N]='tmmt'
set M[N]="totemofmight"
set N=N+1
set B[N]='uflg'
set M[N]="undeadflag"
set N=N+1
set B[N]='vddl'
set M[N]="voodoodoll"
set N=N+1
call DestroyTrigger(GetTriggeringTrigger())
endfunction
function E_V takes nothing returns boolean
set LR=InitHashtable()
return true
endfunction
function E0V takes nothing returns nothing
call GroupRemoveUnit(dl,LoadUnitHandle(i,y,GetHandleId(GetExpiredTimer())))
call Gmv(GetExpiredTimer())
endfunction
function E1V takes nothing returns boolean
set ER="0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
set ZR="0123456789"
call GZv(ZR)
call GZv(ER)
return true
endfunction
function E2V takes nothing returns boolean
return(ls[GetConvertedPlayerId(GetTriggerPlayer())])
endfunction
function E3V takes nothing returns nothing
set g[GetConvertedPlayerId(GetTriggerPlayer())]=GetUnitsOfPlayerAndTypeId(GetTriggerPlayer(),'h000')
call ForGroupBJ(g[GetConvertedPlayerId(GetTriggerPlayer())],x8v)
call DestroyGroup(g[GetPlayerId(GetTriggerPlayer())+1])
call DisplayTextToForce(GetPlayersAll(),k[GetConvertedPlayerId(GetTriggerPlayer())-1]+GetPlayerName(GetTriggerPlayer())+"|R|CFF808040 вышел из игры.|R")
if E2V()then
call DisplayTextToForce(GetPlayersAll(),"TRIGSTR_1122")
set ls[GetConvertedPlayerId(GetTriggerPlayer())]=false
set ls[0]=true
endif
endfunction
function E4V takes nothing returns boolean
return(GetEventPlayerChatString()=="item "+M[GetForLoopIndexA()])
endfunction
function E5V takes nothing returns nothing
set g[GetConvertedPlayerId(GetTriggerPlayer())]=GetUnitsOfPlayerAndTypeId(GetTriggerPlayer(),'h000')
set bj_forLoopAIndex=0
set bj_forLoopAIndexEnd=N
loop
exitwhen bj_forLoopAIndex>bj_forLoopAIndexEnd
if E4V()then
call ForGroupBJ(g[GetConvertedPlayerId(GetTriggerPlayer())],e1v)
endif
set bj_forLoopAIndex=bj_forLoopAIndex+1
endloop
call DestroyGroup(g[GetPlayerId(GetTriggerPlayer())+1])
endfunction
function E6V takes nothing returns boolean
return GetSpellAbilityId()=='A0IG'
endfunction
function E7V takes nothing returns nothing
call KillDestructable(GetEnumDestructable())
endfunction
function E8V takes nothing returns boolean
if GetSpellAbilityId()=='A0HY' then
return true
else
return false
endif
endfunction
function E9V takes nothing returns boolean
return IsUnitSelected(GetFilterUnit(),GetTriggerPlayer())
endfunction
function XvV takes string XeV returns boolean
set ZM[EM]=XeV
set EM=EM+1
set va=Ctv("when calling new_HashMap in RegisterEvents, line 55")
call qQa(EVENT_PLAYER_UNIT_SPELL_EFFECT,OZv)
set EM=EM-1
return true
endfunction
function XxV takes nothing returns boolean
set EM=0
return XvV("RegisterEvents, line 1")
endfunction
function XoV takes nothing returns boolean
set pp=$C8
return true
endfunction
function XrV takes nothing returns nothing
local integer XiV=Hl
local integer XaV=XiV+4096
if XaV<Jl then
set Hl=XaV
call ForForce(bj_FORCE_PLAYER[0],Iz)
else
set XaV=Jl
endif
loop
call FlushChildHashtable(i,XiV)
set XiV=XiV+1
exitwhen XiV==XaV
endloop
endfunction
function XnV takes nothing returns nothing
local unit XVV
if GetUnitAbilityLevel(GetTriggerUnit(),'B05G')==0 then
set XVV=null
return
endif
set XVV=GetTriggerUnit()
if GetUnitAbilityLevel(XVV,'BHds')>0 or GetUnitAbilityLevel(XVV,'B04Q')>0 or GetUnitAbilityLevel(XVV,'B05C')>0 or GetUnitAbilityLevel(XVV,'B05D')>0 or GetUnitAbilityLevel(XVV,'B05E')>0 or GetUnitAbilityLevel(XVV,'B05F')>0 then
call UnitRemoveAbility(XVV,'BHds')
call UnitRemoveAbility(XVV,'B04Q')
call UnitRemoveAbility(XVV,'B05C')
call UnitRemoveAbility(XVV,'B05D')
call UnitRemoveAbility(XVV,'B05E')
call UnitRemoveAbility(XVV,'B05F')
else
call GBv('A0M9',GetUnitAbilityLevel(GetEventDamageSource(),'A0MA'),"acidbomb",XVV)
endif
call UnitRemoveAbility(XVV,'B05G')
set XVV=null
set XVV=null
endfunction
function XEV takes nothing returns boolean
return GetBooleanAnd(IsUnitAliveBJ(GetFilterUnit()),IsUnitEnemy(GetFilterUnit(),GetOwningPlayer(Nu)))
endfunction
function XXV takes nothing returns boolean
set ra=Filter(Ozv)
return true
endfunction
function XOV takes nothing returns boolean
return(ww)and(SubStringBJ(GetEventPlayerChatString(),1,7)=="weather")
endfunction
function XRV takes integer XIV,integer XAV,string XNV returns nothing
set ZM[EM]=XNV
set EM=EM+1
if ph[XIV]==0 then
if XIV==0 then
call Cdv("Nullpointer exception when calling HashMap.remove","when calling error in HashMap, line 27")
else
call Cdv("Called HashMap.remove on invalid object.","when calling error in HashMap, line 27")
endif
endif
if ph[XIV]<=4898 then
call vfV(XIV,XAV,"when calling remove in HashMap, line 27")
else
call vhV(XIV,XAV,"when calling remove in HashMap, line 27")
endif
set EM=EM-1
endfunction
function XbV takes integer XBV,string XcV returns nothing
set ZM[EM]=XcV
set EM=EM+1
if MG[XBV]==0 then
call Cdv("Double free: object of type OnCastListener","when calling error in ClosureEvents, line 50")
else
set VG[BG]=XBV
set BG=BG+1
set MG[XBV]=0
endif
set EM=EM-1
endfunction
function XCV takes integer XdV,string XDV returns nothing
local integer XfV
local integer XFV
set ZM[EM]=XDV
set EM=EM+1
if jW[XdV]!=null then
set XfV=f3v(My,Hzo(jW[XdV]),"when calling get in ClosureEvents, line 60")
if XfV==XdV then
call fqv(My,Hzo(jW[XdV]),hW[XdV],"when calling put in ClosureEvents, line 62")
elseif FW[XdV]!=0 then
set hW[FW[XdV]]=hW[XdV]
endif
else
set XFV=f3v(Ny,kW[XdV],"when calling get in ClosureEvents, line 66")
if XFV==XdV then
call fqv(Ny,kW[XdV],hW[XdV],"when calling put in ClosureEvents, line 68")
elseif FW[XdV]!=0 then
set hW[FW[XdV]]=hW[XdV]
endif
endif
set FW[hW[XdV]]=FW[XdV]
set hW[XdV]=0
set FW[XdV]=0
set EM=EM-1
endfunction
function XgV takes integer XGV,string XhV returns nothing
set ZM[EM]=XhV
set EM=EM+1
call XCV(XGV,"when calling OnCastListener_onDestroy in ClosureEvents, line 58")
call XbV(XGV,"when calling dealloc_OnCastListener in ClosureEvents, line 58")
set EM=EM-1
endfunction
function XHV takes integer XjV,string XJV returns nothing
set ZM[EM]=XJV
set EM=EM+1
if MG[XjV]==0 then
if XjV==0 then
call Cdv("Nullpointer exception when calling OnCastListener.OnCastListener","when calling error in ClosureEvents, line 50")
else
call Cdv("Called OnCastListener.OnCastListener on invalid object.","when calling error in ClosureEvents, line 50")
endif
endif
call XgV(XjV,"when calling destroyOnCastListener in ClosureEvents, line 50")
set EM=EM-1
endfunction
function XkV takes integer XKV,string XlV returns nothing
set ZM[EM]=XlV
set EM=EM+1
if CG[XKV]==0 then
call Cdv("Double free: object of type EventListener","when calling error in ClosureEvents, line 98")
else
set KG[LG]=XKV
set LG=LG+1
set CG[XKV]=0
endif
set EM=EM-1
endfunction
function XLV takes integer XmV returns nothing
local integer XMV=wp[YW[XmV]]
if XMV==XmV then
set wp[YW[XmV]]=GW[XmV]
elseif gW[XmV]!=0 then
set GW[gW[XmV]]=GW[XmV]
endif
if GW[XmV]!=0 then
set gW[GW[XmV]]=gW[XmV]
endif
set XMV=up[YW[XmV]]
if XMV==XmV then
set up[YW[XmV]]=GW[XmV]
elseif gW[XmV]!=0 then
set GW[gW[XmV]]=GW[XmV]
endif
set GW[XmV]=0
set gW[XmV]=0
endfunction
function XpV takes integer XPV,string XqV returns nothing
set ZM[EM]=XqV
set EM=EM+1
call XLV(XPV)
call XkV(XPV,"when calling dealloc_EventListener in ClosureEvents, line 206")
set EM=EM-1
endfunction
function XQV takes integer XsV,string XSV returns nothing
set ZM[EM]=XSV
set EM=EM+1
if CG[XsV]==0 then
if XsV==0 then
call Cdv("Nullpointer exception when calling EventListener.EventListener","when calling error in ClosureEvents, line 98")
else
call Cdv("Called EventListener.EventListener on invalid object.","when calling error in ClosureEvents, line 98")
endif
endif
call XpV(XsV,"when calling destroyEventListener in ClosureEvents, line 98")
set EM=EM-1
endfunction
function XtV takes integer XTV,string XuV returns nothing
local integer XUV
local integer XwV
set ZM[EM]=XuV
set EM=EM+1
if XTV>0 then
if up[XTV]!=0 then
call lpa("unregister unit has listeners. startid: "+SMv(XTV))
set XUV=up[XTV]
set up[XTV]=0
loop
exitwhen not(XUV!=0)
set XwV=XUV
set XUV=GW[XUV]
call XQV(XwV,"when calling dispatch_EventListener_destroyEventListener in ClosureEvents, line 284")
endloop
endif
endif
set EM=EM-1
endfunction
function XWV takes unit XyV,string XYV returns nothing
local integer XzV
local integer XZV
local integer X_V
local integer X0V
set ZM[EM]=XYV
set EM=EM+1
if q5a(XyV)then
call XtV(UHx(XyV),"when calling unregisterEvents in ClosureEvents, line 260")
if fov(My,Hzo(XyV),"when calling has in ClosureEvents, line 261")then
set XzV=f3v(My,Hzo(XyV),"when calling get in ClosureEvents, line 262")
call XRV(My,Hzo(XyV),"when calling remove in ClosureEvents, line 263")
loop
exitwhen not(XzV!=0)
set XZV=XzV
set XzV=hW[XzV]
call XHV(XZV,"when calling dispatch_OnCastListener_destroyOnCastListener in ClosureEvents, line 267")
endloop
endif
if fov(My,Hzo(XyV),"when calling has in ClosureEvents, line 268")then
set X_V=f3v(My,Hzo(XyV),"when calling get in ClosureEvents, line 269")
loop
exitwhen not(X_V!=0)
set X0V=X_V
set X_V=hW[X_V]
call XHV(X0V,"when calling dispatch_OnCastListener_destroyOnCastListener in ClosureEvents, line 273")
endloop
endif
endif
set EM=EM-1
endfunction
function X1V takes nothing returns unit
return hT[FT-1]
endfunction
function X2V takes string X3V returns nothing
set ZM[EM]=X3V
set EM=EM+1
call XWV(X1V(),"when calling unregisterEventsForUnit in ClosureEvents, line 290")
set EM=EM-1
endfunction
function X4V takes nothing returns nothing
set EM=0
call X2V("ClosureEvents, line 290")
endfunction
function X5V takes nothing returns nothing
call UnitDamageTargetBJ(Nu,GetEnumUnit(),Uu,ATTACK_TYPE_NORMAL,DAMAGE_TYPE_FIRE)
call AddSpecialEffectTargetUnitBJ("origin",GetEnumUnit(),"Abilities\\Spells\\Other\\Incinerate\\FireLordDeathExplode.mdl")
call DestroyEffectBJ(GetLastCreatedEffectBJ())
endfunction
function X6V takes nothing returns boolean
call PreloadGenClear()
return true
endfunction
function X7V takes integer X8V returns nothing
loop
exitwhen eb[X8V]==0
set eb[X8V]=eb[X8V]-1
call DestroyLightning(LoadLightningHandle(i,pb[X8V],eb[X8V]))
endloop
call FlushChildHashtable(i,pb[X8V])
endfunction
function X9V takes integer OvV,real OeV,real OxV,real OoV,real OrV returns nothing
local lightning OiV=AddLightning(ab[OvV],false,OeV,OxV,OoV,OrV)
if s!=r[qb[OvV]]then
call SetLightningColor(OiV,.0,.0,.0,.0)
endif
call SaveLightningHandle(i,pb[OvV],eb[OvV],OiV)
set OiV=null
set eb[OvV]=eb[OvV]+1
set OiV=null
endfunction
function OaV takes real OnV returns real
local real OVV=I2R(R2I(OnV))
if OVV==OnV or OnV<.0 then
return OVV
else
return OVV+1.
endif
endfunction
function OEV takes integer OXV,real OOV,real ORV,real OIV returns nothing
local integer OAV=R2I(OaV(RAbsBJ(OIV/yb)))
local real ONV=OIV/OAV
loop
exitwhen OAV==0
call X9V(OXV,OOV,ORV,OOV+ONV,ORV)
set OOV=OOV+ONV
set OAV=OAV-1
endloop
endfunction
function ObV takes integer OBV,real OcV,real OCV,real OdV returns nothing
local integer ODV=R2I(OaV(RAbsBJ(OdV/yb)))
local real OfV=OdV/ODV
loop
exitwhen ODV==0
call X9V(OBV,OcV,OCV,OcV,OCV+OfV)
set OCV=OCV+OfV
set ODV=ODV-1
endloop
endfunction
function OFV takes integer OgV returns nothing
call OEV(OgV,Rb[OgV],Tb[OgV],Yb[OgV]-Rb[OgV])
call OEV(OgV,Yb[OgV],Gb[OgV],Rb[OgV]-Yb[OgV])
call ObV(OgV,Rb[OgV],Gb[OgV],Tb[OgV]-Gb[OgV])
call ObV(OgV,Yb[OgV],Tb[OgV],Gb[OgV]-Tb[OgV])
endfunction
function OGV takes nothing returns boolean
local integer OhV=sy
call X7V(OhV)
call SetRect(fb[OhV],Rb[OhV],Tb[OhV],Yb[OhV],Gb[OhV])
call OFV(OhV)
return true
endfunction
function OHV takes nothing returns nothing
call UnitDamageTarget(ht,GetEnumUnit(),$F*gt,true,true,ATTACK_TYPE_NORMAL,DAMAGE_TYPE_MAGIC,WEAPON_TYPE_WHOKNOWS)
endfunction
function OjV takes nothing returns nothing
local unit OJV=CreateUnitAtLoc(Player(PLAYER_NEUTRAL_PASSIVE),'h0JO',GetUnitLoc(GetEnumUnit()),270.)
call UnitAddAbility(OJV,'A0KW')
call IssueTargetOrderById(OJV,$D0065,GetEnumUnit())
call oLn(OJV,3.)
set OJV=null
set OJV=null
endfunction
function OkV takes nothing returns boolean
return GetSpellAbilityId()=='Asw1' or GetSpellAbilityId()=='Asw2'
endfunction
function OKV takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),1,5)=="time ")
endfunction
function OlV takes nothing returns nothing
set g[GetConvertedPlayerId(GetTriggerPlayer())]=GetUnitsOfPlayerAndTypeId(GetOwningPlayer(GetSoldUnit()),'h000')
call ForGroupBJ(g[GetConvertedPlayerId(GetTriggerPlayer())],oiv)
call DestroyGroup(g[GetPlayerId(GetTriggerPlayer())+1])
endfunction
function OLV takes nothing returns boolean
return(Bw[1]==0)
endfunction
function OmV takes nothing returns nothing
if OLV()then
call EnableTrigger(HS)
endif
set Bw[1]=Bw[1]+1
set Bw[2]=Bw[2]+1
set Nw[1]=GetUnitLoc(Mw)
set wu[Bw[2]]=DistanceBetweenPoints(Nw[1],uu)
set ru[Bw[2]]=.0
set su[Bw[2]]=tu
set iu[Bw[2]]=Mw
set Su[Bw[2]]=AngleBetweenPoints(Nw[1],uu)
set cu[Bw[2]]=ou
set Ou[Bw[2]]=lu
set bu[Bw[2]]=yu
set pu[Bw[2]]=eu*wu[Bw[2]]
call SetUnitPathing(Mw,false)
call SetUnitTimeScalePercent(Mw,qu*100.)
call SetUnitAnimation(Mw,lu)
call GroupAddUnitSimple(Mw,au)
call UnitAddAbilityBJ('Arav',Mw)
call UnitRemoveAbilityBJ('Arav',Mw)
call RemoveLocation(Nw[1])
call RemoveLocation(uu)
endfunction
function OMV takes nothing returns boolean
return SubString(GetEventPlayerChatString(),0,1)=="@"
endfunction
function OpV takes nothing returns boolean
set Fe="ReplaceableTextures\\CommandButtons\\BTNSelectHeroOn.blp"
set ke="ReplaceableTextures\\CommandButtons\\BTNSell.blp"
return true
endfunction
function OPV takes nothing returns nothing
set g[GetConvertedPlayerId(GetTriggerPlayer())]=GetUnitsOfPlayerAll(GetTriggerPlayer())
call ForGroupBJ(g[GetConvertedPlayerId(GetTriggerPlayer())],eNv)
call DestroyGroup(g[GetPlayerId(GetTriggerPlayer())+1])
endfunction
function OqV takes nothing returns nothing
local integer OQV
local integer gxa
local integer OsV
local integer OSV
local integer OtV
set Gy[0]=1
set OQV=1
set gxa=1
set OsV=hy
loop
exitwhen gxa>OsV
set Gy[gxa]=Gy[gxa-1]*2
set OQV=BlzBitOr(OQV,Gy[gxa])
set gxa=gxa+1
endloop
set OSV=0
set OtV=hy
loop
exitwhen OSV>OtV
set gy[OSV]=BlzBitXor(OQV,Gy[OSV])
set OSV=OSV+1
endloop
endfunction
function OTV takes nothing returns boolean
set hy=31
call OqV()
return true
endfunction
function OuV takes integer OUV,integer OwV,string OWV returns nothing
set ZM[EM]=OWV
set EM=EM+1
set vJ[OUV]=true
call zGv(jJ[OUV],OwV,"when calling add in ScmdDataTypes, line 1400")
set EM=EM-1
endfunction
function OyV takes integer OYV,integer OzV,string OZV returns nothing
set ZM[EM]=OZV
set EM=EM+1
if ax[OYV]==0 then
if OYV==0 then
call Cdv("Nullpointer exception when calling BuiltinData.setVariadicArgumentTypes","when calling error in ScmdDataTypes, line 1397")
else
call Cdv("Called BuiltinData.setVariadicArgumentTypes on invalid object.","when calling error in ScmdDataTypes, line 1397")
endif
endif
call OuV(OYV,OzV,"when calling setVariadicArgumentTypes in ScmdDataTypes, line 1397")
set EM=EM-1
endfunction
function O_V takes string O0V returns integer
local integer O1V
set ZM[EM]=O0V
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set O1V=Yj
set Gj[O1V]=$B99
else
call Cdv("Out of memory: Could not create IBuiltin_setVariadicArgumentTypes_ScmdParser.","when calling error in ScmdParser, line 147")
set O1V=0
endif
else
set Tj=Tj-1
set O1V=Rj[Tj]
set Gj[O1V]=$B99
endif
set EM=EM-1
return O1V
endfunction
function O2V takes string O3V returns boolean
local integer O4V
local integer O5V
set ZM[EM]=O3V
set EM=EM+1
set O4V=O_V("when calling alloc_IBuiltin_setVariadicArgumentTypes_ScmdParser in ScmdParser, line 147")
set O5V=OPo(O4V,"when calling new_BuiltinData in ScmdParser, line 147")
call OyV(O5V,xdV(),"when calling setVariadicArgumentTypes in ScmdParser, line 152")
set Yd=p0v(ILo(O5V,"when calling new_BuiltinFunction in ScmdParser, line 147"),"when calling new_SharedPointer in ScmdParser, line 147")
set EM=EM-1
return true
endfunction
function O6V takes nothing returns boolean
set EM=0
return O2V("ScmdParser, line 1")
endfunction
function O7V takes nothing returns boolean
return GetBooleanAnd(IsUnitAliveBJ(GetFilterUnit()),IsUnitEnemy(GetFilterUnit(),GetOwningPlayer(Nu)))
endfunction
function O8V takes string O9V returns nothing
local integer RvV
local integer ReV
local integer RxV
set ZM[EM]=O9V
set EM=EM+1
set RvV=C0v(GetTriggeringTrigger())
set ReV=0
set RxV=c8v(pd,RvV,-1)-1
loop
exitwhen ReV>RxV
call xda(8,fwv(ed,RvV,"when calling loadInt in ScmdDataTypes, line 936"),c8v(pd,RvV,ReV),"when calling resolve in ScmdDataTypes, line 936",0,null,0,null)
call mfv(20,RJv,"when calling dispatch_GenericSharedPointer_destroyGenericSharedPointer in ScmdDataTypes, line 936")
set ReV=ReV+1
endloop
set EM=EM-1
endfunction
function RoV takes nothing returns nothing
set EM=0
call O8V("ScmdDataTypes, line 933")
endfunction
function RrV takes nothing returns nothing
set Ju[8]=GetUnitLoc(GetEnumUnit())
call CreateNUnitsAtLoc(1,'h0LE',GetOwningPlayer(Nu),Ju[8],bj_UNIT_FACING)
call UnitAddAbilityBJ('A06C',GetLastCreatedUnit())
call IssueTargetOrderBJ(GetLastCreatedUnit(),"slow",GetEnumUnit())
call GroupAddUnitSimple(GetLastCreatedUnit(),Ku)
call SaveIntegerBJ(Du+2,0,GetHandleIdBJ(GetLastCreatedUnit()),Au)
call RemoveLocation(Ju[8])
endfunction
function RiV takes nothing returns nothing
call DestroyEffect(AddSpecialEffectTarget("Abilities\\Spells\\Orc\\Bladestorm\\Bladestorm.mdx",GetSpellAbilityUnit(),"origin"))
endfunction
function RaV takes nothing returns boolean
return(GetSpellAbilityId()=='A0HQ')
endfunction
function RnV takes nothing returns nothing
local unit RVV=GetEnumUnit()
local unit REV=CreateUnitAtLoc(Player($F),'h0JO',GetUnitLoc(RVV),270.)
call UnitAddAbility(REV,'A08Z')
call SetUnitAbilityLevel(REV,'A08Z',GetUnitAbilityLevel(GetSpellAbilityUnit(),'A08Y'))
call IssueTargetOrderById(REV,$D006A,RVV)
call oLn(REV,3.)
set RVV=null
set REV=null
set RVV=null
set REV=null
endfunction
function RXV takes nothing returns nothing
call SetUnitState(GetSpellAbilityUnit(),UNIT_STATE_MANA,GetUnitState(GetSpellAbilityUnit(),UNIT_STATE_MANA)+50.)
endfunction
function ROV takes nothing returns boolean
return GetSpellAbilityId()=='A054'
endfunction
function RRV takes nothing returns nothing
call GroupRemoveUnitSimple(GetSpellTargetUnit(),us)
call GroupRemoveUnitSimple(GetSpellTargetUnit(),ws)
call GroupRemoveUnitSimple(GetSpellTargetUnit(),St)
call GroupRemoveUnitSimple(GetSpellTargetUnit(),tt)
call GroupRemoveUnitSimple(GetSpellTargetUnit(),cs)
call GroupRemoveUnitSimple(GetSpellTargetUnit(),ys)
call GroupRemoveUnitSimple(GetSpellTargetUnit(),rs)
endfunction
function RIV takes nothing returns boolean
return(GetEventPlayerChatString()=="'etherealform")
endfunction
function RAV takes nothing returns boolean
return(GetEventPlayerChatString()=="@etherealform")
endfunction
function RNV takes nothing returns nothing
set g[GetConvertedPlayerId(GetTriggerPlayer())]=GetUnitsOfPlayerMatching(GetTriggerPlayer(),Condition(rtv))
if RIV()then
call ForGroupBJ(g[GetConvertedPlayerId(GetTriggerPlayer())],rTv)
elseif RAV()then
call ForGroupBJ(g[GetConvertedPlayerId(GetTriggerPlayer())],ruv)
endif
call DestroyGroup(g[GetPlayerId(GetTriggerPlayer())+1])
endfunction
function RbV takes integer RBV,unit RcV,real RCV returns nothing
call TimerStart(Gpv(RBV,RcV),RCV,false,bz)
endfunction
function RdV takes nothing returns nothing
local unit RDV
if GetUnitAbilityLevel(GetKillingUnit(),'AObe')==0 then
set RDV=null
return
endif
set RDV=GetKillingUnit()
call GBv('ABbe',GetUnitAbilityLevel(RDV,'AObe'),"bloodlust",RDV)
call UnitAddAbility(RDV,'A0AO')
call UnitMakeAbilityPermanent(RDV,true,'A0AO')
call clv(RDV,'A0AO',GetUnitAbilityLevel(RDV,'AObe'))
call RbV(nl,RDV,15.)
set RDV=null
set RDV=null
endfunction
function RfV takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),1,4)=="item")
endfunction
function RFV takes nothing returns nothing
call UnitDamageTarget(Zr[kr[3]],GetEnumUnit(),75*(Qt[kr[3]]+1),true,true,ATTACK_TYPE_NORMAL,DAMAGE_TYPE_MAGIC,WEAPON_TYPE_WHOKNOWS)
endfunction
function RgV takes nothing returns boolean
return IsUnitSelected(GetFilterUnit(),GetTriggerPlayer())
endfunction
function RGV takes nothing returns nothing
local timer RhV=GetExpiredTimer()
local integer RHV=LoadInteger(i,y,GetHandleId(RhV))
call Gmv(RhV)
call RemoveSavedHandle(i,ub[Bl[RHV]],GetHandleId(Nl[RHV]))
call GKv(tb[Bl[RHV]],Nl[RHV])
call GKv(ib[Bl[RHV]],Nl[RHV])
call GJv(RHV)
set RhV=null
set RhV=null
endfunction
function RjV takes nothing returns nothing
call SetBlightRadiusLocBJ(true,GetEnumPlayer(),G,572.)
endfunction
function RJV takes nothing returns boolean
return(GetEventPlayerChatString()=="item firefinbow")
endfunction
function RkV takes nothing returns nothing
set g[GetConvertedPlayerId(GetTriggerPlayer())]=GetUnitsOfPlayerAndTypeId(GetTriggerPlayer(),'h000')
if RJV()then
call ForGroupBJ(g[GetConvertedPlayerId(GetTriggerPlayer())],rFv)
endif
call DestroyGroup(g[GetPlayerId(GetTriggerPlayer())+1])
endfunction
function RKV takes string RlV returns integer
local integer RLV
set ZM[EM]=RlV
set EM=EM+1
if pk==0 then
if ek<$8000 then
set ek=ek+1
set RLV=ek
set qk[RLV]=$C15
else
call Cdv("Out of memory: Could not create IdGenerator.","when calling error in ObjectIdGenerator, line 14")
set RLV=0
endif
else
set pk=pk-1
set RLV=yk[pk]
set qk[RLV]=$C15
endif
set EM=EM-1
return RLV
endfunction
function RmV takes integer wwt returns nothing
endfunction
function RMV takes integer RpV,integer RPV returns nothing
call RmV(RpV)
set TD[RpV]=ModuloInteger(RPV,256)
set YD[RpV]=ModuloInteger(RPV,65536)/256
set GD[RpV]=ModuloInteger(RPV,$1000000)/65536
set gD[RpV]=RPV/$1000000
endfunction
function RqV takes integer RQV,string RsV returns integer
local integer RSV
set ZM[EM]=RsV
set EM=EM+1
set RSV=RKV("when calling alloc_IdGenerator in ObjectIdGenerator, line 20")
call RMV(RSV,RQV)
set EM=EM-1
return RSV
endfunction
function RtV takes string RTV returns boolean
set ZM[EM]=RTV
set EM=EM+1
set eq=RqV('x000',"when calling new_IdGenerator in ObjectIdGenerator, line 7")
call RqV('HM00',"when calling new_IdGenerator in ObjectIdGenerator, line 8")
set qq=RqV('AM00',"when calling new_IdGenerator in ObjectIdGenerator, line 9")
call RqV('BM00',"when calling new_IdGenerator in ObjectIdGenerator, line 10")
call RqV('IM00',"when calling new_IdGenerator in ObjectIdGenerator, line 11")
call RqV('RM00',"when calling new_IdGenerator in ObjectIdGenerator, line 12")
set EM=EM-1
return true
endfunction
function RuV takes nothing returns boolean
set EM=0
return RtV("ObjectIdGenerator, line 1")
endfunction
function RUV takes nothing returns nothing
local unit RwV
local unit RWV
local integer RyV
local integer RYV
local group RzV
local timer RZV
if GetSpellAbilityId()!=JO then
set RwV=null
set RWV=null
set RzV=null
set RZV=null
return
endif
set RwV=GetSpellAbilityUnit()
set RWV=GetSpellTargetUnit()
set RYV=GetHandleId(RwV)
set RyV=LoadInteger(i,VO,RYV)
if RyV!=3 then
set RZV=cFv()
call SaveUnitHandle(i,NO,GetHandleId(RZV),RwV)
call TimerStart(RZV,.0,false,lz)
set RZV=null
call SaveInteger(i,VO,RYV,RyV+1)
endif
call RbV(XO,RwV,4.)
set RyV=GetUnitAbilityLevel(RwV,JO)
call GBv(KO,RyV,"attackonce",RwV)
call GBv(LO,RyV,"attackonce",RWV)
call SetWidgetLife(RWV,GetWidgetLife(RWV)+60*RyV)
set RzV=LoadGroupHandle(i,BO,RYV)
if RzV==null then
set RzV=CreateGroup()
call SaveGroupHandle(i,BO,RYV,RzV)
endif
call opV(CO,RWV)
call GroupAddUnit(RzV,RWV)
call SaveUnitHandle(i,NO,GetHandleId(RWV),RwV)
call SaveInteger(i,MO,GetHandleId(RWV),GetUnitAbilityLevel(RwV,JO))
call RbV(CO,RWV,8.)
set RzV=null
set RWV=null
set RwV=null
set RwV=null
set RWV=null
set RzV=null
set RZV=null
endfunction
function R_V takes nothing returns nothing
call KillUnit(GetEnumUnit())
endfunction
function R0V takes nothing returns nothing
local real R1V=I_e(Ae,Je,2048.,-2048.)
local real R2V=O1
local real R3V=R1V
local real R4V=R2V
local integer R5V=0
local integer R6V=xT-1
local real R7V
local real R8V
loop
exitwhen R5V>R6V
set R7V=I_e(R3V,R4V,256.,.0)
set R8V=O1
set R3V=R7V
set R4V=R8V
set R5V=R5V+1
endloop
endfunction
function R9V takes integer IvV,integer IeV returns integer
local integer IxV
local integer IoV
local integer IrV
local integer IiV
if IvV==3 then
set IxV=0
else
set IxV=IvV+1
endif
set IiV=IxV
if IvV==3 then
if IeV==2 then
set IoV=0
else
set IoV=IeV+1
endif
set IrV=IoV
else
set IrV=IeV
endif
set i6=IiV
set S6=IrV
return i6
endfunction
function IaV takes integer InV,string IVV returns nothing
set ZM[EM]=IVV
set EM=EM+1
if qk[InV]==0 then
call Cdv("Double free: object of type IdGenerator","when calling error in ObjectIdGenerator, line 14")
else
set yk[pk]=InV
set pk=pk+1
set qk[InV]=0
endif
set EM=EM-1
endfunction
function IEV takes integer iwt returns nothing
endfunction
function IXV takes integer IOV,string IRV returns nothing
set ZM[EM]=IRV
set EM=EM+1
call IEV(IOV)
call IaV(IOV,"when calling dealloc_IdGenerator in ObjectIdGenerator, line 14")
set EM=EM-1
endfunction
function IIV takes integer IAV,string INV returns nothing
set ZM[EM]=INV
set EM=EM+1
if qk[IAV]==0 then
if IAV==0 then
call Cdv("Nullpointer exception when calling IdGenerator.IdGenerator","when calling error in ObjectIdGenerator, line 14")
else
call Cdv("Called IdGenerator.IdGenerator on invalid object.","when calling error in ObjectIdGenerator, line 14")
endif
endif
call IXV(IAV,"when calling destroyIdGenerator in ObjectIdGenerator, line 14")
set EM=EM-1
endfunction
function IbV takes nothing returns integer
set s6=0
set t6=0
return s6
endfunction
function IBV takes string IcV returns nothing
local integer ICV
local integer IdV
local integer IDV
local integer IfV
local integer IFV
local integer IgV
local integer IGV
local integer IhV
local integer IHV
local integer IjV
local integer IJV
local integer IkV
local integer IKV
local integer IlV
set ZM[EM]=IcV
set EM=EM+1
if me and GZv(mT)!=2 then
endif
if me and GZv(QT)!=2 then
endif
set ICV=RqV(pEe(mT+"00","when calling fromRawCode in UnitShops, line 62"),"when calling new_IdGenerator in UnitShops, line 62")
set IHV=IbV()
set IjV=t6
set IdV=IHV
set IDV=IjV
set IfV=0
set IFV=jT-1
loop
exitwhen IfV>IFV
set IT[IfV]=l0a(ICV,"when calling next in UnitShops, line 65")
call fqv(HT,IT[IfV],IfV,"when calling put in UnitShops, line 66")
set IJV=IdV
set IkV=IDV
set PT[IfV]=IJV
set AT[IfV]=IkV
set IKV=R9V(IdV,IDV)
set IlV=S6
set IdV=IKV
set IDV=IlV
set IfV=IfV+1
endloop
call IIV(ICV,"when calling dispatch_IdGenerator_destroyIdGenerator in UnitShops, line 69")
set IgV=RqV(pEe(QT+"00","when calling fromRawCode in UnitShops, line 70"),"when calling new_IdGenerator in UnitShops, line 70")
set IGV=0
set IhV=jT-1
loop
exitwhen IGV>IhV
set DT[IGV]=l0a(IgV,"when calling next in UnitShops, line 72")
set IGV=IGV+1
endloop
call IIV(IgV,"when calling dispatch_IdGenerator_destroyIdGenerator in UnitShops, line 73")
set EM=EM-1
endfunction
function ILV takes string ImV returns integer
local integer IMV
set ZM[EM]=ImV
set EM=EM+1
if Qk==0 then
if Wk<$8000 then
set Wk=Wk+1
set IMV=Wk
set Ek[IMV]=$FFD
else
call Cdv("Out of memory: Could not create PlayerDefinedUnitTypesLoadCallback_registerPlayerDefinedUnitTypesLoadCallback_UnitShops.","when calling error in UnitShops, line 155")
set IMV=0
endif
else
set Qk=Qk-1
set IMV=mk[Qk]
set Ek[IMV]=$FFD
endif
set EM=EM-1
return IMV
endfunction
function IpV takes integer IPV returns nothing
set Nq[Bq]=IPV
set Bq=Bq+1
endfunction
function IqV takes string IQV returns nothing
local integer IsV
local integer ISV
local integer ItV
set ZM[EM]=IQV
set EM=EM+1
if me and GZv(mT)!=2 then
endif
set IsV=RqV(pEe(vT+"00","when calling fromRawCode in UnitShops, line 93"),"when calling new_IdGenerator in UnitShops, line 93")
set ISV=0
set ItV=xT-1
loop
exitwhen ISV>ItV
call l0a(IsV,"when calling next in UnitShops, line 95")
set ISV=ISV+1
endloop
call IIV(IsV,"when calling dispatch_IdGenerator_destroyIdGenerator in UnitShops, line 96")
set EM=EM-1
endfunction
function ITV takes string IuV returns boolean
local integer IUV
set ZM[EM]=IuV
set EM=EM+1
set kT[0]="Q"
set kT[1]="W"
set kT[2]="E"
set kT[3]="R"
set kT[4]="A"
set kT[5]="S"
set kT[6]="D"
set kT[7]="F"
set kT[8]="Z"
set kT[9]="X"
set kT[$A]="C"
set kT[$B]="V"
set jT='x'
set xT=$A
set vT="xs"
set mT="AT"
set QT="RT"
set WT=Fe
set ET="Пустой слот"
set ZT="Задать базовый тип"
set UT="Макс. здоровье: {0}
Макс. мана: {1}"
set HT=Ctv("when calling new_HashMap in UnitShops, line 54")
call IBV("when calling generateAbilitiesIds in UnitShops, line 152")
call IqV("when calling generateShopsIds in UnitShops, line 153")
call R0V()
set IUV=ILV("when calling alloc_PlayerDefinedUnitTypesLoadCallback_registerPlayerDefinedUnitTypesLoadCallback_UnitShops in UnitShops, line 155")
call IpV(IUV)
set EM=EM-1
return true
endfunction
function IwV takes nothing returns boolean
set EM=0
return ITV("UnitShops, line 1")
endfunction
function IWV takes unit IyV returns boolean
return UnitAlive(IyV)
endfunction
function IYV takes nothing returns boolean
return IWV(GetFilterUnit())
endfunction
function IzV takes nothing returns boolean
return true
endfunction
function IZV takes nothing returns boolean
set mq="|"
return true
endfunction
function I_V takes nothing returns boolean
return(ModuloReal(ir,2.)==.0)
endfunction
function I0V takes nothing returns boolean
return(DistanceBetweenPoints(Ju[7],Ju[5])<=Fu*5.)and(GetUnitFlyHeight(GetEnumUnit())<=10.)
endfunction
function I1V takes nothing returns boolean
return(DistanceBetweenPoints(Ju[7],Ju[5])<=Fu+10.)or(I0V())
endfunction
function I2V takes nothing returns boolean
return(I1V())
endfunction
function I3V takes nothing returns boolean
return(Mu==1)
endfunction
function I4V takes nothing returns boolean
return(Sr)
endfunction
function I5V takes nothing returns boolean
return(Mu==1)
endfunction
function I6V takes nothing returns boolean
return(Mu==2)
endfunction
function I7V takes nothing returns boolean
return(Yu)
endfunction
function I8V takes nothing returns boolean
return(Yu)
endfunction
function I9V takes nothing returns boolean
return(ModuloReal(ir,3.)==.0)
endfunction
function AvV takes nothing returns boolean
return(Mu==1)or(Mu==3)
endfunction
function AeV takes nothing returns boolean
return(CountUnitsInGroup(lr[rr])==0)and(AvV())
endfunction
function AxV takes nothing returns boolean
return(Mu==2)
endfunction
function AoV takes nothing returns boolean
return(CountUnitsInGroup(Lu)==0)
endfunction
function ArV takes nothing returns boolean
return(Mu==1)
endfunction
function AiV takes nothing returns nothing
set Ju[6]=GetUnitLoc(GetEnumUnit())
set Ju[7]=PolarProjectionBJ(Ju[6],Fu,AngleBetweenPoints(Ju[4],Ju[5]))
set yr=DistanceBetweenPoints(Ju[4],Ju[7])
call SetUnitPositionLoc(GetEnumUnit(),Ju[7])
call SetUnitFlyHeightBJ(GetEnumUnit(),4.*(hu/tr)*yr*((-(1.*yr))/tr+1.),.0)
if I2V()then
call KillUnit(GetEnumUnit())
call GroupRemoveUnitSimple(GetEnumUnit(),lr[rr])
call GroupAddUnitSimple(GetEnumUnit(),Ku)
call SaveIntegerBJ(Du+1,0,GetHandleIdBJ(GetEnumUnit()),Au)
if ArV()then
call AddSpecialEffectLocBJ(Ju[7],"Abilities\\Weapons\\FrostWyrmMissile\\FrostWyrmMissile.mdl")
call DestroyEffectBJ(GetLastCreatedEffectBJ())
elseif I6V()then
set ir=ir+1.
call SaveRealBJ(ir,$B,Bu,Au)
if I_V()then
set Ju[$A]=PolarProjectionBJ(Ju[5],GetRandomReal(Gu,Wu),GetRandomDirectionDeg())
call CreateNUnitsAtLocFacingLocBJ(1,'h00A',GetOwningPlayer(Nu),Ju[5],Ju[$A])
call GroupAddUnitSimple(GetLastCreatedUnit(),cr[rr])
call SaveLocationHandleBJ(Ju[$A],1,GetHandleIdBJ(GetLastCreatedUnit()),Au)
call SaveBooleanBJ(false,2,GetHandleIdBJ(GetLastCreatedUnit()),Au)
endif
if I9V()then
call AddSpecialEffectLocBJ(Ju[7],"Abilities\\Spells\\Other\\Doom\\DoomDeath.mdl")
call DestroyEffectBJ(GetLastCreatedEffectBJ())
endif
else
call AddSpecialEffectLocBJ(Ju[7],"Abilities\\Weapons\\ChimaeraLightningMissile\\ChimaeraLightningMissile.mdl")
call DestroyEffectBJ(GetLastCreatedEffectBJ())
endif
if I4V()then
if I7V()then
call ForForce(GetPlayersAll(),Y0)
endif
call SaveBooleanBJ(false,$C,Bu,Au)
call CreateUbersplatBJ(Ju[7],"DHLB",100.,100.,100.,.0,false,true)
call FinishUbersplat(GetLastCreatedUbersplat())
call SetUbersplatRenderAlways(GetLastCreatedUbersplat(),true)
set br=1
loop
exitwhen br>5
set Ju[8]=PolarProjectionBJ(Ju[7],GetRandomReal(50.,180.),GetRandomDirectionDeg())
if I5V()then
call CreateNUnitsAtLoc(1,'h0IE',GetOwningPlayer(Nu),Ju[8],GetRandomDirectionDeg())
call SetUnitTimeScalePercent(GetLastCreatedUnit(),20.)
elseif AxV()then
call CreateNUnitsAtLoc(1,'h006',GetOwningPlayer(Nu),Ju[8],GetRandomDirectionDeg())
else
call CreateNUnitsAtLoc(1,'h0LG',GetOwningPlayer(Nu),Ju[8],GetRandomDirectionDeg())
call SetUnitTimeScalePercent(GetLastCreatedUnit(),20.)
endif
call GroupAddUnitSimple(GetLastCreatedUnit(),Ku)
call UnitApplyTimedLifeBJ(5.,'BTLF',GetLastCreatedUnit())
call SaveIntegerBJ(Du+7,0,GetHandleIdBJ(GetLastCreatedUnit()),Au)
call RemoveLocation(Ju[8])
set br=br+1
endloop
set bj_wantDestroyGroup=true
call ForGroupBJ(GetUnitsInRangeOfLocMatching(Gu,Ju[7],Condition(z0)),Z0)
if I3V()then
set br=1
loop
exitwhen br>3
call CreateNUnitsAtLoc(1,'h0E1',GetOwningPlayer(Nu),Ju[7],bj_UNIT_FACING)
call KillUnit(GetLastCreatedUnit())
call GroupAddUnitSimple(GetLastCreatedUnit(),Ku)
call SaveIntegerBJ(Du+2,0,GetHandleIdBJ(GetLastCreatedUnit()),Au)
set br=br+1
endloop
set bj_wantDestroyGroup=true
call ForGroupBJ(GetUnitsInRangeOfLocMatching(Qu,Ju[7],Condition(z1)),z2)
endif
endif
set bj_wantDestroyGroup=true
call ForGroupBJ(GetUnitsInRangeOfLocMatching(Gu,Ju[7],Condition(z3)),z4)
if AeV()then
if I8V()then
call ForForce(GetPlayersAll(),z5)
endif
call GroupRemoveUnitSimple(Nu,Lu)
call FlushChildHashtableBJ(Bu,Au)
if AoV()then
call DisableTrigger(GetTriggeringTrigger())
set Vu=0
endif
call RemoveLocation(Ju[4])
call RemoveLocation(Ju[5])
endif
endif
call RemoveLocation(Ju[6])
call RemoveLocation(Ju[7])
endfunction
function AaV takes nothing returns boolean
return(BlzIsUnitInvulnerable(GetFilterUnit())==false and IsUnitType(GetFilterUnit(),UNIT_TYPE_UNDEAD)and IsUnitType(GetFilterUnit(),UNIT_TYPE_MECHANICAL)==false and IsUnitType(GetFilterUnit(),UNIT_TYPE_MAGIC_IMMUNE)==false and IsUnitType(GetFilterUnit(),UNIT_TYPE_STRUCTURE)==false)!=null
endfunction
function AnV takes nothing returns boolean
return IsPlayerEnemy(GetOwningPlayer(GetFilterUnit()),GetOwningPlayer(GetEnumUnit()))==false and GetOwningPlayer(GetFilterUnit())!=Player(bj_PLAYER_NEUTRAL_VICTIM)and GetUnitTypeId(GetFilterUnit())!='h000'
endfunction
function AVV takes nothing returns nothing
local integer AEV=GetUnitAbilityLevel(GetSpellAbilityUnit(),'A0G3')
local real AXV=GetSpellTargetX()
local real AOV=GetSpellTargetY()
call cRv(AddSpecialEffect("Abilities\\Spells\\Other\\TalkToMe\\TalkToMe.mdl",AXV,AOV),AEV)
call cRv(AddSpecialEffect("Abilities\\Spells\\Human\\FlameStrike\\FlameStrikeTarget.mdl",AXV,AOV),AEV)
endfunction
function ARV takes nothing returns boolean
return GetSpellAbilityId()=='A0CB'
endfunction
function AIV takes nothing returns boolean
return(GetUnitAbilityLevelSwapped('A0K1',GetEnumUnit())!=0)or(GetUnitAbilityLevelSwapped('A0K2',GetEnumUnit())!=0)
endfunction
function AAV takes nothing returns boolean
return(GetUnitTypeId(GetEnumUnit())!='h000')and(IsUnitSelected(GetEnumUnit(),GetTriggerPlayer()))and(AIV())
endfunction
function ANV takes nothing returns boolean
return(AAV())
endfunction
function AbV takes nothing returns nothing
local unit ABV=GetEnumUnit()
if ANV()then
call UnitRemoveAbility(ABV,'A0K1')
if IsUnitInGroup(GetEnumUnit(),bt) then
call DestroyEffect(AddSpecialEffectLoc("Objects\\Spawnmodels\\Undead\\ImpaleTargetDust\\ImpaleTargetDust.mdl",GetUnitLoc(ABV)))
call GroupRemoveUnit(bt,ABV)
call SetUnitPathing(ABV,true)
call UnitAddAbility(ABV,'Amrf')
call UnitRemoveAbility(ABV,'Amrf')
call SetUnitFlyHeight(ABV,.0,240.)
call UnitRemoveAbility(ABV,'A0K2')
call UnitRemoveAbility(ABV,'A0K3')
call UnitRemoveAbility(ABV,'A0K4')
call UnitRemoveAbility(ABV,'A0K5')
call UnitRemoveAbility(ABV,'B04J')
call UnitAddAbility(ABV,'A0K1')
call UnitMakeAbilityPermanent(ABV,true,'A0K1')
endif
endif
set ABV=null
set ABV=null
endfunction
function AcV takes nothing returns boolean
return(GetEventPlayerChatString()=="mass remove tree")
endfunction
function ACV takes nothing returns boolean
return(GetEventPlayerChatString()=="reset tree")
endfunction
function AdV takes nothing returns boolean
return(GetEventPlayerChatString()=="kill tree")
endfunction
function ADV takes nothing returns boolean
return(GetEventPlayerChatString()=="remove tree")
endfunction
function AfV takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),1,4)=="tree")
endfunction
function AFV takes nothing returns nothing
set g[GetConvertedPlayerId(GetTriggerPlayer())]=GetUnitsOfPlayerAndTypeId(GetTriggerPlayer(),'h000')
if AfV()then
call ForGroupBJ(g[GetConvertedPlayerId(GetTriggerPlayer())],xQv)
endif
if AdV()then
call ForGroupBJ(g[GetConvertedPlayerId(GetTriggerPlayer())],xsv)
endif
if ADV()then
call ForGroupBJ(g[GetConvertedPlayerId(GetTriggerPlayer())],xSv)
endif
if AcV()then
call ForGroupBJ(g[GetConvertedPlayerId(GetTriggerPlayer())],xtv)
endif
if ACV()then
call ForGroupBJ(g[GetConvertedPlayerId(GetTriggerPlayer())],xTv)
endif
call DestroyGroup(g[GetPlayerId(GetTriggerPlayer())+1])
endfunction
function AgV takes nothing returns nothing
local group AGV=CreateGroup()
call GroupEnumUnitsOfPlayer(AGV,GetTriggerPlayer(),Condition(e4v))
call ForGroup(AGV,e5v)
call DestroyGroup(AGV)
set AGV=null
set AGV=null
endfunction
function AhV takes nothing returns nothing
call SetDestructableInvulnerableBJ(GetEnumDestructable(),true)
call ModifyGateBJ(bj_GATEOPERATION_OPEN,GetEnumDestructable())
call KillDestructable(GetEnumDestructable())
call RemoveDestructable(GetEnumDestructable())
endfunction
function AHV takes nothing returns nothing
call UnitResetCooldown(GetEnumUnit())
endfunction
function AjV takes nothing returns boolean
return(F[GetConvertedPlayerId(GetTriggerPlayer())])and(SubStringBJ(GetEventPlayerChatString(),1,8)=="setrules")
endfunction
function AJV takes nothing returns boolean
return(GetEventPlayerChatString()=="rules")
endfunction
function AkV takes nothing returns nothing
if AjV()then
set Cw=SubStringBJ(GetEventPlayerChatString(),$A,StringLength(GetEventPlayerChatString()))
endif
if AJV()then
call DisplayTextToForce(GetPlayersMatching(Condition(xbv)),"|CFF808040"+Cw+"|r")
endif
endfunction
function AKV takes nothing returns boolean
return(ww)and(SubStringBJ(GetEventPlayerChatString(),1,8)=="aweather")
endfunction
function AlV takes nothing returns nothing
local string ALV=GetEventPlayerChatString()
local player AmV=GetTriggerPlayer()
local group AMV
call GetPlayerId(AmV)
call StringLength(ALV)
if ALV=="'attack" then
set AMV=CreateGroup()
call GroupEnumUnitsOfPlayer(AMV,AmV,Condition(emv))
call ForGroup(AMV,eMv)
call DestroyGroup(AMV)
set AMV=null
set AmV=null
set AmV=null
set AMV=null
return
endif
if ALV=="'aiswitcher" then
set AMV=CreateGroup()
call GroupEnumUnitsOfPlayer(AMV,AmV,Condition(emv))
call ForGroup(AMV,epv)
call DestroyGroup(AMV)
set AMV=null
set AmV=null
set AmV=null
set AMV=null
return
endif
set AMV=null
set AmV=null
set AmV=null
set AMV=null
endfunction
function ApV takes string APV returns string
return duv(APV,1)
endfunction
function AqV takes string AQV returns string
return duv(AQV,0)
endfunction
function AsV takes nothing returns boolean
set JT[0]=""
set JT[1]=""
set JT[2]=""
set JT[3]=""
set JT[4]=""
set JT[5]=""
set JT[6]=""
set JT[7]=""
set JT[8]=""
set JT[9]="\t"
set JT[$A]="
"
set JT[$B]=""
set JT[$C]=""
set JT[$D]="
"
set JT[$E]=""
set JT[$F]=""
set JT[16]=""
set JT[17]=""
set JT[18]=""
set JT[19]=""
set JT[20]=""
set JT[21]=""
set JT[22]=""
set JT[23]=""
set JT[24]=""
set JT[25]=""
set JT[26]=""
set JT[27]=""
set JT[28]=""
set JT[29]=""
set JT[30]=""
set JT[31]=""
set JT[32]=" "
set JT[33]="!"
set JT[34]="\""
set JT[35]="#"
set JT[36]="$"
set JT[37]="%"
set JT[38]="&"
set JT[39]="'"
set JT[40]="("
set JT[41]=")"
set JT[42]="*"
set JT[43]="+"
set JT[44]=","
set JT[45]="-"
set JT[46]="."
set JT[47]="/"
set JT[48]="0"
set JT[49]="1"
set JT[50]="2"
set JT[51]="3"
set JT[52]="4"
set JT[53]="5"
set JT[54]="6"
set JT[55]="7"
set JT[56]="8"
set JT[57]="9"
set JT[58]=":"
set JT[59]=":"
set JT[60]="<"
set JT[61]="="
set JT[62]=">"
set JT[63]="?"
set JT[64]="@"
set JT[65]="A"
set JT[66]="B"
set JT[67]="C"
set JT[68]="D"
set JT[69]="E"
set JT[70]="F"
set JT[71]="G"
set JT[72]="H"
set JT[73]="I"
set JT[74]="J"
set JT[75]="K"
set JT[76]="L"
set JT[77]="M"
set JT[78]="N"
set JT[79]="O"
set JT[80]="P"
set JT[81]="Q"
set JT[82]="R"
set JT[83]="S"
set JT[84]="T"
set JT[85]="U"
set JT[86]="V"
set JT[87]="W"
set JT[88]="X"
set JT[89]="Y"
set JT[90]="Z"
set JT[91]="["
set JT[92]="\\"
set JT[93]="]"
set JT[94]="^"
set JT[95]="_"
set JT[96]="`"
set JT[97]="a"
set JT[98]="b"
set JT[99]="c"
set JT['d']="d"
set JT['e']="e"
set JT['f']="f"
set JT['g']="g"
set JT['h']="h"
set JT['i']="i"
set JT['j']="j"
set JT['k']="k"
set JT['l']="l"
set JT['m']="m"
set JT['n']="n"
set JT['o']="o"
set JT['p']="p"
set JT['q']="q"
set JT['r']="r"
set JT['s']="s"
set JT['t']="t"
set JT['u']="u"
set JT['v']="v"
set JT['w']="w"
set JT['x']="x"
set JT['y']="y"
set JT['z']="z"
set JT['{']="{"
set JT['|']="|"
set JT['}']="}"
set JT[$7E]="~"
set JT[$7F]=""
set JT[$80]=ApV("À")
set JT[$81]=ApV("Á")
set JT[$82]=ApV("Â")
set JT[$83]=ApV("Ã")
set JT[$84]=ApV("Ä")
set JT[$85]=ApV("Å")
set JT[$86]=ApV("Æ")
set JT[$87]=ApV("Ç")
set JT[$88]=ApV("È")
set JT[$89]=ApV("É")
set JT[$8A]=ApV("Ê")
set JT[$8B]=ApV("Ë")
set JT[$8C]=ApV("Ì")
set JT[$8D]=ApV("Í")
set JT[$8E]=ApV("Î")
set JT[$8F]=ApV("Ï")
set JT[$90]=ApV("Ð")
set JT[$91]=ApV("Ñ")
set JT[$92]=ApV("Ò")
set JT[$93]=ApV("Ó")
set JT[$94]=ApV("Ô")
set JT[$95]=ApV("Õ")
set JT[$96]=ApV("Ö")
set JT[$97]=ApV("×")
set JT[$98]=ApV("Ø")
set JT[$99]=ApV("Ù")
set JT[$9A]=ApV("Ú")
set JT[$9B]=ApV("Û")
set JT[$9C]=ApV("Ü")
set JT[$9D]=ApV("Ý")
set JT[$9E]=ApV("Þ")
set JT[$9F]=ApV("ß")
set JT[$A0]=ApV("à")
set JT[$A1]=ApV("á")
set JT[$A2]=ApV("â")
set JT[$A3]=ApV("ã")
set JT[$A4]=ApV("ä")
set JT[$A5]=ApV("å")
set JT[$A6]=ApV("æ")
set JT[$A7]=ApV("ç")
set JT[$A8]=ApV("è")
set JT[$A9]=ApV("é")
set JT[$AA]=ApV("ê")
set JT[$AB]=ApV("ë")
set JT[$AC]=ApV("ì")
set JT[$AD]=ApV("í")
set JT[$AE]=ApV("î")
set JT[$AF]=ApV("ï")
set JT[$B0]=ApV("ð")
set JT[$B1]=ApV("ñ")
set JT[$B2]=ApV("ò")
set JT[$B3]=ApV("ó")
set JT[$B4]=ApV("ô")
set JT[$B5]=ApV("õ")
set JT[$B6]=ApV("ö")
set JT[$B7]=ApV("÷")
set JT[$B8]=ApV("ø")
set JT[$B9]=ApV("ù")
set JT[$BA]=ApV("ú")
set JT[$BB]=ApV("û")
set JT[$BC]=ApV("ü")
set JT[$BD]=ApV("ý")
set JT[$BE]=ApV("þ")
set JT[$BF]=ApV("ÿ")
set JT[$C0]=""
set JT[$C1]=""
set JT[$C2]=AqV("¡")
set JT[$C3]=AqV("À")
set JT[$C4]=AqV("Ā")
set JT[$C5]=AqV("ŀ")
set JT[$C6]=AqV("ƀ")
set JT[$C7]=AqV("ǀ")
set JT[$C8]=AqV("Ȁ")
set JT[$C9]=AqV("ɀ")
set JT[$CA]=AqV("ʀ")
set JT[$CB]=AqV("ˀ")
set JT[$CC]=AqV("̀")
set JT[$CD]=AqV("̀")
set JT[$CE]=AqV("΄")
set JT[$CF]=AqV("π")
set JT[$D0]=AqV("Ё")
set JT[$D1]=AqV("р")
set JT[$D2]=AqV("Ҁ")
set JT[$D3]=AqV("Ӏ")
set JT[$D4]=AqV("Ԁ")
set JT[$D5]=AqV("Հ")
set JT[$D6]=AqV("ր")
set JT[$D7]=AqV("׀")
set JT[$D8]=AqV("؀")
set JT[$D9]=AqV("ـ")
set JT[$DA]=AqV("ڀ")
set JT[$DB]=AqV("ۀ")
set JT[$DC]=AqV("܀")
set JT[$DD]=AqV("ݍ")
set JT[$DE]=AqV("ހ")
set JT[$DF]=AqV("߀")
set JT[$E0]=AqV("ࢠ")
set JT[$E1]=AqV("ក")
set JT[$E2]=AqV("⌀")
set JT[$E3]=""
set JT[$E4]=""
set JT[$E5]=""
set JT[$E6]=""
set JT[$E7]=""
set JT[$E8]=""
set JT[$E9]=""
set JT[$EA]=AqV("꠰")
set JT[$EB]=""
set JT[$EC]=""
set JT[$ED]=AqV("ힰ")
set JT[$EE]=""
set JT[$EF]=AqV("豈")
set JT[$F0]=AqV("𐎠")
set JT[$F1]=""
set JT[$F2]=""
set JT[$F3]=""
set JT[$F4]=""
set JT[$F5]=""
set JT[$F6]=""
set JT[$F7]=""
set JT[$F8]=""
set JT[$F9]=""
set JT[$FA]=""
set JT[$FB]=""
set JT[$FC]=""
set JT[$FD]=""
set JT[$FE]=""
set JT[$FF]=""
return true
endfunction
function ASV takes nothing returns boolean
set dy=.03
set fy='Amrf'
set Ry='Aloc'
set Ty=sa[PLAYER_NEUTRAL_PASSIVE]
return true
endfunction
function AtV takes string ATV returns boolean
set ZM[EM]=ATV
set EM=EM+1
set Gd=BQa("when calling new_HashSet in ScmdPermissions, line 7")
set EM=EM-1
return true
endfunction
function AuV takes nothing returns boolean
set EM=0
return AtV("ScmdPermissions, line 1")
endfunction
function AUV takes string AwV returns string
return HXe(HXe(HXe(HXe(HXe(HXe(HXe(HXe(AwV,"/","/s"),"\\","/b"),"|c","/c"),"|r","/r"),"|n","/n"),"&","/a"),":","/p"),"|","/v")
endfunction
function AWV takes string AyV returns integer
return rsn(AyV)
endfunction
function AYV takes item AzV returns real
return GetItemX(AzV)
endfunction
function AZV takes item A_V returns real
return GetItemY(A_V)
endfunction
function A0V takes item A1V returns string
local string A2V=rGn(rGn(rGn("",axe(A1V)),i0e(A1V)),i7e(A1V))
set A1=A2V
return A1
endfunction
function A3V takes item A4V,real A5V,real A6V,boolean A7V,string A8V returns string
local string A9V=rmn(AWV(A0V(A4V)))+A8V+d0v(iZe(A4V))+A8V
local string NvV
if A7V then
set NvV=ryn(AYV(A4V)-A5V)+A8V+ryn(AZV(A4V)-A6V)+A8V
else
set NvV=""
endif
return A9V+NvV+rmn(aXe(A4V))+A8V+ryn(aae(A4V))+A8V+AUV(aBe(A4V))+A8V+AUV(ave(A4V))+A8V+AUV(aVe(A4V))+A8V+AUV(ake(A4V))+A8V+AUV(are(A4V))
endfunction
function NeV takes item NxV,real NoV,real NrV returns string
return A3V(NxV,NoV,NrV,true,Fn)
endfunction
function NiV takes nothing returns nothing
call rBn(NeV(GetEnumItem(),Ff,kf))
endfunction
function NaV takes nothing returns nothing
call TriggerEvaluate(Nb)
endfunction
function NnV takes nothing returns boolean
return GetBooleanAnd(IsUnitAliveBJ(GetFilterUnit()),IsUnitEnemy(GetFilterUnit(),GetOwningPlayer(Nu)))
endfunction
function NVV takes nothing returns boolean
return GetBooleanAnd(IsUnitAliveBJ(GetFilterUnit()),IsUnitEnemy(GetFilterUnit(),GetOwningPlayer(Nu)))
endfunction
function NEV takes hashtable NXV,integer NOV,integer NRV returns trigger
return LoadTriggerHandle(NXV,NOV,NRV)
endfunction
function NIV takes integer NAV,integer NNV returns trigger
return NEV(XR,NAV,NNV)
endfunction
function NbV takes integer NBV,integer NcV,string NCV returns trigger
local trigger NdV
set ZM[EM]=NCV
set EM=EM+1
if ph[NBV]==0 then
if NBV==0 then
call Cdv("Nullpointer exception when calling Table.loadTrigger","when calling error in Table, line 111")
else
call Cdv("Called Table.loadTrigger on invalid object.","when calling error in Table, line 111")
endif
endif
set NdV=NIV(NBV,NcV)
set EM=EM-1
set ITv=NdV
set NdV=null
return ITv
endfunction
function NDV takes integer NfV,string NFV returns trigger
local trigger NgV
set ZM[EM]=NFV
set EM=EM+1
call zix(RT,0,ConvertFogState(NfV),"when calling saveFogState in TypeCasting, line 95")
set NgV=NbV(RT,0,"when calling loadTrigger in TypeCasting, line 96")
set EM=EM-1
set R2v=NgV
set NgV=null
return R2v
endfunction
function NGV takes string NhV returns boolean
local boolean NHV
set ZM[EM]=NhV
set EM=EM+1
set NHV=isV(NDV(f3v(va,GetSpellAbilityId(),"when calling get in RegisterEvents, line 58"),"when calling triggerFromIndex in RegisterEvents, line 58"))
set EM=EM-1
return NHV
endfunction
function NjV takes nothing returns boolean
set EM=0
return NGV("RegisterEvents, line 58")
endfunction
function NJV takes nothing returns nothing
set Ju[8]=GetUnitLoc(GetEnumUnit())
call CreateNUnitsAtLoc(1,'h0LE',GetOwningPlayer(Nu),Ju[8],bj_UNIT_FACING)
call UnitAddAbilityBJ('A04B',GetLastCreatedUnit())
call SetUnitAbilityLevelSwapped('A04B',GetLastCreatedUnit(),Mu)
call IssueTargetOrderBJ(GetLastCreatedUnit(),"thunderbolt",GetEnumUnit())
call GroupAddUnitSimple(GetLastCreatedUnit(),Ku)
call SaveIntegerBJ(Du+2,0,GetHandleIdBJ(GetLastCreatedUnit()),Au)
call RemoveLocation(Ju[8])
endfunction
function NkV takes nothing returns nothing
local unit NKV=CreateUnitAtLoc(Player(PLAYER_NEUTRAL_PASSIVE),'h0JO',GetUnitLoc(GetSpellAbilityUnit()),GetUnitFacing(GetSpellAbilityUnit()))
call UnitAddAbility(NKV,'A0EQ')
call SetUnitAbilityLevel(NKV,'A0EQ',GetUnitAbilityLevel(GetSpellAbilityUnit(),'A0EP'))
call IssuePointOrderByIdLoc(NKV,$D0079,GetSpellTargetLoc())
call TriggerSleepAction(12.)
call RemoveUnit(NKV)
set NKV=null
set NKV=null
endfunction
function NlV takes nothing returns boolean
return GetSpellAbilityId()=='A0FC' or GetSpellAbilityId()=='A0FD'
endfunction
function NLV takes nothing returns boolean
return(IsPlayerEnemy(GetOwningPlayer(GetSpellAbilityUnit()),GetOwningPlayer(GetFilterUnit()))and IsUnitType(GetEnumUnit(),UNIT_TYPE_STRUCTURE)==false and BlzIsUnitInvulnerable(GetFilterUnit())==false)!=null
endfunction
function NmV takes nothing returns boolean
set Qd=0
return true
endfunction
function NMV takes nothing returns boolean
return GetSpellAbilityId()=='AOda'
endfunction
function NpV takes nothing returns nothing
local integer NPV=0
local integer NqV=0
local integer NQV=0
local integer NsV=0
set NPV=6
set NqV=StringLength(GetEventPlayerChatString())
loop
exitwhen NPV>NqV
if SubString(GetEventPlayerChatString(),NPV-1,NPV)=="-" then
set NQV=S2I(SubString(GetEventPlayerChatString(),5,NPV-1))
set NsV=S2I(SubString(GetEventPlayerChatString(),NPV,StringLength(GetEventPlayerChatString())))
if NsV<NQV then
set NQV=NQV+NsV
set NsV=NQV-NsV
set NQV=NQV-NsV
endif
call DisplayTextToPlayer(GetLocalPlayer(),.0,.0,k[GetPlayerId(GetTriggerPlayer())+1]+GetPlayerName(GetTriggerPlayer())+"|r|CFF808040 ________ |r"+I2S(GetRandomInt(NQV,NsV))+"|CFF808040 ("+I2S(NQV)+"-"+I2S(NsV)+")")
set NPV=0
set NqV=0
set NQV=0
set NsV=0
return
endif
set NPV=NPV+1
endloop
set NPV=0
set NqV=0
endfunction
function NSV takes nothing returns boolean
return(GetUnitTypeId(GetEnumUnit())!='h000')and(IsUnitSelected(GetEnumUnit(),GetTriggerPlayer()))
endfunction
function NtV takes nothing returns boolean
return(NSV())
endfunction
function NTV takes nothing returns nothing
if NtV()then
set bj_forLoopBIndex=1
set bj_forLoopBIndexEnd=fw
loop
exitwhen bj_forLoopBIndex>bj_forLoopBIndexEnd
call UnitRemoveAbilityBJ(Rw[GetForLoopIndexB()],GetEnumUnit())
set bj_forLoopBIndex=bj_forLoopBIndex+1
endloop
call UnitRemoveAbilityBJ('AEme',GetEnumUnit())
endif
endfunction
function NuV takes nothing returns boolean
return GetSpellAbilityId()=='AcS5' or GetSpellAbilityId()=='AcS6'
endfunction
function NUV takes nothing returns nothing
set Zs=.0
set Es=false
set Ps=GetUnitLoc(GetSpellTargetUnit())
set As=GetTriggerUnit()
set Is=30.
set Us="Abilities\\Weapons\\FaerieDragonMissile\\FaerieDragonMissile.mdl"
set Qs="walk"
set Ws=.3
set Ds=GetUnitAbilityLevelSwapped('A0IT',GetTriggerUnit())
set Js=GetSpellTargetUnit()
call CreateNUnitsAtLoc(1,'h0JO',GetOwningPlayer(GetSpellAbilityUnit()),GetUnitLoc(GetSpellTargetUnit()),bj_UNIT_FACING)
call UnitAddAbilityBJ('A0IU',GetLastCreatedUnit())
call UnitApplyTimedLifeBJ(3.,'BTLF',GetLastCreatedUnit())
call IssueTargetOrderBJ(GetLastCreatedUnit(),"attackonce",GetSpellTargetUnit())
call ConditionalTriggerExecute(KS)
endfunction
function NwV takes nothing returns nothing
call ZSn(GetEnumUnit())
endfunction
function NWV takes nothing returns nothing
local group NyV=GetUnitsOfPlayerMatching(GetTriggerPlayer(),Condition(r5v))
if GetEventPlayerChatString()=="'translocation" then
call ForGroup(NyV,r6v)
elseif GetEventPlayerChatString()=="@translocation" then
call ForGroup(NyV,r7v)
endif
call DestroyGroup(NyV)
set NyV=null
set NyV=null
endfunction
function NYV takes nothing returns boolean
return((IsUnitType(GetEnumUnit(),UNIT_TYPE_STRUCTURE))and(GetUnitTypeId(GetEnumUnit())!='h000'))!=null
endfunction
function NzV takes nothing returns nothing
if NYV()then
call SetUnitOwner(GetEnumUnit(),Player(bj_PLAYER_NEUTRAL_VICTIM),true)
endif
endfunction
function NZV takes nothing returns boolean
set ty='ANcl'
set iy='AInv'
set Sy='Avul'
set cy='Aloa'
set oy='Aloc'
set Oy='Adro'
return true
endfunction
function N_V takes string N0V returns boolean
local boolean N1V
set ZM[EM]=N0V
set EM=EM+1
set N1V=(not Mla(umv(GetFilterUnit()),"when calling isUnitTypeProtected in ScmdUnitBuiltins, line 232"))and IsUnitSelected(GetFilterUnit(),GetOwningPlayer(GetFilterUnit()))
set EM=EM-1
return N1V
endfunction
function N2V takes nothing returns boolean
set EM=0
return N_V("ScmdUnitBuiltins, line 232")
endfunction
function N3V takes nothing returns boolean
return(GetSpellAbilityId()=='A0EH')
endfunction
function N4V takes nothing returns boolean
set Cq=$800
return true
endfunction
function N5V takes nothing returns boolean
return(R2I(GetDestructableMaxLife(GetEnumDestructable()))==69)
endfunction
function N6V takes nothing returns nothing
if N5V()then
call RemoveDestructable(GetEnumDestructable())
endif
endfunction
function N7V takes string N8V returns integer
local integer N9V
set ZM[EM]=N8V
set EM=EM+1
if RG==0 then
if TG<$8000 then
set TG=TG+1
set N9V=TG
set YG[N9V]=5108
else
call Cdv("Out of memory: Could not create OnDotDamageStruct.","when calling error in TouchOfKarma, line 86")
set N9V=0
endif
else
set RG=RG-1
set N9V=fG[RG]
set YG[N9V]=5108
endif
set EM=EM-1
return N9V
endfunction
function bvV takes integer f7S returns nothing
endfunction
function beV takes integer bxV returns nothing
call bvV(bxV)
endfunction
function boV takes string brV returns integer
local integer biV
set ZM[EM]=brV
set EM=EM+1
set biV=N7V("when calling alloc_OnDotDamageStruct in TouchOfKarma, line 86")
call beV(biV)
set EM=EM-1
return biV
endfunction
function baV takes integer bnV,integer bVV returns nothing
set wW[bnV]=bVV
endfunction
function bEV takes integer bXV,integer bOV,string bRV returns nothing
set ZM[EM]=bRV
set EM=EM+1
if dG[bXV]==0 then
if bXV==0 then
call Cdv("Nullpointer exception when calling BuffType.setOnPeriodHandler","when calling error in BuffsJurst, line 66")
else
call Cdv("Called BuffType.setOnPeriodHandler on invalid object.","when calling error in BuffsJurst, line 66")
endif
endif
call baV(bXV,bOV)
set EM=EM-1
endfunction
function bIV takes integer o7S returns nothing
endfunction
function bAV takes integer bNV returns nothing
call bIV(bNV)
endfunction
function bbV takes string bBV returns integer
local integer bcV
set ZM[EM]=bBV
set EM=EM+1
if RG==0 then
if TG<$8000 then
set TG=TG+1
set bcV=TG
set YG[bcV]=5105
else
call Cdv("Out of memory: Could not create OnBuffApplicationStruct.","when calling error in TouchOfKarma, line 80")
set bcV=0
endif
else
set RG=RG-1
set bcV=fG[RG]
set YG[bcV]=5105
endif
set EM=EM-1
return bcV
endfunction
function bCV takes string bdV returns integer
local integer bDV
set ZM[EM]=bdV
set EM=EM+1
set bDV=bbV("when calling alloc_OnBuffApplicationStruct in TouchOfKarma, line 80")
call bAV(bDV)
set EM=EM-1
return bDV
endfunction
function bfV takes string bFV returns nothing
local trigger bgV
set ZM[EM]=bFV
set EM=EM+1
set bgV=CreateTrigger()
call dYa(bT,bCV("when calling new_OnBuffApplicationStruct in TouchOfKarma, line 94"),"when calling setOnApplicationHandler in TouchOfKarma, line 94")
call bEV(yT,boV("when calling new_OnDotDamageStruct in TouchOfKarma, line 95"),"when calling setOnPeriodHandler in TouchOfKarma, line 95")
call dYa(yT,boV("when calling new_OnDotDamageStruct in TouchOfKarma, line 96"),"when calling setOnApplicationHandler in TouchOfKarma, line 96")
call Avv(bgV,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(bgV,Filter(Rrv))
call TriggerAddCondition(dT,Filter(Riv))
set EM=EM-1
set bgV=null
endfunction
function bGV takes string bhV returns boolean
set ZM[EM]=bhV
set EM=EM+1
set ST='A0IK'
set cT='B058'
set oT='B059'
set OT='A0II'
set lT='A0J5'
set bT=Dha("when calling create in TouchOfKarma, line 9")
set yT=Dha("when calling create in TouchOfKarma, line 10")
set pT=DOa("when calling create in TouchOfKarma, line 11")
set eT=DOa("when calling create in TouchOfKarma, line 12")
set qT=DOa("when calling create in TouchOfKarma, line 13")
set aT=DOa("when calling create in TouchOfKarma, line 14")
set nT=DOa("when calling create in TouchOfKarma, line 15")
set dT=CreateTrigger()
set fT=CreateGroup()
call bfV("when calling Init in TouchOfKarma, line 1")
set EM=EM-1
return true
endfunction
function bHV takes nothing returns boolean
set EM=0
return bGV("TouchOfKarma, line 1")
endfunction
function bjV takes nothing returns boolean
return(UnitHasBuffBJ(GetAttacker(),'B02A'))
endfunction
function bJV takes nothing returns boolean
return(UnitHasBuffBJ(GetAttacker(),'B02C'))
endfunction
function bkV takes nothing returns boolean
return(UnitHasBuffBJ(GetAttacker(),'B02B'))
endfunction
function bKV takes nothing returns boolean
return(UnitHasBuffBJ(GetAttacker(),'B00Y'))
endfunction
function blV takes nothing returns boolean
return(UnitHasBuffBJ(GetAttacker(),'B02D'))
endfunction
function bLV takes nothing returns nothing
call CreateNUnitsAtLoc(1,'h0JO',GetOwningPlayer(GetAttacker()),GetUnitLoc(GetAttacker()),bj_UNIT_FACING)
call UnitApplyTimedLifeBJ(3.,'BTLF',GetLastCreatedUnit())
if bjV()then
call UnitRemoveBuffBJ('B02A',GetAttacker())
call UnitAddAbilityBJ('A0D5',GetLastCreatedUnit())
call SetUnitAbilityLevelSwapped('A0D5',GetLastCreatedUnit(),GetUnitAbilityLevelSwapped('A0D3',GetAttacker()))
call IssueTargetOrderBJ(GetLastCreatedUnit(),"bloodlust",GetAttacker())
elseif bkV()then
call UnitRemoveBuffBJ('B02B',GetAttacker())
call UnitAddAbilityBJ('A0D6',GetLastCreatedUnit())
call SetUnitAbilityLevelSwapped('A0D6',GetLastCreatedUnit(),GetUnitAbilityLevelSwapped('A0D3',GetAttacker()))
call IssueTargetOrderBJ(GetLastCreatedUnit(),"bloodlust",GetAttacker())
elseif bJV()then
call UnitRemoveBuffBJ('B02C',GetAttacker())
call UnitAddAbilityBJ('A0D7',GetLastCreatedUnit())
call SetUnitAbilityLevelSwapped('A0D7',GetLastCreatedUnit(),GetUnitAbilityLevelSwapped('A0D3',GetAttacker()))
call IssueTargetOrderBJ(GetLastCreatedUnit(),"bloodlust",GetAttacker())
elseif bKV()then
call UnitRemoveBuffBJ('B00Y',GetAttacker())
call UnitAddAbilityBJ('A0D8',GetLastCreatedUnit())
call SetUnitAbilityLevelSwapped('A0D8',GetLastCreatedUnit(),GetUnitAbilityLevelSwapped('A0D3',GetAttacker()))
call IssueTargetOrderBJ(GetLastCreatedUnit(),"bloodlust",GetAttacker())
elseif blV()then
call UnitRemoveBuffBJ('B02D',GetAttacker())
call UnitAddAbilityBJ('A0D8',GetLastCreatedUnit())
call SetUnitAbilityLevelSwapped('A0D8',GetLastCreatedUnit(),GetUnitAbilityLevelSwapped('A0D3',GetAttacker()))
call IssueTargetOrderBJ(GetLastCreatedUnit(),"bloodlust",GetAttacker())
else
call UnitAddAbilityBJ('A0D4',GetLastCreatedUnit())
call SetUnitAbilityLevelSwapped('A0D4',GetLastCreatedUnit(),GetUnitAbilityLevelSwapped('A0D3',GetAttacker()))
call IssueTargetOrderBJ(GetLastCreatedUnit(),"bloodlust",GetAttacker())
endif
endfunction
function bmV takes nothing returns boolean
return(GetSpellAbilityId()=='A088')
endfunction
function bMV takes nothing returns nothing
local group bpV=CreateGroup()
call GroupEnumUnitsInRangeOfLoc(bpV,GetSpellTargetLoc(),300.,Condition(n1v))
call ForGroup(bpV,n2v)
call DestroyGroup(bpV)
set bpV=null
set bpV=null
endfunction
function bPV takes nothing returns boolean
return GetSpellAbilityId()=='A0G1'
endfunction
function bqV takes nothing returns boolean
return IsUnitSelected(GetFilterUnit(),GetTriggerPlayer())
endfunction
function bQV takes nothing returns nothing
set G=GetUnitLoc(GetEnumUnit())
call EnumDestructablesInCircleBJ(256.,G,xpv)
call RemoveLocation(G)
endfunction
function bsV takes nothing returns boolean
set XR=InitHashtable()
return true
endfunction
function bSV takes nothing returns boolean
return(GetUnitTypeId(GetEnumUnit())!='h000')and(IsUnitSelected(GetEnumUnit(),GetTriggerPlayer()))and(GetUnitTypeId(GetEnumUnit())!='h0KW')
endfunction
function btV takes nothing returns nothing
if bSV()then
call UnitAddTypeBJ(ConvertUnitType(20),GetEnumUnit())
endif
endfunction
function bTV takes nothing returns nothing
set g[GetConvertedPlayerId(GetTriggerPlayer())]=GetUnitsOfPlayerMatching(GetTriggerPlayer(),Condition(xXv))
call ForGroupBJ(g[GetConvertedPlayerId(GetTriggerPlayer())],xOv)
call DestroyGroup(g[GetPlayerId(GetTriggerPlayer())+1])
endfunction
function buV takes nothing returns nothing
local unit bUV=GetDyingUnit()
local trigger bwV=CreateTrigger()
local timer bWV=null
call TriggerRegisterUnitStateEvent(bwV,bUV,UNIT_STATE_LIFE,GREATER_THAN_OR_EQUAL,1.)
call TriggerAddAction(bwV,ekv)
if IsUnitType(bUV,UNIT_TYPE_HERO)==false then
set bWV=CreateTimer()
call SaveTriggerHandle(nr,GetHandleId(bWV),StringHash("aiR"),bwV)
call SaveUnitHandle(nr,GetHandleId(bWV),StringHash("aiRu"),bUV)
call SaveTimerHandle(nr,GetHandleId(bUV),StringHash("aiR"),bWV)
call TimerStart(bWV,120.,false,eKv)
set bWV=null
endif
set bwV=null
set bUV=null
set bUV=null
set bwV=null
set bWV=null
endfunction
function byV takes nothing returns boolean
return IsUnitSelected(GetFilterUnit(),GetTriggerPlayer())
endfunction
function bYV takes nothing returns nothing
set g[GetConvertedPlayerId(GetTriggerPlayer())]=GetUnitsOfPlayerAll(GetTriggerPlayer())
call ForGroupBJ(g[GetConvertedPlayerId(GetTriggerPlayer())],eXv)
call DestroyGroup(g[GetPlayerId(GetTriggerPlayer())+1])
endfunction
function bzV takes string bZV returns boolean
set ZM[EM]=bZV
set EM=EM+1
call Ctv("when calling new_HashMap in EventHelper, line 7")
call Ctv("when calling new_HashMap in EventHelper, line 8")
call a6x("when calling new_Table in EventHelper, line 9")
set EM=EM-1
return true
endfunction
function b_V takes nothing returns boolean
set EM=0
return bzV("EventHelper, line 1")
endfunction
function b0V takes nothing returns boolean
return(IsTriggerEnabled(Bt)==false)
endfunction
function b1V takes nothing returns boolean
return(ju<=0)
endfunction
function b2V takes nothing returns nothing
call GroupAddUnitSimple(GetTriggerUnit(),Lu)
call GroupRemoveUnitSimple(GetTriggerUnit(),Hu)
call SaveLocationHandleBJ(GetSpellTargetLoc(),1,GetHandleIdBJ(GetTriggerUnit()),Au)
call SaveIntegerBJ(GetUnitAbilityLevelSwapped('A07H',GetTriggerUnit()),5,GetHandleIdBJ(GetTriggerUnit()),Au)
call SaveIntegerBJ(0,6,GetHandleIdBJ(GetTriggerUnit()),Au)
if b1V()then
call SaveIntegerBJ(3,7,GetHandleIdBJ(GetTriggerUnit()),Au)
else
call SaveIntegerBJ(1,7,GetHandleIdBJ(GetTriggerUnit()),Au)
endif
call SaveIntegerBJ(Vu,8,GetHandleIdBJ(GetTriggerUnit()),Au)
call SaveRealBJ(DistanceBetweenPoints(LoadLocationHandleBJ(0,GetHandleIdBJ(GetTriggerUnit()),Au),LoadLocationHandleBJ(1,GetHandleIdBJ(GetTriggerUnit()),Au)),9,GetHandleIdBJ(GetTriggerUnit()),Au)
call SaveIntegerBJ(0,$A,GetHandleIdBJ(GetTriggerUnit()),Au)
call SaveRealBJ(.0,$B,GetHandleIdBJ(GetTriggerUnit()),Au)
call SaveBooleanBJ(true,$C,GetHandleIdBJ(GetTriggerUnit()),Au)
set Vu=Vu+1
call UnitRemoveAbilityBJ('A06X',GetTriggerUnit())
call SetPlayerAbilityAvailableBJ(true,'A0EH',GetOwningPlayer(GetTriggerUnit()))
call RemoveUnit(LoadUnitHandleBJ(2,GetHandleIdBJ(GetTriggerUnit()),Au))
call RemoveUnit(LoadUnitHandleBJ(3,GetHandleIdBJ(GetTriggerUnit()),Au))
call IssueImmediateOrderBJ(GetTriggerUnit(),"stop")
call SetUnitAnimation(GetTriggerUnit(),"spell slam")
if b0V()then
call EnableTrigger(Bt)
endif
endfunction
function b3V takes string b4V returns integer
local integer b5V
set ZM[EM]=b4V
set EM=EM+1
if jG==0 then
if xG<$8000 then
set xG=xG+1
set b5V=xG
set vG[b5V]=$46D
else
call Cdv("Out of memory: Could not create CallbackSingle_doAfter_DummyCaster_DummyCaster.","when calling error in DummyCaster, line 89")
set b5V=0
endif
else
set jG=jG-1
set b5V=kG[jG]
set vG[b5V]=$46D
endif
set EM=EM-1
return b5V
endfunction
function b6V takes integer b7V,unit b8V,integer b9V,string BvV returns nothing
local integer BeV
local real BxV
set ZM[EM]=BvV
set EM=EM+1
set ZE[b7V]=ZE[b7V]+1
set BxV=EE[b7V]
set BeV=b3V("when calling alloc_CallbackSingle_doAfter_DummyCaster_DummyCaster in DummyCaster, line 89")
call EUx(BeV)
set AE[BeV]=b8V
set DE[BeV]=b9V
set HE[BeV]=b7V
call EQx(BxV,BeV,"when calling doAfter in DummyCaster, line 89")
set EM=EM-1
endfunction
function BoV takes integer BrV,unit BiV,integer BaV,string BnV returns nothing
set ZM[EM]=BnV
set EM=EM+1
if Zg[BrV]==0 then
if BrV==0 then
call Cdv("Nullpointer exception when calling DummyCaster.finish","when calling error in DummyCaster, line 87")
else
call Cdv("Called DummyCaster.finish on invalid object.","when calling error in DummyCaster, line 87")
endif
endif
call b6V(BrV,BiV,BaV,"when calling finish in DummyCaster, line 87")
set EM=EM-1
endfunction
function BVV takes widget BEV returns real
set H3=WVv(BEV)
set J3=LLe(BEV)
return H3
endfunction
function BXV takes real BOV,real BRV returns boolean
return BOV>Ae and BOV<He and BRV>De and BRV<Je
endfunction
function BIV takes real BAV,real BNV returns boolean
return BXV(BAV,BNV)
endfunction
function BbV takes real BBV,real BcV,player BCV,real BdV returns unit
local unit BDV=vAe(BCV,Ep,BBV,BcV,BdV)
local unit BfV=BDV
local unit BFV
local unit BgV
local unit BGV
call Rze(BfV,BBV,BcV)
set BFV=BfV
call wrv(BFV,fy)
set BgV=BFV
call Tlv(BgV,fy)
set BGV=BgV
call wrv(BGV,Ry)
set RLv=BDV
set BDV=null
set BfV=null
set BFV=null
set BgV=null
set BGV=null
return RLv
endfunction
function BhV takes integer BHV,integer BjV,string BJV returns unit
local unit BkV
if BjV<0 or BjV>=6 then
call Cdv("Index out of Bounds",BJV)
elseif BjV<=2 then
if BjV<=1 then
if BjV<=0 then
set BkV=zF[BHV]
else
set BkV=zg[BHV]
endif
else
set BkV=zG[BHV]
endif
elseif BjV<=4 then
if BjV<=3 then
set BkV=zh[BHV]
else
set BkV=zH[BHV]
endif
else
set BkV=zj[BHV]
endif
set Izv=BkV
set BkV=null
return Izv
endfunction
function BKV takes integer BlV,string BLV returns unit
set ZM[EM]=BLV
set EM=EM+1
if LE[BlV]>0 then
set LE[BlV]=LE[BlV]-1
set JE[BlV]=ModuloInteger(JE[BlV]+1,Ip)
set EM=EM-1
return BhV(BlV,JE[BlV],"when reading array ArrayQueue_units in  in DummyRecycler, line 69")
else
call Cdv("Queue empty","when calling error in DummyRecycler, line 71")
set EM=EM-1
return null
endif
endfunction
function BmV takes integer BMV,string BpV returns unit
local unit BPV
set ZM[EM]=BpV
set EM=EM+1
if Ag[BMV]==0 then
if BMV==0 then
call Cdv("Nullpointer exception when calling ArrayQueue.dequeue","when calling error in DummyRecycler, line 65")
else
call Cdv("Called ArrayQueue.dequeue on invalid object.","when calling error in DummyRecycler, line 65")
endif
endif
set BPV=BKV(BMV,"when calling dequeue in DummyRecycler, line 65")
set EM=EM-1
set INv=BPV
set BPV=null
return INv
endfunction
function BqV takes real BQV,real BsV,real BSV,string BtV returns unit
local integer BTV
local unit BuV
local unit BUV
local unit BwV
local unit BWV
set ZM[EM]=BtV
set EM=EM+1
set BTV=c6v(c6v(ModuloReal(T6v(BSV),360.))/Up)
if LE[Dp[BTV]]>0 then
set BuV=BmV(Dp[BTV],"when calling dequeue in DummyRecycler, line 29")
call Rze(BuV,BQV,BsV)
set BUV=BuV
call E9x(BUV)
set BWV=BUV
set EM=EM-1
set Rmv=BWV
set BuV=null
set BUV=null
set BwV=null
set BWV=null
return Rmv
else
set BwV=BbV(BQV,BsV,Ty,BSV)
set EM=EM-1
set RMv=BwV
set BuV=null
set BUV=null
set BwV=null
set BWV=null
return RMv
endif
endfunction
function ByV takes integer BYV,integer BzV,integer BZV,string B_V returns unit
local unit B0V
local unit B1V
local unit B2V
set ZM[EM]=B_V
set EM=EM+1
set B0V=BqV(UE[BYV],IE[BYV],.0,"when calling get in DummyCaster, line 78")
if BIV(UE[BYV],IE[BYV])then
call Rze(B0V,UE[BYV],IE[BYV])
endif
set B1V=B0V
call wrv(B1V,BzV)
set B2V=B1V
call Rqe(B2V,1000000.)
if BZV>1 then
call UPv(B0V,BzV,BZV)
endif
call SPe(B0V,PE[BYV],false)
set EM=EM-1
set R7v=B0V
set B0V=null
set B1V=null
set B2V=null
return R7v
endfunction
function B3V takes integer B4V,integer B5V,integer B6V,string B7V returns unit
local unit B8V
set ZM[EM]=B7V
set EM=EM+1
if Zg[B4V]==0 then
if B4V==0 then
call Cdv("Nullpointer exception when calling DummyCaster.prepare","when calling error in DummyCaster, line 77")
else
call Cdv("Called DummyCaster.prepare on invalid object.","when calling error in DummyCaster, line 77")
endif
endif
set B8V=ByV(B4V,B5V,B6V,"when calling prepare in DummyCaster, line 77")
set EM=EM-1
set IAv=B8V
set B8V=null
return IAv
endfunction
function B9V takes integer cvV,integer ceV,integer cxV,integer coV,widget crV,string ciV returns unit
local unit caV
local boolean cnV
set ZM[EM]=ciV
set EM=EM+1
set caV=B3V(cvV,ceV,cxV,"when calling prepare in DummyCaster, line 59")
call T8v(caV,unv(uov(caV),c3,BVV(crV),J3))
set cnV=xwn(caV,coV,crV)
call BoV(cvV,caV,ceV,"when calling finish in DummyCaster, line 62")
if not cnV then
set caV=null
endif
set EM=EM-1
set R8v=caV
set caV=null
return R8v
endfunction
function cVV takes integer cEV,integer cXV,integer cOV,integer cRV,widget cIV,string cAV returns unit
local unit cNV
set ZM[EM]=cAV
set EM=EM+1
if Zg[cEV]==0 then
if cEV==0 then
call Cdv("Nullpointer exception when calling DummyCaster.castTarget","when calling error in DummyCaster, line 58")
else
call Cdv("Called DummyCaster.castTarget on invalid object.","when calling error in DummyCaster, line 58")
endif
endif
set cNV=B9V(cEV,cXV,cOV,cRV,cIV,"when calling castTarget in DummyCaster, line 58")
set EM=EM-1
set IIv=cNV
set cNV=null
return IIv
endfunction
function cbV takes string cBV returns integer
local integer ccV
set ZM[EM]=cBV
set EM=EM+1
if Wg==0 then
if Eg<$8000 then
set Eg=Eg+1
set ccV=Eg
set Zg[ccV]=$744
else
call Cdv("Out of memory: Could not create DummyCaster.","when calling error in DummyCaster, line 28")
set ccV=0
endif
else
set Wg=Wg-1
set ccV=Qg[Wg]
set Zg[ccV]=$744
endif
set EM=EM-1
return ccV
endfunction
function cCV takes integer cdV returns nothing
local real cDV
local real cfV
set EE[cdV]=5.
set ZE[cdV]=0
set cDV=NT
set cfV=MT
set UE[cdV]=cDV
set IE[cdV]=cfV
set PE[cdV]=Ty
endfunction
function cFV takes integer cgV returns nothing
call cCV(cgV)
endfunction
function cGV takes string chV returns integer
local integer cHV
set ZM[EM]=chV
set EM=EM+1
set cHV=cbV("when calling alloc_DummyCaster in DummyCaster, line 34")
call cFV(cHV)
set EM=EM-1
return cHV
endfunction
function cjV takes unit cJV,widget ckV,real cKV,attacktype clV returns nothing
call UnitDamageTarget(cJV,ckV,cKV,false,false,clV,DAMAGE_TYPE_UNIVERSAL,WEAPON_TYPE_WHOKNOWS)
endfunction
function cLV takes string cmV,widget cMV,string cpV returns effect
return AddSpecialEffectTarget(cmV,cMV,cpV)
endfunction
function cPV takes group cqV,real cQV,real csV,real cSV,boolexpr ctV returns nothing
call GroupEnumUnitsInRange(cqV,cQV,csV,cSV,ctV)
endfunction
function cTV takes real cuV,real cUV returns real
return Atan2(cUV,cuV)
endfunction
function cwV takes player cWV,player cyV returns boolean
return IsPlayerEnemy(cWV,cyV)
endfunction
function cYV takes real czV,real cZV returns real
set AM=czV-cZV
return AM
endfunction
function c_V takes real c0V returns real
local real c1V=ModuloReal(e6e(c0V),Le)
local real c2V
if c1V>=.0 then
set c2V=c1V
else
set c2V=c1V+Le
endif
set i3=uiv(c2V)
return i3
endfunction
function c3V takes real c4V,real c5V,real c6V returns boolean
local real c7V=c_V(cYV(c5V,c4V))
local real c8V=c7V
local real c9V
local real CvV
local real CeV
local real CxV
local real CoV
if e6e(c8V)<=Ke then
set CeV=c_V(cYV(c6V,c4V))
set c9V=CeV
return e6e(c9V)>.0 and e6e(c9V)<e6e(c8V)
else
set CxV=cYV(uiv(Le),c8V)
set c8V=CxV
set CoV=c_V(cYV(c6V,c5V))
set CvV=CoV
return e6e(CvV)>.0 and e6e(CvV)<e6e(c8V)
endif
endfunction
function CrV takes integer CiV,player CaV returns nothing
set PE[CiV]=CaV
endfunction
function CnV takes integer CVV,player CEV,string CXV returns nothing
set ZM[EM]=CXV
set EM=EM+1
if Zg[CVV]==0 then
if CVV==0 then
call Cdv("Nullpointer exception when calling DummyCaster.owner","when calling error in DummyCaster, line 40")
else
call Cdv("Called DummyCaster.owner on invalid object.","when calling error in DummyCaster, line 40")
endif
endif
call CrV(CVV,CEV)
set EM=EM-1
endfunction
function COV takes string CRV returns boolean
local unit CIV
local player CAV
local integer CNV
local group CbV
local group CBV
local real CcV
local real CCV
local real CdV
local unit CDV
local group CfV
local boolean CFV
local integer CgV
local unit CGV
local group ChV
local integer CHV
local integer CjV
local boolean CJV
set ZM[EM]=CRV
set EM=EM+1
if GetSpellAbilityId()==my then
set CIV=GetSpellAbilityUnit()
set CAV=HVo(CIV)
set CNV=USv(CIV,my)
set CbV=CreateGroup()
call cPV(CbV,uov(CIV),c3,Dy,Filter(OLv))
set CBV=CreateGroup()
set CcV=QJv(CIV)
set CCV=uev(CIV)
set CdV=GetUnitFacing(CIV)
set CfV=CbV
loop
exitwhen not F9e(CfV)
set CDV=F6e(CfV)
if c3V(vde(CdV-Hy),vde(CdV+Hy),uiv(Xe-cTV(uev(CDV)-CCV,QJv(CDV)-CcV)))and cwV(HVo(CDV),CAV)then
call KWe(CBV,CDV)
endif
endloop
call kcv(CbV)
set CFV=d5e(CBV)>=Uy
set CgV=CNV*Zy
set ChV=CBV
loop
exitwhen not F9e(ChV)
set CGV=F6e(ChV)
call cjV(CIV,CGV,DQv(CgV),ATTACK_TYPE_MELEE)
call Ksv(cLV("Objects\\Spawnmodels\\Human\\HumanBlood\\HumanBloodKnight.mdl",CGV,"chest"))
if CFV then
set CHV=cGV("when calling new_DummyCaster in Cleave, line 112")
call CnV(CHV,CAV,"when calling owner in Cleave, line 112")
set CjV=CHV
call cVV(CjV,Qy,CNV,Qq,CGV,"when calling castTarget in Cleave, line 112")
endif
endloop
call kcv(CBV)
endif
set CJV=false
set EM=EM-1
set CIV=null
set CAV=null
set CbV=null
set CBV=null
set CDV=null
set CfV=null
set CGV=null
set ChV=null
return CJV
endfunction
function CkV takes nothing returns boolean
set EM=0
return COV("Cleave, line 91")
endfunction
function CKV takes nothing returns boolean
set te="ScriptDialogButton"
return true
endfunction
function ClV takes nothing returns boolean
return GetBooleanAnd(IsUnitAliveBJ(GetFilterUnit()),IsUnitEnemy(GetFilterUnit(),GetOwningPlayer(Nu)))
endfunction
function CLV takes nothing returns boolean
return(GetSpellAbilityId()=='A07N')
endfunction
function CmV takes nothing returns boolean
return(GetDestructableMaxLife(GetEnumDestructable())==2501.)
endfunction
function CMV takes nothing returns nothing
if CmV()then
call ModifyGateBJ(bj_GATEOPERATION_DESTROY,GetEnumDestructable())
endif
endfunction
function CpV takes nothing returns nothing
local unit CPV=LoadUnitHandle(i,y,GetHandleId(GetExpiredTimer()))
call Gmv(GetExpiredTimer())
call BlzEndUnitAbilityCooldown(CPV,'A0MH')
call GBv('A0MI',GetUnitAbilityLevel(CPV,'A0MH'),"attackonce",CPV)
call BlzSetUnitAbilityManaCost(CPV,'A0MH',1,0)
call BlzSetUnitAbilityManaCost(CPV,'A0MH',2,0)
call BlzSetUnitAbilityManaCost(CPV,'A0MH',3,0)
call RbV(el,CPV,5.)
set CPV=null
set CPV=null
endfunction
function CqV takes nothing returns boolean
if GetSpellAbilityId()=='A0H7' then
return true
else
return false
endif
endfunction
function CQV takes nothing returns boolean
return GetUnitTypeId(GetOrderedUnit())=='h000' and GetIssuedOrderId()!=852046and GetIssuedOrderId()!=852047and GetOrderTargetUnit()==null or GetUnitState(GetOrderTargetUnit(),UNIT_STATE_LIFE)>.0
endfunction
function CsV takes nothing returns nothing
local unit CSV=GetSpellAbilityUnit()
if GetSpellAbilityId()=='AcS1' then
call UnitRemoveAbility(CSV,'AcB1')
call UnitAddAbility(CSV,'AcB2')
call UnitMakeAbilityPermanent(CSV,true,'AcB2')
call UnitRemoveAbility(CSV,'AcTS')
else
call UnitRemoveAbility(CSV,'AcB2')
call UnitAddAbility(CSV,'AcB1')
call UnitMakeAbilityPermanent(CSV,true,'AcB1')
call UnitAddAbility(CSV,'AcTS')
call UnitMakeAbilityPermanent(CSV,true,'AcTS')
endif
set CSV=null
set CSV=null
endfunction
function CtV takes nothing returns nothing
set gs[3]=1
loop
exitwhen gs[3]>gs[2]
if IsUnitInGroup(ms[gs[3]],Ys) then
if Fs[gs[3]]<Rs[gs[3]]then
call QueueUnitAnimation(ms[gs[3]],fs[gs[3]])
set xs[1]=GetUnitLoc(ms[gs[3]])
set xs[2]=PolarProjectionBJ(xs[1],js[gs[3]],ds[gs[3]])
if vs[gs[3]] then
call EnumDestructablesInCircleBJ(150.,xs[2],o_v)
endif
call SetUnitPositionLoc(ms[gs[3]],xs[2])
set Fs[gs[3]]=Fs[gs[3]]+js[gs[3]]
if GetRandomInt(1,5)==1 then
call DestroyEffect(AddSpecialEffectTarget(Ts[gs[3]],ms[gs[3]],"chest"))
endif
set ks[gs[3]]=ks[gs[3]]+180./(Rs[gs[3]]/js[gs[3]])
set hs[gs[3]]=SinBJ(ks[gs[3]])*Gs[gs[3]]
call SetUnitFlyHeight(ms[gs[3]],hs[gs[3]],1000000000.)
call RemoveLocation(xs[1])
call RemoveLocation(xs[2])
else
call SetUnitPathing(ms[gs[3]],true)
call GroupRemoveUnit(Ys,ms[gs[3]])
call SetUnitTimeScale(ms[gs[3]],1.)
call SetUnitAnimation(ms[gs[3]],"stand")
call UnitDamageTarget(ms[gs[3]],Ks[gs[3]],25+25*Hs[gs[3]],true,true,ATTACK_TYPE_NORMAL,DAMAGE_TYPE_MAGIC,WEAPON_TYPE_WHOKNOWS)
set ks[gs[3]]=.0
set gs[1]=gs[1]-1
if gs[1]==0 then
set gs[2]=0
call DisableTrigger(GetTriggeringTrigger())
endif
endif
endif
set gs[3]=gs[3]+1
endloop
endfunction
function CTV takes nothing returns boolean
return GetSpellAbilityId()=='A0L4'
endfunction
function CuV takes nothing returns nothing
local unit CUV=GetSpellTargetUnit()
local unit CwV=GetSpellAbilityUnit()
local timer CWV=CreateTimer()
if IsUnitInGroup(CUV,cs) then
call GroupRemoveUnit(cs,CUV)
call GroupRemoveUnit(os,CUV)
endif
call TimerStart(CWV,.01,false,null)
loop
exitwhen TimerGetRemaining(CWV)<=.0
endloop
call GroupAddUnit(cs,CUV)
call TimerStart(CWV,15.,false,null)
loop
if TimerGetRemaining(CWV)<=.0 or IsUnitInGroup(CUV,cs)==false then
call DestroyTimer(CWV)
set CWV=null
set CUV=null
set CwV=null
set CUV=null
set CwV=null
set CWV=null
return
endif
exitwhen GetUnitAbilityLevel(CUV,'B028')>0 or TimerGetRemaining(CWV)<=.0
endloop
call DestroyTimer(CWV)
set CWV=null
loop
exitwhen GetUnitAbilityLevel(CUV,'B028')==0
endloop
set CWV=CreateTimer()
call GroupAddUnit(os,CUV)
call UnitAddAbility(CUV,'B03T')
call UnitMakeAbilityPermanent(CUV,true,'B03T')
call TimerStart(CWV,1.,false,null)
loop
if IsUnitInGroup(CUV,os)==false then
call DestroyTimer(CWV)
set CWV=null
set CUV=null
set CwV=null
set CUV=null
set CwV=null
set CWV=null
return
endif
exitwhen TimerGetRemaining(CWV)<=.0
endloop
call UnitDamageTarget(CwV,CUV,25.,false,true,ATTACK_TYPE_MAGIC,DAMAGE_TYPE_MAGIC,WEAPON_TYPE_WHOKNOWS)
call TimerStart(CWV,1.,false,null)
loop
if IsUnitInGroup(CUV,os)==false then
call DestroyTimer(CWV)
set CWV=null
set CUV=null
set CwV=null
set CUV=null
set CwV=null
set CWV=null
return
endif
exitwhen TimerGetRemaining(CWV)<=.0
endloop
call UnitDamageTarget(CwV,CUV,25.,false,true,ATTACK_TYPE_MAGIC,DAMAGE_TYPE_MAGIC,WEAPON_TYPE_WHOKNOWS)
call TimerStart(CWV,1.,false,null)
loop
if IsUnitInGroup(CUV,os)==false then
call DestroyTimer(CWV)
set CWV=null
set CUV=null
set CwV=null
set CUV=null
set CwV=null
set CWV=null
return
endif
exitwhen TimerGetRemaining(CWV)<=.0
endloop
call UnitDamageTarget(CwV,CUV,25.,false,true,ATTACK_TYPE_MAGIC,DAMAGE_TYPE_MAGIC,WEAPON_TYPE_WHOKNOWS)
call TimerStart(CWV,1.,false,null)
loop
if IsUnitInGroup(CUV,os)==false then
call DestroyTimer(CWV)
set CWV=null
set CUV=null
set CwV=null
set CUV=null
set CwV=null
set CWV=null
return
endif
exitwhen TimerGetRemaining(CWV)<=.0
endloop
call UnitDamageTarget(CwV,CUV,25.,false,true,ATTACK_TYPE_MAGIC,DAMAGE_TYPE_MAGIC,WEAPON_TYPE_WHOKNOWS)
call TimerStart(CWV,1.,false,null)
loop
if IsUnitInGroup(CUV,os)==false then
call DestroyTimer(CWV)
set CWV=null
set CUV=null
set CwV=null
set CUV=null
set CwV=null
set CWV=null
return
endif
exitwhen TimerGetRemaining(CWV)<=.0
endloop
call UnitDamageTarget(CwV,CUV,25.,false,true,ATTACK_TYPE_MAGIC,DAMAGE_TYPE_MAGIC,WEAPON_TYPE_WHOKNOWS)
call DestroyTimer(CWV)
set CWV=null
call GroupRemoveUnit(os,CUV)
call UnitRemoveAbility(CUV,'B03T')
set CUV=null
set CwV=null
set CUV=null
set CwV=null
set CWV=null
endfunction
function CyV takes nothing returns nothing
call SetPlayerHandicapXPBJ(GetEnumPlayer(),.0)
endfunction
function CYV takes nothing returns nothing
local group CzV=GetUnitsOfPlayerMatching(GetTriggerPlayer(),Condition(r1v))
if GetEventPlayerChatString()=="'clotofenergy" then
call ForGroup(CzV,r2v)
elseif GetEventPlayerChatString()=="@clotofenergy" then
call ForGroup(CzV,r3v)
endif
call DestroyGroup(CzV)
set CzV=null
set CzV=null
endfunction
function CZV takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),$A,'y')=="raysoflight")
endfunction
function C_V takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),$A,'y')=="hwind")
endfunction
function C0V takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),$A,'y')=="houtlandwind")
endfunction
function C1V takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),$A,'y')=="loutlandwind")
endfunction
function C2V takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),$A,'y')=="ldungeongreenfog")
endfunction
function C3V takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),$A,'y')=="hdungeonwhitefog")
endfunction
function C4V takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),$A,'y')=="raysofmoonlight")
endfunction
function C5V takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),$A,'y')=="ldungeonbluefog")
endfunction
function C6V takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),$A,'y')=="ldungeonredfog")
endfunction
function C7V takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),$A,'y')=="lashenvillerain")
endfunction
function C8V takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),$A,'y')=="ldungeonwhitefog")
endfunction
function C9V takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),$A,'y')=="hdungeongreenfog")
endfunction
function dvV takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),$A,'y')=="hdungeonredfog")
endfunction
function deV takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),$A,'y')=="dalaranshield")
endfunction
function dxV takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),$A,'y')=="hashenvillerain")
endfunction
function doV takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),$A,'y')=="northrendblizzard")
endfunction
function drV takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),$A,'y')=="llordaeronrain")
endfunction
function diV takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),$A,'y')=="hlordaeronrain")
endfunction
function daV takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),$A,'y')=="hnorthrendsnow")
endfunction
function dnV takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),$A,'y')=="lnorthrendsnow")
endfunction
function dVV takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),$A,'y')=="hdungeonbluefog")
endfunction
function dEV takes nothing returns nothing
call RemoveWeatherEffectBJ(uw)
if dxV()then
call AddWeatherEffectSaveLast(GetPlayableMapRect(),'RAhr')
elseif C7V()then
call AddWeatherEffectSaveLast(GetPlayableMapRect(),'RAlr')
elseif deV()then
call AddWeatherEffectSaveLast(GetPlayableMapRect(),'MEds')
elseif dVV()then
call AddWeatherEffectSaveLast(GetPlayableMapRect(),'FDbh')
elseif C5V()then
call AddWeatherEffectSaveLast(GetPlayableMapRect(),'FDbl')
elseif C9V()then
call AddWeatherEffectSaveLast(GetPlayableMapRect(),'FDgh')
elseif C2V()then
call AddWeatherEffectSaveLast(GetPlayableMapRect(),'FDgl')
elseif dvV()then
call AddWeatherEffectSaveLast(GetPlayableMapRect(),'FDrh')
elseif C6V()then
call AddWeatherEffectSaveLast(GetPlayableMapRect(),'FDrl')
elseif C3V()then
call AddWeatherEffectSaveLast(GetPlayableMapRect(),'FDwh')
elseif C8V()then
call AddWeatherEffectSaveLast(GetPlayableMapRect(),'FDwl')
elseif diV()then
call AddWeatherEffectSaveLast(GetPlayableMapRect(),'RLhr')
elseif drV()then
call AddWeatherEffectSaveLast(GetPlayableMapRect(),'RLlr')
elseif doV()then
call AddWeatherEffectSaveLast(GetPlayableMapRect(),'SNbs')
elseif daV()then
call AddWeatherEffectSaveLast(GetPlayableMapRect(),'SNhs')
elseif dnV()then
call AddWeatherEffectSaveLast(GetPlayableMapRect(),'SNls')
elseif C0V()then
call AddWeatherEffectSaveLast(GetPlayableMapRect(),'WOcw')
elseif C1V()then
call AddWeatherEffectSaveLast(GetPlayableMapRect(),'WOlw')
elseif CZV()then
call AddWeatherEffectSaveLast(GetPlayableMapRect(),'LRaa')
elseif C4V()then
call AddWeatherEffectSaveLast(GetPlayableMapRect(),'LRma')
elseif C_V()then
call AddWeatherEffectSaveLast(GetPlayableMapRect(),'WNcw')
else
return
endif
call EnableWeatherEffect(GetLastCreatedWeatherEffect(),true)
set uw=GetLastCreatedWeatherEffect()
endfunction
function dXV takes nothing returns nothing
set G=GetUnitLoc(GetEnumUnit())
call CreateItemLoc('I070',G)
call RemoveLocation(G)
endfunction
function dOV takes unit dRV returns nothing
local integer dIV=LoadInteger(i,VO,GetHandleId(dRV))
call BlzSetUnitAbilityManaCost(dRV,JO,1,BlzGetUnitAbilityManaCost(dRV,JO,1)-30*dIV)
call BlzSetUnitAbilityManaCost(dRV,JO,2,BlzGetUnitAbilityManaCost(dRV,JO,2)-30*dIV)
call BlzSetUnitAbilityManaCost(dRV,JO,3,BlzGetUnitAbilityManaCost(dRV,JO,3)-30*dIV)
call SaveInteger(i,VO,GetHandleId(dRV),0)
endfunction
function dAV takes nothing returns boolean
call dOV(ry)
return true
endfunction
function dNV takes integer dbV returns camerafield
return ConvertCameraField(dbV)
endfunction
function dBV takes integer Hwi,integer Jwi,string dcV returns nothing
local integer dCV
local integer ddV
local integer dDV
local camerafield dfV
local real dFV
set ZM[EM]=dcV
set EM=EM+1
set dCV=0
set ddV=bj_MAX_PLAYERS
loop
exitwhen dCV>ddV
set dDV=jjv(hd[dCV],"when calling iterator in ScmdPlayerCameraSettingsBuiltins, line 40")
loop
exitwhen not Jgv(dDV,"when calling hasNext in ScmdPlayerCameraSettingsBuiltins, line 40")
set dfV=dNV(jTv(dDV,"when calling next in ScmdPlayerCameraSettingsBuiltins, line 40"))
set dFV=mix(f3v(hd[dCV],Ako(dfV),"when calling get in ScmdPlayerCameraSettingsBuiltins, line 41"))
if ta==sa[dCV]then
call SetCameraField(dfV,dFV,.0)
endif
endloop
call Jqv(dDV,"when calling close in ScmdPlayerCameraSettingsBuiltins, line 40")
set dCV=dCV+1
endloop
set EM=EM-1
set dfV=null
endfunction
function dgV takes integer dGV,integer dhV,string dHV returns nothing
set ZM[EM]=dHV
set EM=EM+1
if fg[dGV]==0 then
if dGV==0 then
call Cdv("Nullpointer exception when calling CallbackPeriodic.call","when calling error in ClosureTimers, line 130")
else
call Cdv("Called CallbackPeriodic.call on invalid object.","when calling error in ClosureTimers, line 130")
endif
endif
call dBV(dGV,dhV,"when calling call_doPeriodically_ScmdPlayerCameraSettingsBuiltins in ClosureTimers, line 130")
set EM=EM-1
endfunction
function djV takes string dJV returns nothing
local integer dkV
set ZM[EM]=dJV
set EM=EM+1
set dkV=aqn(GetExpiredTimer(),"when calling getData in ClosureTimers, line 138")
call dgV(dkV,dkV,"when calling call in ClosureTimers, line 139")
set EM=EM-1
endfunction
function dKV takes nothing returns nothing
set EM=0
call djV("ClosureTimers, line 135")
endfunction
function dlV takes nothing returns boolean
set oe=CreateTimer()
call EAx(oe,100000.,null)
call qYx(CreateTimer(),dy,Ouv)
return true
endfunction
function dLV takes nothing returns nothing
local unit dmV=GetEnumUnit()
call DestroyEffect(AddSpecialEffectTarget("Abilities\\Spells\\Undead\\VampiricAura\\VampiricAuraTarget.mdl",dmV,"origin"))
call SetWidgetLife(dmV,GetWidgetLife(dmV)+wl*(1.-.33*(3-LoadInteger(i,MO,GetHandleId(dmV)))))
set dmV=null
set dmV=null
endfunction
function dMV takes nothing returns boolean
return(CountUnitsInGroup(Lu)==0)and(CountUnitsInGroup(Hu)==0)and(CountUnitsInGroup(Ku)==0)
endfunction
function dpV takes nothing returns nothing
set Du=Du+1
call ForGroupBJ(Hu,x0)
call ForGroupBJ(Ku,o0)
if dMV()then
set Du=0
call DisableTrigger(GetTriggeringTrigger())
endif
endfunction
function dPV takes string dqV returns integer
local integer dQV
set ZM[EM]=dqV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set dQV=Yj
set Gj[dQV]=$B0C
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdSoundFunctions.","when calling error in ScmdSoundFunctions, line 22")
set dQV=0
endif
else
set Tj=Tj-1
set dQV=Rj[Tj]
set Gj[dQV]=$B0C
endif
set EM=EM-1
return dQV
endfunction
function dsV takes string dSV returns integer
local integer dtV
set ZM[EM]=dSV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set dtV=Yj
set Gj[dtV]=$B0A
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdSoundFunctions.","when calling error in ScmdSoundFunctions, line 14")
set dtV=0
endif
else
set Tj=Tj-1
set dtV=Rj[Tj]
set Gj[dtV]=$B0A
endif
set EM=EM-1
return dtV
endfunction
function dTV takes string duV returns integer
local integer dUV
set ZM[EM]=duV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set dUV=Yj
set Gj[dUV]=$B0B
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdSoundFunctions.","when calling error in ScmdSoundFunctions, line 18")
set dUV=0
endif
else
set Tj=Tj-1
set dUV=Rj[Tj]
set Gj[dUV]=$B0B
endif
set EM=EM-1
return dUV
endfunction
function dwV takes string dWV returns integer
local integer dyV
set ZM[EM]=dWV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set dyV=Yj
set Gj[dyV]=$A2F
else
call Cdv("Out of memory: Could not create IBuiltin_registerProtectedBuiltin_ScmdSoundFunctions.","when calling error in ScmdSoundFunctions, line 26")
set dyV=0
endif
else
set Tj=Tj-1
set dyV=Rj[Tj]
set Gj[dyV]=$A2F
endif
set EM=EM-1
return dyV
endfunction
function dYV takes string dzV returns integer
local integer dZV
set ZM[EM]=dzV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set dZV=Yj
set Gj[dZV]=$B0D
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdSoundFunctions.","when calling error in ScmdSoundFunctions, line 30")
set dZV=0
endif
else
set Tj=Tj-1
set dZV=Rj[Tj]
set Gj[dZV]=$B0D
endif
set EM=EM-1
return dZV
endfunction
function d_V takes nothing returns integer
return Zn
endfunction
function d0V takes string d1V returns integer
local integer d2V
set ZM[EM]=d1V
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set d2V=Yj
set Gj[d2V]=$B08
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdSoundFunctions.","when calling error in ScmdSoundFunctions, line 6")
set d2V=0
endif
else
set Tj=Tj-1
set d2V=Rj[Tj]
set Gj[d2V]=$B08
endif
set EM=EM-1
return d2V
endfunction
function d3V takes string d4V returns integer
local integer d5V
set ZM[EM]=d4V
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set d5V=Yj
set Gj[d5V]=$B09
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdSoundFunctions.","when calling error in ScmdSoundFunctions, line 10")
set d5V=0
endif
else
set Tj=Tj-1
set d5V=Rj[Tj]
set Gj[d5V]=$B09
endif
set EM=EM-1
return d5V
endfunction
function d6V takes string d7V returns boolean
local integer d8V
local integer d9V
local integer DvV
local integer DeV
local integer DxV
local integer DoV
local integer DrV
local integer DiV
local integer DaV
local integer DnV
local integer DVV
local integer DEV
local integer DXV
set ZM[EM]=d7V
set EM=EM+1
set d8V=d0V("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdSoundFunctions in ScmdSoundFunctions, line 6")
set d9V=OPo(d8V,"when calling new_BuiltinData in ScmdSoundFunctions, line 6")
call Rxo(d9V,OFo(),"when calling setArgumentsTypes in ScmdSoundFunctions, line 9")
call Foa(ILo(d9V,"when calling new_BuiltinFunction in ScmdSoundFunctions, line 6"),"playmusic","when calling registerProtectedBuiltin in ScmdSoundFunctions, line 6")
set DvV=d3V("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdSoundFunctions in ScmdSoundFunctions, line 10")
set DeV=OPo(DvV,"when calling new_BuiltinData in ScmdSoundFunctions, line 10")
call etV(DeV,OFo(),f3a(),f3a(),"when calling setArgumentsTypes in ScmdSoundFunctions, line 13")
call Foa(ILo(DeV,"when calling new_BuiltinFunction in ScmdSoundFunctions, line 10"),"playmusicex","when calling registerProtectedBuiltin in ScmdSoundFunctions, line 10")
set DxV=dsV("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdSoundFunctions in ScmdSoundFunctions, line 14")
set DoV=OPo(DxV,"when calling new_BuiltinData in ScmdSoundFunctions, line 14")
call Rxo(DoV,f3a(),"when calling setArgumentsTypes in ScmdSoundFunctions, line 17")
call Foa(ILo(DoV,"when calling new_BuiltinFunction in ScmdSoundFunctions, line 14"),"setmusicplayposition","when calling registerProtectedBuiltin in ScmdSoundFunctions, line 14")
set DrV=dTV("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdSoundFunctions in ScmdSoundFunctions, line 18")
set DiV=OPo(DrV,"when calling new_BuiltinData in ScmdSoundFunctions, line 18")
call Rxo(DiV,f3a(),"when calling setArgumentsTypes in ScmdSoundFunctions, line 21")
call Foa(ILo(DiV,"when calling new_BuiltinFunction in ScmdSoundFunctions, line 18"),"setmusicvolume","when calling registerProtectedBuiltin in ScmdSoundFunctions, line 18")
set DaV=dPV("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdSoundFunctions in ScmdSoundFunctions, line 22")
set DnV=OPo(DaV,"when calling new_BuiltinData in ScmdSoundFunctions, line 22")
call Rxo(DnV,d_V(),"when calling setArgumentsTypes in ScmdSoundFunctions, line 25")
call Foa(ILo(DnV,"when calling new_BuiltinFunction in ScmdSoundFunctions, line 22"),"stopmusic","when calling registerProtectedBuiltin in ScmdSoundFunctions, line 22")
set DVV=dwV("when calling alloc_IBuiltin_registerProtectedBuiltin_ScmdSoundFunctions in ScmdSoundFunctions, line 26")
call Foa(ILo(OPo(DVV,"when calling new_BuiltinData in ScmdSoundFunctions, line 26"),"when calling new_BuiltinFunction in ScmdSoundFunctions, line 26"),"resumemusic","when calling registerProtectedBuiltin in ScmdSoundFunctions, line 26")
set DEV=dYV("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdSoundFunctions in ScmdSoundFunctions, line 30")
set DXV=OPo(DEV,"when calling new_BuiltinData in ScmdSoundFunctions, line 30")
call Rxo(DXV,OFo(),"when calling setArgumentsTypes in ScmdSoundFunctions, line 32")
call Foa(ILo(DXV,"when calling new_BuiltinFunction in ScmdSoundFunctions, line 30"),"getsoundfileduration","when calling registerProtectedBuiltin in ScmdSoundFunctions, line 30")
set EM=EM-1
return true
endfunction
function DOV takes nothing returns boolean
set EM=0
return d6V("ScmdSoundFunctions, line 1")
endfunction
function DRV takes nothing returns nothing
local unit DIV=GetSpellAbilityUnit()
local timer DAV=LoadTimerHandle(nr,GetHandleId(DIV),StringHash("bmT"))
local effect DNV=LoadEffectHandle(nr,GetHandleId(DAV),StringHash("e"))
local location DbV=LoadLocationHandle(nr,GetHandleId(DAV),StringHash("l"))
call RemoveLocation(DbV)
set DbV=null
call FlushChildHashtable(nr,GetHandleId(DAV))
call DestroyTimer(DAV)
set DAV=null
call DestroyEffect(DNV)
set DNV=null
set DIV=null
set DAV=null
set DNV=null
set DbV=null
endfunction
function DBV takes nothing returns nothing
local location DcV=GetSpellTargetLoc()
local unit DCV=GetSpellAbilityUnit()
local effect DdV
local effect DDV
local effect DfV
call pAa(.25)
set DdV=AddSpecialEffectLoc("war3mapImported\\EnergyStrike.mdx",DcV)
call pAa(.75)
set DDV=AddSpecialEffectLoc("war3mapImported\\EnergyStrike.mdx",DcV)
call pAa(.75)
set DfV=AddSpecialEffectLoc("war3mapImported\\EnergyStrike.mdx",DcV)
call pAa(1.25)
call iAV("Abilities\\Spells\\Orc\\LightningShield\\LightningShieldTarget.wav",GetLocationX(DcV),GetLocationY(DcV))
call UnitDamagePoint(DCV,.0,200.,GetLocationX(DcV),GetLocationY(DcV),350.,true,true,ATTACK_TYPE_NORMAL,DAMAGE_TYPE_MAGIC,WEAPON_TYPE_WHOKNOWS)
call pAa(.75)
call DestroyEffect(DdV)
set DdV=null
call iAV("Abilities\\Spells\\Orc\\LightningShield\\LightningShieldTarget.wav",GetLocationX(DcV),GetLocationY(DcV))
call UnitDamagePoint(DCV,.0,200.,GetLocationX(DcV),GetLocationY(DcV),350.,true,true,ATTACK_TYPE_NORMAL,DAMAGE_TYPE_MAGIC,WEAPON_TYPE_WHOKNOWS)
call pAa(.75)
call DestroyEffect(DDV)
set DDV=null
call iAV("Abilities\\Spells\\Orc\\LightningShield\\LightningShieldTarget.wav",GetLocationX(DcV),GetLocationY(DcV))
call UnitDamagePoint(DCV,.0,200.,GetLocationX(DcV),GetLocationY(DcV),350.,true,true,ATTACK_TYPE_NORMAL,DAMAGE_TYPE_MAGIC,WEAPON_TYPE_WHOKNOWS)
set DCV=null
call RemoveLocation(DcV)
set DcV=null
call pAa(.75)
call DestroyEffect(DfV)
set DfV=null
set DcV=null
set DCV=null
set DdV=null
set DDV=null
set DfV=null
endfunction
function DFV takes nothing returns boolean
return GetSpellAbilityId()=='A0JG' and GetOwningPlayer(GetSpellTargetUnit())!=Player(bj_PLAYER_NEUTRAL_VICTIM)and GetUnitTypeId(GetSpellTargetUnit())!='h000'
endfunction
function DgV takes nothing returns nothing
local group DGV=CreateGroup()
call GroupEnumUnitsInRangeOfLoc(DGV,GetSpellTargetLoc(),300.,Condition(ntv))
call ForGroup(DGV,nTv)
call DestroyGroup(DGV)
set DGV=null
set DGV=null
endfunction
function DhV takes nothing returns boolean
return(GetEventPlayerChatString()=="@herofocus")
endfunction
function DHV takes nothing returns boolean
return(GetEventPlayerChatString()=="'herofocus")
endfunction
function DjV takes nothing returns nothing
set g[GetConvertedPlayerId(GetTriggerPlayer())]=GetUnitsOfPlayerMatching(GetTriggerPlayer(),Condition(rmv))
if DHV()then
call ForGroupBJ(g[GetConvertedPlayerId(GetTriggerPlayer())],rMv)
elseif DhV()then
call ForGroupBJ(g[GetConvertedPlayerId(GetTriggerPlayer())],rpv)
endif
call DestroyGroup(g[GetPlayerId(GetTriggerPlayer())+1])
endfunction
function DJV takes nothing returns nothing
local unit DkV=LoadUnitHandle(i,y,GetHandleId(GetExpiredTimer()))
call Gmv(GetExpiredTimer())
call BlzSetUnitAbilityManaCost(DkV,'A0MH',1,75)
call BlzSetUnitAbilityManaCost(DkV,'A0MH',2,75)
call BlzSetUnitAbilityManaCost(DkV,'A0MH',3,75)
set DkV=null
set DkV=null
endfunction
function DKV takes nothing returns boolean
return(GetUnitTypeId(GetEnumUnit())!='h000')and(IsUnitSelected(GetEnumUnit(),GetTriggerPlayer()))
endfunction
function DlV takes nothing returns boolean
return(DKV())
endfunction
function DLV takes nothing returns nothing
if DlV()then
call UnitRemoveAbilityBJ(Ns[GetForLoopIndexA()],GetEnumUnit())
endif
endfunction
function DmV takes nothing returns nothing
call CinematicModeBJ(true,GetForceOfPlayer(GetTriggerPlayer()))
call CinematicModeBJ(false,GetForceOfPlayer(GetTriggerPlayer()))
endfunction
function DMV takes nothing returns boolean
return(GetUnitTypeId(GetEnumUnit())!='h000')and(IsUnitSelected(GetEnumUnit(),GetTriggerPlayer()))and(GetUnitTypeId(GetEnumUnit())!='h0KW')
endfunction
function DpV takes nothing returns nothing
if DMV()then
call UnitAddTypeBJ(UNIT_TYPE_PEON,GetEnumUnit())
endif
endfunction
function DPV takes nothing returns nothing
set xt=InitGameCache("Cache.w3v")
set nr=InitHashtable()
call InitHashtable()
call SetDoodadAnimationRect(bj_mapInitialPlayableArea,'VBta',"Stand First",false)
call SetTerrainFogEx(0,1000000000.,1000000000.,.0,1.,1.,1.)
call SetPlayerTechResearched(Player(PLAYER_NEUTRAL_AGGRESSIVE),'Rosp',1)
call SetPlayerTechResearched(Player(PLAYER_NEUTRAL_PASSIVE),'Rosp',1)
call SetPlayerTechResearched(Player(PLAYER_NEUTRAL_AGGRESSIVE),'Rorb',1)
call SetPlayerTechResearched(Player(PLAYER_NEUTRAL_PASSIVE),'Rorb',1)
set Fr[1]=CreateUnitAtLoc(Player(bj_PLAYER_NEUTRAL_VICTIM),'h0N1',GetUnitLoc(fO),bj_UNIT_FACING)
set Fr[2]=CreateUnitAtLoc(Player(bj_PLAYER_NEUTRAL_VICTIM),'h0N4',GetUnitLoc(TO),bj_UNIT_FACING)
set Fr[3]=CreateUnitAtLoc(Player(bj_PLAYER_NEUTRAL_VICTIM),'h0NA',GetUnitLoc(YO),bj_UNIT_FACING)
set Fr[4]=CreateUnitAtLoc(Player(bj_PLAYER_NEUTRAL_VICTIM),'h0NF',GetUnitLoc(RO),bj_UNIT_FACING)
call SetPlayerState(Player(PLAYER_NEUTRAL_AGGRESSIVE),PLAYER_STATE_NO_CREEP_SLEEP,1)
call ForForce(GetPlayersAll(),v9v)
call ForGroup(GetUnitsOfTypeIdAll('h000'),evv)
set k[0]="|CFFFF0303"
set k[1]="|CFF0042FF"
set k[2]="|CFF1CE6B9"
set k[3]="|CFF540081"
set k[4]="|CFFFFFC01"
set k[5]="|CFFFE8A0E"
set k[6]="|CFF20C000"
set k[7]="|CFF282828"
set k[8]="|CFF959697"
set k[9]="|CFF7EBFF1"
set k[$A]="|CFF106246"
set k[$B]="|CFF4E2A04"
set k[16]="|CFFE55BB0"
set F[1]=true
set ls[1]=true
call SetGameSpeed(MAP_SPEED_FASTEST)
call SetMapFlag(MAP_LOCK_SPEED,true)
call DoNotSaveReplay()
call DestroyTrigger(GetTriggeringTrigger())
endfunction
function DqV takes string DQV returns nothing
set ZM[EM]=DQV
set EM=EM+1
call oCn("when calling generalEventCallback in ClosureEvents, line 293")
set EM=EM-1
endfunction
function DsV takes nothing returns nothing
set EM=0
call DqV("ClosureEvents, line 293")
endfunction
function DSV takes nothing returns integer
return fd
endfunction
function DtV takes string DTV returns integer
local integer DuV
set ZM[EM]=DTV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set DuV=Yj
set Gj[DuV]=$B75
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_setVariadicArgumentTypes_registerProtectedBuiltin_ScmdCoreBuiltins.","when calling error in ScmdCoreBuiltins, line 266")
set DuV=0
endif
else
set Tj=Tj-1
set DuV=Rj[Tj]
set Gj[DuV]=$B75
endif
set EM=EM-1
return DuV
endfunction
function DUV takes string DwV returns integer
local integer DWV
set ZM[EM]=DwV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set DWV=Yj
set Gj[DWV]=$AF1
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins.","when calling error in ScmdCoreBuiltins, line 321")
set DWV=0
endif
else
set Tj=Tj-1
set DWV=Rj[Tj]
set Gj[DWV]=$AF1
endif
set EM=EM-1
return DWV
endfunction
function DyV takes string DYV returns integer
local integer DzV
set ZM[EM]=DYV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set DzV=Yj
set Gj[DzV]=$B71
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_setVariadicArgumentTypes_registerProtectedBuiltin_ScmdCoreBuiltins.","when calling error in ScmdCoreBuiltins, line 61")
set DzV=0
endif
else
set Tj=Tj-1
set DzV=Rj[Tj]
set Gj[DzV]=$B71
endif
set EM=EM-1
return DzV
endfunction
function DZV takes string D_V returns integer
local integer D0V
set ZM[EM]=D_V
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set D0V=Yj
set Gj[D0V]=$AE1
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins.","when calling error in ScmdCoreBuiltins, line 168")
set D0V=0
endif
else
set Tj=Tj-1
set D0V=Rj[Tj]
set Gj[D0V]=$AE1
endif
set EM=EM-1
return D0V
endfunction
function D1V takes string D2V returns integer
local integer D3V
set ZM[EM]=D2V
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set D3V=Yj
set Gj[D3V]=$BA0
else
call Cdv("Out of memory: Could not create IBuiltin_setVariadicArgumentTypes_registerProtectedBuiltin_ScmdCoreBuiltins.","when calling error in ScmdCoreBuiltins, line 307")
set D3V=0
endif
else
set Tj=Tj-1
set D3V=Rj[Tj]
set Gj[D3V]=$BA0
endif
set EM=EM-1
return D3V
endfunction
function D4V takes string D5V returns integer
local integer D6V
set ZM[EM]=D5V
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set D6V=Yj
set Gj[D6V]=$B23
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_setProvidingEnumUnit_addOverload_registerProtectedBuiltin_ScmdCoreBuiltins.","when calling error in ScmdCoreBuiltins, line 459")
set D6V=0
endif
else
set Tj=Tj-1
set D6V=Rj[Tj]
set Gj[D6V]=$B23
endif
set EM=EM-1
return D6V
endfunction
function D7V takes string D8V returns integer
local integer D9V
set ZM[EM]=D8V
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set D9V=Yj
set Gj[D9V]=$B9B
else
call Cdv("Out of memory: Could not create IBuiltin_setVariadicArgumentTypes_registerProtectedBuiltin_ScmdCoreBuiltins.","when calling error in ScmdCoreBuiltins, line 25")
set D9V=0
endif
else
set Tj=Tj-1
set D9V=Rj[Tj]
set Gj[D9V]=$B9B
endif
set EM=EM-1
return D9V
endfunction
function fvV takes string feV returns integer
local integer fxV
set ZM[EM]=feV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set fxV=Yj
set Gj[fxV]=$ADF
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins.","when calling error in ScmdCoreBuiltins, line 162")
set fxV=0
endif
else
set Tj=Tj-1
set fxV=Rj[Tj]
set Gj[fxV]=$ADF
endif
set EM=EM-1
return fxV
endfunction
function foV takes string frV returns integer
local integer fiV
set ZM[EM]=frV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set fiV=Yj
set Gj[fiV]=$B73
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_setVariadicArgumentTypes_registerProtectedBuiltin_ScmdCoreBuiltins.","when calling error in ScmdCoreBuiltins, line 237")
set fiV=0
endif
else
set Tj=Tj-1
set fiV=Rj[Tj]
set Gj[fiV]=$B73
endif
set EM=EM-1
return fiV
endfunction
function faV takes string fnV returns integer
local integer fVV
set ZM[EM]=fnV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set fVV=Yj
set Gj[fVV]=$A3A
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdCoreBuiltins.","when calling error in ScmdCoreBuiltins, line 298")
set fVV=0
endif
else
set Tj=Tj-1
set fVV=Rj[Tj]
set Gj[fVV]=$A3A
endif
set EM=EM-1
return fVV
endfunction
function fEV takes string fXV returns integer
local integer fOV
set ZM[EM]=fXV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set fOV=Yj
set Gj[fOV]=$B24
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_setProvidingEnumUnit_registerProtectedBuiltin_ScmdCoreBuiltins.","when calling error in ScmdCoreBuiltins, line 444")
set fOV=0
endif
else
set Tj=Tj-1
set fOV=Rj[Tj]
set Gj[fOV]=$B24
endif
set EM=EM-1
return fOV
endfunction
function fRV takes string fIV returns integer
local integer fAV
set ZM[EM]=fIV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set fAV=Yj
set Gj[fAV]=$ADD
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins.","when calling error in ScmdCoreBuiltins, line 156")
set fAV=0
endif
else
set Tj=Tj-1
set fAV=Rj[Tj]
set Gj[fAV]=$ADD
endif
set EM=EM-1
return fAV
endfunction
function fNV takes integer fbV,integer fBV,string fcV returns integer
local integer fCV
set ZM[EM]=fcV
set EM=EM+1
set fCV=yTv("when calling new_LinkedList in LinkedList, line 403")
call zGv(fCV,fbV,"when calling add in LinkedList, line 405")
call zGv(fCV,fBV,"when calling add in LinkedList, line 405")
set EM=EM-1
return fCV
endfunction
function fdV takes string fDV returns integer
local integer ffV
set ZM[EM]=fDV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set ffV=Yj
set Gj[ffV]=$B74
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_setVariadicArgumentTypes_registerProtectedBuiltin_ScmdCoreBuiltins.","when calling error in ScmdCoreBuiltins, line 263")
set ffV=0
endif
else
set Tj=Tj-1
set ffV=Rj[Tj]
set Gj[ffV]=$B74
endif
set EM=EM-1
return ffV
endfunction
function fFV takes string fgV returns integer
local integer fGV
set ZM[EM]=fgV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set fGV=Yj
set Gj[fGV]=$AF0
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins.","when calling error in ScmdCoreBuiltins, line 302")
set fGV=0
endif
else
set Tj=Tj-1
set fGV=Rj[Tj]
set Gj[fGV]=$AF0
endif
set EM=EM-1
return fGV
endfunction
function fhV takes string fHV returns integer
local integer fjV
set ZM[EM]=fHV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set fjV=Yj
set Gj[fjV]=$B22
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_setProvidingEnumUnit_addOverload_registerProtectedBuiltin_ScmdCoreBuiltins.","when calling error in ScmdCoreBuiltins, line 457")
set fjV=0
endif
else
set Tj=Tj-1
set fjV=Rj[Tj]
set Gj[fjV]=$B22
endif
set EM=EM-1
return fjV
endfunction
function fJV takes string fkV returns integer
local integer fKV
set ZM[EM]=fkV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set fKV=Yj
set Gj[fKV]=$B9A
else
call Cdv("Out of memory: Could not create IBuiltin_setVariadicArgumentTypes_registerProtectedBuiltin_ScmdCoreBuiltins.","when calling error in ScmdCoreBuiltins, line 10")
set fKV=0
endif
else
set Tj=Tj-1
set fKV=Rj[Tj]
set Gj[fKV]=$B9A
endif
set EM=EM-1
return fKV
endfunction
function flV takes string fLV returns integer
local integer fmV
set ZM[EM]=fLV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set fmV=Yj
set Gj[fmV]=$ADE
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins.","when calling error in ScmdCoreBuiltins, line 159")
set fmV=0
endif
else
set Tj=Tj-1
set fmV=Rj[Tj]
set Gj[fmV]=$ADE
endif
set EM=EM-1
return fmV
endfunction
function fMV takes string fpV returns integer
local integer fPV
set ZM[EM]=fpV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set fPV=Yj
set Gj[fPV]=$B76
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_setVariadicArgumentTypes_registerProtectedBuiltin_ScmdCoreBuiltins.","when calling error in ScmdCoreBuiltins, line 313")
set fPV=0
endif
else
set Tj=Tj-1
set fPV=Rj[Tj]
set Gj[fPV]=$B76
endif
set EM=EM-1
return fPV
endfunction
function fqV takes string fQV returns integer
local integer fsV
set ZM[EM]=fQV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set fsV=Yj
set Gj[fsV]=$B70
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_setVariadicArgumentTypes_registerProtectedBuiltin_ScmdCoreBuiltins.","when calling error in ScmdCoreBuiltins, line 40")
set fsV=0
endif
else
set Tj=Tj-1
set fsV=Rj[Tj]
set Gj[fsV]=$B70
endif
set EM=EM-1
return fsV
endfunction
function fSV takes string ftV returns integer
local integer fTV
set ZM[EM]=ftV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set fTV=Yj
set Gj[fTV]=$AE0
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins.","when calling error in ScmdCoreBuiltins, line 165")
set fTV=0
endif
else
set Tj=Tj-1
set fTV=Rj[Tj]
set Gj[fTV]=$AE0
endif
set EM=EM-1
return fTV
endfunction
function fuV takes string fUV returns integer
local integer fwV
set ZM[EM]=fUV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set fwV=Yj
set Gj[fwV]=$BA1
else
call Cdv("Out of memory: Could not create IBuiltin_setVariadicArgumentTypes_registerProtectedBuiltin_ScmdCoreBuiltins.","when calling error in ScmdCoreBuiltins, line 326")
set fwV=0
endif
else
set Tj=Tj-1
set fwV=Rj[Tj]
set Gj[fwV]=$BA1
endif
set EM=EM-1
return fwV
endfunction
function fWV takes string fyV returns integer
local integer fYV
set ZM[EM]=fyV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set fYV=Yj
set Gj[fYV]=$B9C
else
call Cdv("Out of memory: Could not create IBuiltin_setVariadicArgumentTypes_registerProtectedBuiltin_ScmdCoreBuiltins.","when calling error in ScmdCoreBuiltins, line 87")
set fYV=0
endif
else
set Tj=Tj-1
set fYV=Rj[Tj]
set Gj[fYV]=$B9C
endif
set EM=EM-1
return fYV
endfunction
function fzV takes string fZV returns integer
local integer f_V
set ZM[EM]=fZV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set f_V=Yj
set Gj[f_V]=$AE2
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins.","when calling error in ScmdCoreBuiltins, line 171")
set f_V=0
endif
else
set Tj=Tj-1
set f_V=Rj[Tj]
set Gj[f_V]=$AE2
endif
set EM=EM-1
return f_V
endfunction
function f0V takes string f1V returns integer
local integer f2V
set ZM[EM]=f1V
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set f2V=Yj
set Gj[f2V]=$B9F
else
call Cdv("Out of memory: Could not create IBuiltin_setVariadicArgumentTypes_registerProtectedBuiltin_ScmdCoreBuiltins.","when calling error in ScmdCoreBuiltins, line 213")
set f2V=0
endif
else
set Tj=Tj-1
set f2V=Rj[Tj]
set Gj[f2V]=$B9F
endif
set EM=EM-1
return f2V
endfunction
function f3V takes string f4V returns integer
local integer f5V
set ZM[EM]=f4V
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set f5V=Yj
set Gj[f5V]=$AED
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins.","when calling error in ScmdCoreBuiltins, line 287")
set f5V=0
endif
else
set Tj=Tj-1
set f5V=Rj[Tj]
set Gj[f5V]=$AED
endif
set EM=EM-1
return f5V
endfunction
function f6V takes string f7V returns integer
local integer f8V
set ZM[EM]=f7V
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set f8V=Yj
set Gj[f8V]=$A3E
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdCoreBuiltins.","when calling error in ScmdCoreBuiltins, line 377")
set f8V=0
endif
else
set Tj=Tj-1
set f8V=Rj[Tj]
set Gj[f8V]=$A3E
endif
set EM=EM-1
return f8V
endfunction
function f9V takes string FvV returns integer
local integer FeV
set ZM[EM]=FvV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set FeV=Yj
set Gj[FeV]=$A39
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdCoreBuiltins.","when calling error in ScmdCoreBuiltins, line 131")
set FeV=0
endif
else
set Tj=Tj-1
set FeV=Rj[Tj]
set Gj[FeV]=$A39
endif
set EM=EM-1
return FeV
endfunction
function FxV takes string FoV returns integer
local integer FrV
set ZM[EM]=FoV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set FrV=Yj
set Gj[FrV]=$AEB
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins.","when calling error in ScmdCoreBuiltins, line 281")
set FrV=0
endif
else
set Tj=Tj-1
set FrV=Rj[Tj]
set Gj[FrV]=$AEB
endif
set EM=EM-1
return FrV
endfunction
function FiV takes string FaV returns integer
local integer FnV
set ZM[EM]=FaV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set FnV=Yj
set Gj[FnV]=$B78
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_setVariadicArgumentTypes_registerProtectedBuiltin_ScmdCoreBuiltins.","when calling error in ScmdCoreBuiltins, line 367")
set FnV=0
endif
else
set Tj=Tj-1
set FnV=Rj[Tj]
set Gj[FnV]=$B78
endif
set EM=EM-1
return FnV
endfunction
function FVV takes string FEV returns integer
local integer FXV
set ZM[EM]=FEV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set FXV=Yj
set Gj[FXV]=$AD9
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins.","when calling error in ScmdCoreBuiltins, line 126")
set FXV=0
endif
else
set Tj=Tj-1
set FXV=Rj[Tj]
set Gj[FXV]=$AD9
endif
set EM=EM-1
return FXV
endfunction
function FOV takes string FRV returns integer
local integer FIV
set ZM[EM]=FRV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set FIV=Yj
set Gj[FIV]=$AE5
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins.","when calling error in ScmdCoreBuiltins, line 180")
set FIV=0
endif
else
set Tj=Tj-1
set FIV=Rj[Tj]
set Gj[FIV]=$AE5
endif
set EM=EM-1
return FIV
endfunction
function FAV takes string FNV returns integer
local integer FbV
set ZM[EM]=FNV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set FbV=Yj
set Gj[FbV]=$AE8
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins.","when calling error in ScmdCoreBuiltins, line 272")
set FbV=0
endif
else
set Tj=Tj-1
set FbV=Rj[Tj]
set Gj[FbV]=$AE8
endif
set EM=EM-1
return FbV
endfunction
function FBV takes string FcV returns integer
local integer FCV
set ZM[EM]=FcV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set FCV=Yj
set Gj[FCV]=$A3B
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdCoreBuiltins.","when calling error in ScmdCoreBuiltins, line 349")
set FCV=0
endif
else
set Tj=Tj-1
set FCV=Rj[Tj]
set Gj[FCV]=$A3B
endif
set EM=EM-1
return FCV
endfunction
function FdV takes string FDV returns integer
local integer FfV
set ZM[EM]=FDV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set FfV=Yj
set Gj[FfV]=$AD7
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins.","when calling error in ScmdCoreBuiltins, line 112")
set FfV=0
endif
else
set Tj=Tj-1
set FfV=Rj[Tj]
set Gj[FfV]=$AD7
endif
set EM=EM-1
return FfV
endfunction
function FFV takes nothing returns integer
return vn
endfunction
function FgV takes string FGV returns integer
local integer FhV
set ZM[EM]=FGV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set FhV=Yj
set Gj[FhV]=$AEC
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins.","when calling error in ScmdCoreBuiltins, line 284")
set FhV=0
endif
else
set Tj=Tj-1
set FhV=Rj[Tj]
set Gj[FhV]=$AEC
endif
set EM=EM-1
return FhV
endfunction
function FHV takes string FjV returns integer
local integer FJV
set ZM[EM]=FjV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set FJV=Yj
set Gj[FJV]=$A3D
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdCoreBuiltins.","when calling error in ScmdCoreBuiltins, line 375")
set FJV=0
endif
else
set Tj=Tj-1
set FJV=Rj[Tj]
set Gj[FJV]=$A3D
endif
set EM=EM-1
return FJV
endfunction
function FkV takes string FKV returns integer
local integer FlV
set ZM[EM]=FKV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set FlV=Yj
set Gj[FlV]=$A38
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdCoreBuiltins.","when calling error in ScmdCoreBuiltins, line 129")
set FlV=0
endif
else
set Tj=Tj-1
set FlV=Rj[Tj]
set Gj[FlV]=$A38
endif
set EM=EM-1
return FlV
endfunction
function FLV takes string FmV returns integer
local integer FMV
set ZM[EM]=FmV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set FMV=Yj
set Gj[FMV]=$AEE
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins.","when calling error in ScmdCoreBuiltins, line 290")
set FMV=0
endif
else
set Tj=Tj-1
set FMV=Rj[Tj]
set Gj[FMV]=$AEE
endif
set EM=EM-1
return FMV
endfunction
function FpV takes string FPV returns integer
local integer FqV
set ZM[EM]=FPV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set FqV=Yj
set Gj[FqV]=$AF3
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins.","when calling error in ScmdCoreBuiltins, line 380")
set FqV=0
endif
else
set Tj=Tj-1
set FqV=Rj[Tj]
set Gj[FqV]=$AF3
endif
set EM=EM-1
return FqV
endfunction
function FQV takes string FsV returns integer
local integer FSV
set ZM[EM]=FsV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set FSV=Yj
set Gj[FSV]=$ADA
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins.","when calling error in ScmdCoreBuiltins, line 134")
set FSV=0
endif
else
set Tj=Tj-1
set FSV=Rj[Tj]
set Gj[FSV]=$ADA
endif
set EM=EM-1
return FSV
endfunction
function FtV takes string FTV returns integer
local integer FuV
set ZM[EM]=FTV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set FuV=Yj
set Gj[FuV]=$AEF
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins.","when calling error in ScmdCoreBuiltins, line 293")
set FuV=0
endif
else
set Tj=Tj-1
set FuV=Rj[Tj]
set Gj[FuV]=$AEF
endif
set EM=EM-1
return FuV
endfunction
function FUV takes string FwV returns integer
local integer FWV
set ZM[EM]=FwV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set FWV=Yj
set Gj[FWV]=$B79
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_setVariadicArgumentTypes_registerProtectedBuiltin_ScmdCoreBuiltins.","when calling error in ScmdCoreBuiltins, line 388")
set FWV=0
endif
else
set Tj=Tj-1
set FWV=Rj[Tj]
set Gj[FWV]=$B79
endif
set EM=EM-1
return FWV
endfunction
function FyV takes string FYV returns integer
local integer FzV
set ZM[EM]=FYV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set FzV=Yj
set Gj[FzV]=$ADB
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins.","when calling error in ScmdCoreBuiltins, line 149")
set FzV=0
endif
else
set Tj=Tj-1
set FzV=Rj[Tj]
set Gj[FzV]=$ADB
endif
set EM=EM-1
return FzV
endfunction
function FZV takes string F_V returns integer
local integer F0V
set ZM[EM]=F_V
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set F0V=Yj
set Gj[F0V]=$AE6
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins.","when calling error in ScmdCoreBuiltins, line 183")
set F0V=0
endif
else
set Tj=Tj-1
set F0V=Rj[Tj]
set Gj[F0V]=$AE6
endif
set EM=EM-1
return F0V
endfunction
function F1V takes string F2V returns integer
local integer F3V
set ZM[EM]=F2V
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set F3V=Yj
set Gj[F3V]=$AE9
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins.","when calling error in ScmdCoreBuiltins, line 275")
set F3V=0
endif
else
set Tj=Tj-1
set F3V=Rj[Tj]
set Gj[F3V]=$AE9
endif
set EM=EM-1
return F3V
endfunction
function F4V takes string F5V returns integer
local integer F6V
set ZM[EM]=F5V
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set F6V=Yj
set Gj[F6V]=$A3C
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdCoreBuiltins.","when calling error in ScmdCoreBuiltins, line 356")
set F6V=0
endif
else
set Tj=Tj-1
set F6V=Rj[Tj]
set Gj[F6V]=$A3C
endif
set EM=EM-1
return F6V
endfunction
function F7V takes string F8V returns integer
local integer F9V
set ZM[EM]=F8V
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set F9V=Yj
set Gj[F9V]=$B9D
else
call Cdv("Out of memory: Could not create IBuiltin_setVariadicArgumentTypes_registerProtectedBuiltin_ScmdCoreBuiltins.","when calling error in ScmdCoreBuiltins, line 117")
set F9V=0
endif
else
set Tj=Tj-1
set F9V=Rj[Tj]
set Gj[F9V]=$B9D
endif
set EM=EM-1
return F9V
endfunction
function gvV takes string geV returns integer
local integer gxV
set ZM[EM]=geV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set gxV=Yj
set Gj[gxV]=$B72
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_setVariadicArgumentTypes_registerProtectedBuiltin_ScmdCoreBuiltins.","when calling error in ScmdCoreBuiltins, line 216")
set gxV=0
endif
else
set Tj=Tj-1
set gxV=Rj[Tj]
set Gj[gxV]=$B72
endif
set EM=EM-1
return gxV
endfunction
function goV takes string grV returns integer
local integer giV
set ZM[EM]=grV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set giV=Yj
set Gj[giV]=$A1E
else
call Cdv("Out of memory: Could not create IBuiltin_addOverload_registerProtectedBuiltin_ScmdCoreBuiltins.","when calling error in ScmdCoreBuiltins, line 296")
set giV=0
endif
else
set Tj=Tj-1
set giV=Rj[Tj]
set Gj[giV]=$A1E
endif
set EM=EM-1
return giV
endfunction
function gaV takes string gnV returns integer
local integer gVV
set ZM[EM]=gnV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set gVV=Yj
set Gj[gVV]=$B7A
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_setVariadicArgumentTypes_registerProtectedBuiltin_ScmdCoreBuiltins.","when calling error in ScmdCoreBuiltins, line 413")
set gVV=0
endif
else
set Tj=Tj-1
set gVV=Rj[Tj]
set Gj[gVV]=$B7A
endif
set EM=EM-1
return gVV
endfunction
function gEV takes string gXV returns integer
local integer gOV
set ZM[EM]=gXV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set gOV=Yj
set Gj[gOV]=$ADC
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins.","when calling error in ScmdCoreBuiltins, line 152")
set gOV=0
endif
else
set Tj=Tj-1
set gOV=Rj[Tj]
set Gj[gOV]=$ADC
endif
set EM=EM-1
return gOV
endfunction
function gRV takes nothing returns integer
return mn
endfunction
function gIV takes string gAV returns integer
local integer gNV
set ZM[EM]=gAV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set gNV=Yj
set Gj[gNV]=$B9E
else
call Cdv("Out of memory: Could not create IBuiltin_setVariadicArgumentTypes_registerProtectedBuiltin_ScmdCoreBuiltins.","when calling error in ScmdCoreBuiltins, line 210")
set gNV=0
endif
else
set Tj=Tj-1
set gNV=Rj[Tj]
set Gj[gNV]=$B9E
endif
set EM=EM-1
return gNV
endfunction
function gbV takes string gBV returns integer
local integer gcV
set ZM[EM]=gBV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set gcV=Yj
set Gj[gcV]=$AEA
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins.","when calling error in ScmdCoreBuiltins, line 278")
set gcV=0
endif
else
set Tj=Tj-1
set gcV=Rj[Tj]
set Gj[gcV]=$AEA
endif
set EM=EM-1
return gcV
endfunction
function gCV takes string gdV returns integer
local integer gDV
set ZM[EM]=gdV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set gDV=Yj
set Gj[gDV]=$AF2
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins.","when calling error in ScmdCoreBuiltins, line 364")
set gDV=0
endif
else
set Tj=Tj-1
set gDV=Rj[Tj]
set Gj[gDV]=$AF2
endif
set EM=EM-1
return gDV
endfunction
function gfV takes string gFV returns integer
local integer ggV
set ZM[EM]=gFV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set ggV=Yj
set Gj[ggV]=$AD8
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins.","when calling error in ScmdCoreBuiltins, line 123")
set ggV=0
endif
else
set Tj=Tj-1
set ggV=Rj[Tj]
set Gj[ggV]=$AD8
endif
set EM=EM-1
return ggV
endfunction
function gGV takes integer ghV,integer gHV,integer gjV,integer gJV,integer gkV,string gKV returns nothing
set ZM[EM]=gKV
set EM=EM+1
set xJ[ghV]=0
call zGv(jJ[ghV],gHV,"when calling add in ScmdDataTypes, line 1394")
set xJ[ghV]=xJ[ghV]+1
call zGv(jJ[ghV],gjV,"when calling add in ScmdDataTypes, line 1394")
set xJ[ghV]=xJ[ghV]+1
call zGv(jJ[ghV],gJV,"when calling add in ScmdDataTypes, line 1394")
set xJ[ghV]=xJ[ghV]+1
call zGv(jJ[ghV],gkV,"when calling add in ScmdDataTypes, line 1394")
set xJ[ghV]=xJ[ghV]+1
set EM=EM-1
endfunction
function glV takes integer gLV,integer gmV,integer gMV,integer gpV,integer gPV,string gqV returns nothing
set ZM[EM]=gqV
set EM=EM+1
if ax[gLV]==0 then
if gLV==0 then
call Cdv("Nullpointer exception when calling BuiltinData.setArgumentsTypes","when calling error in ScmdDataTypes, line 1391")
else
call Cdv("Called BuiltinData.setArgumentsTypes on invalid object.","when calling error in ScmdDataTypes, line 1391")
endif
endif
call gGV(gLV,gmV,gMV,gpV,gPV,"when calling setArgumentsTypes in ScmdDataTypes, line 1391")
set EM=EM-1
endfunction
function gQV takes nothing returns integer
return ud
endfunction
function gsV takes string gSV returns integer
local integer gtV
set ZM[EM]=gSV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set gtV=Yj
set Gj[gtV]=$AE4
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins.","when calling error in ScmdCoreBuiltins, line 177")
set gtV=0
endif
else
set Tj=Tj-1
set gtV=Rj[Tj]
set Gj[gtV]=$AE4
endif
set EM=EM-1
return gtV
endfunction
function gTV takes string guV returns integer
local integer gUV
set ZM[EM]=guV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set gUV=Yj
set Gj[gUV]=$AE7
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins.","when calling error in ScmdCoreBuiltins, line 269")
set gUV=0
endif
else
set Tj=Tj-1
set gUV=Rj[Tj]
set Gj[gUV]=$AE7
endif
set EM=EM-1
return gUV
endfunction
function gwV takes string gWV returns integer
local integer gyV
set ZM[EM]=gWV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set gyV=Yj
set Gj[gyV]=$AD6
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins.","when calling error in ScmdCoreBuiltins, line 109")
set gyV=0
endif
else
set Tj=Tj-1
set gyV=Rj[Tj]
set Gj[gyV]=$AD6
endif
set EM=EM-1
return gyV
endfunction
function gYV takes string gzV returns integer
local integer gZV
set ZM[EM]=gzV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set gZV=Yj
set Gj[gZV]=$AE3
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins.","when calling error in ScmdCoreBuiltins, line 174")
set gZV=0
endif
else
set Tj=Tj-1
set gZV=Rj[Tj]
set Gj[gZV]=$AE3
endif
set EM=EM-1
return gZV
endfunction
function g_V takes integer g0V,integer g1V,string g2V returns nothing
local integer g3V
local integer g4V
local string g5V
local integer g6V
local integer g7V
set ZM[EM]=g2V
set EM=EM+1
set g3V=p0v(g0V,"when calling new_SharedPointer in ScmdBuiltinsRegistrar, line 26")
set g4V=Xle(g1V,"when calling iterator in ScmdBuiltinsRegistrar, line 27")
loop
exitwhen not Xie(g4V)
set g5V=hxv(E3e(g4V),"when calling stringFromIndex in ScmdBuiltinsRegistrar, line 27")
set g6V=0
set g7V=bj_MAX_PLAYERS-1
loop
exitwhen g6V>g7V
call c6e(g6V,g5V,null,null,g3V,true,"when calling assign in ScmdBuiltinsRegistrar, line 29")
set g6V=g6V+1
endloop
endloop
call Xpe(g4V,"when calling close in ScmdBuiltinsRegistrar, line 27")
call Hcv(g1V,"when calling dispatch_LinkedList_destroyLinkedList in ScmdBuiltinsRegistrar, line 30")
set EM=EM-1
endfunction
function g8V takes string g9V returns integer
local integer GvV
set ZM[EM]=g9V
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set GvV=Yj
set Gj[GvV]=$B77
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_setVariadicArgumentTypes_registerProtectedBuiltin_ScmdCoreBuiltins.","when calling error in ScmdCoreBuiltins, line 329")
set GvV=0
endif
else
set Tj=Tj-1
set GvV=Rj[Tj]
set Gj[GvV]=$B77
endif
set EM=EM-1
return GvV
endfunction
function GeV takes string GxV returns integer
local integer GoV
set ZM[EM]=GxV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set GoV=Yj
set Gj[GoV]=$AD5
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins.","when calling error in ScmdCoreBuiltins, line 106")
set GoV=0
endif
else
set Tj=Tj-1
set GoV=Rj[Tj]
set Gj[GoV]=$AD5
endif
set EM=EM-1
return GoV
endfunction
function GrV takes string GiV returns boolean
local integer GaV
local integer GnV
local integer GVV
local integer GEV
local integer GXV
local integer GOV
local integer GRV
local integer GIV
local integer GAV
local integer GNV
local integer GbV
local integer GBV
local integer GcV
local integer GCV
local integer GdV
local integer GDV
local integer GfV
local integer GFV
local integer GgV
local integer GGV
local integer GhV
local integer GHV
local integer GjV
local integer GJV
local integer GkV
local integer GKV
local integer GlV
local integer GLV
local integer GmV
local integer GMV
local integer GpV
local integer GPV
local integer GqV
local integer GQV
local integer GsV
local integer GSV
local integer GtV
local integer GTV
local integer GuV
local integer GUV
local integer GwV
local integer GWV
local integer GyV
local integer GYV
local integer GzV
local integer GZV
local integer G_V
local integer G0V
local integer G1V
local integer G2V
local integer G3V
local integer G4V
local integer G5V
local integer G6V
local integer G7V
local integer G8V
local integer G9V
local integer hvV
local integer heV
local integer hxV
local integer hoV
local integer hrV
local integer hiV
local integer haV
local integer hnV
local integer hVV
local integer hEV
local integer hXV
local integer hOV
local integer hRV
local integer hIV
local integer hAV
local integer hNV
local integer hbV
local integer hBV
local integer hcV
local integer hCV
local integer hdV
local integer hDV
local integer hfV
local integer hFV
local integer hgV
local integer hGV
local integer hhV
local integer hHV
local integer hjV
local integer hJV
local integer hkV
local integer hKV
local integer hlV
local integer hLV
local integer hmV
local integer hMV
local integer hpV
local integer hPV
local integer hqV
local integer hQV
local integer hsV
local integer hSV
local integer htV
local integer hTV
local integer huV
local integer hUV
local integer hwV
local integer hWV
local integer hyV
local integer hYV
local integer hzV
local integer hZV
local integer h_V
local integer h0V
local integer h1V
local integer h2V
local integer h3V
local integer h4V
local integer h5V
local integer h6V
local integer h7V
local integer h8V
local integer h9V
local integer HvV
local integer HeV
local integer HxV
local integer HoV
local integer HrV
local integer HiV
local integer HaV
local integer HnV
local integer HVV
local integer HEV
local integer HXV
local integer HOV
local integer HRV
local integer HIV
local integer HAV
local integer HNV
local integer HbV
local integer HBV
local integer HcV
local integer HCV
local integer HdV
local integer HDV
local integer HfV
local integer HFV
local integer HgV
set ZM[EM]=GiV
set EM=EM+1
set GaV=fJV("when calling alloc_IBuiltin_setVariadicArgumentTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdCoreBuiltins, line 10")
set GnV=OPo(GaV,"when calling new_BuiltinData in ScmdCoreBuiltins, line 10")
call OyV(GnV,xdV(),"when calling setVariadicArgumentTypes in ScmdCoreBuiltins, line 24")
call Foa(ILo(GnV,"when calling new_BuiltinFunction in ScmdCoreBuiltins, line 10"),"+","when calling registerProtectedBuiltin in ScmdCoreBuiltins, line 10")
set GVV=D7V("when calling alloc_IBuiltin_setVariadicArgumentTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdCoreBuiltins, line 25")
set GEV=OPo(GVV,"when calling new_BuiltinData in ScmdCoreBuiltins, line 25")
call OyV(GEV,FFV(),"when calling setVariadicArgumentTypes in ScmdCoreBuiltins, line 39")
call Foa(ILo(GEV,"when calling new_BuiltinFunction in ScmdCoreBuiltins, line 25"),"*","when calling registerProtectedBuiltin in ScmdCoreBuiltins, line 25")
set GXV=fqV("when calling alloc_IBuiltin_setArgumentsTypes_setVariadicArgumentTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdCoreBuiltins, line 40")
set GOV=OPo(GXV,"when calling new_BuiltinData in ScmdCoreBuiltins, line 40")
call Rxo(GOV,FFV(),"when calling setArgumentsTypes in ScmdCoreBuiltins, line 60")
set GRV=GOV
call OyV(GRV,FFV(),"when calling setVariadicArgumentTypes in ScmdCoreBuiltins, line 60")
call Foa(ILo(GRV,"when calling new_BuiltinFunction in ScmdCoreBuiltins, line 40"),"-","when calling registerProtectedBuiltin in ScmdCoreBuiltins, line 40")
set GIV=DyV("when calling alloc_IBuiltin_setArgumentsTypes_setVariadicArgumentTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdCoreBuiltins, line 61")
set GAV=OPo(GIV,"when calling new_BuiltinData in ScmdCoreBuiltins, line 61")
call Rxo(GAV,FFV(),"when calling setArgumentsTypes in ScmdCoreBuiltins, line 86")
set GNV=GAV
call OyV(GNV,FFV(),"when calling setVariadicArgumentTypes in ScmdCoreBuiltins, line 86")
call Foa(ILo(GNV,"when calling new_BuiltinFunction in ScmdCoreBuiltins, line 61"),"/","when calling registerProtectedBuiltin in ScmdCoreBuiltins, line 61")
set GbV=fWV("when calling alloc_IBuiltin_setVariadicArgumentTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdCoreBuiltins, line 87")
set GBV=OPo(GbV,"when calling new_BuiltinData in ScmdCoreBuiltins, line 87")
call OyV(GBV,xdV(),"when calling setVariadicArgumentTypes in ScmdCoreBuiltins, line 97")
call Foa(ILo(GBV,"when calling new_BuiltinFunction in ScmdCoreBuiltins, line 87"),"println","when calling registerProtectedBuiltin in ScmdCoreBuiltins, line 87")
set GcV=GeV("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdCoreBuiltins, line 106")
set GCV=OPo(GcV,"when calling new_BuiltinData in ScmdCoreBuiltins, line 106")
call Rxo(GCV,xdV(),"when calling setArgumentsTypes in ScmdCoreBuiltins, line 108")
call Foa(G3a(GCV,"when calling new_BuiltinSpecialForm in ScmdCoreBuiltins, line 106"),"quote","when calling registerProtectedBuiltin in ScmdCoreBuiltins, line 106")
set GdV=gwV("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdCoreBuiltins, line 109")
set GDV=OPo(GdV,"when calling new_BuiltinData in ScmdCoreBuiltins, line 109")
call Rxo(GDV,xdV(),"when calling setArgumentsTypes in ScmdCoreBuiltins, line 111")
call Foa(ILo(GDV,"when calling new_BuiltinFunction in ScmdCoreBuiltins, line 109"),"throw","when calling registerProtectedBuiltin in ScmdCoreBuiltins, line 109")
set GfV=FdV("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdCoreBuiltins, line 112")
set GFV=OPo(GfV,"when calling new_BuiltinData in ScmdCoreBuiltins, line 112")
call Rxo(GFV,xdV(),"when calling setArgumentsTypes in ScmdCoreBuiltins, line 114")
call Foa(ILo(GFV,"when calling new_BuiltinFunction in ScmdCoreBuiltins, line 112"),"identity","when calling registerProtectedBuiltin in ScmdCoreBuiltins, line 112")
set GgV=F7V("when calling alloc_IBuiltin_setVariadicArgumentTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdCoreBuiltins, line 117")
set GGV=OPo(GgV,"when calling new_BuiltinData in ScmdCoreBuiltins, line 117")
call OyV(GGV,xdV(),"when calling setVariadicArgumentTypes in ScmdCoreBuiltins, line 122")
call Foa(ILo(GGV,"when calling new_BuiltinFunction in ScmdCoreBuiltins, line 117"),"str","when calling registerProtectedBuiltin in ScmdCoreBuiltins, line 117")
set GhV=gfV("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdCoreBuiltins, line 123")
set GHV=OPo(GhV,"when calling new_BuiltinData in ScmdCoreBuiltins, line 123")
call Rxo(GHV,OFo(),"when calling setArgumentsTypes in ScmdCoreBuiltins, line 125")
call Foa(ILo(GHV,"when calling new_BuiltinFunction in ScmdCoreBuiltins, line 123"),"strlen","when calling registerProtectedBuiltin in ScmdCoreBuiltins, line 123")
set GjV=FVV("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdCoreBuiltins, line 126")
set GJV=OPo(GjV,"when calling new_BuiltinData in ScmdCoreBuiltins, line 126")
call Rxo(GJV,OFo(),"when calling setArgumentsTypes in ScmdCoreBuiltins, line 128")
call Foa(ILo(GJV,"when calling new_BuiltinFunction in ScmdCoreBuiltins, line 126"),"hash","when calling registerProtectedBuiltin in ScmdCoreBuiltins, line 126")
set GkV=FkV("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdCoreBuiltins, line 129")
set GKV=OPo(GkV,"when calling new_BuiltinData in ScmdCoreBuiltins, line 129")
call FRa(GKV,OFo(),f3a(),"when calling setArgumentsTypes in ScmdCoreBuiltins, line 131")
set GmV=ILo(GKV,"when calling new_BuiltinFunction in ScmdCoreBuiltins, line 129")
set HdV=GmV
set GlV=f9V("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdCoreBuiltins, line 131")
set GLV=OPo(GlV,"when calling new_BuiltinData in ScmdCoreBuiltins, line 131")
call etV(GLV,OFo(),f3a(),f3a(),"when calling setArgumentsTypes in ScmdCoreBuiltins, line 133")
call IFo(HdV,GLV,"when calling addOverload in ScmdCoreBuiltins, line 131")
call Foa(GmV,"subs","when calling registerProtectedBuiltin in ScmdCoreBuiltins, line 129")
set GMV=FQV("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdCoreBuiltins, line 134")
set GpV=OPo(GMV,"when calling new_BuiltinData in ScmdCoreBuiltins, line 134")
call Rxo(GpV,OFo(),"when calling setArgumentsTypes in ScmdCoreBuiltins, line 148")
call Foa(ILo(GpV,"when calling new_BuiltinFunction in ScmdCoreBuiltins, line 134"),"reverse","when calling registerProtectedBuiltin in ScmdCoreBuiltins, line 134")
set GPV=FyV("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdCoreBuiltins, line 149")
set GqV=OPo(GPV,"when calling new_BuiltinData in ScmdCoreBuiltins, line 149")
call etV(GqV,OFo(),OFo(),OFo(),"when calling setArgumentsTypes in ScmdCoreBuiltins, line 151")
call Foa(ILo(GqV,"when calling new_BuiltinFunction in ScmdCoreBuiltins, line 149"),"replace","when calling registerProtectedBuiltin in ScmdCoreBuiltins, line 149")
set GQV=gEV("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdCoreBuiltins, line 152")
set GsV=OPo(GQV,"when calling new_BuiltinData in ScmdCoreBuiltins, line 152")
call Rxo(GsV,OFo(),"when calling setArgumentsTypes in ScmdCoreBuiltins, line 155")
call Foa(ILo(GsV,"when calling new_BuiltinFunction in ScmdCoreBuiltins, line 152"),"capitalize","when calling registerProtectedBuiltin in ScmdCoreBuiltins, line 152")
set GSV=fRV("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdCoreBuiltins, line 156")
set GtV=OPo(GSV,"when calling new_BuiltinData in ScmdCoreBuiltins, line 156")
call Rxo(GtV,OFo(),"when calling setArgumentsTypes in ScmdCoreBuiltins, line 158")
call Foa(ILo(GtV,"when calling new_BuiltinFunction in ScmdCoreBuiltins, line 156"),"lower-case","when calling registerProtectedBuiltin in ScmdCoreBuiltins, line 156")
set GTV=flV("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdCoreBuiltins, line 159")
set GuV=OPo(GTV,"when calling new_BuiltinData in ScmdCoreBuiltins, line 159")
call Rxo(GuV,OFo(),"when calling setArgumentsTypes in ScmdCoreBuiltins, line 161")
call Foa(ILo(GuV,"when calling new_BuiltinFunction in ScmdCoreBuiltins, line 159"),"upper-case","when calling registerProtectedBuiltin in ScmdCoreBuiltins, line 159")
set GUV=fvV("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdCoreBuiltins, line 162")
set GwV=OPo(GUV,"when calling new_BuiltinData in ScmdCoreBuiltins, line 162")
call Rxo(GwV,OFo(),"when calling setArgumentsTypes in ScmdCoreBuiltins, line 164")
call Foa(ILo(GwV,"when calling new_BuiltinFunction in ScmdCoreBuiltins, line 162"),"trim","when calling registerProtectedBuiltin in ScmdCoreBuiltins, line 162")
set GWV=fSV("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdCoreBuiltins, line 165")
set GyV=OPo(GWV,"when calling new_BuiltinData in ScmdCoreBuiltins, line 165")
call Rxo(GyV,OFo(),"when calling setArgumentsTypes in ScmdCoreBuiltins, line 167")
call Foa(ILo(GyV,"when calling new_BuiltinFunction in ScmdCoreBuiltins, line 165"),"triml","when calling registerProtectedBuiltin in ScmdCoreBuiltins, line 165")
set GYV=DZV("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdCoreBuiltins, line 168")
set GzV=OPo(GYV,"when calling new_BuiltinData in ScmdCoreBuiltins, line 168")
call Rxo(GzV,OFo(),"when calling setArgumentsTypes in ScmdCoreBuiltins, line 170")
call Foa(ILo(GzV,"when calling new_BuiltinFunction in ScmdCoreBuiltins, line 168"),"trimr","when calling registerProtectedBuiltin in ScmdCoreBuiltins, line 168")
set GZV=fzV("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdCoreBuiltins, line 171")
set G_V=OPo(GZV,"when calling new_BuiltinData in ScmdCoreBuiltins, line 171")
call Rxo(G_V,xdV(),"when calling setArgumentsTypes in ScmdCoreBuiltins, line 173")
call Foa(ILo(G_V,"when calling new_BuiltinFunction in ScmdCoreBuiltins, line 171"),"string?","when calling registerProtectedBuiltin in ScmdCoreBuiltins, line 171")
set G0V=gYV("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdCoreBuiltins, line 174")
set G1V=OPo(G0V,"when calling new_BuiltinData in ScmdCoreBuiltins, line 174")
call Rxo(G1V,OFo(),"when calling setArgumentsTypes in ScmdCoreBuiltins, line 176")
call Foa(ILo(G1V,"when calling new_BuiltinFunction in ScmdCoreBuiltins, line 174"),"blank?","when calling registerProtectedBuiltin in ScmdCoreBuiltins, line 174")
set G2V=gsV("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdCoreBuiltins, line 177")
set G3V=OPo(G2V,"when calling new_BuiltinData in ScmdCoreBuiltins, line 177")
call FRa(G3V,OFo(),OFo(),"when calling setArgumentsTypes in ScmdCoreBuiltins, line 179")
call Foa(ILo(G3V,"when calling new_BuiltinFunction in ScmdCoreBuiltins, line 177"),"starts-with?","when calling registerProtectedBuiltin in ScmdCoreBuiltins, line 177")
set G4V=FOV("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdCoreBuiltins, line 180")
set G5V=OPo(G4V,"when calling new_BuiltinData in ScmdCoreBuiltins, line 180")
call FRa(G5V,OFo(),OFo(),"when calling setArgumentsTypes in ScmdCoreBuiltins, line 182")
call Foa(ILo(G5V,"when calling new_BuiltinFunction in ScmdCoreBuiltins, line 180"),"ends-with?","when calling registerProtectedBuiltin in ScmdCoreBuiltins, line 180")
set G6V=FZV("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdCoreBuiltins, line 183")
set G7V=OPo(G6V,"when calling new_BuiltinData in ScmdCoreBuiltins, line 183")
call FRa(G7V,OFo(),OFo(),"when calling setArgumentsTypes in ScmdCoreBuiltins, line 185")
call Foa(ILo(G7V,"when calling new_BuiltinFunction in ScmdCoreBuiltins, line 183"),"includes?","when calling registerProtectedBuiltin in ScmdCoreBuiltins, line 183")
set G8V=gIV("when calling alloc_IBuiltin_setVariadicArgumentTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdCoreBuiltins, line 210")
set G9V=OPo(G8V,"when calling new_BuiltinData in ScmdCoreBuiltins, line 210")
call OyV(G9V,FFV(),"when calling setVariadicArgumentTypes in ScmdCoreBuiltins, line 212")
call Foa(ILo(G9V,"when calling new_BuiltinFunction in ScmdCoreBuiltins, line 210"),"+","when calling registerProtectedBuiltin in ScmdCoreBuiltins, line 210")
set hvV=f0V("when calling alloc_IBuiltin_setVariadicArgumentTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdCoreBuiltins, line 213")
set heV=OPo(hvV,"when calling new_BuiltinData in ScmdCoreBuiltins, line 213")
call OyV(heV,FFV(),"when calling setVariadicArgumentTypes in ScmdCoreBuiltins, line 215")
call Foa(ILo(heV,"when calling new_BuiltinFunction in ScmdCoreBuiltins, line 213"),"*","when calling registerProtectedBuiltin in ScmdCoreBuiltins, line 213")
set hxV=gvV("when calling alloc_IBuiltin_setArgumentsTypes_setVariadicArgumentTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdCoreBuiltins, line 216")
set hoV=OPo(hxV,"when calling new_BuiltinData in ScmdCoreBuiltins, line 216")
call Rxo(hoV,FFV(),"when calling setArgumentsTypes in ScmdCoreBuiltins, line 236")
set hrV=hoV
call OyV(hrV,FFV(),"when calling setVariadicArgumentTypes in ScmdCoreBuiltins, line 236")
call Foa(ILo(hrV,"when calling new_BuiltinFunction in ScmdCoreBuiltins, line 216"),"-","when calling registerProtectedBuiltin in ScmdCoreBuiltins, line 216")
set hiV=foV("when calling alloc_IBuiltin_setArgumentsTypes_setVariadicArgumentTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdCoreBuiltins, line 237")
set haV=OPo(hiV,"when calling new_BuiltinData in ScmdCoreBuiltins, line 237")
call Rxo(haV,FFV(),"when calling setArgumentsTypes in ScmdCoreBuiltins, line 262")
set hnV=haV
call OyV(hnV,FFV(),"when calling setVariadicArgumentTypes in ScmdCoreBuiltins, line 262")
call Foa(ILo(hnV,"when calling new_BuiltinFunction in ScmdCoreBuiltins, line 237"),"/","when calling registerProtectedBuiltin in ScmdCoreBuiltins, line 237")
set hVV=fdV("when calling alloc_IBuiltin_setArgumentsTypes_setVariadicArgumentTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdCoreBuiltins, line 263")
set hEV=OPo(hVV,"when calling new_BuiltinData in ScmdCoreBuiltins, line 263")
call Rxo(hEV,FFV(),"when calling setArgumentsTypes in ScmdCoreBuiltins, line 265")
set hXV=hEV
call OyV(hXV,FFV(),"when calling setVariadicArgumentTypes in ScmdCoreBuiltins, line 265")
call Foa(ILo(hXV,"when calling new_BuiltinFunction in ScmdCoreBuiltins, line 263"),"max","when calling registerProtectedBuiltin in ScmdCoreBuiltins, line 263")
set hOV=DtV("when calling alloc_IBuiltin_setArgumentsTypes_setVariadicArgumentTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdCoreBuiltins, line 266")
set hRV=OPo(hOV,"when calling new_BuiltinData in ScmdCoreBuiltins, line 266")
call Rxo(hRV,FFV(),"when calling setArgumentsTypes in ScmdCoreBuiltins, line 268")
set hIV=hRV
call OyV(hIV,FFV(),"when calling setVariadicArgumentTypes in ScmdCoreBuiltins, line 268")
call Foa(ILo(hIV,"when calling new_BuiltinFunction in ScmdCoreBuiltins, line 266"),"min","when calling registerProtectedBuiltin in ScmdCoreBuiltins, line 266")
set hAV=gTV("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdCoreBuiltins, line 269")
set hNV=OPo(hAV,"when calling new_BuiltinData in ScmdCoreBuiltins, line 269")
call Rxo(hNV,FFV(),"when calling setArgumentsTypes in ScmdCoreBuiltins, line 271")
call Foa(ILo(hNV,"when calling new_BuiltinFunction in ScmdCoreBuiltins, line 269"),"int","when calling registerProtectedBuiltin in ScmdCoreBuiltins, line 269")
set hbV=FAV("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdCoreBuiltins, line 272")
set hBV=OPo(hbV,"when calling new_BuiltinData in ScmdCoreBuiltins, line 272")
call Rxo(hBV,FFV(),"when calling setArgumentsTypes in ScmdCoreBuiltins, line 274")
call Foa(ILo(hBV,"when calling new_BuiltinFunction in ScmdCoreBuiltins, line 272"),"zero?","when calling registerProtectedBuiltin in ScmdCoreBuiltins, line 272")
set hcV=F1V("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdCoreBuiltins, line 275")
set hCV=OPo(hcV,"when calling new_BuiltinData in ScmdCoreBuiltins, line 275")
call Rxo(hCV,FFV(),"when calling setArgumentsTypes in ScmdCoreBuiltins, line 277")
call Foa(ILo(hCV,"when calling new_BuiltinFunction in ScmdCoreBuiltins, line 275"),"pos?","when calling registerProtectedBuiltin in ScmdCoreBuiltins, line 275")
set hdV=gbV("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdCoreBuiltins, line 278")
set hDV=OPo(hdV,"when calling new_BuiltinData in ScmdCoreBuiltins, line 278")
call Rxo(hDV,FFV(),"when calling setArgumentsTypes in ScmdCoreBuiltins, line 280")
call Foa(ILo(hDV,"when calling new_BuiltinFunction in ScmdCoreBuiltins, line 278"),"neg?","when calling registerProtectedBuiltin in ScmdCoreBuiltins, line 278")
set hfV=FxV("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdCoreBuiltins, line 281")
set hFV=OPo(hfV,"when calling new_BuiltinData in ScmdCoreBuiltins, line 281")
call Rxo(hFV,f3a(),"when calling setArgumentsTypes in ScmdCoreBuiltins, line 283")
call Foa(ILo(hFV,"when calling new_BuiltinFunction in ScmdCoreBuiltins, line 281"),"even?","when calling registerProtectedBuiltin in ScmdCoreBuiltins, line 281")
set hgV=FgV("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdCoreBuiltins, line 284")
set hGV=OPo(hgV,"when calling new_BuiltinData in ScmdCoreBuiltins, line 284")
call Rxo(hGV,f3a(),"when calling setArgumentsTypes in ScmdCoreBuiltins, line 286")
call Foa(ILo(hGV,"when calling new_BuiltinFunction in ScmdCoreBuiltins, line 284"),"odd?","when calling registerProtectedBuiltin in ScmdCoreBuiltins, line 284")
set hhV=f3V("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdCoreBuiltins, line 287")
set hHV=OPo(hhV,"when calling new_BuiltinData in ScmdCoreBuiltins, line 287")
call Rxo(hHV,xdV(),"when calling setArgumentsTypes in ScmdCoreBuiltins, line 289")
call g_V(ILo(hHV,"when calling new_BuiltinFunction in ScmdCoreBuiltins, line 287"),fNV(KCv("int?","when calling stringToIndex in ScmdCoreBuiltins, line 289"),KCv("integer?","when calling stringToIndex in ScmdCoreBuiltins, line 289"),"when calling asList in ScmdCoreBuiltins, line 289"),"when calling registerProtectedBuiltin in ScmdCoreBuiltins, line 287")
set hjV=FLV("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdCoreBuiltins, line 290")
set hJV=OPo(hjV,"when calling new_BuiltinData in ScmdCoreBuiltins, line 290")
call Rxo(hJV,xdV(),"when calling setArgumentsTypes in ScmdCoreBuiltins, line 292")
call Foa(ILo(hJV,"when calling new_BuiltinFunction in ScmdCoreBuiltins, line 290"),"real?","when calling registerProtectedBuiltin in ScmdCoreBuiltins, line 290")
set hkV=FtV("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdCoreBuiltins, line 293")
set hKV=OPo(hkV,"when calling new_BuiltinData in ScmdCoreBuiltins, line 293")
call Rxo(hKV,xdV(),"when calling setArgumentsTypes in ScmdCoreBuiltins, line 295")
call Foa(ILo(hKV,"when calling new_BuiltinFunction in ScmdCoreBuiltins, line 293"),"number?","when calling registerProtectedBuiltin in ScmdCoreBuiltins, line 293")
set hlV=goV("when calling alloc_IBuiltin_addOverload_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdCoreBuiltins, line 296")
set hMV=ILo(OPo(hlV,"when calling new_BuiltinData in ScmdCoreBuiltins, line 296"),"when calling new_BuiltinFunction in ScmdCoreBuiltins, line 296")
set HDV=hMV
set hLV=faV("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdCoreBuiltins, line 298")
set hmV=OPo(hLV,"when calling new_BuiltinData in ScmdCoreBuiltins, line 298")
call Rxo(hmV,gQV(),"when calling setArgumentsTypes in ScmdCoreBuiltins, line 301")
call IFo(HDV,hmV,"when calling addOverload in ScmdCoreBuiltins, line 298")
call Foa(hMV,"rand","when calling registerProtectedBuiltin in ScmdCoreBuiltins, line 296")
set hpV=fFV("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdCoreBuiltins, line 302")
set hPV=OPo(hpV,"when calling new_BuiltinData in ScmdCoreBuiltins, line 302")
call Rxo(hPV,f3a(),"when calling setArgumentsTypes in ScmdCoreBuiltins, line 305")
call Foa(ILo(hPV,"when calling new_BuiltinFunction in ScmdCoreBuiltins, line 302"),"rand-int","when calling registerProtectedBuiltin in ScmdCoreBuiltins, line 302")
set hqV=D1V("when calling alloc_IBuiltin_setVariadicArgumentTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdCoreBuiltins, line 307")
set hQV=OPo(hqV,"when calling new_BuiltinData in ScmdCoreBuiltins, line 307")
call OyV(hQV,xdV(),"when calling setVariadicArgumentTypes in ScmdCoreBuiltins, line 312")
call Foa(ILo(hQV,"when calling new_BuiltinFunction in ScmdCoreBuiltins, line 307"),"vector","when calling registerProtectedBuiltin in ScmdCoreBuiltins, line 307")
set hsV=fMV("when calling alloc_IBuiltin_setArgumentsTypes_setVariadicArgumentTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdCoreBuiltins, line 313")
set hSV=OPo(hsV,"when calling new_BuiltinData in ScmdCoreBuiltins, line 313")
call FRa(hSV,DSV(),xdV(),"when calling setArgumentsTypes in ScmdCoreBuiltins, line 320")
set htV=hSV
call OyV(htV,xdV(),"when calling setVariadicArgumentTypes in ScmdCoreBuiltins, line 320")
call Foa(ILo(htV,"when calling new_BuiltinFunction in ScmdCoreBuiltins, line 313"),"conj","when calling registerProtectedBuiltin in ScmdCoreBuiltins, line 313")
set hTV=DUV("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdCoreBuiltins, line 321")
set huV=OPo(hTV,"when calling new_BuiltinData in ScmdCoreBuiltins, line 321")
call FRa(huV,DSV(),f3a(),"when calling setArgumentsTypes in ScmdCoreBuiltins, line 325")
call Foa(ILo(huV,"when calling new_BuiltinFunction in ScmdCoreBuiltins, line 321"),"nth","when calling registerProtectedBuiltin in ScmdCoreBuiltins, line 321")
set hUV=fuV("when calling alloc_IBuiltin_setVariadicArgumentTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdCoreBuiltins, line 326")
set hwV=OPo(hUV,"when calling new_BuiltinData in ScmdCoreBuiltins, line 326")
call OyV(hwV,xdV(),"when calling setVariadicArgumentTypes in ScmdCoreBuiltins, line 328")
call Foa(ILo(hwV,"when calling new_BuiltinFunction in ScmdCoreBuiltins, line 326"),"do","when calling registerProtectedBuiltin in ScmdCoreBuiltins, line 326")
set hWV=g8V("when calling alloc_IBuiltin_setArgumentsTypes_setVariadicArgumentTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdCoreBuiltins, line 329")
set hyV=OPo(hWV,"when calling new_BuiltinData in ScmdCoreBuiltins, line 329")
call Rxo(hyV,gQV(),"when calling setArgumentsTypes in ScmdCoreBuiltins, line 348")
set hYV=hyV
call OyV(hYV,xdV(),"when calling setVariadicArgumentTypes in ScmdCoreBuiltins, line 348")
call Foa(G3a(hYV,"when calling new_BuiltinSpecialForm in ScmdCoreBuiltins, line 329"),"do-after","when calling registerProtectedBuiltin in ScmdCoreBuiltins, line 329")
set hzV=FBV("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdCoreBuiltins, line 349")
set hZV=OPo(hzV,"when calling new_BuiltinData in ScmdCoreBuiltins, line 349")
call FRa(hZV,xdV(),xdV(),"when calling setArgumentsTypes in ScmdCoreBuiltins, line 356")
set h1V=G3a(hZV,"when calling new_BuiltinSpecialForm in ScmdCoreBuiltins, line 349")
set HfV=h1V
set h_V=F4V("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdCoreBuiltins, line 356")
set h0V=OPo(h_V,"when calling new_BuiltinData in ScmdCoreBuiltins, line 356")
call etV(h0V,xdV(),xdV(),xdV(),"when calling setArgumentsTypes in ScmdCoreBuiltins, line 363")
call Gya(HfV,h0V,"when calling addOverload in ScmdCoreBuiltins, line 356")
call Foa(h1V,"if","when calling registerProtectedBuiltin in ScmdCoreBuiltins, line 349")
set h2V=gCV("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdCoreBuiltins, line 364")
set h3V=OPo(h2V,"when calling new_BuiltinData in ScmdCoreBuiltins, line 364")
call Rxo(h3V,d_V(),"when calling setArgumentsTypes in ScmdCoreBuiltins, line 366")
call Foa(ILo(h3V,"when calling new_BuiltinFunction in ScmdCoreBuiltins, line 364"),"not","when calling registerProtectedBuiltin in ScmdCoreBuiltins, line 364")
set h4V=FiV("when calling alloc_IBuiltin_setArgumentsTypes_setVariadicArgumentTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdCoreBuiltins, line 367")
set h5V=OPo(h4V,"when calling new_BuiltinData in ScmdCoreBuiltins, line 367")
call Rxo(h5V,xdV(),"when calling setArgumentsTypes in ScmdCoreBuiltins, line 374")
set h6V=h5V
call OyV(h6V,xdV(),"when calling setVariadicArgumentTypes in ScmdCoreBuiltins, line 374")
call Foa(ILo(h6V,"when calling new_BuiltinFunction in ScmdCoreBuiltins, line 367"),"=","when calling registerProtectedBuiltin in ScmdCoreBuiltins, line 367")
set h7V=FHV("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdCoreBuiltins, line 375")
set h8V=OPo(h7V,"when calling new_BuiltinData in ScmdCoreBuiltins, line 375")
call FRa(h8V,OFo(),xdV(),"when calling setArgumentsTypes in ScmdCoreBuiltins, line 377")
set HeV=ILo(h8V,"when calling new_BuiltinFunction in ScmdCoreBuiltins, line 375")
set HFV=HeV
set h9V=f6V("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdCoreBuiltins, line 377")
set HvV=OPo(h9V,"when calling new_BuiltinData in ScmdCoreBuiltins, line 377")
call etV(HvV,OFo(),OFo(),xdV(),"when calling setArgumentsTypes in ScmdCoreBuiltins, line 379")
call IFo(HFV,HvV,"when calling addOverload in ScmdCoreBuiltins, line 377")
call Foa(HeV,"def","when calling registerProtectedBuiltin in ScmdCoreBuiltins, line 375")
set HxV=FpV("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdCoreBuiltins, line 380")
set HoV=OPo(HxV,"when calling new_BuiltinData in ScmdCoreBuiltins, line 380")
call FRa(HoV,OFo(),OFo(),"when calling setArgumentsTypes in ScmdCoreBuiltins, line 387")
call Foa(ILo(HoV,"when calling new_BuiltinFunction in ScmdCoreBuiltins, line 380"),"alias","when calling registerProtectedBuiltin in ScmdCoreBuiltins, line 380")
set HrV=FUV("when calling alloc_IBuiltin_setArgumentsTypes_setVariadicArgumentTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdCoreBuiltins, line 388")
set HiV=OPo(HrV,"when calling new_BuiltinData in ScmdCoreBuiltins, line 388")
call FRa(HiV,gRV(),DSV(),"when calling setArgumentsTypes in ScmdCoreBuiltins, line 412")
set HaV=HiV
call OyV(HaV,DSV(),"when calling setVariadicArgumentTypes in ScmdCoreBuiltins, line 412")
call Foa(ILo(HaV,"when calling new_BuiltinFunction in ScmdCoreBuiltins, line 388"),"mapv","when calling registerProtectedBuiltin in ScmdCoreBuiltins, line 388")
set HnV=gaV("when calling alloc_IBuiltin_setArgumentsTypes_setVariadicArgumentTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdCoreBuiltins, line 413")
set HVV=OPo(HnV,"when calling new_BuiltinData in ScmdCoreBuiltins, line 413")
call Rxo(HVV,gRV(),"when calling setArgumentsTypes in ScmdCoreBuiltins, line 429")
set HEV=HVV
call OyV(HEV,xdV(),"when calling setVariadicArgumentTypes in ScmdCoreBuiltins, line 429")
call Foa(ILo(HEV,"when calling new_BuiltinFunction in ScmdCoreBuiltins, line 413"),"apply","when calling registerProtectedBuiltin in ScmdCoreBuiltins, line 413")
set HXV=fEV("when calling alloc_IBuiltin_setArgumentsTypes_setProvidingEnumUnit_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdCoreBuiltins, line 444")
set HOV=OPo(HXV,"when calling new_BuiltinData in ScmdCoreBuiltins, line 444")
call FRa(HOV,xdV(),xdV(),"when calling setArgumentsTypes in ScmdCoreBuiltins, line 446")
set HRV=HOV
call LNa(HRV,"when calling setProvidingEnumUnit in ScmdCoreBuiltins, line 446")
call Foa(G3a(HRV,"when calling new_BuiltinSpecialForm in ScmdCoreBuiltins, line 444"),"fn","when calling registerProtectedBuiltin in ScmdCoreBuiltins, line 444")
set HIV=fhV("when calling alloc_IBuiltin_setArgumentsTypes_setProvidingEnumUnit_addOverload_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdCoreBuiltins, line 457")
set HAV=OPo(HIV,"when calling new_BuiltinData in ScmdCoreBuiltins, line 457")
call etV(HAV,OFo(),xdV(),xdV(),"when calling setArgumentsTypes in ScmdCoreBuiltins, line 459")
set HNV=HAV
call LNa(HNV,"when calling setProvidingEnumUnit in ScmdCoreBuiltins, line 459")
set HCV=G3a(HNV,"when calling new_BuiltinSpecialForm in ScmdCoreBuiltins, line 457")
set HgV=HCV
set HbV=D4V("when calling alloc_IBuiltin_setArgumentsTypes_setProvidingEnumUnit_addOverload_registerProtectedBuiltin_ScmdCoreBuiltins in ScmdCoreBuiltins, line 459")
set HBV=OPo(HbV,"when calling new_BuiltinData in ScmdCoreBuiltins, line 459")
call glV(HBV,OFo(),OFo(),xdV(),xdV(),"when calling setArgumentsTypes in ScmdCoreBuiltins, line 461")
set HcV=HBV
call LNa(HcV,"when calling setProvidingEnumUnit in ScmdCoreBuiltins, line 461")
call Gya(HgV,HcV,"when calling addOverload in ScmdCoreBuiltins, line 459")
call Foa(HCV,"defn","when calling registerProtectedBuiltin in ScmdCoreBuiltins, line 457")
set EM=EM-1
return true
endfunction
function HGV takes nothing returns boolean
set EM=0
return GrV("ScmdCoreBuiltins, line 1")
endfunction
function HhV takes nothing returns boolean
return(Du==LoadIntegerBJ(4,GetHandleIdBJ(GetEnumUnit()),Au))
endfunction
function HHV takes nothing returns nothing
if HhV()then
call GroupRemoveUnitSimple(GetEnumUnit(),Hu)
call RemoveUnit(LoadUnitHandleBJ(2,GetHandleIdBJ(GetEnumUnit()),Au))
call RemoveUnit(LoadUnitHandleBJ(3,GetHandleIdBJ(GetEnumUnit()),Au))
call SetPlayerAbilityAvailableBJ(true,'A07W',GetOwningPlayer(GetEnumUnit()))
call UnitRemoveAbilityBJ('A07X',GetEnumUnit())
set Ju[20]=LoadLocationHandleBJ(0,GetHandleIdBJ(GetEnumUnit()),Au)
call RemoveLocation(Ju[20])
call FlushChildHashtableBJ(GetHandleIdBJ(GetEnumUnit()),Au)
endif
endfunction
function HjV takes nothing returns boolean
return(GetSpellAbilityId()=='A0IP')
endfunction
function HJV takes nothing returns nothing
local unit HkV=GetSpellAbilityUnit()
call SetWidgetLife(HkV,GetWidgetLife(HkV)+75*GetUnitAbilityLevel(HkV,'AOsm')-25.)
set HkV=null
set HkV=null
endfunction
function HKV takes nothing returns boolean
return GetSpellAbilityId()=='AObw'
endfunction
function HlV takes nothing returns boolean
return(GetSpellAbilityId()=='A0DG')
endfunction
function HLV takes nothing returns nothing
local unit HmV
local unit HMV
if GetSpellAbilityId()!='A0GJ' then
set HmV=null
set HMV=null
return
endif
set HmV=GetSpellAbilityUnit()
set HMV=GetSpellTargetUnit()
call DestroyEffect(AddSpecialEffect("Objects\\Spawnmodels\\Undead\\ImpaleTargetDust\\ImpaleTargetDust.mdl",GetUnitX(HmV),GetUnitY(HmV)))
call DestroyEffect(AddSpecialEffect("Abilities\\Spells\\NightElf\\Blink\\BlinkCaster.mdl",GetUnitX(HmV),GetUnitY(HmV)))
call SetUnitX(HmV,GetUnitX(HMV)-(BlzGetUnitCollisionSize(HmV)+BlzGetUnitCollisionSize(HMV))*Cos(Deg2Rad(GetUnitFacing(HMV))))
call SetUnitY(HmV,GetUnitY(HMV)-(BlzGetUnitCollisionSize(HmV)+BlzGetUnitCollisionSize(HMV))*Sin(Deg2Rad(GetUnitFacing(HMV))))
call SetUnitFacing(HmV,Rad2Deg(Atan2(GetUnitY(HMV)-GetUnitY(HmV),GetUnitX(HMV)-GetUnitX(HmV))))
call DestroyEffect(AddSpecialEffect("Abilities\\Spells\\NightElf\\Blink\\BlinkTarget.mdl",GetUnitX(HmV),GetUnitY(HmV)))
call DestroyEffect(AddSpecialEffect("Objects\\Spawnmodels\\Undead\\ImpaleTargetDust\\ImpaleTargetDust.mdl",GetUnitX(HmV),GetUnitY(HmV)))
call DestroyEffect(AddSpecialEffectTarget("Objects\\Spawnmodels\\Critters\\Albatross\\CritterBloodAlbatross.mdl",HMV,"chest"))
call UnitDamageTarget(HmV,HMV,75*GetUnitAbilityLevel(HmV,'A0GJ'),true,true,ATTACK_TYPE_NORMAL,DAMAGE_TYPE_MAGIC,WEAPON_TYPE_WHOKNOWS)
set HMV=null
set HmV=null
set HmV=null
set HMV=null
endfunction
function HpV takes nothing returns boolean
return(GetUnitTypeId(GetEnumUnit())!='h000')and(IsUnitSelected(GetEnumUnit(),GetTriggerPlayer()))
endfunction
function HPV takes nothing returns boolean
return(HpV())
endfunction
function HqV takes nothing returns nothing
if HPV()then
call UnitAddAbilityBJ(Ns[GetForLoopIndexA()],GetEnumUnit())
call UnitMakeAbilityPermanent(GetEnumUnit(),true,Ns[GetForLoopIndexA()])
endif
endfunction
function HQV takes integer HsV returns nothing
call X7V(HsV)
call SetRect(fb[HsV],Rb[HsV],Tb[HsV],Yb[HsV],Gb[HsV])
call OFV(HsV)
endfunction
function HSV takes integer HtV,real HTV returns nothing
set Rb[HtV]=HTV
call HQV(HtV)
endfunction
function HuV takes real HUV,real HwV returns real
if HUV>HwV then
return HUV
endif
return HwV
endfunction
function HWV takes integer HyV,real HYV returns nothing
set Gb[HyV]=HYV
call HQV(HyV)
endfunction
function HzV takes integer HZV returns nothing
set sy=HZV
call TriggerEvaluate(Mb)
endfunction
function H_V takes nothing returns integer
local integer H0V
if hb[0]==0 then
set gb=gb+1
set H0V=gb
else
set H0V=hb[0]
set hb[0]=hb[hb[0]]
endif
return H0V
endfunction
function H1V takes real H2V returns real
local real H3V=I2R(R2I(H2V))
if H3V==H2V or H2V>.0 then
return H3V
else
return H3V-1.
endif
endfunction
function H4V takes integer H5V,string H6V,boolean H7V,real H8V,real H9V,real jvV,real jeV returns integer
local integer jxV=H_V()
set pb[jxV]=B0v()
set eb[jxV]=0
set qb[jxV]=H5V
set ab[jxV]=H6V
set fb[jxV]=Rect(.0,.0,.0,.0)
set nb[jxV]=H8V>jvV
if not nb[jxV]then
set Rb[jxV]=H8V
set Yb[jxV]=jvV
else
set Rb[jxV]=jvV
set Yb[jxV]=H8V
endif
set db[jxV]=H9V>jeV
if not db[jxV]then
set Tb[jxV]=H9V
set Gb[jxV]=jeV
else
set Tb[jxV]=jeV
set Gb[jxV]=H9V
endif
if H7V then
set Rb[jxV]=H1V(Rb[jxV]/128.)*128.
set Tb[jxV]=H1V(Tb[jxV]/128.)*128.
set Yb[jxV]=OaV(Yb[jxV]/128.)*128.
set Gb[jxV]=OaV(Gb[jxV]/128.)*128.
endif
call HzV(jxV)
return jxV
endfunction
function joV takes real jrV,real jiV returns real
if jrV<jiV then
return jrV
endif
return jiV
endfunction
function jaV takes integer jnV,real jVV returns nothing
set Tb[jnV]=jVV
call HQV(jnV)
endfunction
function jEV takes integer jXV returns nothing
call FlushChildHashtable(i,jXV)
call SaveInteger(i,S,jXV,LoadInteger(i,S,0))
call SaveInteger(i,S,0,jXV)
endfunction
function jOV takes integer jRV returns nothing
set hb[jRV]=hb[0]
set hb[0]=jRV
endfunction
function jIV takes integer jAV returns nothing
call X7V(jAV)
call jEV(pb[jAV])
call RemoveRect(fb[jAV])
call jOV(jAV)
endfunction
function jNV takes integer jbV,boolean jBV returns nothing
if jBV then
call SetPlayerTechResearched(r[jbV],Yl,1)
call SetPlayerTechResearched(r[jbV],Gl,0)
else
call SetPlayerTechResearched(r[jbV],Yl,0)
call SetPlayerTechResearched(r[jbV],Gl,1)
endif
endfunction
function jcV takes integer jCV,real jdV returns nothing
set Yb[jCV]=jdV
call HQV(jCV)
endfunction
function jDV takes nothing returns nothing
local integer jfV=GetPlayerId(GetTriggerPlayer())
local integer jFV=GetSpellAbilityId()
if jFV>='AcR1' and jFV<='AcR8' then
if jFV=='AcR1' then
call HSV(Fl[jfV],HuV(Rb[Fl[jfV]]-128.,e))
elseif jFV=='AcR2' then
if Rb[Fl[jfV]]+128.!=Yb[Fl[jfV]]then
call HSV(Fl[jfV],Rb[Fl[jfV]]+128.)
endif
elseif jFV=='AcR3' then
call HWV(Fl[jfV],joV(Gb[Fl[jfV]]+128.,q))
elseif jFV=='AcR4' then
if Gb[Fl[jfV]]-128.!=Tb[Fl[jfV]]then
call HWV(Fl[jfV],Gb[Fl[jfV]]-128.)
endif
elseif jFV=='AcR5' then
call jcV(Fl[jfV],joV(Yb[Fl[jfV]]+128.,p))
elseif jFV=='AcR6' then
if Yb[Fl[jfV]]-128.!=Rb[Fl[jfV]]then
call jcV(Fl[jfV],Yb[Fl[jfV]]-128.)
endif
elseif jFV=='AcR7' then
call jaV(Fl[jfV],HuV(Tb[Fl[jfV]]-128.,a))
elseif jFV=='AcR8' then
if Tb[Fl[jfV]]+128.!=Gb[Fl[jfV]]then
call jaV(Fl[jfV],Tb[Fl[jfV]]+128.)
endif
endif
elseif jFV=='AcR9' then
if not xl[jfV]then
set kl[jfV]=GetSpellTargetX()
set jl[jfV]=GetSpellTargetY()
set xl[jfV]=true
else
set Fl[jfV]=H4V(jfV,"DRAL",true,kl[jfV],jl[jfV],GetSpellTargetX(),GetSpellTargetY())
call jNV(jfV,true)
endif
elseif jFV=='A0KH' then
set xl[jfV]=false
call jIV(Fl[jfV])
call jNV(jfV,false)
elseif jFV=='A0KI' then
endif
endfunction
function jgV takes nothing returns nothing
set eu=.25
set yu=false
set uu=GetSpellTargetLoc()
set Mw=GetTriggerUnit()
set tu=45.
set ou="Abilities\\Weapons\\FaerieDragonMissile\\FaerieDragonMissile.mdl"
set lu="walk"
set qu=.6
call ConditionalTriggerExecute(DS)
endfunction
function jGV takes nothing returns nothing
call GroupRemoveUnit(ps,GetSpellAbilityUnit())
endfunction
function jhV takes nothing returns boolean
return(GetUnitTypeId(GetEnumUnit())!='h000')and(IsUnitSelected(GetEnumUnit(),GetTriggerPlayer()))
endfunction
function jHV takes nothing returns boolean
return(jhV())
endfunction
function jjV takes nothing returns nothing
if jHV()then
call UnitRemoveAbilityBJ('A0G4',GetEnumUnit())
call UnitRemoveAbilityBJ('A0G7',GetEnumUnit())
call UnitRemoveAbilityBJ('A0G5',GetEnumUnit())
call UnitRemoveAbilityBJ('A0G8',GetEnumUnit())
call GroupRemoveUnitSimple(GetEnumUnit(),us)
call GroupRemoveUnitSimple(GetEnumUnit(),ws)
endif
endfunction
function jJV takes nothing returns nothing
local unit jkV=GetEnumUnit()
call SetUnitVertexColor(jkV,$FF,$FF,$FF,$99)
call UnitAddAbility(jkV,'AcB1')
call UnitMakeAbilityPermanent(jkV,true,'AcB1')
call UnitAddAbility(jkV,'AcB2')
call UnitMakeAbilityPermanent(jkV,true,'AcB2')
call UnitAddAbility(jkV,'AcB3')
call UnitMakeAbilityPermanent(jkV,true,'AcB3')
call UnitAddAbility(jkV,'AcB4')
call UnitMakeAbilityPermanent(jkV,true,'AcB4')
call UnitAddAbility(jkV,'AcB5')
call UnitMakeAbilityPermanent(jkV,true,'AcB5')
call UnitAddAbility(jkV,'AcB6')
call UnitMakeAbilityPermanent(jkV,true,'AcB6')
call UnitAddAbility(jkV,'AcB7')
call UnitMakeAbilityPermanent(jkV,true,'AcB7')
call UnitAddAbility(jkV,'AcB8')
call UnitMakeAbilityPermanent(jkV,true,'AcB8')
call UnitRemoveAbility(jkV,'AcB2')
call UnitRemoveAbility(jkV,'AcB4')
call UnitRemoveAbility(jkV,'AcB6')
call UnitRemoveAbility(jkV,'AcB8')
set jkV=null
set jkV=null
endfunction
function jKV takes unit CDr returns boolean
return true
endfunction
function jlV takes unit jLV returns nothing
set hT[FT]=jLV
set FT=FT+1
endfunction
function jmV takes integer itS returns nothing
endfunction
function jMV takes nothing returns nothing
set FT=FT-1
endfunction
function jpV takes unit jPV,integer jqV returns nothing
call SetUnitUserData(jPV,jqV)
endfunction
function jQV takes integer jsV,unit jSV returns nothing
call jmV(jsV)
set GB[jsV]=jSV
call jpV(GB[jsV],jsV)
call jlV(jSV)
call isV(GT)
call jMV()
endfunction
function jtV takes string jTV returns integer
local integer juV
set ZM[EM]=jTV
set EM=EM+1
if Jv==0 then
if Kv<$8000 then
set Kv=Kv+1
set juV=Kv
set Lv[juV]=5110
else
call Cdv("Out of memory: Could not create UnitIndex.","when calling error in UnitIndexer, line 172")
set juV=0
endif
else
set Jv=Jv-1
set juV=Hv[Jv]
set Lv[juV]=5110
endif
set EM=EM-1
return juV
endfunction
function jUV takes unit jwV,string jWV returns integer
local integer jyV
set ZM[EM]=jWV
set EM=EM+1
set jyV=jtV("when calling alloc_UnitIndex in UnitIndexer, line 181")
call jQV(jyV,jwV)
set EM=EM-1
return jyV
endfunction
function jYV takes unit jzV,string jZV returns integer
local integer j_V
set ZM[EM]=jZV
set EM=EM+1
set j_V=UGx(jzV)
if j_V==0 then
set j_V=jUV(jzV,"when calling new_UnitIndex in UnitIndexer, line 135")
endif
set EM=EM-1
return j_V
endfunction
function j0V takes string j1V returns nothing
set ZM[EM]=j1V
set EM=EM+1
if jKV(vTV())then
call jYV(vTV(),"when calling toUnitIndex in UnitIndexer, line 196")
endif
set EM=EM-1
endfunction
function j2V takes nothing returns nothing
set EM=0
call j0V("UnitIndexer, line 196")
endfunction
function j3V takes nothing returns nothing
call ForGroupBJ(Lu,vRv)
endfunction
function j4V takes string j5V returns integer
local integer j6V
set ZM[EM]=j5V
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set j6V=Yj
set Gj[j6V]=$A20
else
call Cdv("Out of memory: Could not create IBuiltin_registerProtectedBuiltin_SLangPlayerFunctions.","when calling error in SLangPlayerFunctions, line 86")
set j6V=0
endif
else
set Tj=Tj-1
set j6V=Rj[Tj]
set Gj[j6V]=$A20
endif
set EM=EM-1
return j6V
endfunction
function j7V takes string j8V returns integer
local integer j9V
set ZM[EM]=j8V
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set j9V=Yj
set Gj[j9V]=$AB5
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_SLangPlayerFunctions.","when calling error in SLangPlayerFunctions, line 55")
set j9V=0
endif
else
set Tj=Tj-1
set j9V=Rj[Tj]
set Gj[j9V]=$AB5
endif
set EM=EM-1
return j9V
endfunction
function JvV takes string JeV returns integer
local integer JxV
set ZM[EM]=JeV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set JxV=Yj
set Gj[JxV]=$AB3
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_SLangPlayerFunctions.","when calling error in SLangPlayerFunctions, line 44")
set JxV=0
endif
else
set Tj=Tj-1
set JxV=Rj[Tj]
set Gj[JxV]=$AB3
endif
set EM=EM-1
return JxV
endfunction
function JoV takes string JrV returns integer
local integer JiV
set ZM[EM]=JrV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set JiV=Yj
set Gj[JiV]=$AB4
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_SLangPlayerFunctions.","when calling error in SLangPlayerFunctions, line 50")
set JiV=0
endif
else
set Tj=Tj-1
set JiV=Rj[Tj]
set Gj[JiV]=$AB4
endif
set EM=EM-1
return JiV
endfunction
function JaV takes string JnV returns integer
local integer JVV
set ZM[EM]=JnV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set JVV=Yj
set Gj[JVV]=$AB6
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_SLangPlayerFunctions.","when calling error in SLangPlayerFunctions, line 72")
set JVV=0
endif
else
set Tj=Tj-1
set JVV=Rj[Tj]
set Gj[JVV]=$AB6
endif
set EM=EM-1
return JVV
endfunction
function JEV takes string JXV returns integer
local integer JOV
set ZM[EM]=JXV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set JOV=Yj
set Gj[JOV]=$AB7
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_SLangPlayerFunctions.","when calling error in SLangPlayerFunctions, line 89")
set JOV=0
endif
else
set Tj=Tj-1
set JOV=Rj[Tj]
set Gj[JOV]=$AB7
endif
set EM=EM-1
return JOV
endfunction
function JRV takes string JIV returns integer
local integer JAV
set ZM[EM]=JIV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set JAV=Yj
set Gj[JAV]=$AAF
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_SLangPlayerFunctions.","when calling error in SLangPlayerFunctions, line 20")
set JAV=0
endif
else
set Tj=Tj-1
set JAV=Rj[Tj]
set Gj[JAV]=$AAF
endif
set EM=EM-1
return JAV
endfunction
function JNV takes string JbV returns integer
local integer JBV
set ZM[EM]=JbV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set JBV=Yj
set Gj[JBV]=$ABA
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_SLangPlayerFunctions.","when calling error in SLangPlayerFunctions, line 107")
set JBV=0
endif
else
set Tj=Tj-1
set JBV=Rj[Tj]
set Gj[JBV]=$ABA
endif
set EM=EM-1
return JBV
endfunction
function JcV takes string JCV returns integer
local integer JdV
set ZM[EM]=JCV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set JdV=Yj
set Gj[JdV]=$AB0
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_SLangPlayerFunctions.","when calling error in SLangPlayerFunctions, line 23")
set JdV=0
endif
else
set Tj=Tj-1
set JdV=Rj[Tj]
set Gj[JdV]=$AB0
endif
set EM=EM-1
return JdV
endfunction
function JDV takes string JfV returns integer
local integer JFV
set ZM[EM]=JfV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set JFV=Yj
set Gj[JFV]=$AB1
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_SLangPlayerFunctions.","when calling error in SLangPlayerFunctions, line 34")
set JFV=0
endif
else
set Tj=Tj-1
set JFV=Rj[Tj]
set Gj[JFV]=$AB1
endif
set EM=EM-1
return JFV
endfunction
function JgV takes string JGV returns integer
local integer JhV
set ZM[EM]=JGV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set JhV=Yj
set Gj[JhV]=$AB2
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_SLangPlayerFunctions.","when calling error in SLangPlayerFunctions, line 40")
set JhV=0
endif
else
set Tj=Tj-1
set JhV=Rj[Tj]
set Gj[JhV]=$AB2
endif
set EM=EM-1
return JhV
endfunction
function JHV takes string JjV returns integer
local integer JJV
set ZM[EM]=JjV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set JJV=Yj
set Gj[JJV]=$AB9
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_SLangPlayerFunctions.","when calling error in SLangPlayerFunctions, line 101")
set JJV=0
endif
else
set Tj=Tj-1
set JJV=Rj[Tj]
set Gj[JJV]=$AB9
endif
set EM=EM-1
return JJV
endfunction
function JkV takes string JKV returns integer
local integer JlV
set ZM[EM]=JKV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set JlV=Yj
set Gj[JlV]=$AB8
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_SLangPlayerFunctions.","when calling error in SLangPlayerFunctions, line 95")
set JlV=0
endif
else
set Tj=Tj-1
set JlV=Rj[Tj]
set Gj[JlV]=$AB8
endif
set EM=EM-1
return JlV
endfunction
function JLV takes string JmV returns boolean
local integer JMV
local integer JpV
local integer JPV
local integer JqV
local integer JQV
local integer JsV
local integer JSV
local integer JtV
local integer JTV
local integer JuV
local integer JUV
local integer JwV
local integer JWV
local integer JyV
local integer JYV
local integer JzV
local integer JZV
local integer J_V
local integer J0V
local integer J1V
local integer J2V
local integer J3V
local integer J4V
local integer J5V
local integer J6V
set ZM[EM]=JmV
set EM=EM+1
set JMV=JRV("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_SLangPlayerFunctions in SLangPlayerFunctions, line 20")
set JpV=OPo(JMV,"when calling new_BuiltinData in SLangPlayerFunctions, line 20")
call Rxo(JpV,OFo(),"when calling setArgumentsTypes in SLangPlayerFunctions, line 22")
call Foa(ILo(JpV,"when calling new_BuiltinFunction in SLangPlayerFunctions, line 20"),"getcolorcode","when calling registerProtectedBuiltin in SLangPlayerFunctions, line 20")
set JPV=JcV("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_SLangPlayerFunctions in SLangPlayerFunctions, line 23")
set JqV=OPo(JPV,"when calling new_BuiltinData in SLangPlayerFunctions, line 23")
call Rxo(JqV,OFo(),"when calling setArgumentsTypes in SLangPlayerFunctions, line 33")
call Foa(ILo(JqV,"when calling new_BuiltinFunction in SLangPlayerFunctions, line 23"),"setlocale","when calling registerProtectedBuiltin in SLangPlayerFunctions, line 23")
set JQV=JDV("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_SLangPlayerFunctions in SLangPlayerFunctions, line 34")
set JsV=OPo(JQV,"when calling new_BuiltinData in SLangPlayerFunctions, line 34")
call FRa(JsV,OFo(),d_V(),"when calling setArgumentsTypes in SLangPlayerFunctions, line 39")
call Foa(ILo(JsV,"when calling new_BuiltinFunction in SLangPlayerFunctions, line 34"),"setplayeralliancestateally","when calling registerProtectedBuiltin in SLangPlayerFunctions, line 34")
set JSV=JgV("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_SLangPlayerFunctions in SLangPlayerFunctions, line 40")
set JtV=OPo(JSV,"when calling new_BuiltinData in SLangPlayerFunctions, line 40")
call Rxo(JtV,OFo(),"when calling setArgumentsTypes in SLangPlayerFunctions, line 43")
call Foa(ILo(JtV,"when calling new_BuiltinFunction in SLangPlayerFunctions, line 40"),"getplayeralliancestateally","when calling registerProtectedBuiltin in SLangPlayerFunctions, line 40")
set JTV=JvV("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_SLangPlayerFunctions in SLangPlayerFunctions, line 44")
set JuV=OPo(JTV,"when calling new_BuiltinData in SLangPlayerFunctions, line 44")
call FRa(JuV,OFo(),d_V(),"when calling setArgumentsTypes in SLangPlayerFunctions, line 49")
call Foa(ILo(JuV,"when calling new_BuiltinFunction in SLangPlayerFunctions, line 44"),"setplayeralliancestatevision","when calling registerProtectedBuiltin in SLangPlayerFunctions, line 44")
set JUV=JoV("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_SLangPlayerFunctions in SLangPlayerFunctions, line 50")
set JwV=OPo(JUV,"when calling new_BuiltinData in SLangPlayerFunctions, line 50")
call Rxo(JwV,OFo(),"when calling setArgumentsTypes in SLangPlayerFunctions, line 53")
call Foa(ILo(JwV,"when calling new_BuiltinFunction in SLangPlayerFunctions, line 50"),"getplayeralliancestatevision","when calling registerProtectedBuiltin in SLangPlayerFunctions, line 50")
set JWV=j7V("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_SLangPlayerFunctions in SLangPlayerFunctions, line 55")
set JyV=OPo(JWV,"when calling new_BuiltinData in SLangPlayerFunctions, line 55")
call Rxo(JyV,gQV(),"when calling setArgumentsTypes in SLangPlayerFunctions, line 59")
call Foa(ILo(JyV,"when calling new_BuiltinFunction in SLangPlayerFunctions, line 55"),"setcameradistance","when calling registerProtectedBuiltin in SLangPlayerFunctions, line 55")
set JYV=JaV("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_SLangPlayerFunctions in SLangPlayerFunctions, line 72")
set JzV=OPo(JYV,"when calling new_BuiltinData in SLangPlayerFunctions, line 72")
call Rxo(JzV,OFo(),"when calling setArgumentsTypes in SLangPlayerFunctions, line 85")
call Foa(ILo(JzV,"when calling new_BuiltinFunction in SLangPlayerFunctions, line 72"),"setplayercolor","when calling registerProtectedBuiltin in SLangPlayerFunctions, line 72")
set JZV=j4V("when calling alloc_IBuiltin_registerProtectedBuiltin_SLangPlayerFunctions in SLangPlayerFunctions, line 86")
call Foa(ILo(OPo(JZV,"when calling new_BuiltinData in SLangPlayerFunctions, line 86"),"when calling new_BuiltinFunction in SLangPlayerFunctions, line 86"),"getplayercolor","when calling registerProtectedBuiltin in SLangPlayerFunctions, line 86")
set J_V=JEV("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_SLangPlayerFunctions in SLangPlayerFunctions, line 89")
set J0V=OPo(J_V,"when calling new_BuiltinData in SLangPlayerFunctions, line 89")
call Rxo(J0V,OFo(),"when calling setArgumentsTypes in SLangPlayerFunctions, line 94")
call Foa(ILo(J0V,"when calling new_BuiltinFunction in SLangPlayerFunctions, line 89"),"ally","when calling registerProtectedBuiltin in SLangPlayerFunctions, line 89")
set J1V=JkV("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_SLangPlayerFunctions in SLangPlayerFunctions, line 95")
set J2V=OPo(J1V,"when calling new_BuiltinData in SLangPlayerFunctions, line 95")
call Rxo(J2V,OFo(),"when calling setArgumentsTypes in SLangPlayerFunctions, line 100")
call Foa(ILo(J2V,"when calling new_BuiltinFunction in SLangPlayerFunctions, line 95"),"unally","when calling registerProtectedBuiltin in SLangPlayerFunctions, line 95")
set J3V=JHV("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_SLangPlayerFunctions in SLangPlayerFunctions, line 101")
set J4V=OPo(J3V,"when calling new_BuiltinData in SLangPlayerFunctions, line 101")
call Rxo(J4V,OFo(),"when calling setArgumentsTypes in SLangPlayerFunctions, line 106")
call Foa(ILo(J4V,"when calling new_BuiltinFunction in SLangPlayerFunctions, line 101"),"vision","when calling registerProtectedBuiltin in SLangPlayerFunctions, line 101")
set J5V=JNV("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_SLangPlayerFunctions in SLangPlayerFunctions, line 107")
set J6V=OPo(J5V,"when calling new_BuiltinData in SLangPlayerFunctions, line 107")
call Rxo(J6V,OFo(),"when calling setArgumentsTypes in SLangPlayerFunctions, line 112")
call Foa(ILo(J6V,"when calling new_BuiltinFunction in SLangPlayerFunctions, line 107"),"unvision","when calling registerProtectedBuiltin in SLangPlayerFunctions, line 107")
set EM=EM-1
return true
endfunction
function J7V takes nothing returns boolean
set EM=0
return JLV("SLangPlayerFunctions, line 1")
endfunction
function J8V takes nothing returns nothing
local integer J9V=0
local integer kvV=0
local integer keV
loop
exitwhen not(kvV<256)
set keV=0
loop
exitwhen not(keV<16)
set Fy[kvV]=J9V
set kvV=kvV+1
set keV=keV+1
endloop
set J9V=J9V+1
endloop
endfunction
function kxV takes nothing returns nothing
local integer koV=0
local integer krV
loop
exitwhen not(koV<256)
set krV=0
loop
exitwhen not(krV<16)
set ky[koV]=krV
set koV=koV+1
set krV=krV+1
endloop
endloop
endfunction
function kiV takes nothing returns nothing
local integer kaV=0
local integer knV=1
loop
exitwhen not(kaV<=32)
set xy[kaV]=knV
set knV=knV*2
set kaV=kaV+1
endloop
endfunction
function kVV takes nothing returns nothing
call J8V()
call kxV()
call kiV()
endfunction
function kEV takes nothing returns boolean
set jy[0]=0
set jy[1]=0
set jy[2]=0
set jy[3]=0
set jy[4]=0
set jy[5]=0
set jy[6]=0
set jy[7]=0
set jy[8]=0
set jy[9]=0
set jy[$A]=0
set jy[$B]=0
set jy[$C]=0
set jy[$D]=0
set jy[$E]=0
set jy[$F]=0
set jy[16]=0
set jy[17]=1
set jy[18]=0
set jy[19]=1
set jy[20]=0
set jy[21]=1
set jy[22]=0
set jy[23]=1
set jy[24]=0
set jy[25]=1
set jy[26]=0
set jy[27]=1
set jy[28]=0
set jy[29]=1
set jy[30]=0
set jy[31]=1
set jy[32]=0
set jy[33]=0
set jy[34]=2
set jy[35]=2
set jy[36]=0
set jy[37]=0
set jy[38]=2
set jy[39]=2
set jy[40]=0
set jy[41]=0
set jy[42]=2
set jy[43]=2
set jy[44]=0
set jy[45]=0
set jy[46]=2
set jy[47]=2
set jy[48]=0
set jy[49]=1
set jy[50]=2
set jy[51]=3
set jy[52]=0
set jy[53]=1
set jy[54]=2
set jy[55]=3
set jy[56]=0
set jy[57]=1
set jy[58]=2
set jy[59]=3
set jy[60]=0
set jy[61]=1
set jy[62]=2
set jy[63]=3
set jy[64]=0
set jy[65]=0
set jy[66]=0
set jy[67]=0
set jy[68]=4
set jy[69]=4
set jy[70]=4
set jy[71]=4
set jy[72]=0
set jy[73]=0
set jy[74]=0
set jy[75]=0
set jy[76]=4
set jy[77]=4
set jy[78]=4
set jy[79]=4
set jy[80]=0
set jy[81]=1
set jy[82]=0
set jy[83]=1
set jy[84]=4
set jy[85]=5
set jy[86]=4
set jy[87]=5
set jy[88]=0
set jy[89]=1
set jy[90]=0
set jy[91]=1
set jy[92]=4
set jy[93]=5
set jy[94]=4
set jy[95]=5
set jy[96]=0
set jy[97]=0
set jy[98]=2
set jy[99]=2
set jy['d']=4
set jy['e']=4
set jy['f']=6
set jy['g']=6
set jy['h']=0
set jy['i']=0
set jy['j']=2
set jy['k']=2
set jy['l']=4
set jy['m']=4
set jy['n']=6
set jy['o']=6
set jy['p']=0
set jy['q']=1
set jy['r']=2
set jy['s']=3
set jy['t']=4
set jy['u']=5
set jy['v']=6
set jy['w']=7
set jy['x']=0
set jy['y']=1
set jy['z']=2
set jy['{']=3
set jy['|']=4
set jy['}']=5
set jy[$7E]=6
set jy[$7F]=7
set jy[$80]=0
set jy[$81]=0
set jy[$82]=0
set jy[$83]=0
set jy[$84]=0
set jy[$85]=0
set jy[$86]=0
set jy[$87]=0
set jy[$88]=8
set jy[$89]=8
set jy[$8A]=8
set jy[$8B]=8
set jy[$8C]=8
set jy[$8D]=8
set jy[$8E]=8
set jy[$8F]=8
set jy[$90]=0
set jy[$91]=1
set jy[$92]=0
set jy[$93]=1
set jy[$94]=0
set jy[$95]=1
set jy[$96]=0
set jy[$97]=1
set jy[$98]=8
set jy[$99]=9
set jy[$9A]=8
set jy[$9B]=9
set jy[$9C]=8
set jy[$9D]=9
set jy[$9E]=8
set jy[$9F]=9
set jy[$A0]=0
set jy[$A1]=0
set jy[$A2]=2
set jy[$A3]=2
set jy[$A4]=0
set jy[$A5]=0
set jy[$A6]=2
set jy[$A7]=2
set jy[$A8]=8
set jy[$A9]=8
set jy[$AA]=$A
set jy[$AB]=$A
set jy[$AC]=8
set jy[$AD]=8
set jy[$AE]=$A
set jy[$AF]=$A
set jy[$B0]=0
set jy[$B1]=1
set jy[$B2]=2
set jy[$B3]=3
set jy[$B4]=0
set jy[$B5]=1
set jy[$B6]=2
set jy[$B7]=3
set jy[$B8]=8
set jy[$B9]=9
set jy[$BA]=$A
set jy[$BB]=$B
set jy[$BC]=8
set jy[$BD]=9
set jy[$BE]=$A
set jy[$BF]=$B
set jy[$C0]=0
set jy[$C1]=0
set jy[$C2]=0
set jy[$C3]=0
set jy[$C4]=4
set jy[$C5]=4
set jy[$C6]=4
set jy[$C7]=4
set jy[$C8]=8
set jy[$C9]=8
set jy[$CA]=8
set jy[$CB]=8
set jy[$CC]=$C
set jy[$CD]=$C
set jy[$CE]=$C
set jy[$CF]=$C
set jy[$D0]=0
set jy[$D1]=1
set jy[$D2]=0
set jy[$D3]=1
set jy[$D4]=4
set jy[$D5]=5
set jy[$D6]=4
set jy[$D7]=5
set jy[$D8]=8
set jy[$D9]=9
set jy[$DA]=8
set jy[$DB]=9
set jy[$DC]=$C
set jy[$DD]=$D
set jy[$DE]=$C
set jy[$DF]=$D
set jy[$E0]=0
set jy[$E1]=0
set jy[$E2]=2
set jy[$E3]=2
set jy[$E4]=4
set jy[$E5]=4
set jy[$E6]=6
set jy[$E7]=6
set jy[$E8]=8
set jy[$E9]=8
set jy[$EA]=$A
set jy[$EB]=$A
set jy[$EC]=$C
set jy[$ED]=$C
set jy[$EE]=$E
set jy[$EF]=$E
set jy[$F0]=0
set jy[$F1]=1
set jy[$F2]=2
set jy[$F3]=3
set jy[$F4]=4
set jy[$F5]=5
set jy[$F6]=6
set jy[$F7]=7
set jy[$F8]=8
set jy[$F9]=9
set jy[$FA]=$A
set jy[$FB]=$B
set jy[$FC]=$C
set jy[$FD]=$D
set jy[$FE]=$E
set jy[$FF]=$F
call kVV()
return true
endfunction
function kXV takes nothing returns boolean
return(Mu==2)
endfunction
function kOV takes nothing returns boolean
return(Mu==1)
endfunction
function kRV takes nothing returns boolean
return(Mu==3)and(ModuloReal(I2R(wr),4.)==.0)
endfunction
function kIV takes nothing returns boolean
return(Mu==1)
endfunction
function kAV takes nothing returns boolean
return(ModuloReal(I2R(sr),2.)==.0)
endfunction
function kNV takes nothing returns boolean
return(Yu)
endfunction
function kbV takes nothing returns boolean
return(Mu==2)
endfunction
function kBV takes nothing returns boolean
return(Mu==1)
endfunction
function kcV takes nothing returns boolean
return(ur==1)and(ModuloReal(I2R(wr),2.)==.0)
endfunction
function kCV takes nothing returns boolean
return(sr==1)
endfunction
function kdV takes nothing returns boolean
return(sr==ju)
endfunction
function kDV takes nothing returns boolean
return(Mu==1)
endfunction
function kfV takes nothing returns boolean
return(ModuloReal(I2R(wr),6.)==.0)
endfunction
function kFV takes nothing returns boolean
return(sr==ku)
endfunction
function kgV takes nothing returns boolean
return(ur<=2)
endfunction
function kGV takes nothing returns boolean
return(Mu==2)
endfunction
function khV takes nothing returns boolean
return(ur==3)and(ModuloReal(I2R(wr),2.)==.0)
endfunction
function kHV takes nothing returns boolean
return(Yu)
endfunction
function kjV takes nothing returns nothing
set Bu=GetHandleIdBJ(GetEnumUnit())
set Nu=GetEnumUnit()
set Mu=3
set wr=LoadIntegerBJ(6,Bu,Au)
set ur=LoadIntegerBJ(7,Bu,Au)
set rr=LoadIntegerBJ(8,Bu,Au)
set sr=LoadIntegerBJ($A,Bu,Au)
call SaveIntegerBJ(wr+1,6,Bu,Au)
if kgV()then
if kcV()then
set Ju[2]=GetUnitLoc(Nu)
if kOV()then
call CreateNUnitsAtLoc(1,'h0ID',GetOwningPlayer(Nu),Ju[2],bj_UNIT_FACING)
call AddSpecialEffectTargetUnitBJ("overhead",Nu,"Abilities\\Weapons\\LichMissile\\LichMissile.mdl")
elseif kGV()then
call CreateNUnitsAtLoc(1,'h002',GetOwningPlayer(Nu),Ju[2],bj_UNIT_FACING)
call AddSpecialEffectTargetUnitBJ("overhead",Nu,"Abilities\\Weapons\\RedDragonBreath\\RedDragonMissile.mdl")
else
call CreateNUnitsAtLoc(1,'h0LH',GetOwningPlayer(Nu),Ju[2],bj_UNIT_FACING)
call AddSpecialEffectTargetUnitBJ("overhead",Nu,"Abilities\\Weapons\\FarseerMissile\\FarseerMissile.mdl")
endif
call DestroyEffectBJ(GetLastCreatedEffectBJ())
call GroupAddUnitSimple(GetLastCreatedUnit(),lr[rr])
call SaveRealBJ(.0,1,GetHandleIdBJ(GetLastCreatedUnit()),Au)
call SaveRealBJ(.0,2,GetHandleIdBJ(GetLastCreatedUnit()),Au)
call SaveRealBJ(10.,3,GetHandleIdBJ(GetLastCreatedUnit()),Au)
set sr=sr+1
call SaveIntegerBJ(sr,$A,Bu,Au)
if kdV()then
call SaveIntegerBJ(2,7,Bu,Au)
endif
call RemoveLocation(Ju[2])
endif
call ForGroupBJ(lr[rr],g0)
else
set tr=LoadRealBJ(9,Bu,Au)
set Ju[4]=LoadLocationHandleBJ(0,Bu,Au)
set Ju[5]=LoadLocationHandleBJ(1,Bu,Au)
set ir=LoadRealBJ($B,Bu,Au)
set Sr=LoadBooleanBJ($C,Bu,Au)
if khV()then
if kIV()then
call CreateNUnitsAtLoc(1,'h0ID',GetOwningPlayer(Nu),Ju[4],AngleBetweenPoints(Ju[4],Ju[5]))
call SetUnitScalePercent(GetLastCreatedUnit(),400.,400.,400.)
call AddSpecialEffectLocBJ(Ju[4],"Abilities\\Weapons\\FrostWyrmMissile\\FrostWyrmMissile.mdl")
call DestroyEffectBJ(GetLastCreatedEffectBJ())
elseif kXV()then
if kAV()then
set Ju[$A]=PolarProjectionBJ(Ju[4],GetRandomReal(Gu,Wu),GetRandomDirectionDeg())
call CreateNUnitsAtLocFacingLocBJ(1,'h00A',GetOwningPlayer(Nu),Ju[4],Ju[$A])
call GroupAddUnitSimple(GetLastCreatedUnit(),cr[rr])
call SaveLocationHandleBJ(Ju[$A],1,GetHandleIdBJ(GetLastCreatedUnit()),Au)
call SaveBooleanBJ(true,2,GetHandleIdBJ(GetLastCreatedUnit()),Au)
endif
call CreateNUnitsAtLoc(1,'h005',GetOwningPlayer(Nu),Ju[4],AngleBetweenPoints(Ju[4],Ju[5]))
call SetUnitScalePercent(GetLastCreatedUnit(),800.,800.,800.)
if kfV()then
call AddSpecialEffectLocBJ(Ju[4],"Abilities\\Spells\\Other\\Doom\\DoomDeath.mdl")
call DestroyEffectBJ(GetLastCreatedEffectBJ())
endif
else
call CreateNUnitsAtLoc(1,'h0LH',GetOwningPlayer(Nu),Ju[4],bj_UNIT_FACING)
call SetUnitScalePercent(GetLastCreatedUnit(),300.,300.,300.)
call SetUnitFlyHeightBJ(GetLastCreatedUnit(),.0,.0)
call KillUnit(GetLastCreatedUnit())
call GroupAddUnitSimple(GetLastCreatedUnit(),Ku)
call SaveIntegerBJ(Du+1,0,GetHandleIdBJ(GetLastCreatedUnit()),Au)
call CreateNUnitsAtLoc(1,'h0LH',GetOwningPlayer(Nu),Ju[4],bj_UNIT_FACING)
call SetUnitScalePercent(GetLastCreatedUnit(),300.,300.,300.)
call AddSpecialEffectLocBJ(Ju[4],"Abilities\\Weapons\\ChimaeraLightningMissile\\ChimaeraLightningMissile.mdl")
call DestroyEffectBJ(GetLastCreatedEffectBJ())
endif
call GroupAddUnitSimple(GetLastCreatedUnit(),lr[rr])
call SetUnitFlyHeightBJ(GetLastCreatedUnit(),.0,.0)
set sr=sr+1
call SaveIntegerBJ(sr,$A,Bu,Au)
if kCV()then
if kNV()then
call ForForce(GetPlayersAll(),G0)
endif
call CreateUbersplatBJ(Ju[4],"DHLB",100.,100.,100.,.0,false,true)
call FinishUbersplat(GetLastCreatedUbersplat())
call SetUbersplatRenderAlways(GetLastCreatedUbersplat(),true)
set br=1
loop
exitwhen br>5
set Ju[8]=PolarProjectionBJ(Ju[4],GetRandomReal(50.,180.),GetRandomDirectionDeg())
if kBV()then
call CreateNUnitsAtLoc(1,'h0IE',GetOwningPlayer(Nu),Ju[8],GetRandomDirectionDeg())
call SetUnitTimeScalePercent(GetLastCreatedUnit(),20.)
elseif kbV()then
call CreateNUnitsAtLoc(1,'h006',GetOwningPlayer(Nu),Ju[8],GetRandomDirectionDeg())
else
call CreateNUnitsAtLoc(1,'h0LG',GetOwningPlayer(Nu),Ju[8],GetRandomDirectionDeg())
call SetUnitTimeScalePercent(GetLastCreatedUnit(),20.)
endif
call GroupAddUnitSimple(GetLastCreatedUnit(),Ku)
call UnitApplyTimedLifeBJ(5.,'BTLF',GetLastCreatedUnit())
call SaveIntegerBJ(Du+7,0,GetHandleIdBJ(GetLastCreatedUnit()),Au)
call RemoveLocation(Ju[8])
set br=br+1
endloop
set bj_wantDestroyGroup=true
call ForGroupBJ(GetUnitsInRangeOfLocMatching(Gu,Ju[4],Condition(h0)),H0)
if kDV()then
set br=1
loop
exitwhen br>3
call CreateNUnitsAtLoc(1,'h0E1',GetOwningPlayer(Nu),Ju[4],bj_UNIT_FACING)
call KillUnit(GetLastCreatedUnit())
call GroupAddUnitSimple(GetLastCreatedUnit(),Ku)
call SaveIntegerBJ(Du+2,0,GetHandleIdBJ(GetLastCreatedUnit()),Au)
set br=br+1
endloop
set bj_wantDestroyGroup=true
call ForGroupBJ(GetUnitsInRangeOfLocMatching(Qu,Ju[4],Condition(j0)),J0)
endif
endif
set bj_wantDestroyGroup=true
call ForGroupBJ(GetUnitsInRangeOfLocMatching(Gu,Ju[4],Condition(k0)),K0)
if kFV()then
if kHV()then
call ForForce(GetPlayersAll(),l0)
endif
call SaveIntegerBJ(4,7,Bu,Au)
endif
endif
call ForGroupBJ(lr[rr],L0)
call ForGroupBJ(cr[rr],m0)
if kRV()then
set pr=GroupPickRandomUnit(lr[rr])
set Ju[$D]=GetUnitLoc(pr)
call CreateNUnitsAtLoc(1,'h0LE',GetOwningPlayer(Nu),Ju[$D],bj_UNIT_FACING)
call SetUnitFlyHeightBJ(GetLastCreatedUnit(),GetUnitFlyHeight(pr),.0)
call UnitAddAbilityBJ('A06R',GetLastCreatedUnit())
set bj_wantDestroyGroup=true
call IssueTargetOrderBJ(GetLastCreatedUnit(),"chainlightning",GroupPickRandomUnit(GetUnitsInRangeOfLocMatching(Pu,Ju[$D],Condition(M0))))
call GroupAddUnitSimple(GetLastCreatedUnit(),Ku)
call SaveIntegerBJ(Du+1,0,GetHandleIdBJ(GetLastCreatedUnit()),Au)
call RemoveLocation(Ju[$D])
endif
endif
endfunction
function kJV takes nothing returns nothing
local unit kkV=GetSpellAbilityUnit()
local unit kKV=GetSpellTargetUnit()
local integer klV=0
local boolean kLV=false
if IsUnitInGroup(kkV,kt)==false then
set kLV=true
call GroupAddUnit(kt,kkV)
endif
call DestroyEffect(AddSpecialEffectTarget("Objects\\Spawnmodels\\Human\\HumanBlood\\HumanBloodKnight.mdl",kKV,"chest"))
call UnitDamageTarget(kkV,kKV,350.,true,true,ATTACK_TYPE_MELEE,DAMAGE_TYPE_NORMAL,WEAPON_TYPE_WHOKNOWS)
if kLV then
call GroupRemoveUnit(kt,kkV)
endif
set kLV=false
set kkV=null
if IsUnitInGroup(kKV,Ft) then
call GroupRemoveUnit(Ft,kKV)
call pAa(1.)
endif
call UnitAddAbility(kKV,'AFcs')
call UnitMakeAbilityPermanent(kKV,true,'AFcs')
call GroupAddUnit(Ft,kKV)
loop
exitwhen IsUnitInGroup(kKV,Ft)==false
call pAa(1.)
set klV=klV+1
if klV==3 or GetUnitState(kKV,UNIT_STATE_LIFE)<=.0 then
call GroupRemoveUnit(Ft,kKV)
endif
endloop
set klV=0
call UnitRemoveAbility(kKV,'AFcs')
call UnitRemoveAbility(kKV,'BOcs')
set kKV=null
set kkV=null
set kKV=null
endfunction
function kmV takes nothing returns nothing
local location kMV=GetSpellTargetLoc()
local player kpV=GetOwningPlayer(GetSpellAbilityUnit())
local unit kPV=CreateUnitAtLoc(kpV,'n028',kMV,270.)
local effect kqV=null
call SetUnitPathing(kPV,false)
call SetUnitPositionLoc(kPV,kMV)
call pAa(6.)
if GetUnitState(kPV,UNIT_STATE_LIFE)>.0 then
call KillUnit(kPV)
set kPV=CreateUnitAtLoc(kpV,'h0JO',kMV,270.)
call UnitAddAbility(kPV,'A0KR')
call IssueImmediateOrderById(kPV,$D009F)
set kqV=AddSpecialEffectLoc("war3mapImported\\EMPBubble.mdx",kMV)
call pAa(2.)
call KillUnit(kPV)
call DestroyEffect(kqV)
endif
call RemoveLocation(kMV)
set kMV=null
set kpV=null
set kPV=null
set kqV=null
set kMV=null
set kpV=null
set kPV=null
set kqV=null
endfunction
function kQV takes nothing returns nothing
call IssueImmediateOrderBJ(GetEnumUnit(),"stop")
endfunction
function ksV takes nothing returns nothing
local unit kSV
set Tu[GetConvertedPlayerId(GetOwningPlayer(GetSpellAbilityUnit()))]=GetSpellAbilityUnit()
call SetUnitLifePercentBJ(Tu[GetConvertedPlayerId(GetOwningPlayer(GetSpellAbilityUnit()))],100.)
call UnitAddAbilityBJ('A07O',Tu[GetConvertedPlayerId(GetOwningPlayer(GetSpellAbilityUnit()))])
set kSV=Tu[GetConvertedPlayerId(GetOwningPlayer(GetSpellAbilityUnit()))]
call TriggerSleepAction(60.)
set Tu[GetConvertedPlayerId(GetOwningPlayer(GetSpellAbilityUnit()))]=kSV
call UnitRemoveAbilityBJ('A07O',Tu[GetConvertedPlayerId(GetOwningPlayer(GetSpellAbilityUnit()))])
set kSV=null
set kSV=null
endfunction
function ktV takes nothing returns nothing
local unit kTV=GetSpellTargetUnit()
local unit kuV=GetSpellAbilityUnit()
local location kUV=GetUnitLoc(GetSpellTargetUnit())
local real kwV=GetUnitState(GetSpellAbilityUnit(),UNIT_STATE_MAX_LIFE)
local real kWV=GetUnitState(GetSpellAbilityUnit(),UNIT_STATE_MAX_MANA)/2.
local real kyV
local effect kYV
local effect kzV
local effect kZV
call DestroyEffect(AddSpecialEffectTarget("Abilities\\Spells\\Human\\Resurrect\\ResurrectCaster.mdl",kuV,"origin"))
call DestroyEffect(AddSpecialEffectTarget("Abilities\\Spells\\Human\\Resurrect\\ResurrectCaster.mdl",kTV,"origin"))
call DestroyEffect(AddSpecialEffectTarget("Abilities\\Spells\\Human\\Resurrect\\ResurrectTarget.mdl",kTV,"origin"))
call TriggerSleepAction(1.)
set kyV=GetUnitState(kTV,UNIT_STATE_LIFE)
if IsUnitAliveBJ(kTV) then
call DestroyEffect(AddSpecialEffectTarget("Abilities\\Spells\\Items\\AIhe\\AIheTarget.mdl",kTV,"origin"))
call SetUnitState(kTV,UNIT_STATE_LIFE,GetUnitState(kTV,UNIT_STATE_LIFE)+kwV)
call DestroyEffect(AddSpecialEffectTarget("Abilities\\Spells\\Items\\AIma\\AImaTarget.mdl",kTV,"origin"))
call SetUnitState(kTV,UNIT_STATE_MANA,GetUnitState(kTV,UNIT_STATE_MANA)+kWV)
if kyV>=kwV/2. then
set kYV=AddSpecialEffectTarget("Abilities\\Spells\\Human\\InnerFire\\InnerFireTarget.mdl",kTV,"overhead")
set kzV=AddSpecialEffectTarget("Abilities\\Spells\\NightElf\\Barkskin\\BarkSkinTarget.mdl",kTV,"right hand")
set kZV=AddSpecialEffectTarget("Abilities\\Spells\\NightElf\\Barkskin\\BarkSkinTarget.mdl",kTV,"left hand")
call UnitAddAbility(kTV,'A0DI')
call UnitAddAbility(kTV,'A0DJ')
call UnitAddAbility(kTV,'A0DK')
call TriggerSleepAction(20.)
call DestroyEffect(kYV)
call DestroyEffect(kzV)
call DestroyEffect(kZV)
call UnitRemoveAbility(kTV,'A0DI')
call UnitRemoveAbility(kTV,'A0DJ')
call UnitRemoveAbility(kTV,'A0DK')
endif
else
call DestroyEffect(AddSpecialEffectLoc("Abilities\\Spells\\Human\\ReviveHuman\\ReviveHuman.mdl",kUV))
call TriggerSleepAction(.2)
set kTV=CreateUnitAtLoc(GetOwningPlayer(kuV),'e01P',kUV,270.)
call TriggerSleepAction(5.)
call KillUnit(kTV)
call DestroyEffect(AddSpecialEffectLoc("Abilities\\Spells\\Undead\\ReplenishHealth\\ReplenishHealthCaster.mdl",kUV))
call DestroyEffect(AddSpecialEffectLoc("Abilities\\Spells\\Undead\\ReplenishHealth\\ReplenishHealthCasterOverhead.mdl",kUV))
call ForGroup(GetUnitsInRangeOfLocAll(250.,kUV),iBv)
endif
set kTV=null
set kuV=null
set kUV=null
set kyV=.0
set kwV=.0
set kWV=.0
set kYV=null
set kzV=null
set kZV=null
set kTV=null
set kuV=null
set kUV=null
set kYV=null
set kzV=null
set kZV=null
endfunction
function k_V takes nothing returns boolean
return(GetOwningPlayer(GetEnumUnit())==GetTriggerPlayer())
endfunction
function k0V takes nothing returns nothing
if k_V()then
set G=GetUnitLoc(GetEnumUnit())
call EnumDestructablesInCircleBJ(256.,G,xjv)
call RemoveLocation(G)
endif
endfunction
function k1V takes nothing returns nothing
local timer k2V
if GetUnitAbilityLevel(GetKillingUnit(),'A0MH')==0 then
set k2V=null
return
endif
set k2V=cFv()
call SaveUnitHandle(i,y,GetHandleId(k2V),GetKillingUnit())
call TimerStart(k2V,.0,false,Sz)
set k2V=null
set k2V=null
endfunction
function k3V takes nothing returns nothing
local destructable k4V=GetSpellTargetDestructable()
if IsDestructableInvulnerable(k4V)==false then
call SetDestructableInvulnerable(k4V,true)
else
call SetDestructableInvulnerable(k4V,false)
endif
set k4V=null
set k4V=null
endfunction
function k5V takes nothing returns boolean
return(GetUnitTypeId(GetEnumUnit())!='h000')and(IsUnitSelected(GetEnumUnit(),GetTriggerPlayer()))
endfunction
function k6V takes nothing returns boolean
return(k5V())
endfunction
function k7V takes nothing returns nothing
if k6V()then
set bj_forLoopBIndex=1
set bj_forLoopBIndexEnd=V
loop
exitwhen bj_forLoopBIndex>bj_forLoopBIndexEnd
call UnitRemoveAbilityBJ(C[GetForLoopIndexB()],GetEnumUnit())
set bj_forLoopBIndex=bj_forLoopBIndex+1
endloop
endif
endfunction
function k8V takes nothing returns boolean
return GetSpellAbilityId()=='AcS3' or GetSpellAbilityId()=='AcS4'
endfunction
function k9V takes nothing returns nothing
call KillDestructable(GetEnumDestructable())
endfunction
function KvV takes nothing returns nothing
local unit KeV=CreateUnitAtLoc(GetOwningPlayer(GetSpellAbilityUnit()),'h0JO',GetUnitLoc(GetSpellAbilityUnit()),GetUnitFacing(GetSpellAbilityUnit()))
call UnitAddAbility(KeV,'A0L5')
call SetUnitAbilityLevel(KeV,'A0L5',GetUnitAbilityLevel(GetSpellAbilityUnit(),'A0L4'))
call IssueTargetOrderById(KeV,$D00B5,GetSpellTargetUnit())
call TriggerSleepAction(3.)
call RemoveUnit(KeV)
set KeV=null
set KeV=null
endfunction
function KxV takes nothing returns boolean
return(GetSpellAbilityId()=='A0GG')
endfunction
function KoV takes nothing returns boolean
return(F[GetConvertedPlayerId(GetTriggerPlayer())])and(GetEventPlayerChatString()=="expgain off")
endfunction
function KrV takes nothing returns boolean
return(F[GetConvertedPlayerId(GetTriggerPlayer())])and(GetEventPlayerChatString()=="expgain on")
endfunction
function KiV takes nothing returns nothing
if KrV()then
call ForForce(GetPlayersAll(),xrv)
endif
if KoV()then
call ForForce(GetPlayersAll(),xiv)
endif
endfunction
function KaV takes nothing returns boolean
return IsUnitSelected(GetFilterUnit(),GetTriggerPlayer())
endfunction
function KnV takes nothing returns boolean
return(GetEventPlayerChatString()=="item darkbook")
endfunction
function KVV takes nothing returns nothing
set g[GetConvertedPlayerId(GetTriggerPlayer())]=GetUnitsOfPlayerAndTypeId(GetTriggerPlayer(),'h000')
if KnV()then
call ForGroupBJ(g[GetConvertedPlayerId(GetTriggerPlayer())],rAv)
endif
call DestroyGroup(g[GetPlayerId(GetTriggerPlayer())+1])
endfunction
function KEV takes unit KXV returns nothing
local unit KOV=LoadUnitHandle(i,yl,GetHandleId(KXV))
local group KRV=LoadGroupHandle(i,bl,GetHandleId(KOV))
call GroupRemoveUnit(KRV,KXV)
if FirstOfGroup(KRV)==null then
call DestroyGroup(KRV)
call SaveGroupHandle(i,bl,GetHandleId(KOV),null)
endif
set KRV=null
set KOV=null
set KOV=null
set KRV=null
endfunction
function KIV takes nothing returns boolean
call KEV(ry)
return true
endfunction
function KAV takes trigger KNV,string KbV returns integer
local integer KBV
set ZM[EM]=KbV
set EM=EM+1
set KBV=fwv(ed,C0v(KNV),"when calling loadInt in ScmdDataTypes, line 960")
set EM=EM-1
return KBV
endfunction
function KcV takes string KCV returns boolean
local boolean KdV
set ZM[EM]=KCV
set EM=EM+1
set KdV=HVo(GetEnteringUnit())==sa[QGv(KAV(GetTriggeringTrigger(),"when calling getContext in SLangTriggerFunctions, line 86"),"when calling getPlayerId in SLangTriggerFunctions, line 86")]
set EM=EM-1
return KdV
endfunction
function KDV takes nothing returns boolean
set EM=0
return KcV("SLangTriggerFunctions, line 85")
endfunction
function KfV takes nothing returns nothing
set Oe=Oe+dy
endfunction
function KFV takes nothing returns boolean
return GetBooleanAnd(IsUnitAliveBJ(GetFilterUnit()),IsUnitEnemy(GetFilterUnit(),GetOwningPlayer(Nu)))
endfunction
function KgV takes nothing returns boolean
return(GetSpellAbilityId()=='A0EH')
endfunction
function KGV takes string KhV returns integer
local integer KHV
set ZM[EM]=KhV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set KHV=Yj
set Gj[KHV]=$A94
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 759")
set KHV=0
endif
else
set Tj=Tj-1
set KHV=Rj[Tj]
set Gj[KHV]=$A94
endif
set EM=EM-1
return KHV
endfunction
function KjV takes string KJV returns integer
local integer KkV
set ZM[EM]=KJV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set KkV=Yj
set Gj[KkV]=$B37
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 168")
set KkV=0
endif
else
set Tj=Tj-1
set KkV=Rj[Tj]
set Gj[KkV]=$B37
endif
set EM=EM-1
return KkV
endfunction
function KKV takes string KlV returns integer
local integer KLV
set ZM[EM]=KlV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set KLV=Yj
set Gj[KLV]=$B87
else
call Cdv("Out of memory: Could not create IBuiltin_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 313")
set KLV=0
endif
else
set Tj=Tj-1
set KLV=Rj[Tj]
set Gj[KLV]=$B87
endif
set EM=EM-1
return KLV
endfunction
function KmV takes string KMV returns integer
local integer KpV
set ZM[EM]=KMV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set KpV=Yj
set Gj[KpV]=$A4C
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 113")
set KpV=0
endif
else
set Tj=Tj-1
set KpV=Rj[Tj]
set Gj[KpV]=$A4C
endif
set EM=EM-1
return KpV
endfunction
function KPV takes string KqV returns integer
local integer KQV
set ZM[EM]=KqV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set KQV=Yj
set Gj[KQV]=$A59
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 251")
set KQV=0
endif
else
set Tj=Tj-1
set KQV=Rj[Tj]
set Gj[KQV]=$A59
endif
set EM=EM-1
return KQV
endfunction
function KsV takes string KSV returns integer
local integer KtV
set ZM[EM]=KSV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set KtV=Yj
set Gj[KtV]=$A6A
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 370")
set KtV=0
endif
else
set Tj=Tj-1
set KtV=Rj[Tj]
set Gj[KtV]=$A6A
endif
set EM=EM-1
return KtV
endfunction
function KTV takes string KuV returns integer
local integer KUV
set ZM[EM]=KuV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set KUV=Yj
set Gj[KUV]=$B4B
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 424")
set KUV=0
endif
else
set Tj=Tj-1
set KUV=Rj[Tj]
set Gj[KUV]=$B4B
endif
set EM=EM-1
return KUV
endfunction
function KwV takes string KWV returns integer
local integer KyV
set ZM[EM]=KWV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set KyV=Yj
set Gj[KyV]=$A7B
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 575")
set KyV=0
endif
else
set Tj=Tj-1
set KyV=Rj[Tj]
set Gj[KyV]=$A7B
endif
set EM=EM-1
return KyV
endfunction
function KYV takes string KzV returns integer
local integer KZV
set ZM[EM]=KzV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set KZV=Yj
set Gj[KZV]=$B8B
else
call Cdv("Out of memory: Could not create IBuiltin_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 644")
set KZV=0
endif
else
set Tj=Tj-1
set KZV=Rj[Tj]
set Gj[KZV]=$B8B
endif
set EM=EM-1
return KZV
endfunction
function K_V takes string K0V returns integer
local integer K1V
set ZM[EM]=K0V
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set K1V=Yj
set Gj[K1V]=$B8F
else
call Cdv("Out of memory: Could not create IBuiltin_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 698")
set K1V=0
endif
else
set Tj=Tj-1
set K1V=Rj[Tj]
set Gj[K1V]=$B8F
endif
set EM=EM-1
return K1V
endfunction
function K2V takes string K3V returns integer
local integer K4V
set ZM[EM]=K3V
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set K4V=Yj
set Gj[K4V]=$B7B
else
call Cdv("Out of memory: Could not create IBuiltin_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 50")
set K4V=0
endif
else
set Tj=Tj-1
set K4V=Rj[Tj]
set Gj[K4V]=$B7B
endif
set EM=EM-1
return K4V
endfunction
function K5V takes string K6V returns integer
local integer K7V
set ZM[EM]=K6V
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set K7V=Yj
set Gj[K7V]=$B68
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 813")
set K7V=0
endif
else
set Tj=Tj-1
set K7V=Rj[Tj]
set Gj[K7V]=$B68
endif
set EM=EM-1
return K7V
endfunction
function K8V takes string K9V returns integer
local integer lvV
set ZM[EM]=K9V
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set lvV=Yj
set Gj[lvV]=$A93
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 752")
set lvV=0
endif
else
set Tj=Tj-1
set lvV=Rj[Tj]
set Gj[lvV]=$A93
endif
set EM=EM-1
return lvV
endfunction
function leV takes string lxV returns integer
local integer loV
set ZM[EM]=lxV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set loV=Yj
set Gj[loV]=$B36
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 161")
set loV=0
endif
else
set Tj=Tj-1
set loV=Rj[Tj]
set Gj[loV]=$B36
endif
set EM=EM-1
return loV
endfunction
function lrV takes string liV returns integer
local integer laV
set ZM[EM]=liV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set laV=Yj
set Gj[laV]=$B3C
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 306")
set laV=0
endif
else
set Tj=Tj-1
set laV=Rj[Tj]
set Gj[laV]=$B3C
endif
set EM=EM-1
return laV
endfunction
function lnV takes string lVV returns integer
local integer lEV
set ZM[EM]=lVV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set lEV=Yj
set Gj[lEV]=$A4B
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 106")
set lEV=0
endif
else
set Tj=Tj-1
set lEV=Rj[Tj]
set Gj[lEV]=$A4B
endif
set EM=EM-1
return lEV
endfunction
function lXV takes string lOV returns integer
local integer lRV
set ZM[EM]=lOV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set lRV=Yj
set Gj[lRV]=$A57
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 245")
set lRV=0
endif
else
set Tj=Tj-1
set lRV=Rj[Tj]
set Gj[lRV]=$A57
endif
set EM=EM-1
return lRV
endfunction
function lIV takes string lAV returns integer
local integer lNV
set ZM[EM]=lAV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set lNV=Yj
set Gj[lNV]=$A69
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 364")
set lNV=0
endif
else
set Tj=Tj-1
set lNV=Rj[Tj]
set Gj[lNV]=$A69
endif
set EM=EM-1
return lNV
endfunction
function lbV takes string lBV returns integer
local integer lcV
set ZM[EM]=lBV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set lcV=Yj
set Gj[lcV]=$B4A
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 417")
set lcV=0
endif
else
set Tj=Tj-1
set lcV=Rj[Tj]
set Gj[lcV]=$B4A
endif
set EM=EM-1
return lcV
endfunction
function lCV takes string ldV returns integer
local integer lDV
set ZM[EM]=ldV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set lDV=Yj
set Gj[lDV]=$A7A
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 569")
set lDV=0
endif
else
set Tj=Tj-1
set lDV=Rj[Tj]
set Gj[lDV]=$A7A
endif
set EM=EM-1
return lDV
endfunction
function lfV takes string lFV returns integer
local integer lgV
set ZM[EM]=lFV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set lgV=Yj
set Gj[lgV]=$B5A
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 637")
set lgV=0
endif
else
set Tj=Tj-1
set lgV=Rj[Tj]
set Gj[lgV]=$B5A
endif
set EM=EM-1
return lgV
endfunction
function lGV takes string lhV returns integer
local integer lHV
set ZM[EM]=lhV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set lHV=Yj
set Gj[lHV]=$A8B
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 692")
set lHV=0
endif
else
set Tj=Tj-1
set lHV=Rj[Tj]
set Gj[lHV]=$A8B
endif
set EM=EM-1
return lHV
endfunction
function ljV takes string lJV returns integer
local integer lkV
set ZM[EM]=lJV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set lkV=Yj
set Gj[lkV]=$B2C
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 19")
set lkV=0
endif
else
set Tj=Tj-1
set lkV=Rj[Tj]
set Gj[lkV]=$B2C
endif
set EM=EM-1
return lkV
endfunction
function lKV takes string llV returns integer
local integer lLV
set ZM[EM]=llV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set lLV=Yj
set Gj[lLV]=$B67
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 806")
set lLV=0
endif
else
set Tj=Tj-1
set lLV=Rj[Tj]
set Gj[lLV]=$B67
endif
set EM=EM-1
return lLV
endfunction
function lmV takes string lMV returns integer
local integer lpV
set ZM[EM]=lMV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set lpV=Yj
set Gj[lpV]=$A92
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 745")
set lpV=0
endif
else
set Tj=Tj-1
set lpV=Rj[Tj]
set Gj[lpV]=$A92
endif
set EM=EM-1
return lpV
endfunction
function lPV takes string lqV returns integer
local integer lQV
set ZM[EM]=lqV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set lQV=Yj
set Gj[lQV]=$B35
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 154")
set lQV=0
endif
else
set Tj=Tj-1
set lQV=Rj[Tj]
set Gj[lQV]=$B35
endif
set EM=EM-1
return lQV
endfunction
function lsV takes string lSV returns integer
local integer ltV
set ZM[EM]=lSV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set ltV=Yj
set Gj[ltV]=$B86
else
call Cdv("Out of memory: Could not create IBuiltin_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 301")
set ltV=0
endif
else
set Tj=Tj-1
set ltV=Rj[Tj]
set Gj[ltV]=$B86
endif
set EM=EM-1
return ltV
endfunction
function lTV takes string luV returns integer
local integer lUV
set ZM[EM]=luV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set lUV=Yj
set Gj[lUV]=$A4A
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 99")
set lUV=0
endif
else
set Tj=Tj-1
set lUV=Rj[Tj]
set Gj[lUV]=$A4A
endif
set EM=EM-1
return lUV
endfunction
function lwV takes string lWV returns integer
local integer lyV
set ZM[EM]=lWV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set lyV=Yj
set Gj[lyV]=$A33
else
call Cdv("Out of memory: Could not create IBuiltin_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 237")
set lyV=0
endif
else
set Tj=Tj-1
set lyV=Rj[Tj]
set Gj[lyV]=$A33
endif
set EM=EM-1
return lyV
endfunction
function lYV takes string lzV returns integer
local integer lZV
set ZM[EM]=lzV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set lZV=Yj
set Gj[lZV]=$A68
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 358")
set lZV=0
endif
else
set Tj=Tj-1
set lZV=Rj[Tj]
set Gj[lZV]=$A68
endif
set EM=EM-1
return lZV
endfunction
function l_V takes string l0V returns integer
local integer l1V
set ZM[EM]=l0V
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set l1V=Yj
set Gj[l1V]=$B49
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 412")
set l1V=0
endif
else
set Tj=Tj-1
set l1V=Rj[Tj]
set Gj[l1V]=$B49
endif
set EM=EM-1
return l1V
endfunction
function l2V takes string l3V returns integer
local integer l4V
set ZM[EM]=l3V
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set l4V=Yj
set Gj[l4V]=$A79
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 558")
set l4V=0
endif
else
set Tj=Tj-1
set l4V=Rj[Tj]
set Gj[l4V]=$A79
endif
set EM=EM-1
return l4V
endfunction
function l5V takes string l6V returns integer
local integer l7V
set ZM[EM]=l6V
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set l7V=Yj
set Gj[l7V]=$B59
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 630")
set l7V=0
endif
else
set Tj=Tj-1
set l7V=Rj[Tj]
set Gj[l7V]=$B59
endif
set EM=EM-1
return l7V
endfunction
function l8V takes string l9V returns integer
local integer LvV
set ZM[EM]=l9V
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set LvV=Yj
set Gj[LvV]=$A8A
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 685")
set LvV=0
endif
else
set Tj=Tj-1
set LvV=Rj[Tj]
set Gj[LvV]=$A8A
endif
set EM=EM-1
return LvV
endfunction
function LeV takes string LxV returns integer
local integer LoV
set ZM[EM]=LxV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set LoV=Yj
set Gj[LoV]=$B66
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 799")
set LoV=0
endif
else
set Tj=Tj-1
set LoV=Rj[Tj]
set Gj[LoV]=$B66
endif
set EM=EM-1
return LoV
endfunction
function LrV takes string LiV returns integer
local integer LaV
set ZM[EM]=LiV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set LaV=Yj
set Gj[LaV]=$B94
else
call Cdv("Out of memory: Could not create IBuiltin_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 749")
set LaV=0
endif
else
set Tj=Tj-1
set LaV=Rj[Tj]
set Gj[LaV]=$B94
endif
set EM=EM-1
return LaV
endfunction
function LnV takes string LVV returns integer
local integer LEV
set ZM[EM]=LVV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set LEV=Yj
set Gj[LEV]=$A53
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 157")
set LEV=0
endif
else
set Tj=Tj-1
set LEV=Rj[Tj]
set Gj[LEV]=$A53
endif
set EM=EM-1
return LEV
endfunction
function LXV takes string LOV returns integer
local integer LRV
set ZM[EM]=LOV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set LRV=Yj
set Gj[LRV]=$A60
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 303")
set LRV=0
endif
else
set Tj=Tj-1
set LRV=Rj[Tj]
set Gj[LRV]=$A60
endif
set EM=EM-1
return LRV
endfunction
function LIV takes string LAV returns integer
local integer LNV
set ZM[EM]=LAV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set LNV=Yj
set Gj[LNV]=$B7E
else
call Cdv("Out of memory: Could not create IBuiltin_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 103")
set LNV=0
endif
else
set Tj=Tj-1
set LNV=Rj[Tj]
set Gj[LNV]=$B7E
endif
set EM=EM-1
return LNV
endfunction
function LbV takes string LBV returns integer
local integer LcV
set ZM[EM]=LBV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set LcV=Yj
set Gj[LcV]=$B83
else
call Cdv("Out of memory: Could not create IBuiltin_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 242")
set LcV=0
endif
else
set Tj=Tj-1
set LcV=Rj[Tj]
set Gj[LcV]=$B83
endif
set EM=EM-1
return LcV
endfunction
function LCV takes string LdV returns integer
local integer LDV
set ZM[EM]=LdV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set LDV=Yj
set Gj[LDV]=$B42
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 362")
set LDV=0
endif
else
set Tj=Tj-1
set LDV=Rj[Tj]
set Gj[LDV]=$B42
endif
set EM=EM-1
return LDV
endfunction
function LfV takes string LFV returns integer
local integer LgV
set ZM[EM]=LFV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set LgV=Yj
set Gj[LgV]=$A71
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 414")
set LgV=0
endif
else
set Tj=Tj-1
set LgV=Rj[Tj]
set Gj[LgV]=$A71
endif
set EM=EM-1
return LgV
endfunction
function LGV takes string LhV returns integer
local integer LHV
set ZM[EM]=LhV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set LHV=Yj
set Gj[LHV]=$B8A
else
call Cdv("Out of memory: Could not create IBuiltin_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 567")
set LHV=0
endif
else
set Tj=Tj-1
set LHV=Rj[Tj]
set Gj[LHV]=$B8A
endif
set EM=EM-1
return LHV
endfunction
function LjV takes string LJV returns integer
local integer LkV
set ZM[EM]=LJV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set LkV=Yj
set Gj[LkV]=$A82
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 633")
set LkV=0
endif
else
set Tj=Tj-1
set LkV=Rj[Tj]
set Gj[LkV]=$A82
endif
set EM=EM-1
return LkV
endfunction
function LKV takes string LlV returns integer
local integer LLV
set ZM[EM]=LlV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set LLV=Yj
set Gj[LLV]=$B8E
else
call Cdv("Out of memory: Could not create IBuiltin_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 690")
set LLV=0
endif
else
set Tj=Tj-1
set LLV=Rj[Tj]
set Gj[LLV]=$B8E
endif
set EM=EM-1
return LLV
endfunction
function LmV takes string LMV returns integer
local integer LpV
set ZM[EM]=LMV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set LpV=Yj
set Gj[LpV]=$A9B
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 802")
set LpV=0
endif
else
set Tj=Tj-1
set LpV=Rj[Tj]
set Gj[LpV]=$A9B
endif
set EM=EM-1
return LpV
endfunction
function LPV takes integer LqV,boolean LQV returns nothing
set mJ[LqV]=LQV
endfunction
function LsV takes integer LSV,boolean LtV,string LTV returns nothing
set ZM[EM]=LTV
set EM=EM+1
if ax[LSV]==0 then
if LSV==0 then
call Cdv("Nullpointer exception when calling BuiltinData.setRequiringEnumUnit","when calling error in ScmdDataTypes, line 1402")
else
call Cdv("Called BuiltinData.setRequiringEnumUnit on invalid object.","when calling error in ScmdDataTypes, line 1402")
endif
endif
call LPV(LSV,LtV)
set EM=EM-1
endfunction
function LuV takes integer LUV,string LwV returns nothing
set ZM[EM]=LwV
set EM=EM+1
call LsV(LUV,true,"when calling setRequiringEnumUnit in ScmdDataTypes, line 1406")
set EM=EM-1
endfunction
function LWV takes integer LyV,string LYV returns nothing
set ZM[EM]=LYV
set EM=EM+1
if ax[LyV]==0 then
if LyV==0 then
call Cdv("Nullpointer exception when calling BuiltinData.setRequiringEnumUnit","when calling error in ScmdDataTypes, line 1405")
else
call Cdv("Called BuiltinData.setRequiringEnumUnit on invalid object.","when calling error in ScmdDataTypes, line 1405")
endif
endif
call LuV(LyV,"when calling setRequiringEnumUnit in ScmdDataTypes, line 1405")
set EM=EM-1
endfunction
function LzV takes string LZV returns integer
local integer L_V
set ZM[EM]=LZV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set L_V=Yj
set Gj[L_V]=$B95
else
call Cdv("Out of memory: Could not create IBuiltin_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 756")
set L_V=0
endif
else
set Tj=Tj-1
set L_V=Rj[Tj]
set Gj[L_V]=$B95
endif
set EM=EM-1
return L_V
endfunction
function L0V takes string L1V returns integer
local integer L2V
set ZM[EM]=L1V
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set L2V=Yj
set Gj[L2V]=$A54
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 164")
set L2V=0
endif
else
set Tj=Tj-1
set L2V=Rj[Tj]
set Gj[L2V]=$A54
endif
set EM=EM-1
return L2V
endfunction
function L3V takes string L4V returns integer
local integer L5V
set ZM[EM]=L4V
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set L5V=Yj
set Gj[L5V]=$A61
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 309")
set L5V=0
endif
else
set Tj=Tj-1
set L5V=Rj[Tj]
set Gj[L5V]=$A61
endif
set EM=EM-1
return L5V
endfunction
function L6V takes string L7V returns integer
local integer L8V
set ZM[EM]=L7V
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set L8V=Yj
set Gj[L8V]=$B31
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 110")
set L8V=0
endif
else
set Tj=Tj-1
set L8V=Rj[Tj]
set Gj[L8V]=$B31
endif
set EM=EM-1
return L8V
endfunction
function L9V takes string mvV returns integer
local integer meV
set ZM[EM]=mvV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set meV=Yj
set Gj[meV]=$A58
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 249")
set meV=0
endif
else
set Tj=Tj-1
set meV=Rj[Tj]
set Gj[meV]=$A58
endif
set EM=EM-1
return meV
endfunction
function mxV takes string moV returns integer
local integer mrV
set ZM[EM]=moV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set mrV=Yj
set Gj[mrV]=$B43
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 367")
set mrV=0
endif
else
set Tj=Tj-1
set mrV=Rj[Tj]
set Gj[mrV]=$B43
endif
set EM=EM-1
return mrV
endfunction
function miV takes string maV returns integer
local integer mnV
set ZM[EM]=maV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set mnV=Yj
set Gj[mnV]=$A72
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 420")
set mnV=0
endif
else
set Tj=Tj-1
set mnV=Rj[Tj]
set Gj[mnV]=$A72
endif
set EM=EM-1
return mnV
endfunction
function mVV takes string mEV returns integer
local integer mXV
set ZM[EM]=mEV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set mXV=Yj
set Gj[mXV]=$B52
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 572")
set mXV=0
endif
else
set Tj=Tj-1
set mXV=Rj[Tj]
set Gj[mXV]=$B52
endif
set EM=EM-1
return mXV
endfunction
function mOV takes string mRV returns integer
local integer mIV
set ZM[EM]=mRV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set mIV=Yj
set Gj[mIV]=$A83
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 640")
set mIV=0
endif
else
set Tj=Tj-1
set mIV=Rj[Tj]
set Gj[mIV]=$A83
endif
set EM=EM-1
return mIV
endfunction
function mAV takes string mNV returns integer
local integer mbV
set ZM[EM]=mNV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set mbV=Yj
set Gj[mbV]=$B12
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 695")
set mbV=0
endif
else
set Tj=Tj-1
set mbV=Rj[Tj]
set Gj[mbV]=$B12
endif
set EM=EM-1
return mbV
endfunction
function mBV takes string mcV returns integer
local integer mCV
set ZM[EM]=mcV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set mCV=Yj
set Gj[mCV]=$A43
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 34")
set mCV=0
endif
else
set Tj=Tj-1
set mCV=Rj[Tj]
set Gj[mCV]=$A43
endif
set EM=EM-1
return mCV
endfunction
function mdV takes string mDV returns integer
local integer mfV
set ZM[EM]=mDV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set mfV=Yj
set Gj[mfV]=$A9C
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 809")
set mfV=0
endif
else
set Tj=Tj-1
set mfV=Rj[Tj]
set Gj[mfV]=$A9C
endif
set EM=EM-1
return mfV
endfunction
function mFV takes integer mgV,integer mGV,integer mhV,integer mHV,integer mjV,integer mJV,string mkV returns nothing
set ZM[EM]=mkV
set EM=EM+1
set xJ[mgV]=0
call zGv(jJ[mgV],mGV,"when calling add in ScmdDataTypes, line 1394")
set xJ[mgV]=xJ[mgV]+1
call zGv(jJ[mgV],mhV,"when calling add in ScmdDataTypes, line 1394")
set xJ[mgV]=xJ[mgV]+1
call zGv(jJ[mgV],mHV,"when calling add in ScmdDataTypes, line 1394")
set xJ[mgV]=xJ[mgV]+1
call zGv(jJ[mgV],mjV,"when calling add in ScmdDataTypes, line 1394")
set xJ[mgV]=xJ[mgV]+1
call zGv(jJ[mgV],mJV,"when calling add in ScmdDataTypes, line 1394")
set xJ[mgV]=xJ[mgV]+1
set EM=EM-1
endfunction
function mKV takes integer mlV,integer mLV,integer mmV,integer mMV,integer mpV,integer mPV,string mqV returns nothing
set ZM[EM]=mqV
set EM=EM+1
if ax[mlV]==0 then
if mlV==0 then
call Cdv("Nullpointer exception when calling BuiltinData.setArgumentsTypes","when calling error in ScmdDataTypes, line 1391")
else
call Cdv("Called BuiltinData.setArgumentsTypes on invalid object.","when calling error in ScmdDataTypes, line 1391")
endif
endif
call mFV(mlV,mLV,mmV,mMV,mpV,mPV,"when calling setArgumentsTypes in ScmdDataTypes, line 1391")
set EM=EM-1
endfunction
function mQV takes string msV returns integer
local integer mSV
set ZM[EM]=msV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set mSV=Yj
set Gj[mSV]=$B96
else
call Cdv("Out of memory: Could not create IBuiltin_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 763")
set mSV=0
endif
else
set Tj=Tj-1
set mSV=Rj[Tj]
set Gj[mSV]=$B96
endif
set EM=EM-1
return mSV
endfunction
function mtV takes string mTV returns integer
local integer muV
set ZM[EM]=mTV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set muV=Yj
set Gj[muV]=$A55
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 171")
set muV=0
endif
else
set Tj=Tj-1
set muV=Rj[Tj]
set Gj[muV]=$A55
endif
set EM=EM-1
return muV
endfunction
function mUV takes string mwV returns integer
local integer mWV
set ZM[EM]=mwV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set mWV=Yj
set Gj[mWV]=$A62
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 315")
set mWV=0
endif
else
set Tj=Tj-1
set mWV=Rj[Tj]
set Gj[mWV]=$A62
endif
set EM=EM-1
return mWV
endfunction
function myV takes string mYV returns integer
local integer mzV
set ZM[EM]=mYV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set mzV=Yj
set Gj[mzV]=$B32
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 117")
set mzV=0
endif
else
set Tj=Tj-1
set mzV=Rj[Tj]
set Gj[mzV]=$B32
endif
set EM=EM-1
return mzV
endfunction
function mZV takes string m_V returns integer
local integer m0V
set ZM[EM]=m_V
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set m0V=Yj
set Gj[m0V]=$B38
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 263")
set m0V=0
endif
else
set Tj=Tj-1
set m0V=Rj[Tj]
set Gj[m0V]=$B38
endif
set EM=EM-1
return m0V
endfunction
function m1V takes string m2V returns integer
local integer m3V
set ZM[EM]=m2V
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set m3V=Yj
set Gj[m3V]=$B44
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 374")
set m3V=0
endif
else
set Tj=Tj-1
set m3V=Rj[Tj]
set Gj[m3V]=$B44
endif
set EM=EM-1
return m3V
endfunction
function m4V takes string m5V returns integer
local integer m6V
set ZM[EM]=m5V
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set m6V=Yj
set Gj[m6V]=$A73
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 426")
set m6V=0
endif
else
set Tj=Tj-1
set m6V=Rj[Tj]
set Gj[m6V]=$A73
endif
set EM=EM-1
return m6V
endfunction
function m7V takes string m8V returns integer
local integer m9V
set ZM[EM]=m8V
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set m9V=Yj
set Gj[m9V]=$B53
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 579")
set m9V=0
endif
else
set Tj=Tj-1
set m9V=Rj[Tj]
set Gj[m9V]=$B53
endif
set EM=EM-1
return m9V
endfunction
function MvV takes string MeV returns integer
local integer MxV
set ZM[EM]=MeV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set MxV=Yj
set Gj[MxV]=$A84
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 646")
set MxV=0
endif
else
set Tj=Tj-1
set MxV=Rj[Tj]
set Gj[MxV]=$A84
endif
set EM=EM-1
return MxV
endfunction
function MoV takes string MrV returns integer
local integer MiV
set ZM[EM]=MrV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set MiV=Yj
set Gj[MiV]=$A8C
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 700")
set MiV=0
endif
else
set Tj=Tj-1
set MiV=Rj[Tj]
set Gj[MiV]=$A8C
endif
set EM=EM-1
return MiV
endfunction
function MaV takes string MnV returns integer
local integer MVV
set ZM[EM]=MnV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set MVV=Yj
set Gj[MVV]=$A44
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 53")
set MVV=0
endif
else
set Tj=Tj-1
set MVV=Rj[Tj]
set Gj[MVV]=$A44
endif
set EM=EM-1
return MVV
endfunction
function MEV takes string MXV returns integer
local integer MOV
set ZM[EM]=MXV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set MOV=Yj
set Gj[MOV]=$A9D
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 816")
set MOV=0
endif
else
set Tj=Tj-1
set MOV=Rj[Tj]
set Gj[MOV]=$A9D
endif
set EM=EM-1
return MOV
endfunction
function MRV takes nothing returns integer
return Vn
endfunction
function MIV takes string MAV returns integer
local integer MNV
set ZM[EM]=MAV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set MNV=Yj
set Gj[MNV]=$A90
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 732")
set MNV=0
endif
else
set Tj=Tj-1
set MNV=Rj[Tj]
set Gj[MNV]=$A90
endif
set EM=EM-1
return MNV
endfunction
function MbV takes string MBV returns integer
local integer McV
set ZM[EM]=MBV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set McV=Yj
set Gj[McV]=$B34
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 141")
set McV=0
endif
else
set Tj=Tj-1
set McV=Rj[Tj]
set Gj[McV]=$B34
endif
set EM=EM-1
return McV
endfunction
function MCV takes string MdV returns integer
local integer MDV
set ZM[EM]=MdV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set MDV=Yj
set Gj[MDV]=$B85
else
call Cdv("Out of memory: Could not create IBuiltin_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 289")
set MDV=0
endif
else
set Tj=Tj-1
set MDV=Rj[Tj]
set Gj[MDV]=$B85
endif
set EM=EM-1
return MDV
endfunction
function MfV takes string MFV returns integer
local integer MgV
set ZM[EM]=MFV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set MgV=Yj
set Gj[MgV]=$A48
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 88")
set MgV=0
endif
else
set Tj=Tj-1
set MgV=Rj[Tj]
set Gj[MgV]=$A48
endif
set EM=EM-1
return MgV
endfunction
function MGV takes string MhV returns integer
local integer MHV
set ZM[EM]=MhV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set MHV=Yj
set Gj[MHV]=$B98
else
call Cdv("Out of memory: Could not create IBuiltin_setRequiringEnumUnit_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 225")
set MHV=0
endif
else
set Tj=Tj-1
set MHV=Rj[Tj]
set Gj[MHV]=$B98
endif
set EM=EM-1
return MHV
endfunction
function MjV takes string MJV returns integer
local integer MkV
set ZM[EM]=MJV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set MkV=Yj
set Gj[MkV]=$A66
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 346")
set MkV=0
endif
else
set Tj=Tj-1
set MkV=Rj[Tj]
set Gj[MkV]=$A66
endif
set EM=EM-1
return MkV
endfunction
function MKV takes string MlV returns integer
local integer MLV
set ZM[EM]=MlV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set MLV=Yj
set Gj[MLV]=$B47
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 400")
set MLV=0
endif
else
set Tj=Tj-1
set MLV=Rj[Tj]
set Gj[MLV]=$B47
endif
set EM=EM-1
return MLV
endfunction
function MmV takes string MMV returns integer
local integer MpV
set ZM[EM]=MMV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set MpV=Yj
set Gj[MpV]=$A77
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 516")
set MpV=0
endif
else
set Tj=Tj-1
set MpV=Rj[Tj]
set Gj[MpV]=$A77
endif
set EM=EM-1
return MpV
endfunction
function MPV takes string MqV returns integer
local integer MQV
set ZM[EM]=MqV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set MQV=Yj
set Gj[MQV]=$B57
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 603")
set MQV=0
endif
else
set Tj=Tj-1
set MQV=Rj[Tj]
set Gj[MQV]=$B57
endif
set EM=EM-1
return MQV
endfunction
function MsV takes string MSV returns integer
local integer MtV
set ZM[EM]=MSV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set MtV=Yj
set Gj[MtV]=$A88
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 671")
set MtV=0
endif
else
set Tj=Tj-1
set MtV=Rj[Tj]
set Gj[MtV]=$A88
endif
set EM=EM-1
return MtV
endfunction
function MTV takes string MuV returns integer
local integer MUV
set ZM[EM]=MuV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set MUV=Yj
set Gj[MUV]=$B64
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 785")
set MUV=0
endif
else
set Tj=Tj-1
set MUV=Rj[Tj]
set Gj[MUV]=$B64
endif
set EM=EM-1
return MUV
endfunction
function MwV takes string MWV returns integer
local integer MyV
set ZM[EM]=MWV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set MyV=Yj
set Gj[MyV]=$A8F
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 727")
set MyV=0
endif
else
set Tj=Tj-1
set MyV=Rj[Tj]
set Gj[MyV]=$A8F
endif
set EM=EM-1
return MyV
endfunction
function MYV takes string MzV returns integer
local integer MZV
set ZM[EM]=MzV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set MZV=Yj
set Gj[MZV]=$B80
else
call Cdv("Out of memory: Could not create IBuiltin_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 136")
set MZV=0
endif
else
set Tj=Tj-1
set MZV=Rj[Tj]
set Gj[MZV]=$B80
endif
set EM=EM-1
return MZV
endfunction
function M_V takes string M0V returns integer
local integer M1V
set ZM[EM]=M0V
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set M1V=Yj
set Gj[M1V]=$B3A
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 282")
set M1V=0
endif
else
set Tj=Tj-1
set M1V=Rj[Tj]
set Gj[M1V]=$B3A
endif
set EM=EM-1
return M1V
endfunction
function M2V takes string M3V returns integer
local integer M4V
set ZM[EM]=M3V
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set M4V=Yj
set Gj[M4V]=$A47
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 82")
set M4V=0
endif
else
set Tj=Tj-1
set M4V=Rj[Tj]
set Gj[M4V]=$A47
endif
set EM=EM-1
return M4V
endfunction
function M5V takes string M6V returns integer
local integer M7V
set ZM[EM]=M6V
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set M7V=Yj
set Gj[M7V]=$A65
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 340")
set M7V=0
endif
else
set Tj=Tj-1
set M7V=Rj[Tj]
set Gj[M7V]=$A65
endif
set EM=EM-1
return M7V
endfunction
function M8V takes string M9V returns integer
local integer pvV
set ZM[EM]=M9V
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set pvV=Yj
set Gj[pvV]=$B89
else
call Cdv("Out of memory: Could not create IBuiltin_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 395")
set pvV=0
endif
else
set Tj=Tj-1
set pvV=Rj[Tj]
set Gj[pvV]=$B89
endif
set EM=EM-1
return pvV
endfunction
function peV takes string pxV returns integer
local integer poV
set ZM[EM]=pxV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set poV=Yj
set Gj[poV]=$A76
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 489")
set poV=0
endif
else
set Tj=Tj-1
set poV=Rj[Tj]
set Gj[poV]=$A76
endif
set EM=EM-1
return poV
endfunction
function prV takes string piV returns integer
local integer paV
set ZM[EM]=piV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set paV=Yj
set Gj[paV]=$B56
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 596")
set paV=0
endif
else
set Tj=Tj-1
set paV=Rj[Tj]
set Gj[paV]=$B56
endif
set EM=EM-1
return paV
endfunction
function pnV takes string pVV returns integer
local integer pEV
set ZM[EM]=pVV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set pEV=Yj
set Gj[pEV]=$A87
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 665")
set pEV=0
endif
else
set Tj=Tj-1
set pEV=Rj[Tj]
set Gj[pEV]=$A87
endif
set EM=EM-1
return pEV
endfunction
function pXV takes string pOV returns integer
local integer pRV
set ZM[EM]=pOV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set pRV=Yj
set Gj[pRV]=$B63
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 780")
set pRV=0
endif
else
set Tj=Tj-1
set pRV=Rj[Tj]
set Gj[pRV]=$B63
endif
set EM=EM-1
return pRV
endfunction
function pIV takes string pAV returns integer
local integer pNV
set ZM[EM]=pAV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set pNV=Yj
set Gj[pNV]=$B60
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 714")
set pNV=0
endif
else
set Tj=Tj-1
set pNV=Rj[Tj]
set Gj[pNV]=$B60
endif
set EM=EM-1
return pNV
endfunction
function pbV takes string pBV returns integer
local integer pcV
set ZM[EM]=pBV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set pcV=Yj
set Gj[pcV]=$A4E
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 126")
set pcV=0
endif
else
set Tj=Tj-1
set pcV=Rj[Tj]
set Gj[pcV]=$A4E
endif
set EM=EM-1
return pcV
endfunction
function pCV takes string pdV returns integer
local integer pDV
set ZM[EM]=pdV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set pDV=Yj
set Gj[pDV]=$A5B
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 273")
set pDV=0
endif
else
set Tj=Tj-1
set pDV=Rj[Tj]
set Gj[pDV]=$A5B
endif
set EM=EM-1
return pDV
endfunction
function pfV takes string pFV returns integer
local integer pgV
set ZM[EM]=pFV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set pgV=Yj
set Gj[pgV]=$B2E
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 72")
set pgV=0
endif
else
set Tj=Tj-1
set pgV=Rj[Tj]
set Gj[pgV]=$B2E
endif
set EM=EM-1
return pgV
endfunction
function pGV takes string phV returns integer
local integer pHV
set ZM[EM]=phV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set pHV=Yj
set Gj[pHV]=$B25
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_setProvidingEnumUnit_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 180")
set pHV=0
endif
else
set Tj=Tj-1
set pHV=Rj[Tj]
set Gj[pHV]=$B25
endif
set EM=EM-1
return pHV
endfunction
function pjV takes string pJV returns integer
local integer pkV
set ZM[EM]=pJV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set pkV=Yj
set Gj[pkV]=$B3D
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 331")
set pkV=0
endif
else
set Tj=Tj-1
set pkV=Rj[Tj]
set Gj[pkV]=$B3D
endif
set EM=EM-1
return pkV
endfunction
function pKV takes string plV returns integer
local integer pLV
set ZM[EM]=plV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set pLV=Yj
set Gj[pLV]=$A6C
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 384")
set pLV=0
endif
else
set Tj=Tj-1
set pLV=Rj[Tj]
set Gj[pLV]=$A6C
endif
set EM=EM-1
return pLV
endfunction
function pmV takes string pMV returns integer
local integer ppV
set ZM[EM]=pMV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set ppV=Yj
set Gj[ppV]=$B4D
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 458")
set ppV=0
endif
else
set Tj=Tj-1
set ppV=Rj[Tj]
set Gj[ppV]=$B4D
endif
set EM=EM-1
return ppV
endfunction
function pPV takes string pqV returns integer
local integer pQV
set ZM[EM]=pqV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set pQV=Yj
set Gj[pQV]=$A7D
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 587")
set pQV=0
endif
else
set Tj=Tj-1
set pQV=Rj[Tj]
set Gj[pQV]=$A7D
endif
set EM=EM-1
return pQV
endfunction
function psV takes string pSV returns integer
local integer ptV
set ZM[EM]=pSV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set ptV=Yj
set Gj[ptV]=$B8C
else
call Cdv("Out of memory: Could not create IBuiltin_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 657")
set ptV=0
endif
else
set Tj=Tj-1
set ptV=Rj[Tj]
set Gj[ptV]=$B8C
endif
set EM=EM-1
return ptV
endfunction
function pTV takes string puV returns integer
local integer pUV
set ZM[EM]=puV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set pUV=Yj
set Gj[pUV]=$A96
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 772")
set pUV=0
endif
else
set Tj=Tj-1
set pUV=Rj[Tj]
set Gj[pUV]=$A96
endif
set EM=EM-1
return pUV
endfunction
function pwV takes string pWV returns integer
local integer pyV
set ZM[EM]=pWV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set pyV=Yj
set Gj[pyV]=$B91
else
call Cdv("Out of memory: Could not create IBuiltin_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 730")
set pyV=0
endif
else
set Tj=Tj-1
set pyV=Rj[Tj]
set Gj[pyV]=$B91
endif
set EM=EM-1
return pyV
endfunction
function pYV takes string pzV returns integer
local integer pZV
set ZM[EM]=pzV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set pZV=Yj
set Gj[pZV]=$A50
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 138")
set pZV=0
endif
else
set Tj=Tj-1
set pZV=Rj[Tj]
set Gj[pZV]=$A50
endif
set EM=EM-1
return pZV
endfunction
function p_V takes string p0V returns integer
local integer p1V
set ZM[EM]=p0V
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set p1V=Yj
set Gj[p1V]=$A5D
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 285")
set p1V=0
endif
else
set Tj=Tj-1
set p1V=Rj[Tj]
set Gj[p1V]=$A5D
endif
set EM=EM-1
return p1V
endfunction
function p2V takes string p3V returns integer
local integer p4V
set ZM[EM]=p3V
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set p4V=Yj
set Gj[p4V]=$B7C
else
call Cdv("Out of memory: Could not create IBuiltin_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 86")
set p4V=0
endif
else
set Tj=Tj-1
set p4V=Rj[Tj]
set Gj[p4V]=$B7C
endif
set EM=EM-1
return p4V
endfunction
function p5V takes string p6V returns integer
local integer p7V
set ZM[EM]=p6V
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set p7V=Yj
set Gj[p7V]=$A30
else
call Cdv("Out of memory: Could not create IBuiltin_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 222")
set p7V=0
endif
else
set Tj=Tj-1
set p7V=Rj[Tj]
set Gj[p7V]=$A30
endif
set EM=EM-1
return p7V
endfunction
function p8V takes string p9V returns integer
local integer PvV
set ZM[EM]=p9V
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set PvV=Yj
set Gj[PvV]=$B3F
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 343")
set PvV=0
endif
else
set Tj=Tj-1
set PvV=Rj[Tj]
set Gj[PvV]=$B3F
endif
set EM=EM-1
return PvV
endfunction
function PeV takes string PxV returns integer
local integer PoV
set ZM[EM]=PxV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set PoV=Yj
set Gj[PoV]=$A6E
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 397")
set PoV=0
endif
else
set Tj=Tj-1
set PoV=Rj[Tj]
set Gj[PoV]=$A6E
endif
set EM=EM-1
return PoV
endfunction
function PrV takes string PiV returns integer
local integer PaV
set ZM[EM]=PiV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set PaV=Yj
set Gj[PaV]=$B4F
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 514")
set PaV=0
endif
else
set Tj=Tj-1
set PaV=Rj[Tj]
set Gj[PaV]=$B4F
endif
set EM=EM-1
return PaV
endfunction
function PnV takes string PVV returns integer
local integer PEV
set ZM[EM]=PVV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set PEV=Yj
set Gj[PEV]=$A7F
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 599")
set PEV=0
endif
else
set Tj=Tj-1
set PEV=Rj[Tj]
set Gj[PEV]=$A7F
endif
set EM=EM-1
return PEV
endfunction
function PXV takes string POV returns integer
local integer PRV
set ZM[EM]=POV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set PRV=Yj
set Gj[PRV]=$B8D
else
call Cdv("Out of memory: Could not create IBuiltin_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 669")
set PRV=0
endif
else
set Tj=Tj-1
set PRV=Rj[Tj]
set Gj[PRV]=$B8D
endif
set EM=EM-1
return PRV
endfunction
function PIV takes string PAV returns integer
local integer PNV
set ZM[EM]=PAV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set PNV=Yj
set Gj[PNV]=$A98
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 782")
set PNV=0
endif
else
set Tj=Tj-1
set PNV=Rj[Tj]
set Gj[PNV]=$A98
endif
set EM=EM-1
return PNV
endfunction
function PbV takes string PBV returns integer
local integer PcV
set ZM[EM]=PBV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set PcV=Yj
set Gj[PcV]=$B92
else
call Cdv("Out of memory: Could not create IBuiltin_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 735")
set PcV=0
endif
else
set Tj=Tj-1
set PcV=Rj[Tj]
set Gj[PcV]=$B92
endif
set EM=EM-1
return PcV
endfunction
function PCV takes string PdV returns integer
local integer PDV
set ZM[EM]=PdV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set PDV=Yj
set Gj[PDV]=$A51
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 144")
set PDV=0
endif
else
set Tj=Tj-1
set PDV=Rj[Tj]
set Gj[PDV]=$A51
endif
set EM=EM-1
return PDV
endfunction
function PfV takes string PFV returns integer
local integer PgV
set ZM[EM]=PFV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set PgV=Yj
set Gj[PgV]=$A5E
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 291")
set PgV=0
endif
else
set Tj=Tj-1
set PgV=Rj[Tj]
set Gj[PgV]=$A5E
endif
set EM=EM-1
return PgV
endfunction
function PGV takes string PhV returns integer
local integer PHV
set ZM[EM]=PhV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set PHV=Yj
set Gj[PHV]=$B7D
else
call Cdv("Out of memory: Could not create IBuiltin_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 91")
set PHV=0
endif
else
set Tj=Tj-1
set PHV=Rj[Tj]
set Gj[PHV]=$B7D
endif
set EM=EM-1
return PHV
endfunction
function PjV takes string PJV returns integer
local integer PkV
set ZM[EM]=PJV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set PkV=Yj
set Gj[PkV]=$A31
else
call Cdv("Out of memory: Could not create IBuiltin_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 228")
set PkV=0
endif
else
set Tj=Tj-1
set PkV=Rj[Tj]
set Gj[PkV]=$A31
endif
set EM=EM-1
return PkV
endfunction
function PKV takes string PlV returns integer
local integer PLV
set ZM[EM]=PlV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set PLV=Yj
set Gj[PLV]=$B40
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 350")
set PLV=0
endif
else
set Tj=Tj-1
set PLV=Rj[Tj]
set Gj[PLV]=$B40
endif
set EM=EM-1
return PLV
endfunction
function PmV takes string PMV returns integer
local integer PpV
set ZM[EM]=PMV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set PpV=Yj
set Gj[PpV]=$A6F
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 403")
set PpV=0
endif
else
set Tj=Tj-1
set PpV=Rj[Tj]
set Gj[PpV]=$A6F
endif
set EM=EM-1
return PpV
endfunction
function PPV takes string PqV returns integer
local integer PQV
set ZM[EM]=PqV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set PQV=Yj
set Gj[PQV]=$B50
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 545")
set PQV=0
endif
else
set Tj=Tj-1
set PQV=Rj[Tj]
set Gj[PQV]=$B50
endif
set EM=EM-1
return PQV
endfunction
function PsV takes string PSV returns integer
local integer PtV
set ZM[EM]=PSV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set PtV=Yj
set Gj[PtV]=$A80
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 605")
set PtV=0
endif
else
set Tj=Tj-1
set PtV=Rj[Tj]
set Gj[PtV]=$A80
endif
set EM=EM-1
return PtV
endfunction
function PTV takes string PuV returns integer
local integer PUV
set ZM[EM]=PuV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set PUV=Yj
set Gj[PUV]=$B5D
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 675")
set PUV=0
endif
else
set Tj=Tj-1
set PUV=Rj[Tj]
set Gj[PUV]=$B5D
endif
set EM=EM-1
return PUV
endfunction
function PwV takes string PWV returns integer
local integer PyV
set ZM[EM]=PWV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set PyV=Yj
set Gj[PyV]=$A99
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 788")
set PyV=0
endif
else
set Tj=Tj-1
set PyV=Rj[Tj]
set Gj[PyV]=$A99
endif
set EM=EM-1
return PyV
endfunction
function PYV takes string PzV returns integer
local integer PZV
set ZM[EM]=PzV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set PZV=Yj
set Gj[PZV]=$A91
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 738")
set PZV=0
endif
else
set Tj=Tj-1
set PZV=Rj[Tj]
set Gj[PZV]=$A91
endif
set EM=EM-1
return PZV
endfunction
function P_V takes string P0V returns integer
local integer P1V
set ZM[EM]=P0V
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set P1V=Yj
set Gj[P1V]=$B81
else
call Cdv("Out of memory: Could not create IBuiltin_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 148")
set P1V=0
endif
else
set Tj=Tj-1
set P1V=Rj[Tj]
set Gj[P1V]=$B81
endif
set EM=EM-1
return P1V
endfunction
function P2V takes string P3V returns integer
local integer P4V
set ZM[EM]=P3V
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set P4V=Yj
set Gj[P4V]=$B3B
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 294")
set P4V=0
endif
else
set Tj=Tj-1
set P4V=Rj[Tj]
set Gj[P4V]=$B3B
endif
set EM=EM-1
return P4V
endfunction
function P5V takes string P6V returns integer
local integer P7V
set ZM[EM]=P6V
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set P7V=Yj
set Gj[P7V]=$A49
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 93")
set P7V=0
endif
else
set Tj=Tj-1
set P7V=Rj[Tj]
set Gj[P7V]=$A49
endif
set EM=EM-1
return P7V
endfunction
function P8V takes string P9V returns integer
local integer qvV
set ZM[EM]=P9V
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set qvV=Yj
set Gj[qvV]=$A32
else
call Cdv("Out of memory: Could not create IBuiltin_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 231")
set qvV=0
endif
else
set Tj=Tj-1
set qvV=Rj[Tj]
set Gj[qvV]=$A32
endif
set EM=EM-1
return qvV
endfunction
function qeV takes string qxV returns integer
local integer qoV
set ZM[EM]=qxV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set qoV=Yj
set Gj[qoV]=$A67
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 352")
set qoV=0
endif
else
set Tj=Tj-1
set qoV=Rj[Tj]
set Gj[qoV]=$A67
endif
set EM=EM-1
return qoV
endfunction
function qrV takes string qiV returns integer
local integer qaV
set ZM[EM]=qiV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set qaV=Yj
set Gj[qaV]=$B48
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 407")
set qaV=0
endif
else
set Tj=Tj-1
set qaV=Rj[Tj]
set Gj[qaV]=$B48
endif
set EM=EM-1
return qaV
endfunction
function qnV takes string qVV returns integer
local integer qEV
set ZM[EM]=qVV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set qEV=Yj
set Gj[qEV]=$A78
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 547")
set qEV=0
endif
else
set Tj=Tj-1
set qEV=Rj[Tj]
set Gj[qEV]=$A78
endif
set EM=EM-1
return qEV
endfunction
function qXV takes string qOV returns integer
local integer qRV
set ZM[EM]=qOV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set qRV=Yj
set Gj[qRV]=$B58
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 624")
set qRV=0
endif
else
set Tj=Tj-1
set qRV=Rj[Tj]
set Gj[qRV]=$B58
endif
set EM=EM-1
return qRV
endfunction
function qIV takes string qAV returns integer
local integer qNV
set ZM[EM]=qAV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set qNV=Yj
set Gj[qNV]=$A89
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 678")
set qNV=0
endif
else
set Tj=Tj-1
set qNV=Rj[Tj]
set Gj[qNV]=$A89
endif
set EM=EM-1
return qNV
endfunction
function qbV takes string qBV returns integer
local integer qcV
set ZM[EM]=qBV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set qcV=Yj
set Gj[qcV]=$B65
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 792")
set qcV=0
endif
else
set Tj=Tj-1
set qcV=Rj[Tj]
set Gj[qcV]=$B65
endif
set EM=EM-1
return qcV
endfunction
function qCV takes string qdV returns integer
local integer qDV
set ZM[EM]=qdV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set qDV=Yj
set Gj[qDV]=$A8E
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 719")
set qDV=0
endif
else
set Tj=Tj-1
set qDV=Rj[Tj]
set Gj[qDV]=$A8E
endif
set EM=EM-1
return qDV
endfunction
function qfV takes string qFV returns integer
local integer qgV
set ZM[EM]=qFV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set qgV=Yj
set Gj[qgV]=$B33
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 129")
set qgV=0
endif
else
set Tj=Tj-1
set qgV=Rj[Tj]
set Gj[qgV]=$B33
endif
set EM=EM-1
return qgV
endfunction
function qGV takes string qhV returns integer
local integer qHV
set ZM[EM]=qhV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set qHV=Yj
set Gj[qHV]=$B84
else
call Cdv("Out of memory: Could not create IBuiltin_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 277")
set qHV=0
endif
else
set Tj=Tj-1
set qHV=Rj[Tj]
set Gj[qHV]=$B84
endif
set EM=EM-1
return qHV
endfunction
function qjV takes string qJV returns integer
local integer qkV
set ZM[EM]=qJV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set qkV=Yj
set Gj[qkV]=$A46
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 75")
set qkV=0
endif
else
set Tj=Tj-1
set qkV=Rj[Tj]
set Gj[qkV]=$A46
endif
set EM=EM-1
return qkV
endfunction
function qKV takes string qlV returns integer
local integer qLV
set ZM[EM]=qlV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set qLV=Yj
set Gj[qLV]=$A64
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 334")
set qLV=0
endif
else
set Tj=Tj-1
set qLV=Rj[Tj]
set Gj[qLV]=$A64
endif
set EM=EM-1
return qLV
endfunction
function qmV takes string qMV returns integer
local integer qpV
set ZM[EM]=qMV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set qpV=Yj
set Gj[qpV]=$B46
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 388")
set qpV=0
endif
else
set Tj=Tj-1
set qpV=Rj[Tj]
set Gj[qpV]=$B46
endif
set EM=EM-1
return qpV
endfunction
function qPV takes string qqV returns integer
local integer qQV
set ZM[EM]=qqV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set qQV=Yj
set Gj[qQV]=$A75
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 460")
set qQV=0
endif
else
set Tj=Tj-1
set qQV=Rj[Tj]
set Gj[qQV]=$A75
endif
set EM=EM-1
return qQV
endfunction
function qsV takes string qSV returns integer
local integer qtV
set ZM[EM]=qSV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set qtV=Yj
set Gj[qtV]=$B55
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 591")
set qtV=0
endif
else
set Tj=Tj-1
set qtV=Rj[Tj]
set Gj[qtV]=$B55
endif
set EM=EM-1
return qtV
endfunction
function qTV takes string quV returns integer
local integer qUV
set ZM[EM]=quV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set qUV=Yj
set Gj[qUV]=$A86
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 659")
set qUV=0
endif
else
set Tj=Tj-1
set qUV=Rj[Tj]
set Gj[qUV]=$A86
endif
set EM=EM-1
return qUV
endfunction
function qwV takes string qWV returns integer
local integer qyV
set ZM[EM]=qWV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set qyV=Yj
set Gj[qyV]=$B62
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 775")
set qyV=0
endif
else
set Tj=Tj-1
set qyV=Rj[Tj]
set Gj[qyV]=$B62
endif
set EM=EM-1
return qyV
endfunction
function qYV takes string qzV returns integer
local integer qZV
set ZM[EM]=qzV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set qZV=Yj
set Gj[qZV]=$B93
else
call Cdv("Out of memory: Could not create IBuiltin_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 742")
set qZV=0
endif
else
set Tj=Tj-1
set qZV=Rj[Tj]
set Gj[qZV]=$B93
endif
set EM=EM-1
return qZV
endfunction
function q_V takes string q0V returns integer
local integer q1V
set ZM[EM]=q0V
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set q1V=Yj
set Gj[q1V]=$A52
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 150")
set q1V=0
endif
else
set Tj=Tj-1
set q1V=Rj[Tj]
set Gj[q1V]=$A52
endif
set EM=EM-1
return q1V
endfunction
function q2V takes string q3V returns integer
local integer q4V
set ZM[EM]=q3V
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set q4V=Yj
set Gj[q4V]=$A5F
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 297")
set q4V=0
endif
else
set Tj=Tj-1
set q4V=Rj[Tj]
set Gj[q4V]=$A5F
endif
set EM=EM-1
return q4V
endfunction
function q5V takes string q6V returns integer
local integer q7V
set ZM[EM]=q6V
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set q7V=Yj
set Gj[q7V]=$B30
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 96")
set q7V=0
endif
else
set Tj=Tj-1
set q7V=Rj[Tj]
set Gj[q7V]=$B30
endif
set EM=EM-1
return q7V
endfunction
function q8V takes string q9V returns integer
local integer QvV
set ZM[EM]=q9V
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set QvV=Yj
set Gj[QvV]=$B11
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 234")
set QvV=0
endif
else
set Tj=Tj-1
set QvV=Rj[Tj]
set Gj[QvV]=$B11
endif
set EM=EM-1
return QvV
endfunction
function QeV takes string QxV returns integer
local integer QoV
set ZM[EM]=QxV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set QoV=Yj
set Gj[QoV]=$B41
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 355")
set QoV=0
endif
else
set Tj=Tj-1
set QoV=Rj[Tj]
set Gj[QoV]=$B41
endif
set EM=EM-1
return QoV
endfunction
function QrV takes string QiV returns integer
local integer QaV
set ZM[EM]=QiV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set QaV=Yj
set Gj[QaV]=$A70
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 409")
set QaV=0
endif
else
set Tj=Tj-1
set QaV=Rj[Tj]
set Gj[QaV]=$A70
endif
set EM=EM-1
return QaV
endfunction
function QnV takes string QVV returns integer
local integer QEV
set ZM[EM]=QVV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set QEV=Yj
set Gj[QEV]=$B51
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 550")
set QEV=0
endif
else
set Tj=Tj-1
set QEV=Rj[Tj]
set Gj[QEV]=$B51
endif
set EM=EM-1
return QEV
endfunction
function QXV takes string QOV returns integer
local integer QRV
set ZM[EM]=QOV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set QRV=Yj
set Gj[QRV]=$A81
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 626")
set QRV=0
endif
else
set Tj=Tj-1
set QRV=Rj[Tj]
set Gj[QRV]=$A81
endif
set EM=EM-1
return QRV
endfunction
function QIV takes string QAV returns integer
local integer QNV
set ZM[EM]=QAV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set QNV=Yj
set Gj[QNV]=$B5E
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 682")
set QNV=0
endif
else
set Tj=Tj-1
set QNV=Rj[Tj]
set Gj[QNV]=$B5E
endif
set EM=EM-1
return QNV
endfunction
function QbV takes string QBV returns integer
local integer QcV
set ZM[EM]=QBV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set QcV=Yj
set Gj[QcV]=$A9A
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 795")
set QcV=0
endif
else
set Tj=Tj-1
set QcV=Rj[Tj]
set Gj[QcV]=$A9A
endif
set EM=EM-1
return QcV
endfunction
function QCV takes string QdV returns integer
local integer QDV
set ZM[EM]=QdV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set QDV=Yj
set Gj[QDV]=$B90
else
call Cdv("Out of memory: Could not create IBuiltin_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 725")
set QDV=0
endif
else
set Tj=Tj-1
set QDV=Rj[Tj]
set Gj[QDV]=$B90
endif
set EM=EM-1
return QDV
endfunction
function QfV takes string QFV returns integer
local integer QgV
set ZM[EM]=QFV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set QgV=Yj
set Gj[QgV]=$A4F
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 132")
set QgV=0
endif
else
set Tj=Tj-1
set QgV=Rj[Tj]
set Gj[QgV]=$A4F
endif
set EM=EM-1
return QgV
endfunction
function QGV takes string QhV returns integer
local integer QHV
set ZM[EM]=QhV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set QHV=Yj
set Gj[QHV]=$A5C
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 279")
set QHV=0
endif
else
set Tj=Tj-1
set QHV=Rj[Tj]
set Gj[QHV]=$A5C
endif
set EM=EM-1
return QHV
endfunction
function QjV takes string QJV returns integer
local integer QkV
set ZM[EM]=QJV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set QkV=Yj
set Gj[QkV]=$B2F
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 79")
set QkV=0
endif
else
set Tj=Tj-1
set QkV=Rj[Tj]
set Gj[QkV]=$B2F
endif
set EM=EM-1
return QkV
endfunction
function QKV takes string QlV returns integer
local integer QLV
set ZM[EM]=QlV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set QLV=Yj
set Gj[QLV]=$B26
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_setProvidingEnumUnit_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 205")
set QLV=0
endif
else
set Tj=Tj-1
set QLV=Rj[Tj]
set Gj[QLV]=$B26
endif
set EM=EM-1
return QLV
endfunction
function QmV takes string QMV returns integer
local integer QpV
set ZM[EM]=QMV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set QpV=Yj
set Gj[QpV]=$B3E
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 338")
set QpV=0
endif
else
set Tj=Tj-1
set QpV=Rj[Tj]
set Gj[QpV]=$B3E
endif
set EM=EM-1
return QpV
endfunction
function QPV takes string QqV returns integer
local integer QQV
set ZM[EM]=QqV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set QQV=Yj
set Gj[QQV]=$A6D
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 391")
set QQV=0
endif
else
set Tj=Tj-1
set QQV=Rj[Tj]
set Gj[QQV]=$A6D
endif
set EM=EM-1
return QQV
endfunction
function QsV takes string QSV returns integer
local integer QtV
set ZM[EM]=QSV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set QtV=Yj
set Gj[QtV]=$B4E
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 487")
set QtV=0
endif
else
set Tj=Tj-1
set QtV=Rj[Tj]
set Gj[QtV]=$B4E
endif
set EM=EM-1
return QtV
endfunction
function QTV takes string QuV returns integer
local integer QUV
set ZM[EM]=QuV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set QUV=Yj
set Gj[QUV]=$A7E
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 593")
set QUV=0
endif
else
set Tj=Tj-1
set QUV=Rj[Tj]
set Gj[QUV]=$A7E
endif
set EM=EM-1
return QUV
endfunction
function QwV takes string QWV returns integer
local integer QyV
set ZM[EM]=QWV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set QyV=Yj
set Gj[QyV]=$B5C
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 662")
set QyV=0
endif
else
set Tj=Tj-1
set QyV=Rj[Tj]
set Gj[QyV]=$B5C
endif
set EM=EM-1
return QyV
endfunction
function QYV takes string QzV returns integer
local integer QZV
set ZM[EM]=QzV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set QZV=Yj
set Gj[QZV]=$A97
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 777")
set QZV=0
endif
else
set Tj=Tj-1
set QZV=Rj[Tj]
set Gj[QZV]=$A97
endif
set EM=EM-1
return QZV
endfunction
function Q_V takes string Q0V returns integer
local integer Q1V
set ZM[EM]=Q0V
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set Q1V=Yj
set Gj[Q1V]=$A8D
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 708")
set Q1V=0
endif
else
set Tj=Tj-1
set Q1V=Rj[Tj]
set Gj[Q1V]=$A8D
endif
set EM=EM-1
return Q1V
endfunction
function Q2V takes string Q3V returns integer
local integer Q4V
set ZM[EM]=Q3V
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set Q4V=Yj
set Gj[Q4V]=$B7F
else
call Cdv("Out of memory: Could not create IBuiltin_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 124")
set Q4V=0
endif
else
set Tj=Tj-1
set Q4V=Rj[Tj]
set Gj[Q4V]=$B7F
endif
set EM=EM-1
return Q4V
endfunction
function Q5V takes string Q6V returns integer
local integer Q7V
set ZM[EM]=Q6V
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set Q7V=Yj
set Gj[Q7V]=$B39
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 270")
set Q7V=0
endif
else
set Tj=Tj-1
set Q7V=Rj[Tj]
set Gj[Q7V]=$B39
endif
set EM=EM-1
return Q7V
endfunction
function Q8V takes string Q9V returns integer
local integer svV
set ZM[EM]=Q9V
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set svV=Yj
set Gj[svV]=$A45
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 64")
set svV=0
endif
else
set Tj=Tj-1
set svV=Rj[Tj]
set Gj[svV]=$A45
endif
set EM=EM-1
return svV
endfunction
function seV takes string sxV returns integer
local integer soV
set ZM[EM]=sxV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set soV=Yj
set Gj[soV]=$A56
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 177")
set soV=0
endif
else
set Tj=Tj-1
set soV=Rj[Tj]
set Gj[soV]=$A56
endif
set EM=EM-1
return soV
endfunction
function srV takes string siV returns integer
local integer saV
set ZM[EM]=siV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set saV=Yj
set Gj[saV]=$A63
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 326")
set saV=0
endif
else
set Tj=Tj-1
set saV=Rj[Tj]
set Gj[saV]=$A63
endif
set EM=EM-1
return saV
endfunction
function snV takes string sVV returns integer
local integer sEV
set ZM[EM]=sVV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set sEV=Yj
set Gj[sEV]=$B45
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 381")
set sEV=0
endif
else
set Tj=Tj-1
set sEV=Rj[Tj]
set Gj[sEV]=$B45
endif
set EM=EM-1
return sEV
endfunction
function sXV takes string sOV returns integer
local integer sRV
set ZM[EM]=sOV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set sRV=Yj
set Gj[sRV]=$A74
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 455")
set sRV=0
endif
else
set Tj=Tj-1
set sRV=Rj[Tj]
set Gj[sRV]=$A74
endif
set EM=EM-1
return sRV
endfunction
function sIV takes string sAV returns integer
local integer sNV
set ZM[EM]=sAV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set sNV=Yj
set Gj[sNV]=$B54
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 584")
set sNV=0
endif
else
set Tj=Tj-1
set sNV=Rj[Tj]
set Gj[sNV]=$B54
endif
set EM=EM-1
return sNV
endfunction
function sbV takes string sBV returns integer
local integer scV
set ZM[EM]=sBV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set scV=Yj
set Gj[scV]=$A85
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 653")
set scV=0
endif
else
set Tj=Tj-1
set scV=Rj[Tj]
set Gj[scV]=$A85
endif
set EM=EM-1
return scV
endfunction
function sCV takes string sdV returns integer
local integer sDV
set ZM[EM]=sdV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set sDV=Yj
set Gj[sDV]=$B61
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 770")
set sDV=0
endif
else
set Tj=Tj-1
set sDV=Rj[Tj]
set Gj[sDV]=$B61
endif
set EM=EM-1
return sDV
endfunction
function sfV takes string sFV returns integer
local integer sgV
set ZM[EM]=sFV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set sgV=Yj
set Gj[sgV]=$B5F
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 703")
set sgV=0
endif
else
set Tj=Tj-1
set sgV=Rj[Tj]
set Gj[sgV]=$B5F
endif
set EM=EM-1
return sgV
endfunction
function sGV takes string shV returns integer
local integer sHV
set ZM[EM]=shV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set sHV=Yj
set Gj[sHV]=$A4D
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 120")
set sHV=0
endif
else
set Tj=Tj-1
set sHV=Rj[Tj]
set Gj[sHV]=$A4D
endif
set EM=EM-1
return sHV
endfunction
function sjV takes string sJV returns integer
local integer skV
set ZM[EM]=sJV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set skV=Yj
set Gj[skV]=$A5A
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 266")
set skV=0
endif
else
set Tj=Tj-1
set skV=Rj[Tj]
set Gj[skV]=$A5A
endif
set EM=EM-1
return skV
endfunction
function sKV takes string slV returns integer
local integer sLV
set ZM[EM]=slV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set sLV=Yj
set Gj[sLV]=$B2D
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 57")
set sLV=0
endif
else
set Tj=Tj-1
set sLV=Rj[Tj]
set Gj[sLV]=$B2D
endif
set EM=EM-1
return sLV
endfunction
function smV takes string sMV returns integer
local integer spV
set ZM[EM]=sMV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set spV=Yj
set Gj[spV]=$B82
else
call Cdv("Out of memory: Could not create IBuiltin_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 175")
set spV=0
endif
else
set Tj=Tj-1
set spV=Rj[Tj]
set Gj[spV]=$B82
endif
set EM=EM-1
return spV
endfunction
function sPV takes string sqV returns integer
local integer sQV
set ZM[EM]=sqV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set sQV=Yj
set Gj[sQV]=$B88
else
call Cdv("Out of memory: Could not create IBuiltin_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 323")
set sQV=0
endif
else
set Tj=Tj-1
set sQV=Rj[Tj]
set Gj[sQV]=$B88
endif
set EM=EM-1
return sQV
endfunction
function ssV takes string sSV returns integer
local integer stV
set ZM[EM]=sSV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set stV=Yj
set Gj[stV]=$A6B
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 377")
set stV=0
endif
else
set Tj=Tj-1
set stV=Rj[Tj]
set Gj[stV]=$A6B
endif
set EM=EM-1
return stV
endfunction
function sTV takes string suV returns integer
local integer sUV
set ZM[EM]=suV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set sUV=Yj
set Gj[sUV]=$B4C
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 453")
set sUV=0
endif
else
set Tj=Tj-1
set sUV=Rj[Tj]
set Gj[sUV]=$B4C
endif
set EM=EM-1
return sUV
endfunction
function swV takes string sWV returns integer
local integer syV
set ZM[EM]=sWV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set syV=Yj
set Gj[syV]=$A7C
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 581")
set syV=0
endif
else
set Tj=Tj-1
set syV=Rj[Tj]
set Gj[syV]=$A7C
endif
set EM=EM-1
return syV
endfunction
function sYV takes string szV returns integer
local integer sZV
set ZM[EM]=szV
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set sZV=Yj
set Gj[sZV]=$B5B
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 650")
set sZV=0
endif
else
set Tj=Tj-1
set sZV=Rj[Tj]
set Gj[sZV]=$B5B
endif
set EM=EM-1
return sZV
endfunction
function s_V takes string s0V returns integer
local integer s1V
set ZM[EM]=s0V
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set s1V=Yj
set Gj[s1V]=$A95
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 766")
set s1V=0
endif
else
set Tj=Tj-1
set s1V=Rj[Tj]
set Gj[s1V]=$A95
endif
set EM=EM-1
return s1V
endfunction
function s2V takes string s3V returns boolean
local integer s4V
local integer s5V
local integer s6V
local integer s7V
local integer s8V
local integer s9V
local integer SvV
local integer SeV
local integer SxV
local integer SoV
local integer SrV
local integer SiV
local integer SaV
local integer SnV
local integer SVV
local integer SEV
local integer SXV
local integer SOV
local integer SRV
local integer SIV
local integer SAV
local integer SNV
local integer SbV
local integer SBV
local integer ScV
local integer SCV
local integer SdV
local integer SDV
local integer SfV
local integer SFV
local integer SgV
local integer SGV
local integer ShV
local integer SHV
local integer SjV
local integer SJV
local integer SkV
local integer SKV
local integer SlV
local integer SLV
local integer SmV
local integer SMV
local integer SpV
local integer SPV
local integer SqV
local integer SQV
local integer SsV
local integer SSV
local integer StV
local integer STV
local integer SuV
local integer SUV
local integer SwV
local integer SWV
local integer SyV
local integer SYV
local integer SzV
local integer SZV
local integer S_V
local integer S0V
local integer S1V
local integer S2V
local integer S3V
local integer S4V
local integer S5V
local integer S6V
local integer S7V
local integer S8V
local integer S9V
local integer tvV
local integer teV
local integer txV
local integer toV
local integer trV
local integer tiV
local integer taV
local integer tnV
local integer tVV
local integer tEV
local integer tXV
local integer tOV
local integer tRV
local integer tIV
local integer tAV
local integer tNV
local integer tbV
local integer tBV
local integer tcV
local integer tCV
local integer tdV
local integer tDV
local integer tfV
local integer tFV
local integer tgV
local integer tGV
local integer thV
local integer tHV
local integer tjV
local integer tJV
local integer tkV
local integer tKV
local integer tlV
local integer tLV
local integer tmV
local integer tMV
local integer tpV
local integer tPV
local integer tqV
local integer tQV
local integer tsV
local integer tSV
local integer ttV
local integer tTV
local integer tuV
local integer tUV
local integer twV
local integer tWV
local integer tyV
local integer tYV
local integer tzV
local integer tZV
local integer t_V
local integer t0V
local integer t1V
local integer t2V
local integer t3V
local integer t4V
local integer t5V
local integer t6V
local integer t7V
local integer t8V
local integer t9V
local integer TvV
local integer TeV
local integer TxV
local integer ToV
local integer TrV
local integer TiV
local integer TaV
local integer TnV
local integer TVV
local integer TEV
local integer TXV
local integer TOV
local integer TRV
local integer TIV
local integer TAV
local integer TNV
local integer TbV
local integer TBV
local integer TcV
local integer TCV
local integer TdV
local integer TDV
local integer TfV
local integer TFV
local integer TgV
local integer TGV
local integer ThV
local integer THV
local integer TjV
local integer TJV
local integer TkV
local integer TKV
local integer TlV
local integer TLV
local integer TmV
local integer TMV
local integer TpV
local integer TPV
local integer TqV
local integer TQV
local integer TsV
local integer TSV
local integer TtV
local integer TTV
local integer TuV
local integer TUV
local integer TwV
local integer TWV
local integer TyV
local integer TYV
local integer TzV
local integer TZV
local integer T_V
local integer T0V
local integer T1V
local integer T2V
local integer T3V
local integer T4V
local integer T5V
local integer T6V
local integer T7V
local integer T8V
local integer T9V
local integer uvV
local integer ueV
local integer uxV
local integer uoV
local integer urV
local integer uiV
local integer uaV
local integer unV
local integer uVV
local integer uEV
local integer uXV
local integer uOV
local integer uRV
local integer uIV
local integer uAV
local integer uNV
local integer ubV
local integer uBV
local integer ucV
local integer uCV
local integer udV
local integer uDV
local integer ufV
local integer uFV
local integer ugV
local integer uGV
local integer uhV
local integer uHV
local integer ujV
local integer uJV
local integer ukV
local integer uKV
local integer ulV
local integer uLV
local integer umV
local integer uMV
local integer upV
local integer uPV
local integer uqV
local integer uQV
local integer usV
local integer uSV
local integer utV
local integer uTV
local integer uuV
local integer uUV
local integer uwV
local integer uWV
local integer uyV
local integer uYV
local integer uzV
local integer uZV
local integer u_V
local integer u0V
local integer u1V
local integer u2V
local integer u3V
local integer u4V
local integer u5V
local integer u6V
local integer u7V
local integer u8V
local integer u9V
local integer UvV
local integer UeV
local integer UxV
local integer UoV
local integer UrV
local integer UiV
local integer UaV
local integer UnV
local integer UVV
local integer UEV
local integer UXV
local integer UOV
local integer URV
local integer UIV
local integer UAV
local integer UNV
local integer UbV
local integer UBV
local integer UcV
local integer UCV
local integer UdV
local integer UDV
local integer UfV
local integer UFV
local integer UgV
local integer UGV
local integer UhV
local integer UHV
local integer UjV
local integer UJV
local integer UkV
local integer UKV
local integer UlV
local integer ULV
local integer UmV
local integer UMV
local integer UpV
local integer UPV
local integer UqV
local integer UQV
local integer UsV
local integer USV
local integer UtV
local integer UTV
local integer UuV
local integer UUV
local integer UwV
local integer UWV
local integer UyV
local integer UYV
local integer UzV
local integer UZV
local integer U_V
local integer U0V
local integer U1V
local integer U2V
local integer U3V
local integer U4V
local integer U5V
local integer U6V
local integer U7V
local integer U8V
local integer U9V
local integer wvV
local integer weV
local integer wxV
local integer woV
local integer wrV
local integer wiV
local integer waV
local integer wnV
local integer wVV
local integer wEV
local integer wXV
local integer wOV
local integer wRV
local integer wIV
local integer wAV
local integer wNV
local integer wbV
local integer wBV
local integer wcV
local integer wCV
local integer wdV
local integer wDV
local integer wfV
local integer wFV
local integer wgV
local integer wGV
local integer whV
local integer wHV
local integer wjV
local integer wJV
local integer wkV
local integer wKV
local integer wlV
local integer wLV
local integer wmV
local integer wMV
local integer wpV
local integer wPV
local integer wqV
local integer wQV
local integer wsV
local integer wSV
local integer wtV
local integer wTV
local integer wuV
local integer wUV
local integer wwV
local integer wWV
local integer wyV
local integer wYV
local integer wzV
local integer wZV
local integer w_V
local integer w0V
local integer w1V
local integer w2V
local integer w3V
local integer w4V
local integer w5V
local integer w6V
local integer w7V
local integer w8V
local integer w9V
local integer WvV
local integer WeV
local integer WxV
local integer WoV
local integer WrV
local integer WiV
local integer WaV
local integer WnV
local integer WVV
local integer WEV
local integer WXV
local integer WOV
local integer WRV
local integer WIV
local integer WAV
local integer WNV
local integer WbV
local integer WBV
local integer WcV
local integer WCV
local integer WdV
local integer WDV
local integer WfV
local integer WFV
local integer WgV
local integer WGV
local integer WhV
local integer WHV
local integer WjV
local integer WJV
local integer WkV
local integer WKV
local integer WlV
local integer WLV
local integer WmV
local integer WMV
local integer WpV
local integer WPV
local integer WqV
local integer WQV
local integer WsV
local integer WSV
local integer WtV
local integer WTV
local integer WuV
local integer WUV
local integer WwV
local integer WWV
local integer WyV
local integer WYV
local integer WzV
local integer WZV
local integer W_V
local integer W0V
local integer W1V
local integer W2V
local integer W3V
local integer W4V
local integer W5V
local integer W6V
local integer W7V
local integer W8V
local integer W9V
local integer yvV
local integer yeV
local integer yxV
local integer yoV
local integer yrV
local integer yiV
local integer yaV
local integer ynV
local integer yVV
local integer yEV
local integer yXV
local integer yOV
local integer yRV
local integer yIV
local integer yAV
local integer yNV
local integer ybV
local integer yBV
local integer ycV
local integer yCV
local integer ydV
local integer yDV
local integer yfV
local integer yFV
local integer ygV
local integer yGV
local integer yhV
local integer yHV
local integer yjV
local integer yJV
local integer ykV
local integer yKV
local integer ylV
local integer yLV
local integer ymV
local integer yMV
local integer ypV
local integer yPV
local integer yqV
local integer yQV
local integer ysV
local integer ySV
local integer ytV
local integer yTV
local integer yuV
local integer yUV
local integer ywV
local integer yWV
local integer yyV
local integer yYV
local integer yzV
local integer yZV
local integer y_V
local integer y0V
local integer y1V
local integer y2V
local integer y3V
local integer y4V
local integer y5V
local integer y6V
local integer y7V
local integer y8V
local integer y9V
local integer YvV
local integer YeV
local integer YxV
local integer YoV
local integer YrV
local integer YiV
local integer YaV
local integer YnV
local integer YVV
local integer YEV
local integer YXV
local integer YOV
local integer YRV
local integer YIV
local integer YAV
local integer YNV
local integer YbV
local integer YBV
local integer YcV
local integer YCV
local integer YdV
local integer YDV
local integer YfV
local integer YFV
local integer YgV
local integer YGV
local integer YhV
local integer YHV
local integer YjV
local integer YJV
local integer YkV
local integer YKV
local integer YlV
local integer YLV
local integer YmV
local integer YMV
local integer YpV
local integer YPV
local integer YqV
local integer YQV
local integer YsV
local integer YSV
local integer YtV
local integer YTV
local integer YuV
local integer YUV
local integer YwV
local integer YWV
local integer YyV
local integer YYV
local integer YzV
local integer YZV
local integer Y_V
local integer Y0V
local integer Y1V
local integer Y2V
local integer Y3V
local integer Y4V
local integer Y5V
local integer Y6V
local integer Y7V
local integer Y8V
local integer Y9V
local integer zvV
local integer zeV
local integer zxV
local integer zoV
local integer zrV
local integer ziV
local integer zaV
local integer znV
local integer zVV
local integer zEV
local integer zXV
local integer zOV
local integer zRV
local integer zIV
local integer zAV
local integer zNV
local integer zbV
local integer zBV
local integer zcV
local integer zCV
local integer zdV
local integer zDV
local integer zfV
local integer zFV
local integer zgV
local integer zGV
local integer zhV
local integer zHV
local integer zjV
local integer zJV
local integer zkV
local integer zKV
local integer zlV
local integer zLV
local integer zmV
local integer zMV
local integer zpV
local integer zPV
local integer zqV
local integer zQV
local integer zsV
local integer zSV
local integer ztV
local integer zTV
set ZM[EM]=s3V
set EM=EM+1
set s4V=ljV("when calling alloc_IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 19")
set s5V=OPo(s4V,"when calling new_BuiltinData in ScmdUnitBuiltins, line 19")
call Rxo(s5V,OFo(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 34")
set s6V=s5V
call LWV(s6V,"when calling setRequiringEnumUnit in ScmdUnitBuiltins, line 34")
set s9V=ILo(s6V,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 19")
set YBV=s9V
set s7V=mBV("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 34")
set s8V=OPo(s7V,"when calling new_BuiltinData in ScmdUnitBuiltins, line 34")
call FRa(s8V,e4V(),OFo(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 49")
call IFo(YBV,s8V,"when calling addOverload in ScmdUnitBuiltins, line 34")
call Foa(s9V,"setowner","when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 19")
set SvV=K2V("when calling alloc_IBuiltin_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 50")
set SeV=OPo(SvV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 50")
call LWV(SeV,"when calling setRequiringEnumUnit in ScmdUnitBuiltins, line 53")
set SrV=ILo(SeV,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 50")
set YcV=SrV
set SxV=MaV("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 53")
set SoV=OPo(SxV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 53")
call Rxo(SoV,e4V(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 56")
call IFo(YcV,SoV,"when calling addOverload in ScmdUnitBuiltins, line 53")
call Foa(SrV,"getowner","when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 50")
set SiV=sKV("when calling alloc_IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 57")
set SaV=OPo(SiV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 57")
call Rxo(SaV,OFo(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 64")
set SnV=SaV
call LWV(SnV,"when calling setRequiringEnumUnit in ScmdUnitBuiltins, line 64")
set SXV=ILo(SnV,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 57")
set YCV=SXV
set SVV=Q8V("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 64")
set SEV=OPo(SVV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 64")
call FRa(SEV,e4V(),OFo(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 71")
call IFo(YCV,SEV,"when calling addOverload in ScmdUnitBuiltins, line 64")
call Foa(SXV,"setcolor","when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 57")
set SOV=pfV("when calling alloc_IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 72")
set SRV=OPo(SOV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 72")
call Rxo(SRV,d_V(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 75")
set SIV=SRV
call LWV(SIV,"when calling setRequiringEnumUnit in ScmdUnitBuiltins, line 75")
set SbV=ILo(SIV,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 72")
set YdV=SbV
set SAV=qjV("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 75")
set SNV=OPo(SAV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 75")
call FRa(SNV,e4V(),d_V(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 78")
call IFo(YdV,SNV,"when calling addOverload in ScmdUnitBuiltins, line 75")
call Foa(SbV,"setpathing","when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 72")
set SBV=QjV("when calling alloc_IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 79")
set ScV=OPo(SBV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 79")
call Rxo(ScV,gQV(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 82")
set SCV=ScV
call LWV(SCV,"when calling setRequiringEnumUnit in ScmdUnitBuiltins, line 82")
set SfV=ILo(SCV,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 79")
set YDV=SfV
set SdV=M2V("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 82")
set SDV=OPo(SdV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 82")
call FRa(SDV,e4V(),gQV(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 85")
call IFo(YDV,SDV,"when calling addOverload in ScmdUnitBuiltins, line 82")
call Foa(SfV,"setpropwindow","when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 79")
set SFV=p2V("when calling alloc_IBuiltin_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 86")
set SgV=OPo(SFV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 86")
call LWV(SgV,"when calling setRequiringEnumUnit in ScmdUnitBuiltins, line 88")
set SHV=ILo(SgV,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 86")
set YfV=SHV
set SGV=MfV("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 88")
set ShV=OPo(SGV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 88")
call Rxo(ShV,e4V(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 90")
call IFo(YfV,ShV,"when calling addOverload in ScmdUnitBuiltins, line 88")
call Foa(SHV,"getpropwindow","when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 86")
set SjV=PGV("when calling alloc_IBuiltin_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 91")
set SJV=OPo(SjV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 91")
call LWV(SJV,"when calling setRequiringEnumUnit in ScmdUnitBuiltins, line 93")
set SlV=ILo(SJV,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 91")
set YFV=SlV
set SkV=P5V("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 93")
set SKV=OPo(SkV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 93")
call Rxo(SKV,e4V(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 95")
call IFo(YFV,SKV,"when calling addOverload in ScmdUnitBuiltins, line 93")
call Foa(SlV,"getdefaultpropwindow","when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 91")
set SLV=q5V("when calling alloc_IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 96")
set SmV=OPo(SLV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 96")
call Rxo(SmV,gQV(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 99")
set SMV=SmV
call LWV(SMV,"when calling setRequiringEnumUnit in ScmdUnitBuiltins, line 99")
set SqV=ILo(SMV,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 96")
set YgV=SqV
set SpV=lTV("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 99")
set SPV=OPo(SpV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 99")
call FRa(SPV,e4V(),gQV(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 102")
call IFo(YgV,SPV,"when calling addOverload in ScmdUnitBuiltins, line 99")
call g_V(SqV,fNV(KCv("setscale","when calling stringToIndex in ScmdUnitBuiltins, line 102"),KCv("setsc","when calling stringToIndex in ScmdUnitBuiltins, line 102"),"when calling asList in ScmdUnitBuiltins, line 102"),"when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 96")
set SQV=LIV("when calling alloc_IBuiltin_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 103")
set SsV=OPo(SQV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 103")
call LWV(SsV,"when calling setRequiringEnumUnit in ScmdUnitBuiltins, line 106")
set STV=ILo(SsV,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 103")
set YGV=STV
set SSV=lnV("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 106")
set StV=OPo(SSV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 106")
call Rxo(StV,e4V(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 109")
call IFo(YGV,StV,"when calling addOverload in ScmdUnitBuiltins, line 106")
call Foa(STV,"getscale","when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 103")
set SuV=L6V("when calling alloc_IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 110")
set SUV=OPo(SuV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 110")
call glV(SUV,f3a(),f3a(),f3a(),f3a(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 113")
set SwV=SUV
call LWV(SwV,"when calling setRequiringEnumUnit in ScmdUnitBuiltins, line 113")
set SYV=ILo(SwV,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 110")
set YhV=SYV
set SWV=KmV("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 113")
set SyV=OPo(SWV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 113")
call mKV(SyV,e4V(),f3a(),f3a(),f3a(),f3a(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 116")
call IFo(YhV,SyV,"when calling addOverload in ScmdUnitBuiltins, line 113")
call Foa(SYV,"setvertexcolor","when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 110")
set SzV=myV("when calling alloc_IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 117")
set SZV=OPo(SzV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 117")
call Rxo(SZV,gQV(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 120")
set S_V=SZV
call LWV(S_V,"when calling setRequiringEnumUnit in ScmdUnitBuiltins, line 120")
set S2V=ILo(S_V,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 117")
set YHV=S2V
set S0V=sGV("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 120")
set S1V=OPo(S0V,"when calling new_BuiltinData in ScmdUnitBuiltins, line 120")
call FRa(S1V,e4V(),gQV(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 123")
call IFo(YHV,S1V,"when calling addOverload in ScmdUnitBuiltins, line 120")
call g_V(S2V,fNV(KCv("setmovespeed","when calling stringToIndex in ScmdUnitBuiltins, line 123"),KCv("setmvspd","when calling stringToIndex in ScmdUnitBuiltins, line 123"),"when calling asList in ScmdUnitBuiltins, line 123"),"when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 117")
set S3V=Q2V("when calling alloc_IBuiltin_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 124")
set S4V=OPo(S3V,"when calling new_BuiltinData in ScmdUnitBuiltins, line 124")
call LWV(S4V,"when calling setRequiringEnumUnit in ScmdUnitBuiltins, line 126")
set S7V=ILo(S4V,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 124")
set YjV=S7V
set S5V=pbV("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 126")
set S6V=OPo(S5V,"when calling new_BuiltinData in ScmdUnitBuiltins, line 126")
call Rxo(S6V,e4V(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 128")
call IFo(YjV,S6V,"when calling addOverload in ScmdUnitBuiltins, line 126")
call Foa(S7V,"getmovespeed","when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 124")
set S8V=qfV("when calling alloc_IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 129")
set S9V=OPo(S8V,"when calling new_BuiltinData in ScmdUnitBuiltins, line 129")
call Rxo(S9V,gQV(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 132")
set tvV=S9V
call LWV(tvV,"when calling setRequiringEnumUnit in ScmdUnitBuiltins, line 132")
set toV=ILo(tvV,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 129")
set YJV=toV
set teV=QfV("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 132")
set txV=OPo(teV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 132")
call FRa(txV,e4V(),gQV(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 135")
call IFo(YJV,txV,"when calling addOverload in ScmdUnitBuiltins, line 132")
call Foa(toV,"setturnspeed","when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 129")
set trV=MYV("when calling alloc_IBuiltin_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 136")
set tiV=OPo(trV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 136")
call LWV(tiV,"when calling setRequiringEnumUnit in ScmdUnitBuiltins, line 138")
set tVV=ILo(tiV,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 136")
set YkV=tVV
set taV=pYV("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 138")
set tnV=OPo(taV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 138")
call Rxo(tnV,e4V(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 140")
call IFo(YkV,tnV,"when calling addOverload in ScmdUnitBuiltins, line 138")
call Foa(tVV,"getturnspeed","when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 136")
set tEV=MbV("when calling alloc_IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 141")
set tXV=OPo(tEV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 141")
call Rxo(tXV,gQV(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 144")
set tOV=tXV
call LWV(tOV,"when calling setRequiringEnumUnit in ScmdUnitBuiltins, line 144")
set tAV=ILo(tOV,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 141")
set YKV=tAV
set tRV=PCV("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 144")
set tIV=OPo(tRV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 144")
call FRa(tIV,e4V(),gQV(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 147")
call IFo(YKV,tIV,"when calling addOverload in ScmdUnitBuiltins, line 144")
call g_V(tAV,fNV(KCv("settimescale","when calling stringToIndex in ScmdUnitBuiltins, line 147"),KCv("settsc","when calling stringToIndex in ScmdUnitBuiltins, line 147"),"when calling asList in ScmdUnitBuiltins, line 147"),"when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 141")
set tNV=P_V("when calling alloc_IBuiltin_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 148")
set tbV=OPo(tNV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 148")
call LWV(tbV,"when calling setRequiringEnumUnit in ScmdUnitBuiltins, line 150")
set tCV=ILo(tbV,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 148")
set YlV=tCV
set tBV=q_V("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 150")
set tcV=OPo(tBV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 150")
call Rxo(tcV,e4V(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 153")
call IFo(YlV,tcV,"when calling addOverload in ScmdUnitBuiltins, line 150")
call Foa(tCV,"gettimescale","when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 148")
set tdV=lPV("when calling alloc_IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 154")
set tDV=OPo(tdV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 154")
call Rxo(tDV,gQV(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 157")
set tfV=tDV
call LWV(tfV,"when calling setRequiringEnumUnit in ScmdUnitBuiltins, line 157")
set tGV=ILo(tfV,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 154")
set YLV=tGV
set tFV=LnV("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 157")
set tgV=OPo(tFV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 157")
call FRa(tgV,e4V(),gQV(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 160")
call IFo(YLV,tgV,"when calling addOverload in ScmdUnitBuiltins, line 157")
call g_V(tGV,fNV(KCv("setflyheight","when calling stringToIndex in ScmdUnitBuiltins, line 160"),KCv("setfh","when calling stringToIndex in ScmdUnitBuiltins, line 160"),"when calling asList in ScmdUnitBuiltins, line 160"),"when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 154")
set thV=leV("when calling alloc_IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 161")
set tHV=OPo(thV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 161")
call Rxo(tHV,gQV(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 164")
set tjV=tHV
call LWV(tjV,"when calling setRequiringEnumUnit in ScmdUnitBuiltins, line 164")
set tKV=ILo(tjV,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 161")
set YmV=tKV
set tJV=L0V("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 164")
set tkV=OPo(tJV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 164")
call FRa(tkV,e4V(),gQV(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 167")
call IFo(YmV,tkV,"when calling addOverload in ScmdUnitBuiltins, line 164")
call Foa(tKV,"setblendtime","when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 161")
set tlV=KjV("when calling alloc_IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 168")
set tLV=OPo(tlV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 168")
call Rxo(tLV,f3a(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 171")
set tmV=tLV
call LWV(tmV,"when calling setRequiringEnumUnit in ScmdUnitBuiltins, line 171")
set tPV=ILo(tmV,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 168")
set YMV=tPV
set tMV=mtV("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 171")
set tpV=OPo(tMV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 171")
call FRa(tpV,e4V(),f3a(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 174")
call IFo(YMV,tpV,"when calling addOverload in ScmdUnitBuiltins, line 171")
call g_V(tPV,fNV(KCv("setinventorysize","when calling stringToIndex in ScmdUnitBuiltins, line 174"),KCv("setinvsz","when calling stringToIndex in ScmdUnitBuiltins, line 174"),"when calling asList in ScmdUnitBuiltins, line 174"),"when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 168")
set tqV=smV("when calling alloc_IBuiltin_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 175")
set tQV=OPo(tqV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 175")
call LWV(tQV,"when calling setRequiringEnumUnit in ScmdUnitBuiltins, line 177")
set ttV=ILo(tQV,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 175")
set YpV=ttV
set tsV=seV("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 177")
set tSV=OPo(tsV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 177")
call Rxo(tSV,e4V(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 179")
call IFo(YpV,tSV,"when calling addOverload in ScmdUnitBuiltins, line 177")
call Foa(ttV,"getinventorysize","when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 175")
set tTV=pGV("when calling alloc_IBuiltin_setArgumentsTypes_setProvidingEnumUnit_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 180")
set tuV=OPo(tTV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 180")
call FRa(tuV,xdV(),hda(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 204")
set tUV=tuV
call LNa(tUV,"when calling setProvidingEnumUnit in ScmdUnitBuiltins, line 204")
call Foa(G3a(tUV,"when calling new_BuiltinSpecialForm in ScmdUnitBuiltins, line 180"),"forgroup","when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 180")
set twV=QKV("when calling alloc_IBuiltin_setArgumentsTypes_setProvidingEnumUnit_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 205")
set tWV=OPo(twV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 205")
call Rxo(tWV,hda(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 221")
set tyV=tWV
call LNa(tyV,"when calling setProvidingEnumUnit in ScmdUnitBuiltins, line 221")
call Foa(G3a(tyV,"when calling new_BuiltinSpecialForm in ScmdUnitBuiltins, line 205"),"forall","when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 205")
set tYV=p5V("when calling alloc_IBuiltin_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 222")
call Foa(ILo(OPo(tYV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 222"),"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 222"),"group","when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 222")
set tzV=MGV("when calling alloc_IBuiltin_setRequiringEnumUnit_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 225")
set tZV=OPo(tzV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 225")
call LWV(tZV,"when calling setRequiringEnumUnit in ScmdUnitBuiltins, line 227")
call Foa(ILo(tZV,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 225"),"getenumunit","when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 225")
set t_V=PjV("when calling alloc_IBuiltin_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 228")
call Foa(ILo(OPo(t_V,"when calling new_BuiltinData in ScmdUnitBuiltins, line 228"),"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 228"),"getall","when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 228")
set t0V=P8V("when calling alloc_IBuiltin_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 231")
call Foa(ILo(OPo(t0V,"when calling new_BuiltinData in ScmdUnitBuiltins, line 231"),"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 231"),"getselected","when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 231")
set t1V=q8V("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 234")
set t2V=OPo(t1V,"when calling new_BuiltinData in ScmdUnitBuiltins, line 234")
call Rxo(t2V,e5V(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 236")
call Foa(ILo(t2V,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 234"),"getinrect","when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 234")
set t3V=lwV("when calling alloc_IBuiltin_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 237")
call Foa(ILo(OPo(t3V,"when calling new_BuiltinData in ScmdUnitBuiltins, line 237"),"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 237"),"clearselection","when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 237")
set t4V=LbV("when calling alloc_IBuiltin_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 242")
set t5V=OPo(t4V,"when calling new_BuiltinData in ScmdUnitBuiltins, line 242")
call LWV(t5V,"when calling setRequiringEnumUnit in ScmdUnitBuiltins, line 245")
set t8V=ILo(t5V,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 242")
set YPV=t8V
set t6V=lXV("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 245")
set t7V=OPo(t6V,"when calling new_BuiltinData in ScmdUnitBuiltins, line 245")
call Rxo(t7V,e4V(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 248")
call IFo(YPV,t7V,"when calling addOverload in ScmdUnitBuiltins, line 245")
call Foa(t8V,"resetcooldown","when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 242")
set t9V=L9V("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 249")
set TvV=OPo(t9V,"when calling new_BuiltinData in ScmdUnitBuiltins, line 249")
call glV(TvV,OFo(),gQV(),gQV(),gQV(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 251")
set ToV=ILo(TvV,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 249")
set YqV=ToV
set TeV=KPV("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 251")
set TxV=OPo(TeV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 251")
call mKV(TxV,f3a(),OFo(),gQV(),gQV(),gQV(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 262")
call IFo(YqV,TxV,"when calling addOverload in ScmdUnitBuiltins, line 251")
call Foa(ToV,"create","when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 249")
set TrV=mZV("when calling alloc_IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 263")
set TiV=OPo(TrV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 263")
call Rxo(TiV,MRV(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 266")
set TaV=TiV
call LWV(TaV,"when calling setRequiringEnumUnit in ScmdUnitBuiltins, line 266")
set TEV=ILo(TaV,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 263")
set YQV=TEV
set TnV=sjV("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 266")
set TVV=OPo(TnV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 266")
call FRa(TVV,MRV(),e4V(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 269")
call IFo(YQV,TVV,"when calling addOverload in ScmdUnitBuiltins, line 266")
call Foa(TEV,"groupaddunit","when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 263")
set TXV=Q5V("when calling alloc_IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 270")
set TOV=OPo(TXV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 270")
call Rxo(TOV,f3a(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 273")
set TRV=TOV
call LWV(TRV,"when calling setRequiringEnumUnit in ScmdUnitBuiltins, line 273")
set TNV=ILo(TRV,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 270")
set YsV=TNV
set TIV=pCV("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 273")
set TAV=OPo(TIV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 273")
call FRa(TAV,e4V(),f3a(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 276")
call IFo(YsV,TAV,"when calling addOverload in ScmdUnitBuiltins, line 273")
call Foa(TNV,"setmaxhp","when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 270")
set TbV=qGV("when calling alloc_IBuiltin_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 277")
set TBV=OPo(TbV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 277")
call LWV(TBV,"when calling setRequiringEnumUnit in ScmdUnitBuiltins, line 279")
set TdV=ILo(TBV,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 277")
set YSV=TdV
set TcV=QGV("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 279")
set TCV=OPo(TcV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 279")
call Rxo(TCV,e4V(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 281")
call IFo(YSV,TCV,"when calling addOverload in ScmdUnitBuiltins, line 279")
call Foa(TdV,"getmaxhp","when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 277")
set TDV=M_V("when calling alloc_IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 282")
set TfV=OPo(TDV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 282")
call Rxo(TfV,f3a(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 285")
set TFV=TfV
call LWV(TFV,"when calling setRequiringEnumUnit in ScmdUnitBuiltins, line 285")
set ThV=ILo(TFV,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 282")
set YtV=ThV
set TgV=p_V("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 285")
set TGV=OPo(TgV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 285")
call FRa(TGV,e4V(),f3a(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 288")
call IFo(YtV,TGV,"when calling addOverload in ScmdUnitBuiltins, line 285")
call Foa(ThV,"setmaxmana","when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 282")
set THV=MCV("when calling alloc_IBuiltin_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 289")
set TjV=OPo(THV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 289")
call LWV(TjV,"when calling setRequiringEnumUnit in ScmdUnitBuiltins, line 291")
set TKV=ILo(TjV,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 289")
set YTV=TKV
set TJV=PfV("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 291")
set TkV=OPo(TJV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 291")
call Rxo(TkV,e4V(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 293")
call IFo(YTV,TkV,"when calling addOverload in ScmdUnitBuiltins, line 291")
call Foa(TKV,"getmaxmana","when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 289")
set TlV=P2V("when calling alloc_IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 294")
set TLV=OPo(TlV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 294")
call Rxo(TLV,gQV(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 297")
set TmV=TLV
call LWV(TmV,"when calling setRequiringEnumUnit in ScmdUnitBuiltins, line 297")
set TPV=ILo(TmV,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 294")
set YuV=TPV
set TMV=q2V("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 297")
set TpV=OPo(TMV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 297")
call FRa(TpV,eJV(),gQV(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 300")
call IFo(YuV,TpV,"when calling addOverload in ScmdUnitBuiltins, line 297")
call Foa(TPV,"sethp","when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 294")
set TqV=lsV("when calling alloc_IBuiltin_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 301")
set TQV=OPo(TqV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 301")
call LWV(TQV,"when calling setRequiringEnumUnit in ScmdUnitBuiltins, line 303")
set TtV=ILo(TQV,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 301")
set YUV=TtV
set TsV=LXV("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 303")
set TSV=OPo(TsV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 303")
call Rxo(TSV,eJV(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 305")
call IFo(YUV,TSV,"when calling addOverload in ScmdUnitBuiltins, line 303")
call Foa(TtV,"gethp","when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 301")
set TTV=lrV("when calling alloc_IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 306")
set TuV=OPo(TTV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 306")
call Rxo(TuV,gQV(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 309")
set TUV=TuV
call LWV(TUV,"when calling setRequiringEnumUnit in ScmdUnitBuiltins, line 309")
set TyV=ILo(TUV,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 306")
set YwV=TyV
set TwV=L3V("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 309")
set TWV=OPo(TwV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 309")
call FRa(TWV,e4V(),gQV(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 312")
call IFo(YwV,TWV,"when calling addOverload in ScmdUnitBuiltins, line 309")
call Foa(TyV,"setmana","when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 306")
set TYV=KKV("when calling alloc_IBuiltin_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 313")
set TzV=OPo(TYV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 313")
call LWV(TzV,"when calling setRequiringEnumUnit in ScmdUnitBuiltins, line 315")
set T0V=ILo(TzV,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 313")
set YWV=T0V
set TZV=mUV("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 315")
set T_V=OPo(TZV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 315")
call Rxo(T_V,e4V(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 317")
call IFo(YWV,T_V,"when calling addOverload in ScmdUnitBuiltins, line 315")
call Foa(T0V,"getmana","when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 313")
set T1V=sPV("when calling alloc_IBuiltin_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 323")
set T2V=OPo(T1V,"when calling new_BuiltinData in ScmdUnitBuiltins, line 323")
call LWV(T2V,"when calling setRequiringEnumUnit in ScmdUnitBuiltins, line 326")
set T5V=ILo(T2V,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 323")
set YyV=T5V
set T3V=srV("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 326")
set T4V=OPo(T3V,"when calling new_BuiltinData in ScmdUnitBuiltins, line 326")
call Rxo(T4V,e4V(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 329")
call IFo(YyV,T4V,"when calling addOverload in ScmdUnitBuiltins, line 326")
call Foa(T5V,"refresh","when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 323")
set T6V=pjV("when calling alloc_IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 331")
set T7V=OPo(T6V,"when calling new_BuiltinData in ScmdUnitBuiltins, line 331")
call FRa(T7V,f3a(),f3a(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 334")
set T8V=T7V
call LWV(T8V,"when calling setRequiringEnumUnit in ScmdUnitBuiltins, line 334")
set ueV=ILo(T8V,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 331")
set YYV=ueV
set T9V=qKV("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 334")
set uvV=OPo(T9V,"when calling new_BuiltinData in ScmdUnitBuiltins, line 334")
call etV(uvV,e4V(),f3a(),f3a(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 337")
call IFo(YYV,uvV,"when calling addOverload in ScmdUnitBuiltins, line 334")
call Foa(ueV,"setbasedamage","when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 331")
set uxV=QmV("when calling alloc_IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 338")
set uoV=OPo(uxV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 338")
call Rxo(uoV,f3a(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 340")
set urV=uoV
call LWV(urV,"when calling setRequiringEnumUnit in ScmdUnitBuiltins, line 340")
set unV=ILo(urV,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 338")
set YzV=unV
set uiV=M5V("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 340")
set uaV=OPo(uiV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 340")
call FRa(uaV,e4V(),f3a(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 342")
call IFo(YzV,uaV,"when calling addOverload in ScmdUnitBuiltins, line 340")
call Foa(unV,"getbasedamage","when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 338")
set uVV=p8V("when calling alloc_IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 343")
set uEV=OPo(uVV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 343")
call FRa(uEV,f3a(),f3a(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 346")
set uXV=uEV
call LWV(uXV,"when calling setRequiringEnumUnit in ScmdUnitBuiltins, line 346")
set uIV=ILo(uXV,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 343")
set YZV=uIV
set uOV=MjV("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 346")
set uRV=OPo(uOV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 346")
call etV(uRV,e4V(),f3a(),f3a(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 349")
call IFo(YZV,uRV,"when calling addOverload in ScmdUnitBuiltins, line 346")
call Foa(uIV,"setdicesides","when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 343")
set uAV=PKV("when calling alloc_IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 350")
set uNV=OPo(uAV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 350")
call Rxo(uNV,f3a(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 352")
set ubV=uNV
call LWV(ubV,"when calling setRequiringEnumUnit in ScmdUnitBuiltins, line 352")
set uCV=ILo(ubV,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 350")
set Y_V=uCV
set uBV=qeV("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 352")
set ucV=OPo(uBV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 352")
call FRa(ucV,e4V(),f3a(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 354")
call IFo(Y_V,ucV,"when calling addOverload in ScmdUnitBuiltins, line 352")
call Foa(uCV,"getdicesides","when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 350")
set udV=QeV("when calling alloc_IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 355")
set uDV=OPo(udV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 355")
call FRa(uDV,f3a(),f3a(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 358")
set ufV=uDV
call LWV(ufV,"when calling setRequiringEnumUnit in ScmdUnitBuiltins, line 358")
set uGV=ILo(ufV,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 355")
set Y0V=uGV
set uFV=lYV("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 358")
set ugV=OPo(uFV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 358")
call etV(ugV,e4V(),f3a(),f3a(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 361")
call IFo(Y0V,ugV,"when calling addOverload in ScmdUnitBuiltins, line 358")
call Foa(uGV,"setdicenumber","when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 355")
set uhV=LCV("when calling alloc_IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 362")
set uHV=OPo(uhV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 362")
call Rxo(uHV,f3a(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 364")
set ujV=uHV
call LWV(ujV,"when calling setRequiringEnumUnit in ScmdUnitBuiltins, line 364")
set uKV=ILo(ujV,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 362")
set Y1V=uKV
set uJV=lIV("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 364")
set ukV=OPo(uJV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 364")
call FRa(ukV,e4V(),f3a(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 366")
call IFo(Y1V,ukV,"when calling addOverload in ScmdUnitBuiltins, line 364")
call Foa(uKV,"getdicenumber","when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 362")
set ulV=mxV("when calling alloc_IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 367")
set uLV=OPo(ulV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 367")
call Rxo(uLV,f3a(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 370")
set umV=uLV
call LWV(umV,"when calling setRequiringEnumUnit in ScmdUnitBuiltins, line 370")
set uPV=ILo(umV,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 367")
set Y2V=uPV
set uMV=KsV("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 370")
set upV=OPo(uMV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 370")
call FRa(upV,e4V(),f3a(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 373")
call IFo(Y2V,upV,"when calling addOverload in ScmdUnitBuiltins, line 370")
call Foa(uPV,"setarmor","when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 367")
set uqV=m1V("when calling alloc_IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 374")
set uQV=OPo(uqV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 374")
call Rxo(uQV,gQV(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 377")
set usV=uQV
call LWV(usV,"when calling setRequiringEnumUnit in ScmdUnitBuiltins, line 377")
set uTV=ILo(usV,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 374")
set Y3V=uTV
set uSV=ssV("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 377")
set utV=OPo(uSV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 377")
call FRa(utV,e4V(),gQV(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 380")
call IFo(Y3V,utV,"when calling addOverload in ScmdUnitBuiltins, line 377")
call g_V(uTV,fNV(KCv("sethpregeneration","when calling stringToIndex in ScmdUnitBuiltins, line 380"),KCv("sethpreg","when calling stringToIndex in ScmdUnitBuiltins, line 380"),"when calling asList in ScmdUnitBuiltins, line 380"),"when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 374")
set uuV=snV("when calling alloc_IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 381")
set uUV=OPo(uuV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 381")
call Rxo(uUV,gQV(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 384")
set uwV=uUV
call LWV(uwV,"when calling setRequiringEnumUnit in ScmdUnitBuiltins, line 384")
set uYV=ILo(uwV,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 381")
set Y4V=uYV
set uWV=pKV("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 384")
set uyV=OPo(uWV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 384")
call FRa(uyV,e4V(),gQV(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 387")
call IFo(Y4V,uyV,"when calling addOverload in ScmdUnitBuiltins, line 384")
call g_V(uYV,fNV(KCv("setmanaregeneration","when calling stringToIndex in ScmdUnitBuiltins, line 387"),KCv("setmanareg","when calling stringToIndex in ScmdUnitBuiltins, line 387"),"when calling asList in ScmdUnitBuiltins, line 387"),"when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 381")
set uzV=qmV("when calling alloc_IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 388")
set uZV=OPo(uzV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 388")
call Rxo(uZV,gQV(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 391")
set u_V=uZV
call LWV(u_V,"when calling setRequiringEnumUnit in ScmdUnitBuiltins, line 391")
set u2V=ILo(u_V,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 388")
set Y5V=u2V
set u0V=QPV("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 391")
set u1V=OPo(u0V,"when calling new_BuiltinData in ScmdUnitBuiltins, line 391")
call FRa(u1V,e4V(),gQV(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 394")
call IFo(Y5V,u1V,"when calling addOverload in ScmdUnitBuiltins, line 391")
call g_V(u2V,fNV(KCv("setsightradius","when calling stringToIndex in ScmdUnitBuiltins, line 394"),KCv("setsgtrds","when calling stringToIndex in ScmdUnitBuiltins, line 394"),"when calling asList in ScmdUnitBuiltins, line 394"),"when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 388")
set u3V=M8V("when calling alloc_IBuiltin_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 395")
set u4V=OPo(u3V,"when calling new_BuiltinData in ScmdUnitBuiltins, line 395")
call LWV(u4V,"when calling setRequiringEnumUnit in ScmdUnitBuiltins, line 397")
set u7V=ILo(u4V,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 395")
set Y6V=u7V
set u5V=PeV("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 397")
set u6V=OPo(u5V,"when calling new_BuiltinData in ScmdUnitBuiltins, line 397")
call Rxo(u6V,e4V(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 399")
call IFo(Y6V,u6V,"when calling addOverload in ScmdUnitBuiltins, line 397")
call Foa(u7V,"getarmor","when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 395")
set u8V=MKV("when calling alloc_IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 400")
set u9V=OPo(u8V,"when calling new_BuiltinData in ScmdUnitBuiltins, line 400")
call FRa(u9V,gQV(),f3a(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 403")
set UvV=u9V
call LWV(UvV,"when calling setRequiringEnumUnit in ScmdUnitBuiltins, line 403")
set UoV=ILo(UvV,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 400")
set Y7V=UoV
set UeV=PmV("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 403")
set UxV=OPo(UeV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 403")
call etV(UxV,e4V(),gQV(),f3a(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 406")
call IFo(Y7V,UxV,"when calling addOverload in ScmdUnitBuiltins, line 403")
call g_V(UoV,fNV(KCv("setattackcooldown","when calling stringToIndex in ScmdUnitBuiltins, line 406"),KCv("setatkcd","when calling stringToIndex in ScmdUnitBuiltins, line 406"),"when calling asList in ScmdUnitBuiltins, line 406"),"when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 400")
set UrV=qrV("when calling alloc_IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 407")
set UiV=OPo(UrV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 407")
call FRa(UiV,f3a(),d_V(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 409")
set UaV=UiV
call LWV(UaV,"when calling setRequiringEnumUnit in ScmdUnitBuiltins, line 409")
set UEV=ILo(UaV,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 407")
set Y8V=UEV
set UnV=QrV("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 409")
set UVV=OPo(UnV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 409")
call etV(UVV,e4V(),f3a(),d_V(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 411")
call IFo(Y8V,UVV,"when calling addOverload in ScmdUnitBuiltins, line 409")
call g_V(UEV,fNV(KCv("setattackenabled","when calling stringToIndex in ScmdUnitBuiltins, line 411"),KCv("setatkena","when calling stringToIndex in ScmdUnitBuiltins, line 411"),"when calling asList in ScmdUnitBuiltins, line 411"),"when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 407")
set UXV=l_V("when calling alloc_IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 412")
set UOV=OPo(UXV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 412")
call Rxo(UOV,f3a(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 414")
set URV=UOV
call LWV(URV,"when calling setRequiringEnumUnit in ScmdUnitBuiltins, line 414")
set UNV=ILo(URV,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 412")
set Y9V=UNV
set UIV=LfV("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 414")
set UAV=OPo(UIV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 414")
call FRa(UAV,e4V(),f3a(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 416")
call IFo(Y9V,UAV,"when calling addOverload in ScmdUnitBuiltins, line 414")
call Foa(UNV,"getattackcooldown","when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 412")
set UbV=lbV("when calling alloc_IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 417")
set UBV=OPo(UbV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 417")
call FRa(UBV,gQV(),f3a(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 420")
set UcV=UBV
call LWV(UcV,"when calling setRequiringEnumUnit in ScmdUnitBuiltins, line 420")
set UDV=ILo(UcV,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 417")
set zvV=UDV
set UCV=miV("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 420")
set UdV=OPo(UCV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 420")
call etV(UdV,e4V(),gQV(),f3a(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 423")
call IFo(zvV,UdV,"when calling addOverload in ScmdUnitBuiltins, line 420")
call g_V(UDV,fNV(KCv("setattackrange","when calling stringToIndex in ScmdUnitBuiltins, line 423"),KCv("setatkrng","when calling stringToIndex in ScmdUnitBuiltins, line 423"),"when calling asList in ScmdUnitBuiltins, line 423"),"when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 417")
set UfV=KTV("when calling alloc_IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 424")
set UFV=OPo(UfV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 424")
call Rxo(UFV,f3a(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 426")
set UgV=UFV
call LWV(UgV,"when calling setRequiringEnumUnit in ScmdUnitBuiltins, line 426")
set UHV=ILo(UgV,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 424")
set zeV=UHV
set UGV=m4V("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 426")
set UhV=OPo(UGV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 426")
call FRa(UhV,e4V(),f3a(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 428")
call IFo(zeV,UhV,"when calling addOverload in ScmdUnitBuiltins, line 426")
call Foa(UHV,"getattackrange","when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 424")
set UjV=sTV("when calling alloc_IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 453")
set UJV=OPo(UjV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 453")
call FRa(UJV,f3a(),OFo(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 455")
set UkV=UJV
call LWV(UkV,"when calling setRequiringEnumUnit in ScmdUnitBuiltins, line 455")
set ULV=ILo(UkV,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 453")
set zxV=ULV
set UKV=sXV("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 455")
set UlV=OPo(UKV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 455")
call etV(UlV,e4V(),f3a(),OFo(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 457")
call IFo(zxV,UlV,"when calling addOverload in ScmdUnitBuiltins, line 455")
call g_V(ULV,fNV(KCv("setattacktype","when calling stringToIndex in ScmdUnitBuiltins, line 457"),KCv("setatkt","when calling stringToIndex in ScmdUnitBuiltins, line 457"),"when calling asList in ScmdUnitBuiltins, line 457"),"when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 453")
set UmV=pmV("when calling alloc_IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 458")
set UMV=OPo(UmV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 458")
call FRa(UMV,f3a(),OFo(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 460")
set UpV=UMV
call LWV(UpV,"when calling setRequiringEnumUnit in ScmdUnitBuiltins, line 460")
set UQV=ILo(UpV,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 458")
set zoV=UQV
set UPV=qPV("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 460")
set UqV=OPo(UPV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 460")
call etV(UqV,e4V(),f3a(),OFo(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 462")
call IFo(zoV,UqV,"when calling addOverload in ScmdUnitBuiltins, line 460")
call g_V(UQV,fNV(KCv("setprojectile","when calling stringToIndex in ScmdUnitBuiltins, line 462"),KCv("setprj","when calling stringToIndex in ScmdUnitBuiltins, line 462"),"when calling asList in ScmdUnitBuiltins, line 462"),"when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 458")
set UsV=QsV("when calling alloc_IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 487")
set USV=OPo(UsV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 487")
call Rxo(USV,OFo(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 489")
set UtV=USV
call LWV(UtV,"when calling setRequiringEnumUnit in ScmdUnitBuiltins, line 489")
set UUV=ILo(UtV,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 487")
set zrV=UUV
set UTV=peV("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 489")
set UuV=OPo(UTV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 489")
call FRa(UuV,e4V(),OFo(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 491")
call IFo(zrV,UuV,"when calling addOverload in ScmdUnitBuiltins, line 489")
call g_V(UUV,fNV(KCv("setdefensetype","when calling stringToIndex in ScmdUnitBuiltins, line 491"),KCv("setdeft","when calling stringToIndex in ScmdUnitBuiltins, line 491"),"when calling asList in ScmdUnitBuiltins, line 491"),"when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 487")
set UwV=PrV("when calling alloc_IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 514")
set UWV=OPo(UwV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 514")
call Rxo(UWV,OFo(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 516")
set UyV=UWV
call LWV(UyV,"when calling setRequiringEnumUnit in ScmdUnitBuiltins, line 516")
set UZV=ILo(UyV,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 514")
set ziV=UZV
set UYV=MmV("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 516")
set UzV=OPo(UYV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 516")
call FRa(UzV,e4V(),OFo(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 518")
call IFo(ziV,UzV,"when calling addOverload in ScmdUnitBuiltins, line 516")
call g_V(UZV,fNV(KCv("setarmortype","when calling stringToIndex in ScmdUnitBuiltins, line 518"),KCv("setarmt","when calling stringToIndex in ScmdUnitBuiltins, line 518"),"when calling asList in ScmdUnitBuiltins, line 518"),"when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 514")
set U_V=PPV("when calling alloc_IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 545")
set U0V=OPo(U_V,"when calling new_BuiltinData in ScmdUnitBuiltins, line 545")
call Rxo(U0V,OFo(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 547")
set U1V=U0V
call LWV(U1V,"when calling setRequiringEnumUnit in ScmdUnitBuiltins, line 547")
set U4V=ILo(U1V,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 545")
set zaV=U4V
set U2V=qnV("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 547")
set U3V=OPo(U2V,"when calling new_BuiltinData in ScmdUnitBuiltins, line 547")
call FRa(U3V,e4V(),OFo(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 549")
call IFo(zaV,U3V,"when calling addOverload in ScmdUnitBuiltins, line 547")
call g_V(U4V,fNV(KCv("setmovetype","when calling stringToIndex in ScmdUnitBuiltins, line 549"),KCv("setmvt","when calling stringToIndex in ScmdUnitBuiltins, line 549"),"when calling asList in ScmdUnitBuiltins, line 549"),"when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 545")
set U5V=QnV("when calling alloc_IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 550")
set U6V=OPo(U5V,"when calling new_BuiltinData in ScmdUnitBuiltins, line 550")
call Rxo(U6V,f3a(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 558")
set U7V=U6V
call LWV(U7V,"when calling setRequiringEnumUnit in ScmdUnitBuiltins, line 558")
set wvV=ILo(U7V,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 550")
set znV=wvV
set U8V=l2V("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 558")
set U9V=OPo(U8V,"when calling new_BuiltinData in ScmdUnitBuiltins, line 558")
call FRa(U9V,e4V(),f3a(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 566")
call IFo(znV,U9V,"when calling addOverload in ScmdUnitBuiltins, line 558")
call g_V(wvV,fNV(KCv("setlevel","when calling stringToIndex in ScmdUnitBuiltins, line 566"),KCv("setlvl","when calling stringToIndex in ScmdUnitBuiltins, line 566"),"when calling asList in ScmdUnitBuiltins, line 566"),"when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 550")
set weV=LGV("when calling alloc_IBuiltin_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 567")
set wxV=OPo(weV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 567")
call LWV(wxV,"when calling setRequiringEnumUnit in ScmdUnitBuiltins, line 569")
set wiV=ILo(wxV,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 567")
set zVV=wiV
set woV=lCV("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 569")
set wrV=OPo(woV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 569")
call Rxo(wrV,e4V(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 571")
call IFo(zVV,wrV,"when calling addOverload in ScmdUnitBuiltins, line 569")
call Foa(wiV,"getlevel","when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 567")
set waV=mVV("when calling alloc_IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 572")
set wnV=OPo(waV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 572")
call Rxo(wnV,f3a(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 575")
set wVV=wnV
call LWV(wVV,"when calling setRequiringEnumUnit in ScmdUnitBuiltins, line 575")
set wOV=ILo(wVV,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 572")
set zEV=wOV
set wEV=KwV("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 575")
set wXV=OPo(wEV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 575")
call FRa(wXV,e4V(),f3a(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 578")
call IFo(zEV,wXV,"when calling addOverload in ScmdUnitBuiltins, line 575")
call Foa(wOV,"setstr","when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 572")
set wRV=m7V("when calling alloc_IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 579")
set wIV=OPo(wRV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 579")
call Rxo(wIV,d_V(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 581")
set wAV=wIV
call LWV(wAV,"when calling setRequiringEnumUnit in ScmdUnitBuiltins, line 581")
set wBV=ILo(wAV,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 579")
set zXV=wBV
set wNV=swV("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 581")
set wbV=OPo(wNV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 581")
call FRa(wbV,e4V(),d_V(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 583")
call IFo(zXV,wbV,"when calling addOverload in ScmdUnitBuiltins, line 581")
call Foa(wBV,"getstr","when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 579")
set wcV=sIV("when calling alloc_IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 584")
set wCV=OPo(wcV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 584")
call Rxo(wCV,f3a(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 587")
set wdV=wCV
call LWV(wdV,"when calling setRequiringEnumUnit in ScmdUnitBuiltins, line 587")
set wFV=ILo(wdV,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 584")
set zOV=wFV
set wDV=pPV("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 587")
set wfV=OPo(wDV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 587")
call FRa(wfV,e4V(),f3a(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 590")
call IFo(zOV,wfV,"when calling addOverload in ScmdUnitBuiltins, line 587")
call Foa(wFV,"setagi","when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 584")
set wgV=qsV("when calling alloc_IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 591")
set wGV=OPo(wgV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 591")
call Rxo(wGV,d_V(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 593")
set whV=wGV
call LWV(whV,"when calling setRequiringEnumUnit in ScmdUnitBuiltins, line 593")
set wJV=ILo(whV,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 591")
set zRV=wJV
set wHV=QTV("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 593")
set wjV=OPo(wHV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 593")
call FRa(wjV,e4V(),d_V(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 595")
call IFo(zRV,wjV,"when calling addOverload in ScmdUnitBuiltins, line 593")
call Foa(wJV,"getagi","when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 591")
set wkV=prV("when calling alloc_IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 596")
set wKV=OPo(wkV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 596")
call Rxo(wKV,f3a(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 599")
set wlV=wKV
call LWV(wlV,"when calling setRequiringEnumUnit in ScmdUnitBuiltins, line 599")
set wMV=ILo(wlV,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 596")
set zIV=wMV
set wLV=PnV("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 599")
set wmV=OPo(wLV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 599")
call FRa(wmV,e4V(),f3a(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 602")
call IFo(zIV,wmV,"when calling addOverload in ScmdUnitBuiltins, line 599")
call Foa(wMV,"setint","when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 596")
set wpV=MPV("when calling alloc_IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 603")
set wPV=OPo(wpV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 603")
call Rxo(wPV,d_V(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 605")
set wqV=wPV
call LWV(wqV,"when calling setRequiringEnumUnit in ScmdUnitBuiltins, line 605")
set wSV=ILo(wqV,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 603")
set zAV=wSV
set wQV=PsV("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 605")
set wsV=OPo(wQV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 605")
call FRa(wsV,e4V(),d_V(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 607")
call IFo(zAV,wsV,"when calling addOverload in ScmdUnitBuiltins, line 605")
call Foa(wSV,"getint","when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 603")
set wtV=qXV("when calling alloc_IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 624")
set wTV=OPo(wtV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 624")
call Rxo(wTV,OFo(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 626")
set wuV=wTV
call LWV(wuV,"when calling setRequiringEnumUnit in ScmdUnitBuiltins, line 626")
set wWV=ILo(wuV,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 624")
set zNV=wWV
set wUV=QXV("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 626")
set wwV=OPo(wUV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 626")
call FRa(wwV,e4V(),OFo(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 628")
call IFo(zNV,wwV,"when calling addOverload in ScmdUnitBuiltins, line 626")
call g_V(wWV,fNV(KCv("setprimaryattribute","when calling stringToIndex in ScmdUnitBuiltins, line 628"),KCv("setprimattr","when calling stringToIndex in ScmdUnitBuiltins, line 628"),"when calling asList in ScmdUnitBuiltins, line 628"),"when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 624")
set wyV=l5V("when calling alloc_IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 630")
set wYV=OPo(wyV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 630")
call FRa(wYV,d_V(),d_V(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 633")
set wzV=wYV
call LWV(wzV,"when calling setRequiringEnumUnit in ScmdUnitBuiltins, line 633")
set w0V=ILo(wzV,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 630")
set zbV=w0V
set wZV=LjV("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 633")
set w_V=OPo(wZV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 633")
call etV(w_V,e4V(),d_V(),d_V(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 636")
call IFo(zbV,w_V,"when calling addOverload in ScmdUnitBuiltins, line 633")
call Foa(w0V,"removebuffs","when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 630")
set w1V=lfV("when calling alloc_IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 637")
set w2V=OPo(w1V,"when calling new_BuiltinData in ScmdUnitBuiltins, line 637")
call Rxo(w2V,gQV(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 640")
set w3V=w2V
call LWV(w3V,"when calling setRequiringEnumUnit in ScmdUnitBuiltins, line 640")
set w6V=ILo(w3V,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 637")
set zBV=w6V
set w4V=mOV("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 640")
set w5V=OPo(w4V,"when calling new_BuiltinData in ScmdUnitBuiltins, line 640")
call FRa(w5V,e4V(),gQV(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 643")
call IFo(zBV,w5V,"when calling addOverload in ScmdUnitBuiltins, line 640")
call g_V(w6V,fNV(KCv("setfacing","when calling stringToIndex in ScmdUnitBuiltins, line 643"),KCv("fa","when calling stringToIndex in ScmdUnitBuiltins, line 643"),"when calling asList in ScmdUnitBuiltins, line 643"),"when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 637")
set w7V=KYV("when calling alloc_IBuiltin_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 644")
set w8V=OPo(w7V,"when calling new_BuiltinData in ScmdUnitBuiltins, line 644")
call LWV(w8V,"when calling setRequiringEnumUnit in ScmdUnitBuiltins, line 646")
set WeV=ILo(w8V,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 644")
set zcV=WeV
set w9V=MvV("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 646")
set WvV=OPo(w9V,"when calling new_BuiltinData in ScmdUnitBuiltins, line 646")
call Rxo(WvV,e4V(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 648")
call IFo(zcV,WvV,"when calling addOverload in ScmdUnitBuiltins, line 646")
call Foa(WeV,"getfacing","when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 644")
set WxV=sYV("when calling alloc_IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 650")
set WoV=OPo(WxV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 650")
call Rxo(WoV,gQV(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 653")
set WrV=WoV
call LWV(WrV,"when calling setRequiringEnumUnit in ScmdUnitBuiltins, line 653")
set WnV=ILo(WrV,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 650")
set zCV=WnV
set WiV=sbV("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 653")
set WaV=OPo(WiV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 653")
call FRa(WaV,e4V(),gQV(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 656")
call IFo(zCV,WaV,"when calling addOverload in ScmdUnitBuiltins, line 653")
call Foa(WnV,"setx","when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 650")
set WVV=psV("when calling alloc_IBuiltin_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 657")
set WEV=OPo(WVV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 657")
call LWV(WEV,"when calling setRequiringEnumUnit in ScmdUnitBuiltins, line 659")
set WRV=ILo(WEV,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 657")
set zdV=WRV
set WXV=qTV("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 659")
set WOV=OPo(WXV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 659")
call Rxo(WOV,eJV(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 661")
call IFo(zdV,WOV,"when calling addOverload in ScmdUnitBuiltins, line 659")
call Foa(WRV,"getx","when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 657")
set WIV=QwV("when calling alloc_IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 662")
set WAV=OPo(WIV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 662")
call Rxo(WAV,gQV(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 665")
set WNV=WAV
call LWV(WNV,"when calling setRequiringEnumUnit in ScmdUnitBuiltins, line 665")
set WcV=ILo(WNV,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 662")
set zDV=WcV
set WbV=pnV("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 665")
set WBV=OPo(WbV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 665")
call FRa(WBV,e4V(),gQV(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 668")
call IFo(zDV,WBV,"when calling addOverload in ScmdUnitBuiltins, line 665")
call Foa(WcV,"sety","when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 662")
set WCV=PXV("when calling alloc_IBuiltin_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 669")
set WdV=OPo(WCV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 669")
call LWV(WdV,"when calling setRequiringEnumUnit in ScmdUnitBuiltins, line 671")
set WFV=ILo(WdV,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 669")
set zfV=WFV
set WDV=MsV("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 671")
set WfV=OPo(WDV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 671")
call Rxo(WfV,eJV(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 673")
call IFo(zfV,WfV,"when calling addOverload in ScmdUnitBuiltins, line 671")
call Foa(WFV,"gety","when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 669")
set WgV=PTV("when calling alloc_IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 675")
set WGV=OPo(WgV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 675")
call Rxo(WGV,gQV(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 678")
set WhV=WGV
call LWV(WhV,"when calling setRequiringEnumUnit in ScmdUnitBuiltins, line 678")
set WJV=ILo(WhV,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 675")
set zFV=WJV
set WHV=qIV("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 678")
set WjV=OPo(WHV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 678")
call FRa(WjV,e4V(),gQV(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 681")
call IFo(zFV,WjV,"when calling addOverload in ScmdUnitBuiltins, line 678")
call Foa(WJV,"movex","when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 675")
set WkV=QIV("when calling alloc_IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 682")
set WKV=OPo(WkV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 682")
call Rxo(WKV,gQV(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 685")
set WlV=WKV
call LWV(WlV,"when calling setRequiringEnumUnit in ScmdUnitBuiltins, line 685")
set WMV=ILo(WlV,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 682")
set zgV=WMV
set WLV=l8V("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 685")
set WmV=OPo(WLV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 685")
call FRa(WmV,e4V(),gQV(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 688")
call IFo(zgV,WmV,"when calling addOverload in ScmdUnitBuiltins, line 685")
call Foa(WMV,"movey","when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 682")
set WpV=LKV("when calling alloc_IBuiltin_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 690")
set WPV=OPo(WpV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 690")
call LWV(WPV,"when calling setRequiringEnumUnit in ScmdUnitBuiltins, line 692")
set WsV=ILo(WPV,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 690")
set zGV=WsV
set WqV=lGV("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 692")
set WQV=OPo(WqV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 692")
call Rxo(WQV,e4V(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 694")
call IFo(zGV,WQV,"when calling addOverload in ScmdUnitBuiltins, line 692")
call Foa(WsV,"gettypeid","when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 690")
set WSV=mAV("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 695")
set WtV=OPo(WSV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 695")
call Rxo(WtV,f3a(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 697")
call Foa(ILo(WtV,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 695"),"isherounitid","when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 695")
set WTV=K_V("when calling alloc_IBuiltin_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 698")
set WuV=OPo(WTV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 698")
call LWV(WuV,"when calling setRequiringEnumUnit in ScmdUnitBuiltins, line 700")
set WWV=ILo(WuV,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 698")
set zhV=WWV
set WUV=MoV("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 700")
set WwV=OPo(WUV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 700")
call Rxo(WwV,e4V(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 702")
call IFo(zhV,WwV,"when calling addOverload in ScmdUnitBuiltins, line 700")
call g_V(WWV,fNV(KCv("isstructure","when calling stringToIndex in ScmdUnitBuiltins, line 702"),KCv("structure?","when calling stringToIndex in ScmdUnitBuiltins, line 702"),"when calling asList in ScmdUnitBuiltins, line 702"),"when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 698")
set WyV=sfV("when calling alloc_IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 703")
set WYV=OPo(WyV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 703")
call Rxo(WYV,OFo(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 708")
set WzV=WYV
call LWV(WzV,"when calling setRequiringEnumUnit in ScmdUnitBuiltins, line 708")
set W0V=ILo(WzV,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 703")
set zHV=W0V
set WZV=Q_V("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 708")
set W_V=OPo(WZV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 708")
call FRa(W_V,e4V(),OFo(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 713")
call IFo(zHV,W_V,"when calling addOverload in ScmdUnitBuiltins, line 708")
call Foa(W0V,"setname","when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 703")
set W1V=pIV("when calling alloc_IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 714")
set W2V=OPo(W1V,"when calling new_BuiltinData in ScmdUnitBuiltins, line 714")
call Rxo(W2V,OFo(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 719")
set W3V=W2V
call LWV(W3V,"when calling setRequiringEnumUnit in ScmdUnitBuiltins, line 719")
set W6V=ILo(W3V,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 714")
set zjV=W6V
set W4V=qCV("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 719")
set W5V=OPo(W4V,"when calling new_BuiltinData in ScmdUnitBuiltins, line 719")
call FRa(W5V,e4V(),OFo(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 724")
call IFo(zjV,W5V,"when calling addOverload in ScmdUnitBuiltins, line 719")
call Foa(W6V,"setpropername","when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 714")
set W7V=QCV("when calling alloc_IBuiltin_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 725")
set W8V=OPo(W7V,"when calling new_BuiltinData in ScmdUnitBuiltins, line 725")
call LWV(W8V,"when calling setRequiringEnumUnit in ScmdUnitBuiltins, line 727")
set yeV=ILo(W8V,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 725")
set zJV=yeV
set W9V=MwV("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 727")
set yvV=OPo(W9V,"when calling new_BuiltinData in ScmdUnitBuiltins, line 727")
call Rxo(yvV,e4V(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 729")
call IFo(zJV,yvV,"when calling addOverload in ScmdUnitBuiltins, line 727")
call Foa(yeV,"getname","when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 725")
set yxV=pwV("when calling alloc_IBuiltin_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 730")
set yoV=OPo(yxV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 730")
call LWV(yoV,"when calling setRequiringEnumUnit in ScmdUnitBuiltins, line 732")
set yaV=ILo(yoV,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 730")
set zkV=yaV
set yrV=MIV("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 732")
set yiV=OPo(yrV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 732")
call Rxo(yiV,e4V(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 734")
call IFo(zkV,yiV,"when calling addOverload in ScmdUnitBuiltins, line 732")
call Foa(yaV,"getpropername","when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 730")
set ynV=PbV("when calling alloc_IBuiltin_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 735")
set yVV=OPo(ynV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 735")
call LWV(yVV,"when calling setRequiringEnumUnit in ScmdUnitBuiltins, line 738")
set yOV=ILo(yVV,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 735")
set zKV=yOV
set yEV=PYV("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 738")
set yXV=OPo(yEV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 738")
call Rxo(yXV,e4V(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 741")
call IFo(zKV,yXV,"when calling addOverload in ScmdUnitBuiltins, line 738")
call Foa(yOV,"pause","when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 735")
set yRV=qYV("when calling alloc_IBuiltin_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 742")
set yIV=OPo(yRV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 742")
call LWV(yIV,"when calling setRequiringEnumUnit in ScmdUnitBuiltins, line 745")
set ybV=ILo(yIV,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 742")
set zlV=ybV
set yAV=lmV("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 745")
set yNV=OPo(yAV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 745")
call Rxo(yNV,e4V(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 748")
call IFo(zlV,yNV,"when calling addOverload in ScmdUnitBuiltins, line 745")
call Foa(ybV,"unpause","when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 742")
set yBV=LrV("when calling alloc_IBuiltin_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 749")
set ycV=OPo(yBV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 749")
call LWV(ycV,"when calling setRequiringEnumUnit in ScmdUnitBuiltins, line 752")
set yDV=ILo(ycV,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 749")
set zLV=yDV
set yCV=K8V("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 752")
set ydV=OPo(yCV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 752")
call Rxo(ydV,e4V(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 755")
call IFo(zLV,ydV,"when calling addOverload in ScmdUnitBuiltins, line 752")
call Foa(yDV,"remove","when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 749")
set yfV=LzV("when calling alloc_IBuiltin_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 756")
set yFV=OPo(yfV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 756")
call LWV(yFV,"when calling setRequiringEnumUnit in ScmdUnitBuiltins, line 759")
set yhV=ILo(yFV,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 756")
set zmV=yhV
set ygV=KGV("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 759")
set yGV=OPo(ygV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 759")
call Rxo(yGV,e4V(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 762")
call IFo(zmV,yGV,"when calling addOverload in ScmdUnitBuiltins, line 759")
call Foa(yhV,"kill","when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 756")
set yHV=mQV("when calling alloc_IBuiltin_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 763")
set yjV=OPo(yHV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 763")
call LWV(yjV,"when calling setRequiringEnumUnit in ScmdUnitBuiltins, line 766")
set yKV=ILo(yjV,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 763")
set zMV=yKV
set yJV=s_V("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 766")
set ykV=OPo(yJV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 766")
call Rxo(ykV,e4V(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 769")
call IFo(zMV,ykV,"when calling addOverload in ScmdUnitBuiltins, line 766")
call Foa(yKV,"explode","when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 763")
set ylV=sCV("when calling alloc_IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 770")
set yLV=OPo(ylV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 770")
call Rxo(yLV,OFo(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 772")
set ymV=yLV
call LWV(ymV,"when calling setRequiringEnumUnit in ScmdUnitBuiltins, line 772")
set yPV=ILo(ymV,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 770")
set zpV=yPV
set yMV=pTV("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 772")
set ypV=OPo(yMV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 772")
call FRa(ypV,e4V(),OFo(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 774")
call IFo(zpV,ypV,"when calling addOverload in ScmdUnitBuiltins, line 772")
call Foa(yPV,"issueimmediateorder","when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 770")
set yqV=qwV("when calling alloc_IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 775")
set yQV=OPo(yqV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 775")
call etV(yQV,OFo(),gQV(),gQV(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 777")
set ysV=yQV
call LWV(ysV,"when calling setRequiringEnumUnit in ScmdUnitBuiltins, line 777")
set yTV=ILo(ysV,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 775")
set zPV=yTV
set ySV=QYV("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 777")
set ytV=OPo(ySV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 777")
call glV(ytV,e4V(),OFo(),gQV(),gQV(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 779")
call IFo(zPV,ytV,"when calling addOverload in ScmdUnitBuiltins, line 777")
call Foa(yTV,"issuepointorder","when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 775")
set yuV=pXV("when calling alloc_IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 780")
set yUV=OPo(yuV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 780")
call FRa(yUV,OFo(),eJV(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 782")
set ywV=yUV
call LWV(ywV,"when calling setRequiringEnumUnit in ScmdUnitBuiltins, line 782")
set yYV=ILo(ywV,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 780")
set zqV=yYV
set yWV=PIV("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 782")
set yyV=OPo(yWV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 782")
call etV(yyV,e4V(),OFo(),eJV(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 784")
call IFo(zqV,yyV,"when calling addOverload in ScmdUnitBuiltins, line 782")
call Foa(yYV,"issuetargetorder","when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 780")
set yzV=MTV("when calling alloc_IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 785")
set yZV=OPo(yzV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 785")
call Rxo(yZV,OFo(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 788")
set y_V=yZV
call LWV(y_V,"when calling setRequiringEnumUnit in ScmdUnitBuiltins, line 788")
set y2V=ILo(y_V,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 785")
set zQV=y2V
set y0V=PwV("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 788")
set y1V=OPo(y0V,"when calling new_BuiltinData in ScmdUnitBuiltins, line 788")
call FRa(y1V,e4V(),OFo(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 791")
call IFo(zQV,y1V,"when calling addOverload in ScmdUnitBuiltins, line 788")
call Foa(y2V,"queueanimation","when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 785")
set y3V=qbV("when calling alloc_IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 792")
set y4V=OPo(y3V,"when calling new_BuiltinData in ScmdUnitBuiltins, line 792")
call Rxo(y4V,OFo(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 795")
set y5V=y4V
call LWV(y5V,"when calling setRequiringEnumUnit in ScmdUnitBuiltins, line 795")
set y8V=ILo(y5V,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 792")
set zsV=y8V
set y6V=QbV("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 795")
set y7V=OPo(y6V,"when calling new_BuiltinData in ScmdUnitBuiltins, line 795")
call FRa(y7V,e4V(),OFo(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 798")
call IFo(zsV,y7V,"when calling addOverload in ScmdUnitBuiltins, line 795")
call Foa(y8V,"setanimation","when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 792")
set y9V=LeV("when calling alloc_IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 799")
set YvV=OPo(y9V,"when calling new_BuiltinData in ScmdUnitBuiltins, line 799")
call Rxo(YvV,f3a(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 802")
set YeV=YvV
call LWV(YeV,"when calling setRequiringEnumUnit in ScmdUnitBuiltins, line 802")
set YrV=ILo(YeV,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 799")
set zSV=YrV
set YxV=LmV("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 802")
set YoV=OPo(YxV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 802")
call FRa(YoV,e4V(),f3a(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 805")
call IFo(zSV,YoV,"when calling addOverload in ScmdUnitBuiltins, line 802")
call Foa(YrV,"setanimationbyindex","when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 799")
set YiV=lKV("when calling alloc_IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 806")
set YaV=OPo(YiV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 806")
call Rxo(YaV,OFo(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 809")
set YnV=YaV
call LWV(YnV,"when calling setRequiringEnumUnit in ScmdUnitBuiltins, line 809")
set YXV=ILo(YnV,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 806")
set ztV=YXV
set YVV=mdV("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 809")
set YEV=OPo(YVV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 809")
call FRa(YEV,e4V(),OFo(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 812")
call IFo(ztV,YEV,"when calling addOverload in ScmdUnitBuiltins, line 809")
call g_V(YXV,fNV(KCv("addanimationproperties","when calling stringToIndex in ScmdUnitBuiltins, line 812"),KCv("addanimprop","when calling stringToIndex in ScmdUnitBuiltins, line 812"),"when calling asList in ScmdUnitBuiltins, line 812"),"when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 806")
set YOV=K5V("when calling alloc_IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 813")
set YRV=OPo(YOV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 813")
call Rxo(YRV,OFo(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 816")
set YIV=YRV
call LWV(YIV,"when calling setRequiringEnumUnit in ScmdUnitBuiltins, line 816")
set YbV=ILo(YIV,"when calling new_BuiltinFunction in ScmdUnitBuiltins, line 813")
set zTV=YbV
set YAV=MEV("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdUnitBuiltins in ScmdUnitBuiltins, line 816")
set YNV=OPo(YAV,"when calling new_BuiltinData in ScmdUnitBuiltins, line 816")
call FRa(YNV,e4V(),OFo(),"when calling setArgumentsTypes in ScmdUnitBuiltins, line 819")
call IFo(zTV,YNV,"when calling addOverload in ScmdUnitBuiltins, line 816")
call g_V(YbV,fNV(KCv("removeanimationproperties","when calling stringToIndex in ScmdUnitBuiltins, line 819"),KCv("remanimprop","when calling stringToIndex in ScmdUnitBuiltins, line 819"),"when calling asList in ScmdUnitBuiltins, line 819"),"when calling registerProtectedBuiltin in ScmdUnitBuiltins, line 813")
set EM=EM-1
return true
endfunction
function zuV takes nothing returns boolean
set EM=0
return s2V("ScmdUnitBuiltins, line 1")
endfunction
function zUV takes nothing returns nothing
set Ju[8]=GetUnitLoc(GetEnumUnit())
call CreateNUnitsAtLoc(1,'h0LE',GetOwningPlayer(Nu),Ju[8],bj_UNIT_FACING)
call UnitAddAbilityBJ('A04B',GetLastCreatedUnit())
call SetUnitAbilityLevelSwapped('A04B',GetLastCreatedUnit(),Mu)
call IssueTargetOrderBJ(GetLastCreatedUnit(),"thunderbolt",GetEnumUnit())
call GroupAddUnitSimple(GetLastCreatedUnit(),Ku)
call SaveIntegerBJ(Du+2,0,GetHandleIdBJ(GetLastCreatedUnit()),Au)
call RemoveLocation(Ju[8])
endfunction
function zwV takes nothing returns boolean
return(IsPlayerEnemy(GetOwningPlayer(GetSpellAbilityUnit()),GetOwningPlayer(GetFilterUnit()))and IsUnitType(GetEnumUnit(),UNIT_TYPE_STRUCTURE)==false and BlzIsUnitInvulnerable(GetFilterUnit())==false)!=null
endfunction
function zWV takes nothing returns nothing
local unit zyV=GetSpellAbilityUnit()
if GetSpellAbilityId()=='A0HI' then
call UnitRemoveAbility(zyV,'A0HI')
call UnitAddAbility(zyV,'A0HK')
call UnitMakeAbilityPermanent(zyV,true,'A0HK')
call UnitAddAbility(zyV,'A0HJ')
call UnitMakeAbilityPermanent(zyV,true,'A0HJ')
else
call UnitRemoveAbility(zyV,'A0HK')
call UnitRemoveAbility(zyV,'A0HJ')
call UnitAddAbility(zyV,'A0HI')
call UnitMakeAbilityPermanent(zyV,true,'A0HI')
endif
set zyV=null
set zyV=null
endfunction
function zYV takes nothing returns boolean
return(GetOwningPlayer(GetEnumUnit())==GetTriggerPlayer())
endfunction
function zzV takes nothing returns nothing
if zYV()then
set G=GetUnitLoc(GetEnumUnit())
call EnumDestructablesInCircleBJ(256.,G,xHv)
call RemoveLocation(G)
endif
endfunction
function zZV takes player z_V,string z0V,boolean z1V,boolean z2V returns nothing
if Tr==null then
set Tr=CreateSoundFromLabel("InterfaceError",false,false,false,$A,$A)
endif
if GetLocalPlayer()==z_V then
if z2V then
call ClearTextMessages()
call DisplayTimedTextToPlayer(z_V,.5,2.,2.,"|cffffcc00"+z0V+"|r")
endif
if z1V then
call StartSound(Tr)
endif
endif
endfunction
function z3V takes nothing returns nothing
local destructable z4V=GetSpellTargetDestructable()
local integer z5V
local integer z6V
if GetDestructableTypeId(GetSpellTargetDestructable())=='DTlv' or GetDestructableTypeId(GetSpellTargetDestructable())=='LTg1' or GetDestructableTypeId(GetSpellTargetDestructable())=='ZTg1' or GetDestructableTypeId(GetSpellTargetDestructable())=='ITtg' or GetDestructableTypeId(GetSpellTargetDestructable())=='ATg1' or GetDestructableTypeId(GetSpellTargetDestructable())=='YTce' or GetDestructableTypeId(GetSpellTargetDestructable())=='DTc1' or GetDestructableTypeId(GetSpellTargetDestructable())=='DTc2' or GetDestructableTypeId(GetSpellTargetDestructable())=='DTg5' or GetDestructableTypeId(GetSpellTargetDestructable())=='ZTd1' or GetDestructableTypeId(GetSpellTargetDestructable())=='ZTd5' or GetDestructableTypeId(GetSpellTargetDestructable())=='ITg1' or GetDestructableTypeId(GetSpellTargetDestructable())=='DTg1' or GetDestructableTypeId(GetSpellTargetDestructable())=='ZTsx' or GetDestructableTypeId(GetSpellTargetDestructable())=='DTg1' or GetDestructableTypeId(GetSpellTargetDestructable())=='ITx1' or GetDestructableTypeId(GetSpellTargetDestructable())=='LTe1' then
set z5V=0
set z6V=ts
if GetDestructableTypeId(GetSpellTargetDestructable())=='DTlv' then
loop
exitwhen z5V>z6V
if z4V==Fw[z5V]then
set Fw[z5V]=null
set hw[z5V]=null
endif
set z5V=z5V+1
endloop
else
loop
exitwhen z5V>z6V
if z4V==hw[z5V]then
set Fw[z5V]=null
set hw[z5V]=null
endif
set z5V=z5V+1
endloop
endif
else
call zZV(GetOwningPlayer(GetSpellAbilityUnit()),"",true,false)
endif
set z5V=0
set z6V=0
set z4V=null
set z4V=null
endfunction
function z7V takes nothing returns nothing
local location z8V=GetOrderPointLoc()
local unit z9V=GetOrderedUnit()
local integer ZvV=GetIssuedOrderId()
if OrderId2String(ZvV)!=null and mJa(GetUnitLoc(z9V),z8V)>800. then
call SetUnitPositionLoc(z9V,mqa(GetUnitLoc(z9V),mJa(GetUnitLoc(z9V),z8V)-800.,mma(GetUnitLoc(z9V),z8V)))
call TriggerSleepAction(.01)
call IssuePointOrderByIdLoc(z9V,ZvV,z8V)
endif
call RemoveLocation(z8V)
set z8V=null
set ZvV=0
set z9V=null
set z8V=null
set z9V=null
endfunction
function ZeV takes nothing returns boolean
return GetSpellAbilityId()=='AcS1' or GetSpellAbilityId()=='AcS2'
endfunction
function ZxV takes nothing returns nothing
local effect ZoV=AddSpecialEffectTarget("Abilities\\Spells\\Items\\AIhe\\AIheTarget.mdl",GetSpellAbilityUnit(),"origin")
call DestroyEffect(AddSpecialEffectTarget("Objects\\Spawnmodels\\Human\\HumanBlood\\HumanBloodKnight.mdl",GetSpellTargetUnit(),"chest"))
call UnitDamageTarget(GetSpellAbilityUnit(),GetSpellTargetUnit(),75*GetUnitAbilityLevel(GetSpellAbilityUnit(),'A0HW')-25,true,true,ATTACK_TYPE_NORMAL,DAMAGE_TYPE_MAGIC,WEAPON_TYPE_WHOKNOWS)
call SetUnitState(GetSpellAbilityUnit(),UNIT_STATE_LIFE,GetUnitState(GetSpellAbilityUnit(),UNIT_STATE_LIFE)+50*GetUnitAbilityLevel(GetSpellAbilityUnit(),'A0HW'))
call pAa(1.833)
call DestroyEffect(ZoV)
set ZoV=null
set ZoV=null
endfunction
function ZrV takes nothing returns nothing
call SetPlayerHandicapXPBJ(GetEnumPlayer(),100.)
endfunction
function ZiV takes nothing returns nothing
if GetUnitTypeId(GetEnumUnit())!='h000' and IsUnitSelected(GetEnumUnit(),GetTriggerPlayer()) then
call UnitRemoveAbility(GetEnumUnit(),'A0IR')
endif
endfunction
function ZaV takes unit ZnV returns nothing
call SaveReal(i,HO,GetHandleId(ZnV),GetUnitAbilityLevel(ZnV,'A0HL')*'d'*(2.-GetWidgetLife(ZnV)/BlzGetUnitMaxHP(ZnV))*1.)
endfunction
function ZVV takes nothing returns boolean
call ZaV(ry)
return true
endfunction
function ZEV takes integer ZXV returns real
set L9=vH[ZXV]
set X9=mH[ZXV]
return L9
endfunction
function ZOV takes integer ZRV,string ZIV returns real
local real ZAV
local real ZNV
local real ZbV
local real ZBV
set ZM[EM]=ZIV
set EM=EM+1
if Jk[ZRV]==0 then
if ZRV==0 then
call Cdv("Nullpointer exception when calling RectDrawing.getMax","when calling error in RectDrawing, line 97")
else
call Cdv("Called RectDrawing.getMax on invalid object.","when calling error in RectDrawing, line 97")
endif
endif
set ZbV=ZEV(ZRV)
set ZBV=X9
set ZAV=ZbV
set ZNV=ZBV
set EM=EM-1
set zA=ZAV
set zN=ZNV
return zA
endfunction
function ZcV takes integer ZCV returns real
set J9=jH[ZCV]
set K9=xH[ZCV]
return J9
endfunction
function ZdV takes integer ZDV,string ZfV returns real
local real ZFV
local real ZgV
local real ZGV
local real ZhV
set ZM[EM]=ZfV
set EM=EM+1
if Jk[ZDV]==0 then
if ZDV==0 then
call Cdv("Nullpointer exception when calling RectDrawing.getMin","when calling error in RectDrawing, line 88")
else
call Cdv("Called RectDrawing.getMin on invalid object.","when calling error in RectDrawing, line 88")
endif
endif
set ZGV=ZcV(ZDV)
set ZhV=K9
set ZFV=ZGV
set ZgV=ZhV
set EM=EM-1
set zR=ZFV
set zI=ZgV
return zR
endfunction
function ZHV takes integer ZjV,real ZJV,real ZkV,string ZKV returns nothing
local real ZlV
local real ZLV
set ZM[EM]=ZKV
set EM=EM+1
set ZlV=ZJV
set ZLV=ZkV
set jH[ZjV]=ZlV
set xH[ZjV]=ZLV
call xin(ZjV,"when calling repaint in RectDrawing, line 94")
set EM=EM-1
endfunction
function ZmV takes integer ZMV,real ZpV,real ZPV,string ZqV returns nothing
set ZM[EM]=ZqV
set EM=EM+1
if Jk[ZMV]==0 then
if ZMV==0 then
call Cdv("Nullpointer exception when calling RectDrawing.setMin","when calling error in RectDrawing, line 92")
else
call Cdv("Called RectDrawing.setMin on invalid object.","when calling error in RectDrawing, line 92")
endif
endif
call ZHV(ZMV,ZpV,ZPV,"when calling setMin in RectDrawing, line 92")
set EM=EM-1
endfunction
function ZQV takes integer ZsV,unit IJi,string ZSV returns nothing
local real ZtV
local real ZTV
local real ZuV
local real ZUV
local real ZwV
local real ZWV
local real ZyV
set ZM[EM]=ZSV
set EM=EM+1
set ZwV=ZdV(eR[RX[ZsV]],"when calling getMin in SotfrpGuiRegions, line 232")
set ZWV=zI
set ZtV=ZwV
set ZTV=ZWV
set ZUV=ZTV+128.
call ZOV(eR[RX[ZsV]],"when calling getMax in SotfrpGuiRegions, line 233")
set ZyV=zN
set ZuV=ZyV
if ZUV!=ZuV then
call ZmV(eR[RX[ZsV]],ZtV,ZTV+128.,"when calling setMin in SotfrpGuiRegions, line 234")
endif
set EM=EM-1
endfunction
function ZYV takes unit ZzV,real ZZV,real Z_V returns nothing
call SetUnitPosition(ZzV,ZZV,Z_V)
endfunction
function Z0V takes nothing returns real
set A3=GetSpellTargetX()
set D3=GetSpellTargetY()
return A3
endfunction
function Z1V takes integer gWi,unit Z2V returns nothing
call ZYV(Z2V,Z0V(),D3)
endfunction
function Z3V takes integer Z4V,real Z5V,real Z6V,string Z7V returns nothing
local real Z8V
local real Z9V
set ZM[EM]=Z7V
set EM=EM+1
set Z8V=Z5V
set Z9V=Z6V
set vH[Z4V]=Z8V
set mH[Z4V]=Z9V
call xin(Z4V,"when calling repaint in RectDrawing, line 103")
set EM=EM-1
endfunction
function vvE takes integer veE,real vxE,real voE,string vrE returns nothing
set ZM[EM]=vrE
set EM=EM+1
if Jk[veE]==0 then
if veE==0 then
call Cdv("Nullpointer exception when calling RectDrawing.setMax","when calling error in RectDrawing, line 101")
else
call Cdv("Called RectDrawing.setMax on invalid object.","when calling error in RectDrawing, line 101")
endif
endif
call Z3V(veE,vxE,voE,"when calling setMax in RectDrawing, line 101")
set EM=EM-1
endfunction
function viE takes integer vaE,unit mHi,string vnE returns nothing
local real vVE
local real vEE
local real vXE
local real vOE
set ZM[EM]=vnE
set EM=EM+1
set vXE=ZOV(eR[eX[vaE]],"when calling getMax in SotfrpGuiRegions, line 211")
set vOE=zN
set vVE=vXE
set vEE=vOE
call vvE(eR[eX[vaE]],vVE,Kve(vEE+128.,Je),"when calling setMax in SotfrpGuiRegions, line 212")
set EM=EM-1
endfunction
function vRE takes integer vIE,unit AHi,string vAE returns nothing
local real vNE
local real vbE
local real vBE
local real vcE
set ZM[EM]=vAE
set EM=EM+1
set vBE=ZOV(eR[qX[vIE]],"when calling getMax in SotfrpGuiRegions, line 214")
set vcE=zN
set vNE=vBE
set vbE=vcE
call vvE(eR[qX[vIE]],Kve(vNE+128.,He),vbE,"when calling setMax in SotfrpGuiRegions, line 215")
set EM=EM-1
endfunction
function vCE takes integer vdE,unit FJi,string vDE returns nothing
local real vfE
local real vFE
local real vgE
local real vGE
local real vhE
local real vHE
local real vjE
set ZM[EM]=vDE
set EM=EM+1
set vhE=ZOV(eR[fX[vdE]],"when calling getMax in SotfrpGuiRegions, line 228")
set vHE=zN
set vfE=vhE
set vFE=vHE
set vGE=vfE-128.
set vjE=ZdV(eR[fX[vdE]],"when calling getMin in SotfrpGuiRegions, line 229")
set vgE=vjE
if vGE!=vgE then
call vvE(eR[fX[vdE]],vfE-128.,vFE,"when calling setMax in SotfrpGuiRegions, line 230")
endif
set EM=EM-1
endfunction
function vJE takes integer bRc,integer yRc returns nothing
endfunction
function vkE takes integer vKE,unit Efs returns nothing
call vJE(vKE,GetSpellAbilityId())
endfunction
function vlE takes integer vLE,string vmE returns nothing
set ZM[EM]=vmE
set EM=EM+1
call vLn(vLE,"when calling clear in RectDrawing, line 78")
call lnv(QH[vLE])
call JEv(hH[vLE],"when calling dispatch_HashList_destroyHashList in RectDrawing, line 80")
set EM=EM-1
endfunction
function vME takes integer vpE,string vPE returns nothing
set ZM[EM]=vPE
set EM=EM+1
if Jk[vpE]==0 then
call Cdv("Double free: object of type RectDrawing","when calling error in RectDrawing, line 5")
else
set Ak[Dk]=vpE
set Dk=Dk+1
set Jk[vpE]=0
endif
set EM=EM-1
endfunction
function vqE takes integer vQE,string vsE returns nothing
set ZM[EM]=vsE
set EM=EM+1
call vlE(vQE,"when calling RectDrawing_onDestroy in RectDrawing, line 77")
call vME(vQE,"when calling dealloc_RectDrawing in RectDrawing, line 77")
set EM=EM-1
endfunction
function vSE takes integer vtE,string vTE returns nothing
set ZM[EM]=vTE
set EM=EM+1
if Jk[vtE]==0 then
if vtE==0 then
call Cdv("Nullpointer exception when calling RectDrawing.RectDrawing","when calling error in RectDrawing, line 5")
else
call Cdv("Called RectDrawing.RectDrawing on invalid object.","when calling error in RectDrawing, line 5")
endif
endif
call vqE(vtE,"when calling destroyRectDrawing in RectDrawing, line 5")
set EM=EM-1
endfunction
function vuE takes integer vUE,string vwE returns integer
local integer vWE
set ZM[EM]=vwE
set EM=EM+1
set vWE=eR[vUE]
call van(qR[vUE],vWE,"when calling remove in SotfrpGuiRegions, line 93")
set eR[vUE]=0
set fR[vUE]=false
call hDa(vUE,uR,false)
call hja(vUE,rR)
set EM=EM-1
return vWE
endfunction
function vyE takes integer vYE,unit iKi,string vzE returns nothing
set ZM[EM]=vzE
set EM=EM+1
set fR[YX[vYE]]=false
if eR[YX[vYE]]!=0 then
call vSE(vuE(YX[vYE],"when calling retrieveCoreRectDrawing in SotfrpGuiRegions, line 248"),"when calling dispatch_RectDrawing_destroyRectDrawing in SotfrpGuiRegions, line 248")
endif
set EM=EM-1
endfunction
function vZE takes integer v_E,unit qJi,string v0E returns nothing
local real v1E
local real v2E
local real v3E
local real v4E
local real v5E
local real v6E
local real v7E
set ZM[EM]=v0E
set EM=EM+1
set v5E=ZOV(eR[dX[v_E]],"when calling getMax in SotfrpGuiRegions, line 224")
set v6E=zN
set v1E=v5E
set v2E=v6E
set v4E=v2E-128.
call ZdV(eR[dX[v_E]],"when calling getMin in SotfrpGuiRegions, line 225")
set v7E=zI
set v3E=v7E
if v4E!=v3E then
call vvE(eR[dX[v_E]],v1E,v2E-128.,"when calling setMax in SotfrpGuiRegions, line 226")
endif
set EM=EM-1
endfunction
function v8E takes integer Xes returns nothing
endfunction
function v9E takes integer evE returns nothing
call v8E(evE)
endfunction
function eeE takes integer XdS returns nothing
endfunction
function exE takes integer eoE returns nothing
call v9E(eoE)
call eeE(eoE)
endfunction
function erE takes string eiE returns integer
local integer eaE
set ZM[EM]=eiE
set EM=EM+1
if gG==0 then
if hG<$8000 then
set hG=hG+1
set eaE=hG
set FG[eaE]=708
else
call Cdv("Out of memory: Could not create BuffInstance⟪integer⟫.","when calling error in Buffs, line 13")
set eaE=0
endif
else
set gG=gG-1
set eaE=GG[gG]
set FG[eaE]=708
endif
set EM=EM-1
return eaE
endfunction
function enE takes string eVE returns integer
local integer eEE
set ZM[EM]=eVE
set EM=EM+1
set eEE=erE("when calling alloc_BuffInstance⟪integer⟫ in Buffs, line 13")
call exE(eEE)
set EM=EM-1
return eEE
endfunction
function eXE takes string eOE returns integer
local integer eRE
set ZM[EM]=eOE
set EM=EM+1
if jG==0 then
if xG<$8000 then
set xG=xG+1
set eRE=xG
set vG[eRE]=$468
else
call Cdv("Out of memory: Could not create CallbackSingle_doAfter_Buff_Buffs⟪integer⟫.","when calling error in Buffs, line 61")
set eRE=0
endif
else
set jG=jG-1
set eRE=kG[jG]
set vG[eRE]=$468
endif
set EM=EM-1
return eRE
endfunction
function eIE takes integer eAE,real eNE,real ebE returns nothing
local real eBE=eNE
local real ecE=ebE
set UE[eAE]=eBE
set IE[eAE]=ecE
endfunction
function eCE takes integer edE,real eDE,real efE,string eFE returns nothing
set ZM[EM]=eFE
set EM=EM+1
if Zg[edE]==0 then
if edE==0 then
call Cdv("Nullpointer exception when calling DummyCaster.origin","when calling error in DummyCaster, line 36")
else
call Cdv("Called DummyCaster.origin on invalid object.","when calling error in DummyCaster, line 36")
endif
endif
call eIE(edE,eDE,efE)
set EM=EM-1
endfunction
function egE takes integer eGE,integer Kpu,unit ehE,integer eHE,string ejE returns nothing
local integer eJE
local integer ekE
set ZM[EM]=ejE
set EM=EM+1
call lUx("applying to "+zAv(ehE)+" "+SMv(eHE))
set eJE=cGV("when calling new_DummyCaster in DummyBuffs, line 62")
call eCE(eJE,uov(ehE),c3,"when calling origin in DummyBuffs, line 62")
set ekE=eJE
call cVV(ekE,eGE,eHE,Qq,ehE,"when calling castTarget in DummyBuffs, line 62")
set EM=EM-1
endfunction
function eKE takes integer Ubt,unit elE,integer eLE,string emE returns nothing
set ZM[EM]=emE
set EM=EM+1
call egE(Wa,Ea,elE,eLE,"when calling apply in RollTheBones, line 28")
set EM=EM-1
endfunction
function eME takes integer dyt,unit epE,integer ePE,string eqE returns nothing
set ZM[EM]=eqE
set EM=EM+1
call egE(Pa,Aa,epE,ePE,"when calling apply in RollTheBones, line 44")
set EM=EM-1
endfunction
function eQE takes integer iyt,unit Syt,integer esE returns nothing
call lUx("grand melee lvl "+SMv(esE)+" removed")
endfunction
function eSE takes integer uyt,unit ryt,integer etE returns nothing
call lUx("grand melee lvl "+SMv(etE)+" expired")
endfunction
function eTE takes integer Vbt,unit euE,integer eUE,string ewE returns nothing
set ZM[EM]=ewE
set EM=EM+1
call lUx("applying grand melee")
call egE(Za,Ua,euE,eUE,"when calling apply in RollTheBones, line 34")
set EM=EM-1
endfunction
function eWE takes integer eyE,unit eYE,integer ezE,string eZE returns nothing
set ZM[EM]=eZE
set EM=EM+1
if cj[eyE]==0 then
if eyE==0 then
call Cdv("Nullpointer exception when calling EventHandler⟪integer⟫.fire","when calling error in Buffs, line 9")
else
call Cdv("Called EventHandler⟪integer⟫.fire on invalid object.","when calling error in Buffs, line 9")
endif
endif
if cj[eyE]<=$7AD then
if cj[eyE]<=$7AC then
if cj[eyE]<=$7AB then
call eKE(eyE,eYE,ezE,"when calling fire_onApplication_RollTheBones in Buffs, line 9")
else
call eME(eyE,eYE,ezE,"when calling fire_onApplication_RollTheBones in Buffs, line 9")
endif
else
call eTE(eyE,eYE,ezE,"when calling fire_onApplication_onExpiration_onRemoval_RollTheBones in Buffs, line 9")
endif
elseif cj[eyE]<=$7AE then
call eSE(eyE,eYE,ezE)
else
call eQE(eyE,eYE,ezE)
endif
set EM=EM-1
endfunction
function e_E takes string e0E returns integer
local integer e1E
set ZM[EM]=e0E
set EM=EM+1
if jG==0 then
if xG<$8000 then
set xG=xG+1
set e1E=xG
set vG[e1E]=$469
else
call Cdv("Out of memory: Could not create CallbackSingle_doAfter_Buff_Buffs⟪integer⟫.","when calling error in Buffs, line 64")
set e1E=0
endif
else
set jG=jG-1
set e1E=kG[jG]
set vG[e1E]=$469
endif
set EM=EM-1
return e1E
endfunction
function e2E takes integer e3E,unit e4E,integer e5E,string e6E returns nothing
set ZM[EM]=e6E
set EM=EM+1
call vcV(FM[e3E],C0v(e4E),"when calling removeInt in Buffs, line 37")
if jM[e3E]!=0 then
call eWE(jM[e3E],e4E,e5E,"when calling fire in Buffs, line 39")
endif
set EM=EM-1
endfunction
function e7E takes integer e8E,unit e9E,integer xvE,string xeE returns nothing
set ZM[EM]=xeE
set EM=EM+1
if Im[e8E]==0 then
if e8E==0 then
call Cdv("Nullpointer exception when calling Buff⟪integer⟫.removeNoCbDestroy","when calling error in Buffs, line 36")
else
call Cdv("Called Buff⟪integer⟫.removeNoCbDestroy on invalid object.","when calling error in Buffs, line 36")
endif
endif
call e2E(e8E,e9E,xvE,"when calling removeNoCbDestroy in Buffs, line 36")
set EM=EM-1
endfunction
function xxE takes integer Nes returns nothing
endfunction
function xoE takes integer Bxx returns nothing
call xxE(Bxx)
endfunction
function xrE takes integer xiE,string xaE returns nothing
set ZM[EM]=xaE
set EM=EM+1
if FG[xiE]==0 then
call Cdv("Double free: object of type BuffInstance⟪integer⟫","when calling error in Buffs, line 13")
else
set GG[gG]=xiE
set gG=gG+1
set FG[xiE]=0
endif
set EM=EM-1
endfunction
function xnE takes integer xVE,string xEE returns nothing
set ZM[EM]=xEE
set EM=EM+1
call xoE(xVE)
call xrE(xVE,"when calling dealloc_BuffInstance⟪integer⟫ in Buffs, line 13")
set EM=EM-1
endfunction
function xXE takes integer xOE,string xRE returns nothing
set ZM[EM]=xRE
set EM=EM+1
if FG[xOE]==0 then
if xOE==0 then
call Cdv("Nullpointer exception when calling BuffInstance⟪integer⟫.BuffInstance","when calling error in Buffs, line 13")
else
call Cdv("Called BuffInstance⟪integer⟫.BuffInstance on invalid object.","when calling error in Buffs, line 13")
endif
endif
call xnE(xOE,"when calling destroyBuffInstance⟪integer⟫ in Buffs, line 13")
set EM=EM-1
endfunction
function xIE takes integer xAE,unit xNE,string xbE returns nothing
local integer xBE
set ZM[EM]=xbE
set EM=EM+1
set xBE=fwv(FM[xAE],C0v(xNE),"when calling loadInt in Buffs, line 42")
if xBE!=0 then
call e7E(xAE,xNE,WM[xBE],"when calling removeNoCbDestroy in Buffs, line 44")
call lUx("cleaning up!")
call xXE(xBE,"when calling dispatch_BuffInstance⟪integer⟫_destroyBuffInstance⟪integer⟫ in Buffs, line 46")
endif
set EM=EM-1
endfunction
function xcE takes integer xCE,unit xdE,string xDE returns nothing
set ZM[EM]=xDE
set EM=EM+1
if Im[xCE]==0 then
if xCE==0 then
call Cdv("Nullpointer exception when calling Buff⟪integer⟫.remove","when calling error in Buffs, line 41")
else
call Cdv("Called Buff⟪integer⟫.remove on invalid object.","when calling error in Buffs, line 41")
endif
endif
call xIE(xCE,xdE,"when calling remove in Buffs, line 41")
set EM=EM-1
endfunction
function xfE takes integer xFE,unit xgE,integer xGE,real xhE,string xHE returns nothing
local integer xjE
local integer xJE
local integer xkE
local real xKE
local real xlE
set ZM[EM]=xHE
set EM=EM+1
call xcE(xFE,xgE,"when calling remove in Buffs, line 53")
if kM[xFE]!=0 then
call eWE(kM[xFE],xgE,xGE,"when calling fire in Buffs, line 55")
endif
set xjE=enE("when calling new_BuffInstance⟪integer⟫ in Buffs, line 56")
call lUx("inst created")
set WM[xjE]=xGE
call lUx("duration: "+qwv(xhE))
call bxx(xGE,"when calling new_Box⟪integer⟫ in Buffs, line 60")
set xKE=xhE
set xJE=eXE("when calling alloc_CallbackSingle_doAfter_Buff_Buffs⟪integer⟫ in Buffs, line 61")
call EUx(xJE)
call EQx(xKE,xJE,"when calling doAfter in Buffs, line 61")
set xlE=xhE
set xkE=e_E("when calling alloc_CallbackSingle_doAfter_Buff_Buffs⟪integer⟫ in Buffs, line 64")
call EUx(xkE)
call EQx(xlE,xkE,"when calling doAfter in Buffs, line 64")
call Dyv(FM[xFE],C0v(xgE),xjE,"when calling saveInt in Buffs, line 71")
set EM=EM-1
endfunction
function xLE takes integer xmE,unit xME,integer xpE,real xPE,string xqE returns nothing
set ZM[EM]=xqE
set EM=EM+1
if Im[xmE]==0 then
if xmE==0 then
call Cdv("Nullpointer exception when calling Buff⟪integer⟫.apply","when calling error in Buffs, line 52")
else
call Cdv("Called Buff⟪integer⟫.apply on invalid object.","when calling error in Buffs, line 52")
endif
endif
call xfE(xmE,xME,xpE,xPE,"when calling apply in Buffs, line 52")
set EM=EM-1
endfunction
function xQE takes integer Gyt,unit xsE,string xSE returns nothing
local integer xtE
set ZM[EM]=xSE
set EM=EM+1
if GetRandomInt(0,1)==0 then
set xtE=Ia
else
set xtE=Da
endif
call xLE(xtE,xsE,USv(xsE,ma),DQv(Qa),"when calling apply in RollTheBones, line 48")
set EM=EM-1
endfunction
function xTE takes integer NKi,unit MKi,unit xuE,string xUE returns nothing
set ZM[EM]=xUE
set EM=EM+1
call xLE(hR,xuE,0,DQv(GR),"when calling apply in StickyGrenade, line 71")
set EM=EM-1
endfunction
function xwE takes integer xWE,unit xyE,unit xYE,string xzE returns nothing
set ZM[EM]=xzE
set EM=EM+1
if MG[xWE]==0 then
if xWE==0 then
call Cdv("Nullpointer exception when calling OnUnitCast.fireEx","when calling error in ClosureEvents, line 96")
else
call Cdv("Called OnUnitCast.fireEx on invalid object.","when calling error in ClosureEvents, line 96")
endif
endif
call xTE(xWE,xyE,xYE,"when calling fireEx_onTargetCast_StickyGrenade in ClosureEvents, line 96")
set EM=EM-1
endfunction
function xZE takes integer x_E,unit x0E,string x1E returns nothing
set ZM[EM]=x1E
set EM=EM+1
call xwE(x_E,x0E,GetSpellTargetUnit(),"when calling fireEx in ClosureEvents, line 94")
set EM=EM-1
endfunction
function x2E takes integer x3E,unit tJi,string x4E returns nothing
local real x5E
local real x6E
local real x7E
local real x8E
local real x9E
local real ovE
local real oeE
set ZM[EM]=x4E
set EM=EM+1
set x9E=ZdV(eR[nX[x3E]],"when calling getMin in SotfrpGuiRegions, line 220")
set ovE=zI
set x5E=x9E
set x6E=ovE
set x8E=x5E+128.
set oeE=ZOV(eR[nX[x3E]],"when calling getMax in SotfrpGuiRegions, line 221")
set x7E=oeE
if x8E!=x7E then
call ZmV(eR[nX[x3E]],x5E+128.,x6E,"when calling setMin in SotfrpGuiRegions, line 222")
endif
set EM=EM-1
endfunction
function oxE takes integer ooE,unit VHi,string orE returns nothing
local real oiE
local real oaE
local real onE
local real oVE
set ZM[EM]=orE
set EM=EM+1
set onE=ZdV(eR[aX[ooE]],"when calling getMin in SotfrpGuiRegions, line 217")
set oVE=zI
set oiE=onE
set oaE=oVE
call ZmV(eR[aX[ooE]],oiE,k2e(oaE-128.,De),"when calling setMin in SotfrpGuiRegions, line 218")
set EM=EM-1
endfunction
function oEE takes string oXE returns integer
local integer oOE
set ZM[EM]=oXE
set EM=EM+1
if ug==0 then
if rg<$8000 then
set rg=rg+1
set oOE=rg
set sg[oOE]=$877
else
call Cdv("Out of memory: Could not create ForGroupCallback_forUnitsOfPlayer_onPointCast_SotfrpGuiLocust.","when calling error in SotfrpGuiLocust, line 25")
set oOE=0
endif
else
set ug=ug-1
set oOE=wg[ug]
set sg[oOE]=$877
endif
set EM=EM-1
return oOE
endfunction
function oRE takes integer oIE,unit hZi,real oAE,real oNE,string obE returns nothing
local integer oBE
local player ocE
local real oCE
local real odE
set ZM[EM]=obE
set EM=EM+1
set ocE=sa[YL[oIE]]
set oBE=oEE("when calling alloc_ForGroupCallback_forUnitsOfPlayer_onPointCast_SotfrpGuiLocust in SotfrpGuiLocust, line 25")
set oCE=oAE
set odE=oNE
set GL[oBE]=oCE
set gL[oBE]=odE
set hL[oBE]=YL[oIE]
call g2i(ocE,oBE,"when calling forUnitsOfPlayer in SotfrpGuiLocust, line 25")
set EM=EM-1
set ocE=null
endfunction
function oDE takes real ofE,real oFE,real ogE returns real
set r3=ofE
set s3=oFE
set t3=ogE
return r3
endfunction
function oGE takes integer ohE returns integer
return usv(ohE,"numVar")
endfunction
function oHE takes integer ojE,real oJE,real okE returns destructable
local real oKE
local real olE
local integer oLE
local integer omE
if Df[ojE]then
set olE=GetRandomReal(.0,360.)
else
set olE=Hf[ojE]
endif
set oKE=olE
if Kf[ojE]then
set omE=GetRandomInt(0,oGE(Pf[ojE])-1)
else
set omE=Lf[ojE]
endif
set oLE=omE
return O0a(sa[ojE],Pf[ojE],oDE(oJE,okE,Af[ojE]),s3,t3,oKE,Jf[ojE],oLE)
endfunction
function oME takes integer opE,unit eZi,real oPE,real oqE returns nothing
call oHE(TL[opE],oPE,oqE)
endfunction
function oQE takes integer eOt returns nothing
endfunction
function osE takes integer oSE,player otE,string oTE,boolean ouE,real oUE,real owE,real oWE,real oyE,string oYE returns nothing
set ZM[EM]=oYE
set EM=EM+1
call oQE(oSE)
set hH[oSE]=TEv("when calling new_HashList in RectDrawing, line 54")
set FH[oSE]=otE
set kH[oSE]=oTE
if oUE<=oWE then
set jH[oSE]=oUE
set vH[oSE]=oWE
else
set jH[oSE]=oWE
set vH[oSE]=oUE
endif
if owE<=oyE then
set xH[oSE]=owE
set mH[oSE]=oyE
else
set xH[oSE]=oyE
set mH[oSE]=owE
endif
if ouE then
set jH[oSE]=P0x(jH[oSE]/128.)*128.
set xH[oSE]=P0x(xH[oSE]/128.)*128.
set vH[oSE]=P3x(vH[oSE]/128.)*128.
set mH[oSE]=P3x(mH[oSE]/128.)*128.
endif
set QH[oSE]=Rect(.0,.0,.0,.0)
call xin(oSE,"when calling repaint in RectDrawing, line 75")
set EM=EM-1
endfunction
function ozE takes string oZE returns integer
local integer o_E
set ZM[EM]=oZE
set EM=EM+1
if Dk==0 then
if Hk<$8000 then
set Hk=Hk+1
set o_E=Hk
set Jk[o_E]=4209
else
call Cdv("Out of memory: Could not create RectDrawing.","when calling error in RectDrawing, line 5")
set o_E=0
endif
else
set Dk=Dk-1
set o_E=Ak[Dk]
set Jk[o_E]=4209
endif
set EM=EM-1
return o_E
endfunction
function o0E takes player o1E,string o2E,boolean o3E,real o4E,real o5E,real o6E,real o7E,string o8E returns integer
local integer o9E
set ZM[EM]=o8E
set EM=EM+1
set o9E=ozE("when calling alloc_RectDrawing in RectDrawing, line 53")
call osE(o9E,o1E,o2E,o3E,o4E,o5E,o6E,o7E,"when calling construct_RectDrawing in RectDrawing, line 53")
set EM=EM-1
return o9E
endfunction
function rvE takes integer reE,unit BJi,real rxE,real roE,string rrE returns nothing
local real riE
local real raE
set ZM[EM]=rrE
set EM=EM+1
if not fR[TX[reE]]then
set fR[TX[reE]]=true
set riE=rxE
set raE=roE
set nR[TX[reE]]=riE
set dR[TX[reE]]=raE
else
set eR[TX[reE]]=o0E(sa[TX[reE]],ve,true,nR[TX[reE]],dR[TX[reE]],rxE,roE,"when calling new_RectDrawing in SotfrpGuiRegions, line 241")
call rOa(qR[TX[reE]],eR[TX[reE]],"when calling add in SotfrpGuiRegions, line 242")
call hja(TX[reE],uR)
call hDa(TX[reE],rR,false)
endif
set EM=EM-1
endfunction
function rnE takes integer rVE,unit rEE,real rXE,real rOE,string rRE returns nothing
set ZM[EM]=rRE
set EM=EM+1
if MG[rVE]==0 then
if rVE==0 then
call Cdv("Nullpointer exception when calling OnPointCast.fireEx","when calling error in ClosureEvents, line 89")
else
call Cdv("Called OnPointCast.fireEx on invalid object.","when calling error in ClosureEvents, line 89")
endif
endif
if MG[rVE]<=$F41 then
if MG[rVE]<=$F40 then
call oME(rVE,rEE,rXE,rOE)
else
call oRE(rVE,rEE,rXE,rOE,"when calling fireEx_onPointCast_SotfrpGuiLocust in ClosureEvents, line 89")
endif
else
call rvE(rVE,rEE,rXE,rOE,"when calling fireEx_onPointCast_SotfrpGuiRegions in ClosureEvents, line 89")
endif
set EM=EM-1
endfunction
function rIE takes nothing returns real
set X3=GetSpellTargetX()
set C3=GetSpellTargetY()
return X3
endfunction
function rAE takes nothing returns real
set V3=rIE()
set B3=C3
return V3
endfunction
function rNE takes integer rbE,unit rBE,string rcE returns nothing
set ZM[EM]=rcE
set EM=EM+1
call rnE(rbE,rBE,rAE(),B3,"when calling fireEx in ClosureEvents, line 87")
set EM=EM-1
endfunction
function rCE takes integer rdE,unit GHi,string rDE returns nothing
local real rfE
local real rFE
local real rgE
local real rGE
set ZM[EM]=rDE
set EM=EM+1
set rgE=ZdV(eR[pX[rdE]],"when calling getMin in SotfrpGuiRegions, line 208")
set rGE=zI
set rfE=rgE
set rFE=rGE
call ZmV(eR[pX[rdE]],k2e(rfE-128.,Ae),rFE,"when calling setMin in SotfrpGuiRegions, line 209")
set EM=EM-1
endfunction
function rhE takes player rHE,real rjE,real rJE returns nothing
call SetCameraQuickPositionForPlayer(rHE,rjE,rJE)
endfunction
function rkE takes integer rKE returns real
set C9=YHx(QH[rKE])
set V9=k1
return C9
endfunction
function rlE takes integer rLE,string rmE returns real
local real rME
local real rpE
local real rPE
local real rqE
set ZM[EM]=rmE
set EM=EM+1
if Jk[rLE]==0 then
if rLE==0 then
call Cdv("Nullpointer exception when calling RectDrawing.getCenter","when calling error in RectDrawing, line 106")
else
call Cdv("Called RectDrawing.getCenter on invalid object.","when calling error in RectDrawing, line 106")
endif
endif
set rPE=rkE(rLE)
set rqE=V9
set rME=rPE
set rpE=rqE
set EM=EM-1
set N1=rME
set M1=rpE
return N1
endfunction
function rQE takes unit rsE,eventid rSE,integer rtE,string rTE returns integer
local integer ruE
set ZM[EM]=rTE
set EM=EM+1
set ruE=UHx(rsE)
if ruE<=0 then
set EM=EM-1
return rtE
endif
set YW[rtE]=q1a(rSE,"when calling toIntId in ClosureEvents, line 124")
if up[ruE]!=0 then
set gW[up[ruE]]=rtE
set GW[rtE]=up[ruE]
endif
set up[ruE]=rtE
set EM=EM-1
return rtE
endfunction
function rUE takes string rwE returns integer
local integer rWE
set ZM[EM]=rwE
set EM=EM+1
if LG==0 then
if XG<$8000 then
set XG=XG+1
set rWE=XG
set CG[rWE]=$7BB
else
call Cdv("Out of memory: Could not create EventListener_add_SotfrpGuiRegions.","when calling error in SotfrpGuiRegions, line 113")
set rWE=0
endif
else
set LG=LG-1
set rWE=KG[LG]
set CG[rWE]=$7BB
endif
set EM=EM-1
return rWE
endfunction
function ryE takes string rYE returns integer
local integer rzE
set ZM[EM]=rYE
set EM=EM+1
if LG==0 then
if XG<$8000 then
set XG=XG+1
set rzE=XG
set CG[rzE]=$7BA
else
call Cdv("Out of memory: Could not create EventListener_add_SotfrpGuiRegions.","when calling error in SotfrpGuiRegions, line 106")
set rzE=0
endif
else
set LG=LG-1
set rzE=KG[LG]
set CG[rzE]=$7BA
endif
set EM=EM-1
return rzE
endfunction
function rZE takes integer r_E,string r0E returns unit
local unit r1E
local unit r2E
local unit r3E
local integer r4E
local integer r5E
local unit r6E
local playerunitevent r7E
local unit r8E
local playerunitevent r9E
set ZM[EM]=r0E
set EM=EM+1
set r2E=vAe(sa[r_E],wR,rlE(eR[r_E],"when calling getCenter in SotfrpGuiRegions, line 101"),M1,vde(270.))
call tSv(r2E,oa)
set r3E=r2E
call w0v(r3E,$FF,$FF,$FF,25)
set r1E=r3E
if ta!=sa[r_E]then
call NXe(r1E,.0)
endif
call fqv(aR,Hzo(r1E),vuE(r_E,"when calling retrieveCoreRectDrawing in SotfrpGuiRegions, line 105"),"when calling put in SotfrpGuiRegions, line 105")
set r6E=r1E
set r7E=EVENT_PLAYER_UNIT_SELECTED
set r4E=ryE("when calling alloc_EventListener_add_SotfrpGuiRegions in SotfrpGuiRegions, line 106")
call Zen(r4E)
set PL[r4E]=r_E
set AL[r4E]=r1E
call rQE(r6E,r7E,r4E,"when calling add in SotfrpGuiRegions, line 106")
set r8E=r1E
set r9E=EVENT_PLAYER_UNIT_DESELECTED
set r5E=rUE("when calling alloc_EventListener_add_SotfrpGuiRegions in SotfrpGuiRegions, line 113")
call Zen(r5E)
set DL[r5E]=r_E
set HL[r5E]=r1E
call rQE(r8E,r9E,r5E,"when calling add in SotfrpGuiRegions, line 113")
set EM=EM-1
set RYv=r1E
set r1E=null
set r2E=null
set r3E=null
set r6E=null
set r7E=null
set r8E=null
set r9E=null
return RYv
endfunction
function ivE takes player ieE,real ixE,real ioE returns nothing
call SetCameraPositionForPlayer(ieE,ixE,ioE)
endfunction
function irE takes player iiE,unit iaE returns nothing
if ta==iiE then
call ClearSelection()
call SelectUnit(iaE,true)
endif
endfunction
function inE takes nothing returns real
set w3=GetCameraTargetPositionX()
set u3=GetCameraTargetPositionY()
return w3
endfunction
function iVE takes integer iEE,unit OKi,string iXE returns nothing
local unit iOE
set ZM[EM]=iXE
set EM=EM+1
set iOE=rZE(GX[iEE],"when calling initSpecifier in SotfrpGuiRegions, line 250")
call irE(sa[GX[iEE]],iOE)
call rhE(sa[GX[iEE]],inE(),u3)
call ivE(sa[GX[iEE]],uov(iOE),c3)
call hDa(GX[iEE],uR,false)
call hja(GX[iEE],rR)
set EM=EM-1
set iOE=null
endfunction
function iRE takes integer iIE,unit iAE,string iNE returns nothing
set ZM[EM]=iNE
set EM=EM+1
if MG[iIE]==0 then
if iIE==0 then
call Cdv("Nullpointer exception when calling OnCastListener.fire","when calling error in ClosureEvents, line 56")
else
call Cdv("Called OnCastListener.fire on invalid object.","when calling error in ClosureEvents, line 56")
endif
endif
if MG[iIE]<=$F39 then
if MG[iIE]<=$F35 then
if MG[iIE]<=$F33 then
if MG[iIE]<=$F32 then
call vkE(iIE,iAE)
else
call xQE(iIE,iAE,"when calling fire_onCast_RollTheBones in ClosureEvents, line 56")
endif
elseif MG[iIE]<=$F34 then
call Z1V(iIE,iAE)
else
call rCE(iIE,iAE,"when calling fire_onCast_SotfrpGuiRegions in ClosureEvents, line 56")
endif
elseif MG[iIE]<=$F37 then
if MG[iIE]<=$F36 then
call viE(iIE,iAE,"when calling fire_onCast_SotfrpGuiRegions in ClosureEvents, line 56")
else
call vRE(iIE,iAE,"when calling fire_onCast_SotfrpGuiRegions in ClosureEvents, line 56")
endif
elseif MG[iIE]<=$F38 then
call oxE(iIE,iAE,"when calling fire_onCast_SotfrpGuiRegions in ClosureEvents, line 56")
else
call x2E(iIE,iAE,"when calling fire_onCast_SotfrpGuiRegions in ClosureEvents, line 56")
endif
elseif MG[iIE]<=$F3D then
if MG[iIE]<=$F3B then
if MG[iIE]<=$F3A then
call vZE(iIE,iAE,"when calling fire_onCast_SotfrpGuiRegions in ClosureEvents, line 56")
else
call vCE(iIE,iAE,"when calling fire_onCast_SotfrpGuiRegions in ClosureEvents, line 56")
endif
elseif MG[iIE]<=$F3C then
call ZQV(iIE,iAE,"when calling fire_onCast_SotfrpGuiRegions in ClosureEvents, line 56")
else
call vyE(iIE,iAE,"when calling fire_onCast_SotfrpGuiRegions in ClosureEvents, line 56")
endif
elseif MG[iIE]<=$F42 then
if MG[iIE]<=$F3E then
call iVE(iIE,iAE,"when calling fire_onCast_SotfrpGuiRegions in ClosureEvents, line 56")
else
call rNE(iIE,iAE,"when calling fire in ClosureEvents, line 56")
endif
else
call xZE(iIE,iAE,"when calling fire in ClosureEvents, line 56")
endif
set EM=EM-1
endfunction
function ibE takes string iBE returns nothing
local unit icE
local integer iCE
local integer idE
local integer iDE
local integer ifE
local integer iFE
set ZM[EM]=iBE
set EM=EM+1
set icE=GetTriggerUnit()
set iCE=GetSpellAbilityId()
if fov(My,Hzo(icE),"when calling has in ClosureEvents, line 191")then
set idE=f3v(My,Hzo(icE),"when calling get in ClosureEvents, line 192")
loop
exitwhen not(idE!=0)
set iDE=hW[idE]
if kW[idE]==-1 or kW[idE]==iCE then
call iRE(idE,GetSpellAbilityUnit(),"when calling fire in ClosureEvents, line 196")
endif
set idE=iDE
endloop
endif
if fov(Ny,iCE,"when calling has in ClosureEvents, line 198")then
set ifE=f3v(Ny,iCE,"when calling get in ClosureEvents, line 199")
loop
exitwhen not(ifE!=0)
set iFE=hW[ifE]
if jW[ifE]==null or jW[ifE]==icE then
call iRE(ifE,GetSpellAbilityUnit(),"when calling fire in ClosureEvents, line 203")
endif
set ifE=iFE
endloop
endif
set EM=EM-1
set icE=null
endfunction
function igE takes string iGE returns nothing
set ZM[EM]=iGE
set EM=EM+1
call ibE("when calling onSpellEffect in ClosureEvents, line 310")
set EM=EM-1
endfunction
function ihE takes nothing returns nothing
set EM=0
call igE("ClosureEvents, line 310")
endfunction
function iHE takes nothing returns nothing
call CameraSetEQNoiseForPlayer(GetEnumPlayer(),4.)
endfunction
function ijE takes nothing returns boolean
return(Du==LoadIntegerBJ(0,GetHandleIdBJ(GetEnumUnit()),Au))
endfunction
function iJE takes nothing returns nothing
if ijE()then
call FlushChildHashtableBJ(GetHandleIdBJ(GetEnumUnit()),Au)
call GroupRemoveUnitSimple(GetEnumUnit(),Ku)
call RemoveUnit(GetEnumUnit())
endif
endfunction
function ikE takes nothing returns boolean
return(IsUnitSelected(GetEnumUnit(),GetTriggerPlayer()))
endfunction
function iKE takes nothing returns nothing
if ikE()then
set G=GetUnitLoc(GetEnumUnit())
call EnumDestructablesInCircleBJ(256.,GetUnitLoc(GetEnumUnit()),vAv)
call RemoveLocation(G)
endif
endfunction
function ilE takes integer iLE,timer imE,real iME,string ipE returns nothing
local timer iPE
local timer iqE
set ZM[EM]=ipE
set EM=EM+1
set iPE=imE
call EXx(iPE,iLE,"when calling setData in ClosureTimers, line 134")
set iqE=iPE
call qYx(iqE,iME,RNv)
set EM=EM-1
set iPE=null
set iqE=null
endfunction
function iQE takes integer isE,timer iSE,real itE,string iTE returns nothing
set ZM[EM]=iTE
set EM=EM+1
if fg[isE]==0 then
if isE==0 then
call Cdv("Nullpointer exception when calling CallbackPeriodic.start","when calling error in ClosureTimers, line 132")
else
call Cdv("Called CallbackPeriodic.start on invalid object.","when calling error in ClosureTimers, line 132")
endif
endif
call ilE(isE,iSE,itE,"when calling start in ClosureTimers, line 132")
set EM=EM-1
endfunction
function iuE takes timer iUE,real iwE,integer iWE,string iyE returns integer
set ZM[EM]=iyE
set EM=EM+1
call iQE(iWE,iUE,iwE,"when calling start in ClosureTimers, line 45")
set EM=EM-1
return iWE
endfunction
function iYE takes real izE,integer iZE,string i_E returns integer
local integer i0E
set ZM[EM]=i_E
set EM=EM+1
set i0E=iuE(EMx("when calling getTimer in ClosureTimers, line 57"),izE,iZE,"when calling doPeriodically in ClosureTimers, line 57")
set EM=EM-1
return i0E
endfunction
function i1E takes string i2E returns integer
local integer i3E
set ZM[EM]=i2E
set EM=EM+1
if ng==0 then
if dg<$8000 then
set dg=dg+1
set i3E=dg
set fg[i3E]=$465
else
call Cdv("Out of memory: Could not create CallbackPeriodic_doPeriodically_ScmdPlayerCameraSettingsBuiltins.","when calling error in ScmdPlayerCameraSettingsBuiltins, line 38")
set i3E=0
endif
else
set ng=ng-1
set i3E=ag[ng]
set fg[i3E]=$465
endif
set EM=EM-1
return i3E
endfunction
function i4E takes integer oTs returns nothing
endfunction
function i5E takes integer i6E returns nothing
call i4E(i6E)
endfunction
function i7E takes string i8E returns integer
local integer i9E
set ZM[EM]=i8E
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set i9E=Yj
set Gj[i9E]=$A41
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdPlayerCameraSettingsBuiltins.","when calling error in ScmdPlayerCameraSettingsBuiltins, line 50")
set i9E=0
endif
else
set Tj=Tj-1
set i9E=Rj[Tj]
set Gj[i9E]=$A41
endif
set EM=EM-1
return i9E
endfunction
function avE takes string aeE returns integer
local integer axE
set ZM[EM]=aeE
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set axE=Yj
set Gj[axE]=$A42
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdPlayerCameraSettingsBuiltins.","when calling error in ScmdPlayerCameraSettingsBuiltins, line 73")
set axE=0
endif
else
set Tj=Tj-1
set axE=Rj[Tj]
set Gj[axE]=$A42
endif
set EM=EM-1
return axE
endfunction
function aoE takes string arE returns integer
local integer aiE
set ZM[EM]=arE
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set aiE=Yj
set Gj[aiE]=$AFF
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdPlayerCameraSettingsBuiltins.","when calling error in ScmdPlayerCameraSettingsBuiltins, line 80")
set aiE=0
endif
else
set Tj=Tj-1
set aiE=Rj[Tj]
set Gj[aiE]=$AFF
endif
set EM=EM-1
return aiE
endfunction
function aaE takes string anE returns boolean
local integer aVE
local integer aEE
local integer aXE
local integer aOE
local integer aRE
local integer aIE
local integer aAE
local integer aNE
local integer abE
local integer aBE
local real acE
local integer aCE
set ZM[EM]=anE
set EM=EM+1
set aVE=0
set aEE=bj_MAX_PLAYERS
loop
exitwhen aVE>aEE
set hd[aVE]=PTe("when calling new_IterableMap in ScmdPlayerCameraSettingsBuiltins, line 17")
set aVE=aVE+1
endloop
set acE=dy/2.
set aXE=i1E("when calling alloc_CallbackPeriodic_doPeriodically_ScmdPlayerCameraSettingsBuiltins in ScmdPlayerCameraSettingsBuiltins, line 38")
call i5E(aXE)
call iYE(acE,aXE,"when calling doPeriodically in ScmdPlayerCameraSettingsBuiltins, line 38")
call SetCameraField(CAMERA_FIELD_FARZ,Fa,.0)
set aOE=i7E("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdPlayerCameraSettingsBuiltins in ScmdPlayerCameraSettingsBuiltins, line 50")
set aRE=OPo(aOE,"when calling new_BuiltinData in ScmdPlayerCameraSettingsBuiltins, line 50")
call FRa(aRE,OFo(),gQV(),"when calling setArgumentsTypes in ScmdPlayerCameraSettingsBuiltins, line 73")
set aNE=ILo(aRE,"when calling new_BuiltinFunction in ScmdPlayerCameraSettingsBuiltins, line 50")
set aCE=aNE
set aIE=avE("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdPlayerCameraSettingsBuiltins in ScmdPlayerCameraSettingsBuiltins, line 73")
set aAE=OPo(aIE,"when calling new_BuiltinData in ScmdPlayerCameraSettingsBuiltins, line 73")
call Rxo(aAE,OFo(),"when calling setArgumentsTypes in ScmdPlayerCameraSettingsBuiltins, line 78")
call IFo(aCE,aAE,"when calling addOverload in ScmdPlayerCameraSettingsBuiltins, line 73")
call Foa(aNE,"cam","when calling registerProtectedBuiltin in ScmdPlayerCameraSettingsBuiltins, line 50")
set abE=aoE("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdPlayerCameraSettingsBuiltins in ScmdPlayerCameraSettingsBuiltins, line 80")
set aBE=OPo(abE,"when calling new_BuiltinData in ScmdPlayerCameraSettingsBuiltins, line 80")
call Rxo(aBE,gQV(),"when calling setArgumentsTypes in ScmdPlayerCameraSettingsBuiltins, line 84")
call Foa(ILo(aBE,"when calling new_BuiltinFunction in ScmdPlayerCameraSettingsBuiltins, line 80"),"zoom","when calling registerProtectedBuiltin in ScmdPlayerCameraSettingsBuiltins, line 80")
set EM=EM-1
return true
endfunction
function adE takes nothing returns boolean
set EM=0
return aaE("ScmdPlayerCameraSettingsBuiltins, line 1")
endfunction
function aDE takes nothing returns boolean
return true
endfunction
function afE takes nothing returns nothing
call ForGroupBJ(qs,a0v)
call ForGroupBJ(es,a1v)
endfunction
function aFE takes nothing returns nothing
local group agE=CreateGroup()
call GroupEnumUnitsInRangeOfLoc(agE,GetSpellTargetLoc(),300.,Condition(nwv))
call ForGroup(agE,nWv)
call DestroyGroup(agE)
set agE=null
set agE=null
endfunction
function aGE takes nothing returns nothing
local timer ahE=CreateTimer()
local location aHE=GetUnitLoc(GetSpellAbilityUnit())
local location ajE=GetSpellTargetLoc()
call SaveLocationHandle(nr,GetHandleId(ahE),StringHash("l1"),aHE)
call SaveLocationHandle(nr,GetHandleId(ahE),StringHash("l2"),ajE)
set aHE=null
set ajE=null
call SaveInteger(nr,GetHandleId(ahE),StringHash("i"),1)
call TimerStart(ahE,.1,true,VTv)
set ahE=null
set ahE=null
set aHE=null
set ajE=null
endfunction
function aJE takes nothing returns boolean
return(GetUnitTypeId(GetEnumUnit())!='h000')and(IsUnitSelected(GetEnumUnit(),GetTriggerPlayer()))
endfunction
function akE takes nothing returns boolean
return(GetBooleanAnd(GetUnitAbilityLevelSwapped('A0K7',GetEnumUnit())==0,GetUnitAbilityLevelSwapped('A0K6',GetEnumUnit())==0))
endfunction
function aKE takes nothing returns nothing
if aJE()then
if akE()then
call UnitAddAbilityBJ('A0K6',GetEnumUnit())
call UnitMakeAbilityPermanent(GetEnumUnit(),true,'A0K6')
endif
endif
endfunction
function alE takes nothing returns nothing
set gs[3]=1
loop
exitwhen gs[3]>gs[2]
if IsUnitInGroup(ms[gs[3]],Ys) then
if Fs[gs[3]]<Rs[gs[3]]then
call QueueUnitAnimation(ms[gs[3]],fs[gs[3]])
set xs[1]=GetUnitLoc(ms[gs[3]])
set xs[2]=PolarProjectionBJ(xs[1],js[gs[3]],ds[gs[3]])
if vs[gs[3]] then
call EnumDestructablesInCircleBJ(150.,xs[2],o1v)
endif
call SetUnitPositionLoc(ms[gs[3]],xs[2])
set Fs[gs[3]]=Fs[gs[3]]+js[gs[3]]
if GetRandomInt(1,5)==1 then
call DestroyEffect(AddSpecialEffectTarget(Ts[gs[3]],ms[gs[3]],"chest"))
endif
set ks[gs[3]]=ks[gs[3]]+180./(Rs[gs[3]]/js[gs[3]])
set hs[gs[3]]=SinBJ(ks[gs[3]])*Gs[gs[3]]
call SetUnitFlyHeight(ms[gs[3]],hs[gs[3]],1000000000.)
call RemoveLocation(xs[1])
call RemoveLocation(xs[2])
else
call SetUnitPathing(ms[gs[3]],true)
call GroupRemoveUnit(Ys,ms[gs[3]])
call SetUnitTimeScale(ms[gs[3]],1.)
call SetUnitAnimation(ms[gs[3]],"stand")
call DestroyEffect(AddSpecialEffectTarget("Objects\\Spawnmodels\\Human\\HumanBlood\\HumanBloodKnight.mdl",Ks[gs[3]],"chest"))
call UnitDamageTarget(ms[gs[3]],Ks[gs[3]],225.*(2.-GetUnitState(Ks[gs[3]],UNIT_STATE_LIFE)/GetUnitState(Ks[gs[3]],UNIT_STATE_MAX_LIFE)),true,true,ATTACK_TYPE_MELEE,DAMAGE_TYPE_NORMAL,WEAPON_TYPE_WHOKNOWS)
if GetUnitState(Ks[gs[3]],UNIT_STATE_LIFE)/GetUnitState(Ks[gs[3]],UNIT_STATE_MAX_LIFE)<=.25 then
call pAa(1.)
call UnitRemoveAbility(ms[gs[3]],'AOex')
call UnitAddAbility(ms[gs[3]],'AOex')
call UnitMakeAbilityPermanent(ms[gs[3]],true,'AOex')
endif
set ks[gs[3]]=.0
set gs[1]=gs[1]-1
if gs[1]==0 then
set gs[2]=0
call DisableTrigger(GetTriggeringTrigger())
endif
endif
endif
set gs[3]=gs[3]+1
endloop
endfunction
function aLE takes nothing returns nothing
call KWe(ae,GetEnumUnit())
endfunction
function amE takes nothing returns boolean
return GetEventPlayerChatString()=="ai 1 on" or GetEventPlayerChatString()=="ai 1 off" or GetEventPlayerChatString()=="ai 2 on" or GetEventPlayerChatString()=="ai 2 off"
endfunction
function aME takes nothing returns nothing
if GetUnitTypeId(GetEnumUnit())!='h000' and IsUnitSelected(GetEnumUnit(),GetTriggerPlayer()) and GetUnitAbilityLevel(GetEnumUnit(),'A0JG')==0 and GetUnitAbilityLevel(GetEnumUnit(),'A0JH')==0 then
call UnitAddAbility(GetEnumUnit(),'A0JG')
call UnitMakeAbilityPermanent(GetEnumUnit(),true,'A0JG')
endif
endfunction
function apE takes nothing returns boolean
return(GetSpellAbilityId()=='TMd1')or(GetSpellAbilityId()=='TMd2')or(GetSpellAbilityId()=='TMd3')or(GetSpellAbilityId()=='TMd4')
endfunction
function aPE takes nothing returns boolean
return(gw)and(apE())
endfunction
function aqE takes string aQE returns nothing
local sound asE=CreateSound(aQE,false,true,true,$A,$A,"CombatSoundsEAX")
call SetSoundChannel(asE,5)
call SetSoundVolume(asE,$7F)
call SetSoundPitch(asE,1.)
call SetSoundDistances(asE,999999.,99999.)
call SetSoundDistanceCutoff(asE,99999.)
call SetSoundConeAngles(asE,.0,.0,$7F)
call SetSoundConeOrientation(asE,.0,.0,.0)
call SetSoundPosition(asE,.0,.0,50.)
call StartSound(asE)
call StopSound(asE,false,false)
set asE=null
set asE=null
endfunction
function aSE takes nothing returns nothing
call aqE("Abilities\\Spells\\Orc\\LightningShield\\LightningShieldTarget.wav")
call aqE("Abilities\\Spells\\Orc\\EtherealForm\\SpiritWalkerMorph.wav")
endfunction
function atE takes unit aTE returns nothing
local timer auE=cFv()
call SaveUnitHandle(i,y,GetHandleId(auE),aTE)
call TimerStart(auE,.0,false,sz)
set auE=null
set auE=null
endfunction
function aUE takes nothing returns boolean
call atE(ry)
return true
endfunction
function awE takes string aWE returns boolean
local boolean ayE
set ZM[EM]=aWE
set EM=EM+1
set ayE=o1V(GetFilterUnit(),Xn,"when calling isUnitAccessibleByPlayer in ScmdDataTypes, line 1666")
set EM=EM-1
return ayE
endfunction
function aYE takes nothing returns boolean
set EM=0
return awE("ScmdDataTypes, line 1666")
endfunction
function azE takes nothing returns nothing
set Ju[8]=GetUnitLoc(GetEnumUnit())
call CreateNUnitsAtLoc(1,'h0LE',GetOwningPlayer(Nu),Ju[8],bj_UNIT_FACING)
call UnitAddAbilityBJ('A06N',GetLastCreatedUnit())
call SetUnitAbilityLevelSwapped('A06N',GetLastCreatedUnit(),Mu)
call IssueTargetOrderBJ(GetLastCreatedUnit(),"thunderbolt",GetEnumUnit())
call GroupAddUnitSimple(GetLastCreatedUnit(),Ku)
call SaveIntegerBJ(Du+2,0,GetHandleIdBJ(GetLastCreatedUnit()),Au)
call RemoveLocation(Ju[8])
endfunction
function aZE takes nothing returns nothing
set G=GetUnitLoc(GetEnumUnit())
call CreateDestructableLoc('DTrx',G,270.,1.,0)
call RemoveLocation(G)
endfunction
function a_E takes string a0E returns integer
local integer a1E
set ZM[EM]=a0E
set EM=EM+1
if Cx==0 then
if Vx<$8000 then
set Vx=Vx+1
set a1E=Vx
set Bx[a1E]=$70B
else
call Cdv("Out of memory: Could not create DisjointGroups.","when calling error in ScmdUnitParamLinkingBuiltins, line 15")
set a1E=0
endif
else
set Cx=Cx-1
set a1E=Xx[Cx]
set Bx[a1E]=$70B
endif
set EM=EM-1
return a1E
endfunction
function a2E takes integer a3E,string a4E returns nothing
set ZM[EM]=a4E
set EM=EM+1
set aL[a3E]=PTe("when calling new_IterableMap in ScmdUnitParamLinkingBuiltins, line 17")
set EM=EM-1
endfunction
function a5E takes integer a6E,string a7E returns nothing
set ZM[EM]=a7E
set EM=EM+1
call a2E(a6E,"when calling DisjointGroups_init in ScmdUnitParamLinkingBuiltins, line 15")
set EM=EM-1
endfunction
function a8E takes string a9E returns integer
local integer nvE
set ZM[EM]=a9E
set EM=EM+1
set nvE=a_E("when calling alloc_DisjointGroups in ScmdUnitParamLinkingBuiltins, line 15")
call a5E(nvE,"when calling construct_DisjointGroups in ScmdUnitParamLinkingBuiltins, line 15")
set EM=EM-1
return nvE
endfunction
function neE takes string nxE returns integer
local integer noE
set ZM[EM]=nxE
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set noE=Yj
set Gj[noE]=$AAB
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerBuiltin_ScmdUnitParamLinkingBuiltins.","when calling error in ScmdUnitParamLinkingBuiltins, line 178")
set noE=0
endif
else
set Tj=Tj-1
set noE=Rj[Tj]
set Gj[noE]=$AAB
endif
set EM=EM-1
return noE
endfunction
function nrE takes string niE returns integer
local integer naE
set ZM[EM]=niE
set EM=EM+1
if LG==0 then
if XG<$8000 then
set XG=XG+1
set naE=XG
set CG[naE]=$7B7
else
call Cdv("Out of memory: Could not create EventListener_add_ScmdUnitParamLinkingBuiltins.","when calling error in ScmdUnitParamLinkingBuiltins, line 123")
set naE=0
endif
else
set LG=LG-1
set naE=KG[LG]
set CG[naE]=$7B7
endif
set EM=EM-1
return naE
endfunction
function nnE takes string nVE returns integer
local integer nEE
set ZM[EM]=nVE
set EM=EM+1
if Am==0 then
if Dm<$8000 then
set Dm=Dm+1
set nEE=Dm
else
call Cdv("Out of memory: Could not create Box⟪boolean⟫.","when calling error in Box, line 14")
set nEE=0
endif
else
set Am=Am-1
set nEE=Pm[Am]
endif
set EM=EM-1
return nEE
endfunction
function nXE takes integer kdS returns nothing
endfunction
function nOE takes integer nRE,boolean nIE returns nothing
call nXE(nRE)
set xM[nRE]=nIE
endfunction
function nAE takes boolean nNE,string nbE returns integer
local integer nBE
set ZM[EM]=nbE
set EM=EM+1
set nBE=nnE("when calling alloc_Box⟪boolean⟫ in Box, line 17")
call nOE(nBE,nNE)
set EM=EM-1
return nBE
endfunction
function ncE takes string nCE returns integer
local integer ndE
set ZM[EM]=nCE
set EM=EM+1
if LG==0 then
if XG<$8000 then
set XG=XG+1
set ndE=XG
set CG[ndE]=$7B8
else
call Cdv("Out of memory: Could not create EventListener_add_ScmdUnitParamLinkingBuiltins.","when calling error in ScmdUnitParamLinkingBuiltins, line 135")
set ndE=0
endif
else
set LG=LG-1
set ndE=KG[LG]
set CG[ndE]=$7B8
endif
set EM=EM-1
return ndE
endfunction
function nDE takes string nfE returns integer
local integer nFE
set ZM[EM]=nfE
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set nFE=Yj
set Gj[nFE]=$AAC
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerBuiltin_ScmdUnitParamLinkingBuiltins.","when calling error in ScmdUnitParamLinkingBuiltins, line 188")
set nFE=0
endif
else
set Tj=Tj-1
set nFE=Rj[Tj]
set Gj[nFE]=$AAC
endif
set EM=EM-1
return nFE
endfunction
function ngE takes string nGE returns integer
local integer nhE
set ZM[EM]=nGE
set EM=EM+1
if LG==0 then
if XG<$8000 then
set XG=XG+1
set nhE=XG
set CG[nhE]=$7B5
else
call Cdv("Out of memory: Could not create EventListener_add_ScmdUnitParamLinkingBuiltins.","when calling error in ScmdUnitParamLinkingBuiltins, line 103")
set nhE=0
endif
else
set LG=LG-1
set nhE=KG[LG]
set CG[nhE]=$7B5
endif
set EM=EM-1
return nhE
endfunction
function nHE takes string njE returns integer
local integer nJE
set ZM[EM]=njE
set EM=EM+1
if LG==0 then
if XG<$8000 then
set XG=XG+1
set nJE=XG
set CG[nJE]=$7B6
else
call Cdv("Out of memory: Could not create EventListener_add_ScmdUnitParamLinkingBuiltins.","when calling error in ScmdUnitParamLinkingBuiltins, line 114")
set nJE=0
endif
else
set LG=LG-1
set nJE=KG[LG]
set CG[nJE]=$7B6
endif
set EM=EM-1
return nJE
endfunction
function nkE takes string nKE returns integer
local integer nlE
set ZM[EM]=nKE
set EM=EM+1
if LG==0 then
if XG<$8000 then
set XG=XG+1
set nlE=XG
set CG[nlE]=$7B4
else
call Cdv("Out of memory: Could not create EventListener_add_ScmdUnitParamLinkingBuiltins.","when calling error in ScmdUnitParamLinkingBuiltins, line 90")
set nlE=0
endif
else
set LG=LG-1
set nlE=KG[LG]
set CG[nlE]=$7B4
endif
set EM=EM-1
return nlE
endfunction
function nLE takes string nmE returns integer
local integer nME
set ZM[EM]=nmE
set EM=EM+1
if LG==0 then
if XG<$8000 then
set XG=XG+1
set nME=XG
set CG[nME]=$7B3
else
call Cdv("Out of memory: Could not create EventListener_add_ScmdUnitParamLinkingBuiltins.","when calling error in ScmdUnitParamLinkingBuiltins, line 71")
set nME=0
endif
else
set LG=LG-1
set nME=KG[LG]
set CG[nME]=$7B3
endif
set EM=EM-1
return nME
endfunction
function npE takes integer nPE,string nqE,string nQE,string nsE,string nSE returns nothing
local integer ntE
local integer nTE
local integer nuE
set ZM[EM]=nSE
set EM=EM+1
set ntE=p0v(nPE,"when calling new_SharedPointer in ScmdBuiltinsRegistrar, line 9")
set nTE=0
set nuE=bj_MAX_PLAYERS-1
loop
exitwhen nTE>nuE
call Cie(nTE,nqE,nQE,nsE,MJv(ntE,"when calling clone in ScmdBuiltinsRegistrar, line 11"),"when calling assign in ScmdBuiltinsRegistrar, line 11")
set nTE=nTE+1
endloop
call mfv(17,ntE,"when calling dispatch_SharedPointer_destroySharedPointer in ScmdBuiltinsRegistrar, line 12")
set EM=EM-1
endfunction
function nUE takes integer nwE,string nWE,string nyE returns nothing
set ZM[EM]=nyE
set EM=EM+1
call npE(nwE,nWE,null,null,"when calling registerBuiltin in ScmdBuiltinsRegistrar, line 15")
set EM=EM-1
endfunction
function nYE takes string nzE returns boolean
local integer nZE
local integer n_E
local integer n0E
local integer n1E
local integer n2E
local integer n3E
local integer n4E
local integer n5E
local integer n6E
local integer n7E
local integer n8E
local integer n9E
local integer VvE
local integer VeE
local integer VxE
local playerunitevent VoE
local playerunitevent VrE
local playerunitevent ViE
local playerunitevent VaE
local playerunitevent VnE
local playerunitevent VVE
set ZM[EM]=nzE
set EM=EM+1
set Wd=PTe("when calling new_IterableMap in ScmdUnitParamLinkingBuiltins, line 62")
call oyn(O3v)
set nZE=a8E("when calling new_DisjointGroups in ScmdUnitParamLinkingBuiltins, line 69")
call WTv(Wd,1,nZE,"when calling put in ScmdUnitParamLinkingBuiltins, line 70")
set VoE=EVENT_PLAYER_UNIT_DAMAGED
set n_E=nLE("when calling alloc_EventListener_add_ScmdUnitParamLinkingBuiltins in ScmdUnitParamLinkingBuiltins, line 71")
call Zen(n_E)
set wL[n_E]=nZE
call ZCn(VoE,n_E,"when calling add in ScmdUnitParamLinkingBuiltins, line 71")
set n0E=a8E("when calling new_DisjointGroups in ScmdUnitParamLinkingBuiltins, line 88")
call WTv(Wd,0,n0E,"when calling put in ScmdUnitParamLinkingBuiltins, line 89")
set VrE=EVENT_PLAYER_UNIT_DAMAGED
set n1E=nkE("when calling alloc_EventListener_add_ScmdUnitParamLinkingBuiltins in ScmdUnitParamLinkingBuiltins, line 90")
call Zen(n1E)
set uL[n1E]=n0E
call ZCn(VrE,n1E,"when calling add in ScmdUnitParamLinkingBuiltins, line 90")
set n2E=nAE(false,"when calling new_Box⟪boolean⟫ in ScmdUnitParamLinkingBuiltins, line 99")
set n3E=a8E("when calling new_DisjointGroups in ScmdUnitParamLinkingBuiltins, line 101")
call WTv(Wd,3,n3E,"when calling put in ScmdUnitParamLinkingBuiltins, line 102")
set ViE=EVENT_PLAYER_UNIT_DEATH
set n4E=ngE("when calling alloc_EventListener_add_ScmdUnitParamLinkingBuiltins in ScmdUnitParamLinkingBuiltins, line 103")
call Zen(n4E)
set tL[n4E]=n2E
set iL[n4E]=n3E
call ZCn(ViE,n4E,"when calling add in ScmdUnitParamLinkingBuiltins, line 103")
set n5E=a8E("when calling new_DisjointGroups in ScmdUnitParamLinkingBuiltins, line 112")
call WTv(Wd,4,n5E,"when calling put in ScmdUnitParamLinkingBuiltins, line 113")
set VaE=EVENT_PLAYER_UNIT_ISSUED_ORDER
set n6E=nHE("when calling alloc_EventListener_add_ScmdUnitParamLinkingBuiltins in ScmdUnitParamLinkingBuiltins, line 114")
call Zen(n6E)
set SL[n6E]=n2E
set cL[n6E]=n5E
call ZCn(VaE,n6E,"when calling add in ScmdUnitParamLinkingBuiltins, line 114")
set VnE=EVENT_PLAYER_UNIT_ISSUED_POINT_ORDER
set n7E=nrE("when calling alloc_EventListener_add_ScmdUnitParamLinkingBuiltins in ScmdUnitParamLinkingBuiltins, line 123")
call Zen(n7E)
set oL[n7E]=n2E
set OL[n7E]=n5E
call ZCn(VnE,n7E,"when calling add in ScmdUnitParamLinkingBuiltins, line 123")
set VVE=EVENT_PLAYER_UNIT_ISSUED_TARGET_ORDER
set n8E=ncE("when calling alloc_EventListener_add_ScmdUnitParamLinkingBuiltins in ScmdUnitParamLinkingBuiltins, line 135")
call Zen(n8E)
set lL[n8E]=n2E
set bL[n8E]=n5E
call ZCn(VVE,n8E,"when calling add in ScmdUnitParamLinkingBuiltins, line 135")
set n9E=neE("when calling alloc_IBuiltin_setArgumentsTypes_registerBuiltin_ScmdUnitParamLinkingBuiltins in ScmdUnitParamLinkingBuiltins, line 178")
set VvE=OPo(n9E,"when calling new_BuiltinData in ScmdUnitParamLinkingBuiltins, line 178")
call Rxo(VvE,OFo(),"when calling setArgumentsTypes in ScmdUnitParamLinkingBuiltins, line 187")
call nUE(ILo(VvE,"when calling new_BuiltinFunction in ScmdUnitParamLinkingBuiltins, line 178"),"link","when calling registerBuiltin in ScmdUnitParamLinkingBuiltins, line 178")
set VeE=nDE("when calling alloc_IBuiltin_setArgumentsTypes_registerBuiltin_ScmdUnitParamLinkingBuiltins in ScmdUnitParamLinkingBuiltins, line 188")
set VxE=OPo(VeE,"when calling new_BuiltinData in ScmdUnitParamLinkingBuiltins, line 188")
call Rxo(VxE,OFo(),"when calling setArgumentsTypes in ScmdUnitParamLinkingBuiltins, line 195")
call nUE(ILo(VxE,"when calling new_BuiltinFunction in ScmdUnitParamLinkingBuiltins, line 188"),"unlink","when calling registerBuiltin in ScmdUnitParamLinkingBuiltins, line 188")
set EM=EM-1
set VoE=null
set VrE=null
set ViE=null
set VaE=null
set VnE=null
set VVE=null
return true
endfunction
function VEE takes nothing returns boolean
set EM=0
return nYE("ScmdUnitParamLinkingBuiltins, line 1")
endfunction
function VXE takes nothing returns boolean
return GetBooleanAnd(IsUnitAliveBJ(GetFilterUnit()),IsUnitEnemy(GetFilterUnit(),GetOwningPlayer(Nu)))
endfunction
function VOE takes nothing returns boolean
return(RectContainsLoc(GetPlayableMapRect(),Ju[9])==false)
endfunction
function VRE takes nothing returns nothing
set Ju[9]=GetSpellTargetLoc()
if VOE()then
call IssueImmediateOrderBJ(GetTriggerUnit(),"stop")
set Xu=GetForceOfPlayer(GetOwningPlayer(GetTriggerUnit()))
call DisplayTextToForce(Xu,"TRIGSTR_8544")
call DestroyForce(Xu)
endif
call RemoveLocation(Ju[9])
endfunction
function VIE takes nothing returns nothing
local unit VAE=GetEventDamageSource()
if GetRandomInt(0,$3E8)<='}' then
call UnitRemoveAbility(VAE,'AOcs')
call UnitAddAbility(VAE,'AOcs')
call GroupAddUnit(kt,VAE)
call pAa(10.)
call GroupRemoveUnit(kt,VAE)
else
call GroupAddUnit(kt,VAE)
call pAa(1.)
call GroupRemoveUnit(kt,VAE)
endif
set VAE=null
set VAE=null
endfunction
function VNE takes nothing returns nothing
local unit VbE=GetEventDamageSource()
call GroupAddUnit(jt,VbE)
call UnitDamageTarget(VbE,GetTriggerUnit(),GetEventDamage()*.75,true,true,ATTACK_TYPE_NORMAL,DAMAGE_TYPE_MAGIC,WEAPON_TYPE_WHOKNOWS)
call GroupRemoveUnit(jt,VbE)
set VbE=null
set VbE=null
endfunction
function VBE takes nothing returns nothing
if GetUnitAbilityLevel(GetTriggerUnit(),'BOcs')>0 and IsUnitInGroup(GetEventDamageSource(),jt)==false then
call VNE()
endif
if GetUnitAbilityLevel(GetEventDamageSource(),'AOcs')>0 and IsUnitInGroup(GetEventDamageSource(),kt)==false then
call VIE()
endif
endfunction
function VcE takes nothing returns boolean
return(GetSpellAbilityId()=='A0GL')
endfunction
function VCE takes nothing returns nothing
call UnitAddAbilityBJ('Arbr',GetSpellAbilityUnit())
call UnitAddAbilityBJ('A0CY',GetSpellAbilityUnit())
call UnitRemoveAbilityBJ('A0CX',GetSpellAbilityUnit())
endfunction
function VdE takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),1,9)=="watertint")and(S2R(SubStringBJ(GetEventPlayerChatString(),$B,$D))<=100.)and(S2R(SubStringBJ(GetEventPlayerChatString(),$B,$D))>=.0)and(S2R(SubStringBJ(GetEventPlayerChatString(),$E,16))<=100.)and(S2R(SubStringBJ(GetEventPlayerChatString(),$E,16))>=.0)and(S2R(SubStringBJ(GetEventPlayerChatString(),17,19))<=100.)and(S2R(SubStringBJ(GetEventPlayerChatString(),17,19))>=.0)and(S2R(SubStringBJ(GetEventPlayerChatString(),20,22))<=100.)and(S2R(SubStringBJ(GetEventPlayerChatString(),20,22))>=.0)
endfunction
function VDE takes nothing returns nothing
call GroupRemoveUnit(ql,LoadUnitHandle(i,y,GetHandleId(GetExpiredTimer())))
call Gmv(GetExpiredTimer())
endfunction
function VfE takes nothing returns boolean
return true
endfunction
function VFE takes nothing returns boolean
return(GetEventPlayerChatString()=="@allhero")
endfunction
function VgE takes nothing returns boolean
return(GetEventPlayerChatString()=="@allunit")
endfunction
function VGE takes nothing returns nothing
set g[GetConvertedPlayerId(GetTriggerPlayer())]=GetUnitsOfPlayerAll(GetTriggerPlayer())
if VgE()then
call ForGroupBJ(g[GetConvertedPlayerId(GetTriggerPlayer())],eWv)
call DestroyGroup(g[GetPlayerId(GetTriggerPlayer())+1])
return
endif
if VFE()then
call ForGroupBJ(g[GetConvertedPlayerId(GetTriggerPlayer())],eyv)
call DestroyGroup(g[GetPlayerId(GetTriggerPlayer())+1])
return
endif
endfunction
function VhE takes nothing returns nothing
local unit VHE=GetSpellAbilityUnit()
if GetSpellAbilityId()=='AcS5' then
call UnitRemoveAbility(VHE,'AcB5')
call UnitAddAbility(VHE,'AcB6')
call UnitMakeAbilityPermanent(VHE,true,'AcB6')
call UnitRemoveAbility(VHE,'AInv')
else
call UnitRemoveAbility(VHE,'AcB6')
call UnitAddAbility(VHE,'AcB5')
call UnitMakeAbilityPermanent(VHE,true,'AcB5')
call UnitAddAbility(VHE,'AInv')
call UnitMakeAbilityPermanent(VHE,true,'AInv')
endif
set VHE=null
set VHE=null
endfunction
function VjE takes nothing returns boolean
return IsUnitSelected(GetFilterUnit(),GetTriggerPlayer())
endfunction
function VJE takes nothing returns boolean
return IsUnitSelected(GetFilterUnit(),GetTriggerPlayer())
endfunction
function VkE takes string VKE returns boolean
local boolean VlE
set ZM[EM]=VKE
set EM=EM+1
set VlE=not Mla(umv(GetFilterUnit()),"when calling isUnitTypeProtected in SotfrpGuiRegions, line 139")
set EM=EM-1
return VlE
endfunction
function VLE takes nothing returns boolean
set EM=0
return VkE("SotfrpGuiRegions, line 139")
endfunction
function VmE takes nothing returns boolean
return GetBooleanAnd(IsUnitAliveBJ(GetFilterUnit()),IsUnitEnemy(GetFilterUnit(),GetOwningPlayer(Nu)))
endfunction
function VME takes nothing returns boolean
return(IsTriggerEnabled(Kt)==false)
endfunction
function VpE takes nothing returns nothing
call GroupAddUnitSimple(GetTriggerUnit(),Hu)
set Ju[0]=GetSpellTargetLoc()
set Cu=GetConvertedPlayerId(GetOwningPlayer(GetTriggerUnit()))-1
call SaveLocationHandleBJ(Ju[0],0,GetHandleIdBJ(GetTriggerUnit()),Au)
call CreateNUnitsAtLoc(1,'h0LF',GetOwningPlayer(GetTriggerUnit()),Ju[0],90.)
call SetUnitScalePercent(GetLastCreatedUnit(),Gu,Gu,Gu)
call SetUnitVertexColorBJ(GetLastCreatedUnit(),100.,100.,100.,100.)
if GetLocalPlayer()==Player(Cu)then
call SetUnitVertexColorBJ(GetLastCreatedUnit(),100.,100.,100.,.0)
endif
call SaveUnitHandleBJ(GetLastCreatedUnit(),2,GetHandleIdBJ(GetTriggerUnit()),Au)
call CreateNUnitsAtLoc(1,'h0LF',GetOwningPlayer(GetTriggerUnit()),Ju[0],90.)
call SetUnitScalePercent(GetLastCreatedUnit(),gu,gu,gu)
call SetUnitVertexColorBJ(GetLastCreatedUnit(),100.,100.,100.,100.)
if GetLocalPlayer()==Player(Cu)then
call SetUnitVertexColorBJ(GetLastCreatedUnit(),100.,100.,100.,.0)
endif
call SaveUnitHandleBJ(GetLastCreatedUnit(),3,GetHandleIdBJ(GetTriggerUnit()),Au)
call SaveIntegerBJ(Du+5,4,GetHandleIdBJ(GetTriggerUnit()),Au)
call UnitAddAbilityBJ('A06X',GetTriggerUnit())
call SetUnitAbilityLevelSwapped('A06X',GetTriggerUnit(),GetUnitAbilityLevelSwapped('A0EH',GetTriggerUnit()))
call SetPlayerAbilityAvailableBJ(false,'A0EH',GetOwningPlayer(GetTriggerUnit()))
if VME()then
call EnableTrigger(Kt)
endif
endfunction
function VPE takes nothing returns nothing
local integer gxa=0
local integer OsV=bj_MAX_PLAYER_SLOTS-1
loop
exitwhen gxa>OsV
set sa[gxa]=Player(gxa)
set gxa=gxa+1
endloop
endfunction
function VqE takes nothing returns boolean
set ta=GetLocalPlayer()
call VPE()
return true
endfunction
function VQE takes string VsE returns integer
local integer VSE
set ZM[EM]=VsE
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set VSE=Yj
set Gj[VSE]=$B29
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_addOverload_addOverload_registerProtectedBuiltin_SotFRP_AbilitySystem.","when calling error in SotFRP_AbilitySystem, line 48")
set VSE=0
endif
else
set Tj=Tj-1
set VSE=Rj[Tj]
set Gj[VSE]=$B29
endif
set EM=EM-1
return VSE
endfunction
function VtE takes string VTE returns integer
local integer VuE
set ZM[EM]=VTE
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set VuE=Yj
set Gj[VuE]=$B28
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_addOverload_addOverload_registerProtectedBuiltin_SotFRP_AbilitySystem.","when calling error in SotFRP_AbilitySystem, line 45")
set VuE=0
endif
else
set Tj=Tj-1
set VuE=Rj[Tj]
set Gj[VuE]=$B28
endif
set EM=EM-1
return VuE
endfunction
function VUE takes string VwE returns integer
local integer VWE
set ZM[EM]=VwE
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set VWE=Yj
set Gj[VWE]=$A36
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_addOverload_registerProtectedBuiltin_SotFRP_AbilitySystem.","when calling error in SotFRP_AbilitySystem, line 51")
set VWE=0
endif
else
set Tj=Tj-1
set VWE=Rj[Tj]
set Gj[VWE]=$A36
endif
set EM=EM-1
return VWE
endfunction
function VyE takes string VYE returns integer
local integer VzE
set ZM[EM]=VYE
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set VzE=Yj
set Gj[VzE]=$B6C
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_SotFRP_AbilitySystem.","when calling error in SotFRP_AbilitySystem, line 79")
set VzE=0
endif
else
set Tj=Tj-1
set VzE=Rj[Tj]
set Gj[VzE]=$B6C
endif
set EM=EM-1
return VzE
endfunction
function VZE takes string V_E returns integer
local integer V0E
set ZM[EM]=V_E
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set V0E=Yj
set Gj[V0E]=$B6B
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_SotFRP_AbilitySystem.","when calling error in SotFRP_AbilitySystem, line 72")
set V0E=0
endif
else
set Tj=Tj-1
set V0E=Rj[Tj]
set Gj[V0E]=$B6B
endif
set EM=EM-1
return V0E
endfunction
function V1E takes string V2E returns integer
local integer V3E
set ZM[EM]=V2E
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set V3E=Yj
set Gj[V3E]=$A9F
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_SotFRP_AbilitySystem.","when calling error in SotFRP_AbilitySystem, line 61")
set V3E=0
endif
else
set Tj=Tj-1
set V3E=Rj[Tj]
set Gj[V3E]=$A9F
endif
set EM=EM-1
return V3E
endfunction
function V4E takes string V5E returns integer
local integer V6E
set ZM[EM]=V5E
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set V6E=Yj
set Gj[V6E]=$AA1
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_SotFRP_AbilitySystem.","when calling error in SotFRP_AbilitySystem, line 75")
set V6E=0
endif
else
set Tj=Tj-1
set V6E=Rj[Tj]
set Gj[V6E]=$AA1
endif
set EM=EM-1
return V6E
endfunction
function V7E takes string V8E returns integer
local integer V9E
set ZM[EM]=V8E
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set V9E=Yj
set Gj[V9E]=$AA2
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_SotFRP_AbilitySystem.","when calling error in SotFRP_AbilitySystem, line 82")
set V9E=0
endif
else
set Tj=Tj-1
set V9E=Rj[Tj]
set Gj[V9E]=$AA2
endif
set EM=EM-1
return V9E
endfunction
function EvE takes string EeE returns integer
local integer ExE
set ZM[EM]=EeE
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set ExE=Yj
set Gj[ExE]=$B6A
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_SotFRP_AbilitySystem.","when calling error in SotFRP_AbilitySystem, line 65")
set ExE=0
endif
else
set Tj=Tj-1
set ExE=Rj[Tj]
set Gj[ExE]=$B6A
endif
set EM=EM-1
return ExE
endfunction
function EoE takes string ErE returns integer
local integer EiE
set ZM[EM]=ErE
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set EiE=Yj
set Gj[EiE]=$AA0
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_SotFRP_AbilitySystem.","when calling error in SotFRP_AbilitySystem, line 68")
set EiE=0
endif
else
set Tj=Tj-1
set EiE=Rj[Tj]
set Gj[EiE]=$AA0
endif
set EM=EM-1
return EiE
endfunction
function EaE takes string EnE returns integer
local integer EVE
set ZM[EM]=EnE
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set EVE=Yj
set Gj[EVE]=$B69
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_SotFRP_AbilitySystem.","when calling error in SotFRP_AbilitySystem, line 58")
set EVE=0
endif
else
set Tj=Tj-1
set EVE=Rj[Tj]
set Gj[EVE]=$B69
endif
set EM=EM-1
return EVE
endfunction
function EEE takes string EXE returns integer
local integer EOE
set ZM[EM]=EXE
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set EOE=Yj
set Gj[EOE]=$A9E
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_SotFRP_AbilitySystem.","when calling error in SotFRP_AbilitySystem, line 54")
set EOE=0
endif
else
set Tj=Tj-1
set EOE=Rj[Tj]
set Gj[EOE]=$A9E
endif
set EM=EM-1
return EOE
endfunction
function ERE takes string EIE returns boolean
local integer EAE
local integer ENE
local integer EbE
local integer EBE
local integer EcE
local integer ECE
local integer EdE
local integer EDE
local integer EfE
local integer EFE
local integer EgE
local integer EGE
local integer EhE
local integer EHE
local integer EjE
local integer EJE
local integer EkE
local integer EKE
local integer ElE
local integer ELE
local integer EmE
local integer EME
local integer EpE
local integer EPE
local integer EqE
local integer EQE
local integer EsE
local integer ESE
local integer EtE
local integer ETE
local integer EuE
local integer EUE
local integer EwE
local integer EWE
local integer EyE
local integer EYE
local integer EzE
local integer EZE
local integer E_E
local integer E0E
local integer E1E
local integer E2E
local integer E3E
local integer E4E
set ZM[EM]=EIE
set EM=EM+1
set EAE=VtE("when calling alloc_IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_addOverload_addOverload_registerProtectedBuiltin_SotFRP_AbilitySystem in SotFRP_AbilitySystem, line 45")
set ENE=OPo(EAE,"when calling new_BuiltinData in SotFRP_AbilitySystem, line 45")
call Rxo(ENE,OFo(),"when calling setArgumentsTypes in SotFRP_AbilitySystem, line 48")
set EbE=ENE
call LWV(EbE,"when calling setRequiringEnumUnit in SotFRP_AbilitySystem, line 48")
set EdE=ILo(EbE,"when calling new_BuiltinFunction in SotFRP_AbilitySystem, line 45")
set EZE=EdE
set EBE=VQE("when calling alloc_IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_addOverload_addOverload_registerProtectedBuiltin_SotFRP_AbilitySystem in SotFRP_AbilitySystem, line 48")
set EcE=OPo(EBE,"when calling new_BuiltinData in SotFRP_AbilitySystem, line 48")
call FRa(EcE,OFo(),f3a(),"when calling setArgumentsTypes in SotFRP_AbilitySystem, line 51")
set ECE=EcE
call LWV(ECE,"when calling setRequiringEnumUnit in SotFRP_AbilitySystem, line 51")
call IFo(EZE,ECE,"when calling addOverload in SotFRP_AbilitySystem, line 48")
set EFE=EdE
set E_E=EFE
set EDE=VUE("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_addOverload_registerProtectedBuiltin_SotFRP_AbilitySystem in SotFRP_AbilitySystem, line 51")
set EfE=OPo(EDE,"when calling new_BuiltinData in SotFRP_AbilitySystem, line 51")
call FRa(EfE,e4V(),OFo(),"when calling setArgumentsTypes in SotFRP_AbilitySystem, line 54")
call IFo(E_E,EfE,"when calling addOverload in SotFRP_AbilitySystem, line 51")
set EhE=EFE
set E0E=EhE
set EgE=EEE("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_SotFRP_AbilitySystem in SotFRP_AbilitySystem, line 54")
set EGE=OPo(EgE,"when calling new_BuiltinData in SotFRP_AbilitySystem, line 54")
call etV(EGE,e4V(),OFo(),f3a(),"when calling setArgumentsTypes in SotFRP_AbilitySystem, line 57")
call IFo(E0E,EGE,"when calling addOverload in SotFRP_AbilitySystem, line 54")
call g_V(EhE,fNV(KCv("addability","when calling stringToIndex in SotFRP_AbilitySystem, line 57"),KCv("'","when calling stringToIndex in SotFRP_AbilitySystem, line 57"),"when calling asList in SotFRP_AbilitySystem, line 57"),"when calling registerProtectedBuiltin in SotFRP_AbilitySystem, line 45")
set EHE=EaE("when calling alloc_IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_SotFRP_AbilitySystem in SotFRP_AbilitySystem, line 58")
set EjE=OPo(EHE,"when calling new_BuiltinData in SotFRP_AbilitySystem, line 58")
call Rxo(EjE,OFo(),"when calling setArgumentsTypes in SotFRP_AbilitySystem, line 61")
set EJE=EjE
call LWV(EJE,"when calling setRequiringEnumUnit in SotFRP_AbilitySystem, line 61")
set ElE=ILo(EJE,"when calling new_BuiltinFunction in SotFRP_AbilitySystem, line 58")
set E1E=ElE
set EkE=V1E("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_SotFRP_AbilitySystem in SotFRP_AbilitySystem, line 61")
set EKE=OPo(EkE,"when calling new_BuiltinData in SotFRP_AbilitySystem, line 61")
call FRa(EKE,e4V(),OFo(),"when calling setArgumentsTypes in SotFRP_AbilitySystem, line 64")
call IFo(E1E,EKE,"when calling addOverload in SotFRP_AbilitySystem, line 61")
call g_V(ElE,fNV(KCv("removeability","when calling stringToIndex in SotFRP_AbilitySystem, line 64"),KCv("@","when calling stringToIndex in SotFRP_AbilitySystem, line 64"),"when calling asList in SotFRP_AbilitySystem, line 64"),"when calling registerProtectedBuiltin in SotFRP_AbilitySystem, line 58")
set ELE=EvE("when calling alloc_IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_SotFRP_AbilitySystem in SotFRP_AbilitySystem, line 65")
set EmE=OPo(ELE,"when calling new_BuiltinData in SotFRP_AbilitySystem, line 65")
call FRa(EmE,OFo(),f3a(),"when calling setArgumentsTypes in SotFRP_AbilitySystem, line 68")
set EME=EmE
call LWV(EME,"when calling setRequiringEnumUnit in SotFRP_AbilitySystem, line 68")
set EqE=ILo(EME,"when calling new_BuiltinFunction in SotFRP_AbilitySystem, line 65")
set E2E=EqE
set EpE=EoE("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_SotFRP_AbilitySystem in SotFRP_AbilitySystem, line 68")
set EPE=OPo(EpE,"when calling new_BuiltinData in SotFRP_AbilitySystem, line 68")
call etV(EPE,e4V(),OFo(),f3a(),"when calling setArgumentsTypes in SotFRP_AbilitySystem, line 71")
call IFo(E2E,EPE,"when calling addOverload in SotFRP_AbilitySystem, line 68")
call Foa(EqE,"setabilitylevel","when calling registerProtectedBuiltin in SotFRP_AbilitySystem, line 65")
set EQE=VZE("when calling alloc_IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_SotFRP_AbilitySystem in SotFRP_AbilitySystem, line 72")
set EsE=OPo(EQE,"when calling new_BuiltinData in SotFRP_AbilitySystem, line 72")
call etV(EsE,OFo(),f3a(),f3a(),"when calling setArgumentsTypes in SotFRP_AbilitySystem, line 75")
set ESE=EsE
call LWV(ESE,"when calling setRequiringEnumUnit in SotFRP_AbilitySystem, line 75")
set EuE=ILo(ESE,"when calling new_BuiltinFunction in SotFRP_AbilitySystem, line 72")
set E3E=EuE
set EtE=V4E("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_SotFRP_AbilitySystem in SotFRP_AbilitySystem, line 75")
set ETE=OPo(EtE,"when calling new_BuiltinData in SotFRP_AbilitySystem, line 75")
call glV(ETE,e4V(),OFo(),f3a(),f3a(),"when calling setArgumentsTypes in SotFRP_AbilitySystem, line 78")
call IFo(E3E,ETE,"when calling addOverload in SotFRP_AbilitySystem, line 75")
call Foa(EuE,"setabilitymanacost","when calling registerProtectedBuiltin in SotFRP_AbilitySystem, line 72")
set EUE=VyE("when calling alloc_IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_SotFRP_AbilitySystem in SotFRP_AbilitySystem, line 79")
set EwE=OPo(EUE,"when calling new_BuiltinData in SotFRP_AbilitySystem, line 79")
call etV(EwE,OFo(),f3a(),gQV(),"when calling setArgumentsTypes in SotFRP_AbilitySystem, line 82")
set EWE=EwE
call LWV(EWE,"when calling setRequiringEnumUnit in SotFRP_AbilitySystem, line 82")
set EzE=ILo(EWE,"when calling new_BuiltinFunction in SotFRP_AbilitySystem, line 79")
set E4E=EzE
set EyE=V7E("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_SotFRP_AbilitySystem in SotFRP_AbilitySystem, line 82")
set EYE=OPo(EyE,"when calling new_BuiltinData in SotFRP_AbilitySystem, line 82")
call glV(EYE,e4V(),OFo(),f3a(),gQV(),"when calling setArgumentsTypes in SotFRP_AbilitySystem, line 85")
call IFo(E4E,EYE,"when calling addOverload in SotFRP_AbilitySystem, line 82")
call Foa(EzE,"setabilitycooldown","when calling registerProtectedBuiltin in SotFRP_AbilitySystem, line 79")
set EM=EM-1
return true
endfunction
function E5E takes nothing returns boolean
set EM=0
return ERE("SotFRP_AbilitySystem, line 1")
endfunction
function E6E takes nothing returns nothing
local integer E7E=1
loop
exitwhen E7E>$3B9ACA00
if GetSpellAbilityUnit()==Gr[E7E]then
call GroupRemoveUnit(ps,Gr[E7E])
call DestroyEffect(AddSpecialEffectLoc("Abilities\\Spells\\Human\\MassTeleport\\MassTeleportCaster.mdl",GetUnitLoc(Gr[E7E])))
call SetUnitPositionLoc(Gr[E7E],gr[E7E])
call DestroyEffect(AddSpecialEffectLoc("Abilities\\Spells\\Human\\MassTeleport\\MassTeleportTarget.mdl",GetUnitLoc(Gr[E7E])))
set Gr[E7E]=null
set gr[E7E]=null
return
endif
set E7E=E7E+1
endloop
set E7E=0
endfunction
function E8E takes nothing returns nothing
local unit E9E=GetSpellAbilityUnit()
local integer XvE=0
local integer XeE=GetUnitAbilityLevel(E9E,'A0EU')
if IsUnitInGroup(E9E,st) then
call GroupRemoveUnit(st,E9E)
call pAa(1.)
endif
call GroupAddUnit(st,E9E)
call DestroyEffect(AddSpecialEffectTarget("Abilities\\Spells\\Human\\InnerFire\\InnerFireTarget.mdl",E9E,"overhead"))
call UnitAddAbility(E9E,'A0EV')
call UnitMakeAbilityPermanent(E9E,true,'A0EV')
call SetUnitAbilityLevel(E9E,'A0EV',XeE)
call UnitAddAbility(E9E,'A0JN')
call UnitMakeAbilityPermanent(E9E,true,'A0JN')
call SetUnitAbilityLevel(E9E,'A0JN',XeE)
set XeE=0
loop
exitwhen IsUnitInGroup(E9E,st)==false
call pAa(1.)
set XvE=XvE+1
if XvE==5 or GetUnitState(E9E,UNIT_STATE_LIFE)<=.0 then
call GroupRemoveUnit(st,E9E)
endif
endloop
call UnitRemoveAbility(E9E,'A0EV')
call UnitRemoveAbility(E9E,'A0JN')
call UnitRemoveAbility(E9E,'B031')
set E9E=null
set XvE=0
set E9E=null
endfunction
function XxE takes nothing returns nothing
local unit XoE=GetSpellAbilityUnit()
local effect XrE=AddSpecialEffectTarget("Abilities\\Spells\\Orc\\EtherealForm\\SpiritWalkerChange.mdl",XoE,"chest")
call iAV("Abilities\\Spells\\Orc\\EtherealForm\\SpiritWalkerMorph.wav",GetUnitX(XoE),GetUnitY(XoE))
if GetSpellAbilityId()=='A0FC' then
call UnitRemoveAbility(XoE,'A0FC')
call UnitAddAbility(XoE,'A0FD')
call UnitMakeAbilityPermanent(XoE,true,'A0FD')
call UnitAddAbility(XoE,'A0FF')
call UnitMakeAbilityPermanent(XoE,true,'A0FF')
else
call UnitRemoveAbility(XoE,'A0FD')
call UnitRemoveAbility(XoE,'A0FF')
call UnitAddAbility(XoE,'A0FC')
call UnitMakeAbilityPermanent(XoE,true,'A0FC')
endif
call pAa(.934)
call DestroyEffect(XrE)
set XoE=null
set XrE=null
set XoE=null
set XrE=null
endfunction
function XiE takes nothing returns nothing
local unit XaE=GetEnumUnit()
local unit XnE=CreateUnitAtLoc(Player($F),'h0JO',GetUnitLoc(XaE),270.)
call UnitAddAbility(XnE,'A091')
call SetUnitAbilityLevel(XnE,'A091',GetUnitAbilityLevel(GetSpellAbilityUnit(),'A090'))
call IssueTargetOrderById(XnE,$D0216,XaE)
call oLn(XnE,3.)
set XaE=null
set XnE=null
set XaE=null
set XnE=null
endfunction
function XVE takes nothing returns nothing
call SetWaterBaseColorBJ(S2R(SubStringBJ(GetEventPlayerChatString(),$B,$D)),S2R(SubStringBJ(GetEventPlayerChatString(),$E,16)),S2R(SubStringBJ(GetEventPlayerChatString(),17,19)),S2R(SubStringBJ(GetEventPlayerChatString(),20,22)))
endfunction
function XEE takes nothing returns nothing
local string XXE=GetEventPlayerChatString()
local player XOE=GetTriggerPlayer()
local group XRE
set g[GetConvertedPlayerId(XOE)]=GetUnitsOfPlayerAndTypeId(XOE,'h000')
if XXE=="remove gate" then
call ForGroup(g[GetConvertedPlayerId(XOE)],xkv)
else
set XRE=CreateGroup()
call GroupEnumUnitsOfPlayer(XRE,XOE,Condition(eFv))
if XXE=="destroy gate" then
call ForGroup(XRE,xKv)
elseif XXE=="open gate" then
call ForGroup(XRE,xlv)
elseif XXE=="close gate" then
call ForGroup(XRE,xLv)
endif
call DestroyGroup(XRE)
set XRE=null
endif
call DestroyGroup(g[GetPlayerId(XOE)+1])
set XOE=null
set XOE=null
set XRE=null
endfunction
function XIE takes nothing returns boolean
return true
endfunction
function XAE takes nothing returns nothing
local destructable XNE=GetSpellTargetDestructable()
call SetDestructableInvulnerable(XNE,true)
call KillDestructable(XNE)
call RemoveDestructable(XNE)
set XNE=null
set XNE=null
endfunction
function XbE takes nothing returns boolean
return GetUnitTypeId(GetSpellAbilityUnit())=='h000'
endfunction
function XBE takes unit XcE,location XCE returns boolean
if RectContainsUnit(RectFromCenterSizeBJ(XCE,50.,50.),XcE) then
return true
else
return false
endif
endfunction
function XdE takes nothing returns nothing
local location XDE=GetSpellTargetLoc()
local unit XfE=CreateUnitAtLoc(GetOwningPlayer(GetSpellAbilityUnit()),'h0PM',GetUnitLoc(GetSpellAbilityUnit()),GetUnitFacing(GetSpellAbilityUnit()))
local real XFE
call UnitAddAbility(XfE,'A0GC')
call SetUnitAbilityLevel(XfE,'A0GC',GetUnitAbilityLevel(GetSpellAbilityUnit(),'A0GG'))
call UnitAddAbility(XfE,'A0GX')
call SetUnitAbilityLevel(XfE,'A0GX',GetUnitAbilityLevel(GetSpellAbilityUnit(),'A0GG'))
set XFE=20+$A*GetUnitAbilityLevel(GetSpellAbilityUnit(),'A0GG')
call SetUnitPathing(XfE,false)
call IssuePointOrderByIdLoc(XfE,$D0012,XDE)
loop
call PolledWait(.1)
exitwhen XBE(XfE,XDE)
endloop
call UnitDamagePointLoc(XfE,.0,200.,XDE,XFE,ATTACK_TYPE_NORMAL,DAMAGE_TYPE_FIRE)
call KillUnit(XfE)
set XfE=null
set XDE=null
set XFE=.0
set XfE=null
set XDE=null
endfunction
function XgE takes nothing returns nothing
local group XGE=CreateGroup()
call GroupEnumUnitsOfPlayer(XGE,GetTriggerPlayer(),Condition(eFv))
if GetEventPlayerChatString()=="ai 1 on" then
call ForGroup(XGE,egv)
elseif GetEventPlayerChatString()=="ai 1 off" then
call ForGroup(XGE,eGv)
elseif GetEventPlayerChatString()=="ai 2 on" then
call ForGroup(XGE,ehv)
else
call ForGroup(XGE,eHv)
endif
call DestroyGroup(XGE)
set XGE=null
set XGE=null
endfunction
function XhE takes nothing returns nothing
if GetUnitTypeId(GetEnumUnit())!='h000' and IsUnitSelected(GetEnumUnit(),GetTriggerPlayer()) then
call GroupAddUnit(Xs,GetEnumUnit())
endif
endfunction
function XHE takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),1,4)=="item")
endfunction
function XjE takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),1,3)=="sfx")
endfunction
function XJE takes nothing returns boolean
return(GetEventPlayerChatString()=="elevator 2")
endfunction
function XkE takes nothing returns boolean
return(GetEventPlayerChatString()=="elevator 1")
endfunction
function XKE takes nothing returns boolean
return(GetEventPlayerChatString()=="remove elevator")
endfunction
function XlE takes nothing returns nothing
set g[GetConvertedPlayerId(GetTriggerPlayer())]=GetUnitsOfPlayerAndTypeId(GetTriggerPlayer(),'h000')
if XkE()then
call ForGroupBJ(g[GetConvertedPlayerId(GetTriggerPlayer())],vCv)
endif
if XJE()then
call ForGroupBJ(g[GetConvertedPlayerId(GetTriggerPlayer())],vdv)
endif
if XKE()then
call ForGroupBJ(g[GetConvertedPlayerId(GetTriggerPlayer())],vDv)
endif
call DestroyGroup(g[GetPlayerId(GetTriggerPlayer())+1])
endfunction
function XLE takes string XmE returns boolean
local integer XME
local integer XpE
set ZM[EM]=XmE
set EM=EM+1
call Ctv("when calling new_HashMap in SotFRP_Init, line 8")
call Ctv("when calling new_HashMap in SotFRP_Init, line 9")
set XME=0
set XpE=bj_MAX_PLAYER_SLOTS-1
loop
exitwhen XME>XpE
call Xsx(sa[XME],qf,"when calling setLocale in SotFRP_Init, line 17")
set XME=XME+1
endloop
set EM=EM-1
return true
endfunction
function XPE takes nothing returns boolean
set EM=0
return XLE("SotFRP_Init, line 1")
endfunction
function XqE takes nothing returns boolean
return(GetSpellAbilityId()=='A07X')
endfunction
function XQE takes nothing returns boolean
return GetSpellAbilityId()=='A09V'
endfunction
function XsE takes nothing returns nothing
call ForGroup(GetUnitsInRangeOfLocMatching(800.,GetUnitLoc(GetSpellAbilityUnit()),Condition(awv)),aWv)
endfunction
function XSE takes nothing returns boolean
return GetSpellAbilityId()=='A08W'
endfunction
function XtE takes nothing returns boolean
return GetSpellAbilityId()=='AOsm'
endfunction
function XTE takes nothing returns nothing
local unit XuE=GetSpellAbilityUnit()
local location XUE=GetSpellTargetLoc()
local location XwE=GetUnitLoc(XuE)
local effect XWE=AddSpecialEffect("Abilities\\Spells\\Other\\NoblePhantasm\\NoblePhantasm.mdx",GetLocationX(XwE)+200.*Cos(Atan2(GetLocationY(XUE)-GetLocationY(XwE),GetLocationX(XUE)-GetLocationX(XwE))),GetLocationY(XwE)+200.*Sin(Atan2(GetLocationY(XUE)-GetLocationY(XwE),GetLocationX(XUE)-GetLocationX(XwE))))
local effect XyE=AddSpecialEffect("Abilities\\Spells\\Other\\NoblePhantasm\\NoblePhantasm.mdx",GetLocationX(XwE)+400.*Cos(Atan2(GetLocationY(XUE)-GetLocationY(XwE),GetLocationX(XUE)-GetLocationX(XwE))),GetLocationY(XwE)+400.*Sin(Atan2(GetLocationY(XUE)-GetLocationY(XwE),GetLocationX(XUE)-GetLocationX(XwE))))
local effect XYE=AddSpecialEffect("Abilities\\Spells\\Other\\NoblePhantasm\\NoblePhantasm.mdx",GetLocationX(XwE)+600.*Cos(Atan2(GetLocationY(XUE)-GetLocationY(XwE),GetLocationX(XUE)-GetLocationX(XwE))),GetLocationY(XwE)+600.*Sin(Atan2(GetLocationY(XUE)-GetLocationY(XwE),GetLocationX(XUE)-GetLocationX(XwE))))
local boolean XzE=BlzIsUnitInvulnerable(XuE)
if XzE==false then
call SetUnitInvulnerable(XuE,true)
endif
call UnitDamagePoint(XuE,.0,200.,GetLocationX(XwE)+200.*Cos(Atan2(GetLocationY(XUE)-GetLocationY(XwE),GetLocationX(XUE)-GetLocationX(XwE))),GetLocationY(XwE)+200.*Sin(Atan2(GetLocationY(XUE)-GetLocationY(XwE),GetLocationX(XUE)-GetLocationX(XwE))),350.,true,true,ATTACK_TYPE_NORMAL,DAMAGE_TYPE_MAGIC,WEAPON_TYPE_WHOKNOWS)
call UnitDamagePoint(XuE,.0,200.,GetLocationX(XwE)+400.*Cos(Atan2(GetLocationY(XUE)-GetLocationY(XwE),GetLocationX(XUE)-GetLocationX(XwE))),GetLocationY(XwE)+400.*Sin(Atan2(GetLocationY(XUE)-GetLocationY(XwE),GetLocationX(XUE)-GetLocationX(XwE))),350.,true,true,ATTACK_TYPE_NORMAL,DAMAGE_TYPE_MAGIC,WEAPON_TYPE_WHOKNOWS)
call UnitDamagePoint(XuE,.0,200.,GetLocationX(XwE)+600.*Cos(Atan2(GetLocationY(XUE)-GetLocationY(XwE),GetLocationX(XUE)-GetLocationX(XwE))),GetLocationY(XwE)+600.*Sin(Atan2(GetLocationY(XUE)-GetLocationY(XwE),GetLocationX(XUE)-GetLocationX(XwE))),350.,true,true,ATTACK_TYPE_NORMAL,DAMAGE_TYPE_MAGIC,WEAPON_TYPE_WHOKNOWS)
if XzE==false then
call SetUnitInvulnerable(XuE,false)
endif
set XzE=false
call RemoveLocation(XUE)
call RemoveLocation(XwE)
set XUE=null
set XwE=null
set XuE=null
call cRv(XWE,2.)
call cRv(XyE,2.)
call cRv(XYE,2.)
set XWE=null
set XyE=null
set XYE=null
set XuE=null
set XUE=null
set XwE=null
set XWE=null
set XyE=null
set XYE=null
endfunction
function XZE takes nothing returns nothing
if GetUnitAbilityLevel(GetSpellTargetUnit(),'A09G')!=0 then
call IssueImmediateOrderById(GetSpellAbilityUnit(),$D0004)
call DestroyEffect(AddSpecialEffectTarget("Abilities\\Spells\\Items\\SpellShieldAmulet\\SpellShieldCaster.mdl",GetSpellTargetUnit(),"origin"))
endif
endfunction
function X_E takes nothing returns boolean
return(GetUnitTypeId(GetEnumUnit())!='h000')and(IsUnitSelected(GetEnumUnit(),GetTriggerPlayer()))
endfunction
function X0E takes nothing returns nothing
if X_E()then
call UnitRemoveAbilityBJ('A08V',GetEnumUnit())
call UnitRemoveAbilityBJ('A08T',GetEnumUnit())
call UnitRemoveAbilityBJ('A08U',GetEnumUnit())
call UnitRemoveAbilityBJ('A08S',GetEnumUnit())
call GroupRemoveUnitSimple(GetEnumUnit(),dr)
call GroupRemoveUnitSimple(GetEnumUnit(),Rr)
call GroupRemoveUnitSimple(GetEnumUnit(),fr)
endif
endfunction
function X1E takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),5,StringLength(GetEventPlayerChatString()))=="lordaeronwintersky")
endfunction
function X2E takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),5,StringLength(GetEventPlayerChatString()))=="lordaeronsummersky")
endfunction
function X3E takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),5,StringLength(GetEventPlayerChatString()))=="genericsky")
endfunction
function X4E takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),5,StringLength(GetEventPlayerChatString()))=="lordaeronwinterskypink")
endfunction
function X5E takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),5,StringLength(GetEventPlayerChatString()))=="lordaeronsummersky")
endfunction
function X6E takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),5,StringLength(GetEventPlayerChatString()))=="lordaeronwinterskybrightgreen")
endfunction
function X7E takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),5,StringLength(GetEventPlayerChatString()))=="lordaeronwinterskyred")
endfunction
function X8E takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),5,StringLength(GetEventPlayerChatString()))=="blizzardsky")
endfunction
function X9E takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),5,StringLength(GetEventPlayerChatString()))=="dalaransky")
endfunction
function OvE takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),5,StringLength(GetEventPlayerChatString()))=="felwoodsky")
endfunction
function OeE takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),5,StringLength(GetEventPlayerChatString()))=="lordaeronwinterskybrightgreen")
endfunction
function OxE takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),5,StringLength(GetEventPlayerChatString()))=="lordaeronwintersky")
endfunction
function OoE takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),5,StringLength(GetEventPlayerChatString()))=="lordaeronwinterskypurple")
endfunction
function OrE takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),5,StringLength(GetEventPlayerChatString()))=="genericsky")
endfunction
function OiE takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),5,StringLength(GetEventPlayerChatString()))=="outlandsky")
endfunction
function OaE takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),5,StringLength(GetEventPlayerChatString()))=="lordaeronfallsky")
endfunction
function OnE takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),5,StringLength(GetEventPlayerChatString()))=="lordaeronfallsky")
endfunction
function OVE takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),5,StringLength(GetEventPlayerChatString()))=="foggedsky")
endfunction
function OEE takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),5,StringLength(GetEventPlayerChatString()))=="lordaeronwinterskyyellow")
endfunction
function OXE takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),5,StringLength(GetEventPlayerChatString()))=="blizzardsky")
endfunction
function OOE takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),5,StringLength(GetEventPlayerChatString()))=="foggedsky")
endfunction
function ORE takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),5,StringLength(GetEventPlayerChatString()))=="lordaeronwinterskyred")
endfunction
function OIE takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),5,StringLength(GetEventPlayerChatString()))=="lordaeronwinterskyyellow")
endfunction
function OAE takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),5,StringLength(GetEventPlayerChatString()))=="outlandsky")
endfunction
function ONE takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),5,StringLength(GetEventPlayerChatString()))=="lordaeronwinterskypurple")
endfunction
function ObE takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),5,StringLength(GetEventPlayerChatString()))=="felwoodsky")
endfunction
function OBE takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),5,StringLength(GetEventPlayerChatString()))=="lordaeronwinterskypink")
endfunction
function OcE takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),5,StringLength(GetEventPlayerChatString()))=="dalaransky")
endfunction
function OCE takes nothing returns nothing
if OXE()then
call SetSkyModel("Environment\\Sky\\BlizzardSky\\BlizzardSky.mdl")
return
endif
if OcE()then
call SetSkyModel("Environment\\Sky\\DalaranSky\\DalaranSky.mdl")
return
endif
if ObE()then
call SetSkyModel("Environment\\Sky\\FelwoodSky\\FelwoodSky.mdl")
return
endif
if OOE()then
call SetSkyModel("Environment\\Sky\\FoggedSky\\FoggedSky.mdl")
return
endif
if OrE()then
call SetSkyModel("Environment\\Sky\\Sky\\SkyLight.mdl")
return
endif
if OnE()then
call SetSkyModel("Environment\\Sky\\LordaeronFallSky\\LordaeronFallSky.mdl")
return
endif
if X5E()then
call SetSkyModel("Environment\\Sky\\LordaeronSummerSky\\LordaeronSummerSky.mdl")
return
endif
if OEE()then
call SetSkyModel("Environment\\Sky\\LordaeronWinterSkyYellow\\LordaeronWinterSkyYellow.mdl")
return
endif
if OiE()then
call SetSkyModel("Environment\\Sky\\Outland_Sky\\Outland_Sky.mdl")
return
endif
if X7E()then
call SetSkyModel("Environment\\Sky\\LordaeronWinterSkyRed\\LordaeronWinterSkyRed.mdl")
return
endif
if OoE()then
call SetSkyModel("Environment\\Sky\\LordaeronWinterSkyPurple\\LordaeronWinterSkyPurple.mdl")
return
endif
if X1E()then
call SetSkyModel("Environment\\Sky\\LordaeronWinterSky\\LordaeronWinterSky.mdl")
return
endif
if X4E()then
call SetSkyModel("Environment\\Sky\\LordaeronWinterSkyPink\\LordaeronWinterSkyPink.mdl")
return
endif
if X6E()then
call SetSkyModel("Environment\\Sky\\LordaeronWinterSkyBrightGreen\\LordaeronWinterSkyBrightGreen.mdl")
return
endif
if X8E()then
call SetSkyModel("Environment\\Sky\\BlizzardSky\\BlizzardSky.mdl")
return
endif
if X9E()then
call SetSkyModel("Environment\\Sky\\DalaranSky\\DalaranSky.mdl")
return
endif
if OvE()then
call SetSkyModel("Environment\\Sky\\FelwoodSky\\FelwoodSky.mdl")
return
endif
if OVE()then
call SetSkyModel("Environment\\Sky\\FoggedSky\\FoggedSky.mdl")
return
endif
if X3E()then
call SetSkyModel("Environment\\Sky\\Sky\\SkyLight.mdl")
return
endif
if OaE()then
call SetSkyModel("Environment\\Sky\\LordaeronFallSky\\LordaeronFallSky.mdl")
return
endif
if X2E()then
call SetSkyModel("Environment\\Sky\\LordaeronSummerSky\\LordaeronSummerSky.mdl")
return
endif
if OxE()then
call SetSkyModel("Environment\\Sky\\LordaeronWinterSky\\LordaeronWinterSky.mdl")
return
endif
if OeE()then
call SetSkyModel("Environment\\Sky\\LordaeronWinterSkyBrightGreen\\LordaeronWinterSkyBrightGreen.mdl")
return
endif
if OBE()then
call SetSkyModel("Environment\\Sky\\LordaeronWinterSkyPink\\LordaeronWinterSkyPink.mdl")
return
endif
if ONE()then
call SetSkyModel("Environment\\Sky\\LordaeronWinterSkyPurple\\LordaeronWinterSkyPurple.mdl")
return
endif
if ORE()then
call SetSkyModel("Environment\\Sky\\LordaeronWinterSkyRed\\LordaeronWinterSkyRed.mdl")
return
endif
if OIE()then
call SetSkyModel("Environment\\Sky\\LordaeronWinterSkyYellow\\LordaeronWinterSkyYellow.mdl")
return
endif
if OAE()then
call SetSkyModel("Environment\\Sky\\Outland_Sky\\Outland_Sky.mdl")
return
endif
endfunction
function OdE takes nothing returns boolean
return(F[GetConvertedPlayerId(GetTriggerPlayer())])and(GetEventPlayerChatString()=="addstat on")
endfunction
function ODE takes nothing returns boolean
return(F[GetConvertedPlayerId(GetTriggerPlayer())])and(GetEventPlayerChatString()=="addstat off")
endfunction
function OfE takes nothing returns nothing
if OdE()then
endif
if ODE()then
endif
endfunction
function OFE takes nothing returns boolean
return true
endfunction
function OgE takes integer OGE,integer OhE,unit OHE returns nothing
call SaveUnitHandle(LR,OGE,OhE,OHE)
endfunction
function OjE takes integer OJE,integer OkE,unit OKE,string OlE returns nothing
set ZM[EM]=OlE
set EM=EM+1
if jv[OJE]==0 then
if OJE==0 then
call Cdv("Nullpointer exception when calling Table.saveUnit","when calling error in TableJurst, line 103")
else
call Cdv("Called Table.saveUnit on invalid object.","when calling error in TableJurst, line 103")
endif
endif
call OgE(OJE,OkE,OKE)
set EM=EM-1
endfunction
function OLE takes string OmE returns nothing
local unit OME
local integer OpE
local integer OPE
set ZM[EM]=OmE
set EM=EM+1
if GetSpellAbilityId()==ST then
set OME=GetSpellAbilityUnit()
call nfn(bT,OME,12.,"when calling apply in TouchOfKarma, line 65")
set OpE=cGV("when calling new_DummyCaster in TouchOfKarma, line 66")
call CnV(OpE,HVo(OME),"when calling owner in TouchOfKarma, line 66")
set OPE=OpE
call cVV(OPE,OT,GetUnitAbilityLevel(OME,ST),Qq,OME,"when calling castTarget in TouchOfKarma, line 66")
call OjE(qT,GetHandleId(OME),GetSpellTargetUnit(),"when calling saveUnit in TouchOfKarma, line 68")
call OjE(aT,GetHandleId(GetSpellTargetUnit()),OME,"when calling saveUnit in TouchOfKarma, line 69")
endif
set EM=EM-1
set OME=null
endfunction
function OqE takes nothing returns nothing
set EM=0
call OLE("TouchOfKarma, line 98")
endfunction
function OQE takes group OsE,rect OSE,boolexpr OtE returns nothing
call GroupEnumUnitsInRect(OsE,OSE,OtE)
endfunction
function OTE takes group OuE,rect OUE returns nothing
call OQE(OuE,OUE,null)
endfunction
function OwE takes string OWE returns integer
local integer OyE
set ZM[EM]=OWE
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set OyE=Yj
set Gj[OyE]=$AA3
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_SotfrpGuiCoreUnit.","when calling error in SotfrpGuiCoreUnit, line 72")
set OyE=0
endif
else
set Tj=Tj-1
set OyE=Rj[Tj]
set Gj[OyE]=$AA3
endif
set EM=EM-1
return OyE
endfunction
function OYE takes string OzE returns integer
local integer OZE
set ZM[EM]=OzE
set EM=EM+1
if LG==0 then
if XG<$8000 then
set XG=XG+1
set OZE=XG
set CG[OZE]=$7B9
else
call Cdv("Out of memory: Could not create EventListener_add_SotfrpGuiCoreUnit.","when calling error in SotfrpGuiCoreUnit, line 60")
set OZE=0
endif
else
set LG=LG-1
set OZE=KG[LG]
set CG[OZE]=$7B9
endif
set EM=EM-1
return OZE
endfunction
function O_E takes string O0E returns integer
local integer O1E
set ZM[EM]=O0E
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set O1E=Yj
set Gj[O1E]=$B6D
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_SotfrpGuiCoreUnit.","when calling error in SotfrpGuiCoreUnit, line 69")
set O1E=0
endif
else
set Tj=Tj-1
set O1E=Rj[Tj]
set Gj[O1E]=$B6D
endif
set EM=EM-1
return O1E
endfunction
function O2E takes integer O3E returns nothing
set xJ[O3E]=0
endfunction
function O4E takes integer O5E,string O6E returns nothing
set ZM[EM]=O6E
set EM=EM+1
if ax[O5E]==0 then
if O5E==0 then
call Cdv("Nullpointer exception when calling BuiltinData.setArgumentsTypes","when calling error in ScmdDataTypes, line 1391")
else
call Cdv("Called BuiltinData.setArgumentsTypes on invalid object.","when calling error in ScmdDataTypes, line 1391")
endif
endif
call O2E(O5E)
set EM=EM-1
endfunction
function O7E takes string O8E returns integer
local integer O9E
set ZM[EM]=O8E
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set O9E=Yj
set Gj[O9E]=$A34
else
call Cdv("Out of memory: Could not create IBuiltin_registerProtectedBuiltin_SotfrpGuiCoreUnit.","when calling error in SotfrpGuiCoreUnit, line 77")
set O9E=0
endif
else
set Tj=Tj-1
set O9E=Rj[Tj]
set Gj[O9E]=$A34
endif
set EM=EM-1
return O9E
endfunction
function RvE takes integer ReE,integer RxE returns nothing
set gd[ReE]=RxE
endfunction
function RoE takes string RrE returns integer
local integer RiE
set ZM[EM]=RrE
set EM=EM+1
if BG==0 then
if NG<$8000 then
set NG=NG+1
set RiE=NG
set MG[RiE]=$F34
else
call Cdv("Out of memory: Could not create OnCastListener_onCast_SotfrpGuiCoreUnit.","when calling error in SotfrpGuiCoreUnit, line 46")
set RiE=0
endif
else
set BG=BG-1
set RiE=VG[BG]
set MG[RiE]=$F34
endif
set EM=EM-1
return RiE
endfunction
function RaE takes nothing returns integer
return xf
endfunction
function RnE takes nothing returns integer
return Vf
endfunction
function RVE takes player REE returns real
set p1=GetPlayerStartLocationX(REE)
set e1=GetPlayerStartLocationY(REE)
return p1
endfunction
function RXE takes integer ROE,string RRE returns unit
local unit RIE
local unit RAE
local integer RNE
local unit RbE
local integer RBE
set ZM[EM]=RRE
set EM=EM+1
set RAE=vAe(sa[ROE],RaE(),RVE(sa[ROE]),e1,vde(270.))
call w0v(RAE,$FF,$FF,$FF,$96)
set RIE=RAE
set RbE=RIE
set RBE=RnE()
set RNE=RoE("when calling alloc_OnCastListener_onCast_SotfrpGuiCoreUnit in SotfrpGuiCoreUnit, line 46")
call Gla(RNE)
call hOa(RbE,RBE,RNE,"when calling onCast in SotfrpGuiCoreUnit, line 46")
set EM=EM-1
set RWv=RIE
set RIE=null
set RAE=null
set RbE=null
return RWv
endfunction
function RcE takes string RCE returns integer
local integer RdE
set ZM[EM]=RCE
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set RdE=Yj
set Gj[RdE]=$AA4
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_SotfrpGuiCoreUnit.","when calling error in SotfrpGuiCoreUnit, line 92")
set RdE=0
endif
else
set Tj=Tj-1
set RdE=Rj[Tj]
set Gj[RdE]=$AA4
endif
set EM=EM-1
return RdE
endfunction
function RDE takes string RfE returns integer
local integer RFE
set ZM[EM]=RfE
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set RFE=Yj
set Gj[RFE]=$B1A
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_SotfrpGuiCoreUnit.","when calling error in SotfrpGuiCoreUnit, line 110")
set RFE=0
endif
else
set Tj=Tj-1
set RFE=Rj[Tj]
set Gj[RFE]=$B1A
endif
set EM=EM-1
return RFE
endfunction
function RgE takes integer aku,string nku,string dku returns nothing
endfunction
function RGE takes integer RhE,string RHE returns nothing
call RgE(gB[RhE],"unam",RHE)
endfunction
function RjE takes integer RJE,string RkE,string RKE returns nothing
set ZM[EM]=RKE
set EM=EM+1
if uv[RJE]==0 then
if RJE==0 then
call Cdv("Nullpointer exception when calling W3UDefinition.setName","when calling error in UnitObjEditing, line 232")
else
call Cdv("Called W3UDefinition.setName on invalid object.","when calling error in UnitObjEditing, line 232")
endif
endif
call RGE(RJE,RkE)
set EM=EM-1
endfunction
function RlE takes integer RLE,integer RmE,string RME returns nothing
set ZM[EM]=RME
set EM=EM+1
call lea(rQ[RLE],"Car1",sQ[RLE],1,RmE,"when calling setLevelsDataInt in AbilityObjEditing, line 3400")
call K5a(RLE,"CargoCapacity",RmE,"when calling addTooltipProperty in AbilityObjEditing, line 3401")
set EM=EM-1
endfunction
function RpE takes integer RPE,integer RqE,string RQE returns nothing
set ZM[EM]=RQE
set EM=EM+1
if tY[RPE]==0 then
if RPE==0 then
call Cdv("Nullpointer exception when calling AbilityDefinitionCargoHoldTransport.presetCargoCapacity","when calling error in AbilityObjEditing, line 3399")
else
call Cdv("Called AbilityDefinitionCargoHoldTransport.presetCargoCapacity on invalid object.","when calling error in AbilityObjEditing, line 3399")
endif
endif
call RlE(RPE,RqE,"when calling presetCargoCapacity in AbilityObjEditing, line 3399")
set EM=EM-1
endfunction
function RsE takes integer RSE,string RtE returns nothing
call RgE(gB[RSE],"umdl",RtE)
endfunction
function RTE takes integer RuE,string RUE,string RwE returns nothing
set ZM[EM]=RwE
set EM=EM+1
if uv[RuE]==0 then
if RuE==0 then
call Cdv("Nullpointer exception when calling UnitOrBuildingOrHeroDefinition.setModelFile","when calling error in UnitObjEditing, line 450")
else
call Cdv("Called UnitOrBuildingOrHeroDefinition.setModelFile on invalid object.","when calling error in UnitObjEditing, line 450")
endif
endif
call RsE(RuE,RUE)
set EM=EM-1
endfunction
function RWE takes string RyE returns integer
local integer RYE
set ZM[EM]=RyE
set EM=EM+1
if DG==0 then
if HG<$8000 then
set HG=HG+1
set RYE=HG
set JG[RYE]=4176
else
call Cdv("Out of memory: Could not create RealLevelClosure_presetCastRange_addButton_SotfrpGuiCoreUnit.","when calling error in SotfrpGuiCoreUnit, line 33")
set RYE=0
endif
else
set DG=DG-1
set RYE=AG[DG]
set JG[RYE]=4176
endif
set EM=EM-1
return RYE
endfunction
function RzE takes integer Rku,string Tku,real Yku returns nothing
endfunction
function RZE takes integer R_E,real R0E returns nothing
call RzE(gB[R_E],"usca",R0E)
endfunction
function R1E takes integer R2E,real R3E,string R4E returns nothing
set ZM[EM]=R4E
set EM=EM+1
if uv[R2E]==0 then
if R2E==0 then
call Cdv("Nullpointer exception when calling UnitOrBuildingOrHeroDefinition.setScalingValue","when calling error in UnitObjEditing, line 369")
else
call Cdv("Called UnitOrBuildingOrHeroDefinition.setScalingValue on invalid object.","when calling error in UnitObjEditing, line 369")
endif
endif
call RZE(R2E,R3E)
set EM=EM-1
endfunction
function R5E takes string R6E returns integer
local integer R7E
set ZM[EM]=R6E
set EM=EM+1
if Mx==0 then
if wv<$8000 then
set wv=wv+1
set R7E=wv
set uv[R7E]=5170
else
call Cdv("Out of memory: Could not create SotfrpGuiHelperUnitPreset.","when calling error in SotfrpGuiPresets, line 124")
set R7E=0
endif
else
set Mx=Mx-1
set R7E=Nx[Mx]
set uv[R7E]=5170
endif
set EM=EM-1
return R7E
endfunction
function R8E takes integer oku,string Oku,integer lku returns nothing
endfunction
function R9E takes integer IvE,string IeE,boolean IxE returns nothing
call R8E(IvE,IeE,yRe(IxE))
endfunction
function IoE takes integer IrE,boolean IiE returns nothing
call R9E(gB[IrE],"ubdg",IiE)
endfunction
function IaE takes integer InE,boolean IVE,string IEE returns nothing
set ZM[EM]=IEE
set EM=EM+1
if uv[InE]==0 then
if InE==0 then
call Cdv("Nullpointer exception when calling UnitOrBuildingOrHeroDefinition.setIsaBuilding","when calling error in UnitObjEditing, line 480")
else
call Cdv("Called UnitOrBuildingOrHeroDefinition.setIsaBuilding on invalid object.","when calling error in UnitObjEditing, line 480")
endif
endif
call IoE(InE,IVE)
set EM=EM-1
endfunction
function IXE takes integer gku,string hku,real Fku returns nothing
endfunction
function IOE takes integer IRE,real IIE returns nothing
call IXE(gB[IRE],"ucpt",IIE)
endfunction
function IAE takes integer INE,real IbE,string IBE returns nothing
set ZM[EM]=IBE
set EM=EM+1
if uv[INE]==0 then
if INE==0 then
call Cdv("Nullpointer exception when calling UnitOrBuildingOrHeroDefinition.setAnimationCastPoint","when calling error in UnitObjEditing, line 768")
else
call Cdv("Called UnitOrBuildingOrHeroDefinition.setAnimationCastPoint on invalid object.","when calling error in UnitObjEditing, line 768")
endif
endif
call IOE(INE,IbE)
set EM=EM-1
endfunction
function IcE takes integer ICE,string IdE returns nothing
call RgE(gB[ICE],"usnd",IdE)
endfunction
function IDE takes integer IfE,string IFE,string IgE returns nothing
set ZM[EM]=IgE
set EM=EM+1
if uv[IfE]==0 then
if IfE==0 then
call Cdv("Nullpointer exception when calling UnitOrBuildingOrHeroDefinition.setUnitSoundSet","when calling error in UnitObjEditing, line 271")
else
call Cdv("Called UnitOrBuildingOrHeroDefinition.setUnitSoundSet on invalid object.","when calling error in UnitObjEditing, line 271")
endif
endif
call IcE(IfE,IFE)
set EM=EM-1
endfunction
function IGE takes integer IhE,string IHE returns nothing
call RgE(gB[IhE],"upgr",IHE)
endfunction
function IjE takes integer IJE,string IkE,string IKE returns nothing
set ZM[EM]=IKE
set EM=EM+1
if uv[IJE]==0 then
if IJE==0 then
call Cdv("Nullpointer exception when calling UnitOrBuildingOrHeroDefinition.setUpgradesUsed","when calling error in UnitObjEditing, line 268")
else
call Cdv("Called UnitOrBuildingOrHeroDefinition.setUpgradesUsed on invalid object.","when calling error in UnitObjEditing, line 268")
endif
endif
call IGE(IJE,IkE)
set EM=EM-1
endfunction
function IlE takes integer ILE,real ImE returns nothing
call RzE(gB[ILE],"umxp",ImE)
endfunction
function IME takes integer IpE,real IPE,string IqE returns nothing
set ZM[EM]=IqE
set EM=EM+1
if uv[IpE]==0 then
if IpE==0 then
call Cdv("Nullpointer exception when calling UnitOrBuildingOrHeroDefinition.setMaximumPitchAngledegrees","when calling error in UnitObjEditing, line 459")
else
call Cdv("Called UnitOrBuildingOrHeroDefinition.setMaximumPitchAngledegrees on invalid object.","when calling error in UnitObjEditing, line 459")
endif
endif
call IlE(IpE,IPE)
set EM=EM-1
endfunction
function IQE takes integer IsE,real ISE returns nothing
call RzE(gB[IsE],"umxr",ISE)
endfunction
function ItE takes integer ITE,real IuE,string IUE returns nothing
set ZM[EM]=IUE
set EM=EM+1
if uv[ITE]==0 then
if ITE==0 then
call Cdv("Nullpointer exception when calling UnitOrBuildingOrHeroDefinition.setMaximumRollAngledegrees","when calling error in UnitObjEditing, line 456")
else
call Cdv("Called UnitOrBuildingOrHeroDefinition.setMaximumRollAngledegrees on invalid object.","when calling error in UnitObjEditing, line 456")
endif
endif
call IQE(ITE,IuE)
set EM=EM-1
endfunction
function IwE takes integer IWE,integer IyE returns nothing
call R8E(gB[IWE],"umvs",IyE)
endfunction
function IYE takes integer IzE,integer IZE,string I_E returns nothing
set ZM[EM]=I_E
set EM=EM+1
if uv[IzE]==0 then
if IzE==0 then
call Cdv("Nullpointer exception when calling UnitOrBuildingOrHeroDefinition.setSpeedBase","when calling error in UnitObjEditing, line 323")
else
call Cdv("Called UnitOrBuildingOrHeroDefinition.setSpeedBase on invalid object.","when calling error in UnitObjEditing, line 323")
endif
endif
call IwE(IzE,IZE)
set EM=EM-1
endfunction
function I0E takes integer I1E,string I2E returns nothing
call RgE(gB[I1E],"utip",I2E)
endfunction
function I3E takes integer I4E,string I5E,string I6E returns nothing
set ZM[EM]=I6E
set EM=EM+1
if uv[I4E]==0 then
if I4E==0 then
call Cdv("Nullpointer exception when calling W3UDefinition.setTooltipBasic","when calling error in UnitObjEditing, line 223")
else
call Cdv("Called W3UDefinition.setTooltipBasic on invalid object.","when calling error in UnitObjEditing, line 223")
endif
endif
call I0E(I4E,I5E)
set EM=EM-1
endfunction
function I7E takes integer I8E returns string
local integer I9E=I8E
local string AvE
if I9E==0 then
set AvE="normal"
elseif I9E==1 then
set AvE="small"
elseif I9E==2 then
set AvE="medium"
elseif I9E==3 then
set AvE="large"
elseif I9E==4 then
set AvE="fort"
elseif I9E==5 then
set AvE="hero"
elseif I9E==6 then
set AvE="divine"
else
set AvE="none"
endif
return AvE
endfunction
function AeE takes integer AxE,integer AoE returns nothing
call RgE(gB[AxE],"udty",I7E(AoE))
endfunction
function ArE takes integer AiE,integer AaE,string AnE returns nothing
set ZM[EM]=AnE
set EM=EM+1
if uv[AiE]==0 then
if AiE==0 then
call Cdv("Nullpointer exception when calling UnitOrBuildingOrHeroDefinition.setArmorType","when calling error in UnitObjEditing, line 555")
else
call Cdv("Called UnitOrBuildingOrHeroDefinition.setArmorType on invalid object.","when calling error in UnitObjEditing, line 555")
endif
endif
call AeE(AiE,AaE)
set EM=EM-1
endfunction
function AVE takes integer AEE,string AXE returns nothing
call RgE(gB[AEE],"ushu",AXE)
endfunction
function AOE takes integer ARE,string AIE,string AAE returns nothing
set ZM[EM]=AAE
set EM=EM+1
if uv[ARE]==0 then
if ARE==0 then
call Cdv("Nullpointer exception when calling UnitOrBuildingOrHeroDefinition.setShadowImageUnit","when calling error in UnitObjEditing, line 348")
else
call Cdv("Called UnitOrBuildingOrHeroDefinition.setShadowImageUnit on invalid object.","when calling error in UnitObjEditing, line 348")
endif
endif
call AVE(ARE,AIE)
set EM=EM-1
endfunction
function ANE takes integer AbE,integer ABE returns nothing
call R8E(gB[AbE],"uaen",ABE)
endfunction
function AcE takes integer ACE,integer AdE,string ADE returns nothing
set ZM[EM]=ADE
set EM=EM+1
if uv[ACE]==0 then
if ACE==0 then
call Cdv("Nullpointer exception when calling UnitOrBuildingOrHeroDefinition.setAttacksEnabled","when calling error in UnitObjEditing, line 588")
else
call Cdv("Called UnitOrBuildingOrHeroDefinition.setAttacksEnabled on invalid object.","when calling error in UnitObjEditing, line 588")
endif
endif
call ANE(ACE,AdE)
set EM=EM-1
endfunction
function AfE takes integer AFE,real AgE returns nothing
call IXE(gB[AFE],"ucbs",AgE)
endfunction
function AGE takes integer AhE,real AHE,string AjE returns nothing
set ZM[EM]=AjE
set EM=EM+1
if uv[AhE]==0 then
if AhE==0 then
call Cdv("Nullpointer exception when calling UnitOrBuildingOrHeroDefinition.setAnimationCastBackswing","when calling error in UnitObjEditing, line 771")
else
call Cdv("Called UnitOrBuildingOrHeroDefinition.setAnimationCastBackswing on invalid object.","when calling error in UnitObjEditing, line 771")
endif
endif
call AfE(AhE,AHE)
set EM=EM-1
endfunction
function AJE takes integer AkE,string AKE returns nothing
call RgE(gB[AkE],"utub",AKE)
endfunction
function AlE takes integer ALE,string AmE,string AME returns nothing
set ZM[EM]=AME
set EM=EM+1
if uv[ALE]==0 then
if ALE==0 then
call Cdv("Nullpointer exception when calling W3UDefinition.setTooltipExtended","when calling error in UnitObjEditing, line 220")
else
call Cdv("Called W3UDefinition.setTooltipExtended on invalid object.","when calling error in UnitObjEditing, line 220")
endif
endif
call AJE(ALE,AmE)
set EM=EM-1
endfunction
function ApE takes integer APE,integer AqE returns nothing
call R8E(gB[APE],"udef",AqE)
endfunction
function AQE takes integer AsE,integer ASE,string AtE returns nothing
set ZM[EM]=AtE
set EM=EM+1
if uv[AsE]==0 then
if AsE==0 then
call Cdv("Nullpointer exception when calling UnitOrBuildingOrHeroDefinition.setDefenseBase","when calling error in UnitObjEditing, line 558")
else
call Cdv("Called UnitOrBuildingOrHeroDefinition.setDefenseBase on invalid object.","when calling error in UnitObjEditing, line 558")
endif
endif
call ApE(AsE,ASE)
set EM=EM-1
endfunction
function ATE takes integer AuE,integer AUE returns nothing
call R8E(gB[AuE],"uhpm",AUE)
endfunction
function AwE takes integer AWE,integer AyE,string AYE returns nothing
set ZM[EM]=AYE
set EM=EM+1
if uv[AWE]==0 then
if AWE==0 then
call Cdv("Nullpointer exception when calling UnitOrBuildingOrHeroDefinition.setHitPointsMaximumBase","when calling error in UnitObjEditing, line 495")
else
call Cdv("Called UnitOrBuildingOrHeroDefinition.setHitPointsMaximumBase on invalid object.","when calling error in UnitObjEditing, line 495")
endif
endif
call ATE(AWE,AyE)
set EM=EM-1
endfunction
function AzE takes integer AZE,string A_E returns nothing
set ZM[EM]=A_E
set EM=EM+1
call AcE(AZE,0,"when calling setAttacksEnabled in SotfrpGuiPresets, line 129")
call AQE(AZE,0,"when calling setDefenseBase in SotfrpGuiPresets, line 130")
call ArE(AZE,6,"when calling setArmorType in SotfrpGuiPresets, line 131")
call AGE(AZE,.0,"when calling setAnimationCastBackswing in SotfrpGuiPresets, line 132")
call IAE(AZE,.0,"when calling setAnimationCastPoint in SotfrpGuiPresets, line 133")
call IME(AZE,.0,"when calling setMaximumPitchAngledegrees in SotfrpGuiPresets, line 134")
call ItE(AZE,.0,"when calling setMaximumRollAngledegrees in SotfrpGuiPresets, line 135")
call AOE(AZE,"","when calling setShadowImageUnit in SotfrpGuiPresets, line 136")
call IYE(AZE,0,"when calling setSpeedBase in SotfrpGuiPresets, line 137")
call IDE(AZE,"","when calling setUnitSoundSet in SotfrpGuiPresets, line 138")
call I3E(AZE,"","when calling setTooltipBasic in SotfrpGuiPresets, line 139")
call AlE(AZE,"","when calling setTooltipExtended in SotfrpGuiPresets, line 140")
call IjE(AZE,"","when calling setUpgradesUsed in SotfrpGuiPresets, line 141")
call AwE(AZE,je,"when calling setHitPointsMaximumBase in SotfrpGuiPresets, line 142")
call IaE(AZE,true,"when calling setIsaBuilding in SotfrpGuiPresets, line 143")
set EM=EM-1
endfunction
function A0E takes integer A1E,string A2E returns nothing
set ZM[EM]=A2E
set EM=EM+1
if uv[A1E]==0 then
if A1E==0 then
call Cdv("Nullpointer exception when calling SotfrpGuiHelperUnitPreset.initialize","when calling error in SotfrpGuiPresets, line 128")
else
call Cdv("Called SotfrpGuiHelperUnitPreset.initialize on invalid object.","when calling error in SotfrpGuiPresets, line 128")
endif
endif
call AzE(A1E,"when calling initialize in SotfrpGuiPresets, line 128")
set EM=EM-1
endfunction
function A3E takes integer CIi returns nothing
endfunction
function A4E takes integer A5E,string A6E returns nothing
set ZM[EM]=A6E
set EM=EM+1
call l4a()
set mL[A5E]=yTv("when calling new_LinkedList in SotfrpGuiPresets, line 45")
call A3E(A5E)
set EM=EM-1
endfunction
function A7E takes integer AiS returns nothing
endfunction
function A8E takes integer sSS returns nothing
endfunction
function A9E takes integer NvE,integer NeE,integer NxE returns nothing
local integer NoE
call A8E(NvE)
set NoE=Kla("w3u",NeE,NxE)
set gB[NvE]=NoE
endfunction
function NrE takes integer NiE,integer NaE,integer NnE returns nothing
call A9E(NiE,NaE,NnE)
call A7E(NiE)
endfunction
function NVE takes integer ytS returns nothing
endfunction
function NEE takes integer NXE,integer NOE,integer NRE returns nothing
call NrE(NXE,NOE,NRE)
call NVE(NXE)
endfunction
function NIE takes integer NAE,string NNE returns nothing
set ZM[EM]=NNE
set EM=EM+1
call NEE(NAE,l0a(eq,"when calling next in SotfrpGuiPresets, line 146"),Nf)
call A4E(NAE,"when calling SotfrpGuiHelperUnitPreset_init in SotfrpGuiPresets, line 145")
call A0E(NAE,"when calling initialize in SotfrpGuiPresets, line 147")
set EM=EM-1
endfunction
function NbE takes string NBE returns integer
local integer NcE
set ZM[EM]=NBE
set EM=EM+1
set NcE=R5E("when calling alloc_SotfrpGuiHelperUnitPreset in SotfrpGuiPresets, line 145")
call NIE(NcE,"when calling construct_SotfrpGuiHelperUnitPreset in SotfrpGuiPresets, line 145")
set EM=EM-1
return NcE
endfunction
function NCE takes integer NdE,string NDE returns nothing
call RgE(gB[NdE],"uico",NDE)
endfunction
function NfE takes integer NFE,string NgE,string NGE returns nothing
set ZM[EM]=NGE
set EM=EM+1
if uv[NFE]==0 then
if NFE==0 then
call Cdv("Nullpointer exception when calling UnitOrBuildingOrHeroDefinition.setIconGameInterface","when calling error in UnitObjEditing, line 486")
else
call Cdv("Called UnitOrBuildingOrHeroDefinition.setIconGameInterface on invalid object.","when calling error in UnitObjEditing, line 486")
endif
endif
call NCE(NFE,NgE)
set EM=EM-1
endfunction
function NhE takes integer NHE returns string
local string NjE=""
local integer NJE=NHE
if NJE==0 then
elseif NJE==1 then
set NjE="foot"
elseif NJE==2 then
set NjE="horse"
elseif NJE==3 then
set NjE="fly"
elseif NJE==4 then
set NjE="hover"
elseif NJE==5 then
set NjE="float"
else
set NjE="amph"
endif
return NjE
endfunction
function NkE takes integer NKE,integer NlE returns nothing
call RgE(gB[NKE],"umvt",NhE(NlE))
endfunction
function NLE takes integer NmE,integer NME,string NpE returns nothing
set ZM[EM]=NpE
set EM=EM+1
if uv[NmE]==0 then
if NmE==0 then
call Cdv("Nullpointer exception when calling UnitOrBuildingOrHeroDefinition.setMovementType","when calling error in UnitObjEditing, line 277")
else
call Cdv("Called UnitOrBuildingOrHeroDefinition.setMovementType on invalid object.","when calling error in UnitObjEditing, line 277")
endif
endif
call NkE(NmE,NME)
set EM=EM-1
endfunction
function NPE takes integer NqE,integer NQE,boolean NsE,string NSE returns nothing
if NQE<0 or NQE>=$C then
call Cdv("Index out of Bounds",NSE)
elseif NQE<=5 then
if NQE<=2 then
if NQE<=1 then
if NQE<=0 then
set zu[NqE]=NsE
else
set zU[NqE]=NsE
endif
else
set zw[NqE]=NsE
endif
elseif NQE<=4 then
if NQE<=3 then
set zW[NqE]=NsE
else
set zy[NqE]=NsE
endif
else
set zY[NqE]=NsE
endif
elseif NQE<=8 then
if NQE<=7 then
if NQE<=6 then
set vz[NqE]=NsE
else
set ez[NqE]=NsE
endif
else
set xz[NqE]=NsE
endif
elseif NQE<=$A then
if NQE<=9 then
set oz[NqE]=NsE
else
set rz[NqE]=NsE
endif
else
set iz[NqE]=NsE
endif
endfunction
function NtE takes integer NTE,integer NuE,string NUE returns nothing
set ZM[EM]=NUE
set EM=EM+1
call kya(rQ[NTE],"atp1",sQ[NTE],0,NuE,"when calling setLevelsDataString in AbilityObjEditing, line 232")
call hya(NTE,"TooltipNormal",NuE,"when calling addTooltipProperty in AbilityObjEditing, line 233")
set EM=EM-1
endfunction
function NwE takes integer NWE,integer NyE,string NYE returns nothing
set ZM[EM]=NYE
set EM=EM+1
if tY[NWE]==0 then
if NWE==0 then
call Cdv("Nullpointer exception when calling AbilityDefinition.presetTooltipNormal","when calling error in AbilityObjEditing, line 231")
else
call Cdv("Called AbilityDefinition.presetTooltipNormal on invalid object.","when calling error in AbilityObjEditing, line 231")
endif
endif
call NtE(NWE,NyE,"when calling presetTooltipNormal in AbilityObjEditing, line 231")
set EM=EM-1
endfunction
function NzE takes string NZE returns integer
local integer N_E
set ZM[EM]=NZE
set EM=EM+1
if FF==0 then
if kF<$8000 then
set kF=kF+1
set N_E=kF
set jF[N_E]=4971
else
call Cdv("Out of memory: Could not create ToStringClosure_joinBy_setAbilityList_Palette_SotfrpGuiHelperUnitPreset_SotfrpGuiPresets.","when calling error in SotfrpGuiPresets, line 57")
set N_E=0
endif
else
set FF=FF-1
set N_E=hF[FF]
set jF[N_E]=4971
endif
set EM=EM-1
return N_E
endfunction
function N0E takes integer N1E,string N2E returns nothing
call RgE(gB[N1E],"uabi",N2E)
endfunction
function N3E takes integer N4E,string N5E,string N6E returns nothing
set ZM[EM]=N6E
set EM=EM+1
if uv[N4E]==0 then
if N4E==0 then
call Cdv("Nullpointer exception when calling UnitOrBuildingOrHeroDefinition.setNormalAbilities","when calling error in UnitObjEditing, line 438")
else
call Cdv("Called UnitOrBuildingOrHeroDefinition.setNormalAbilities on invalid object.","when calling error in UnitObjEditing, line 438")
endif
endif
call N0E(N4E,N5E)
set EM=EM-1
endfunction
function N7E takes integer N8E,string N9E,string bvE returns nothing
set ZM[EM]=bvE
set EM=EM+1
call N3E(N8E,N9E,"when calling setNormalAbilities in SotfrpGuiPresets, line 156")
set EM=EM-1
endfunction
function beE takes integer bxE,string boE,string brE returns nothing
set ZM[EM]=brE
set EM=EM+1
if uv[bxE]==0 then
if bxE==0 then
call Cdv("Nullpointer exception when calling SotfrpGuiHelperUnitPreset.setAbilityList","when calling error in SotfrpGuiPresets, line 155")
else
call Cdv("Called SotfrpGuiHelperUnitPreset.setAbilityList on invalid object.","when calling error in SotfrpGuiPresets, line 155")
endif
endif
call N7E(bxE,boE,"when calling setAbilityList in SotfrpGuiPresets, line 155")
set EM=EM-1
endfunction
function biE takes integer baE,integer bnE,string bVE returns nothing
local integer bEE
local integer bXE
local integer bOE
set ZM[EM]=bVE
set EM=EM+1
call zGv(mL[baE],bnE,"when calling add in SotfrpGuiPresets, line 56")
set bOE=baE
set bXE=mL[baE]
set bEE=NzE("when calling alloc_ToStringClosure_joinBy_setAbilityList_Palette_SotfrpGuiHelperUnitPreset_SotfrpGuiPresets in SotfrpGuiPresets, line 57")
call beE(bOE,HNa(bXE,bEE,",","when calling joinBy in SotfrpGuiPresets, line 57"),"when calling setAbilityList in SotfrpGuiPresets, line 57")
set EM=EM-1
endfunction
function bRE takes integer bIE,integer bAE,string bNE returns nothing
set ZM[EM]=bNE
set EM=EM+1
if uv[bIE]==0 then
if bIE==0 then
call Cdv("Nullpointer exception when calling SotfrpGuiHelperUnitPreset.addAbility","when calling error in SotfrpGuiPresets, line 55")
else
call Cdv("Called SotfrpGuiHelperUnitPreset.addAbility on invalid object.","when calling error in SotfrpGuiPresets, line 55")
endif
endif
call biE(bIE,bAE,"when calling addAbility in SotfrpGuiPresets, line 55")
set EM=EM-1
endfunction
function bbE takes integer bBE returns integer
return SQ[bBE]
endfunction
function bcE takes integer bCE,string bdE returns integer
local integer bDE
set ZM[EM]=bdE
set EM=EM+1
if tY[bCE]==0 then
if bCE==0 then
call Cdv("Nullpointer exception when calling AbilityDefinition.getNewId","when calling error in AbilityObjEditing, line 48")
else
call Cdv("Called AbilityDefinition.getNewId on invalid object.","when calling error in AbilityObjEditing, line 48")
endif
endif
set bDE=bbE(bCE)
set EM=EM-1
return bDE
endfunction
function bfE takes integer bFE,integer bgE,string bGE returns nothing
set ZM[EM]=bGE
set EM=EM+1
call bRE(bFE,bcE(bgE,"when calling getNewId in SotfrpGuiPresets, line 60"),"when calling addAbility in SotfrpGuiPresets, line 60")
set EM=EM-1
endfunction
function bhE takes integer bHE,integer bjE,string bJE returns nothing
set ZM[EM]=bJE
set EM=EM+1
if uv[bHE]==0 then
if bHE==0 then
call Cdv("Nullpointer exception when calling SotfrpGuiHelperUnitPreset.addAbility","when calling error in SotfrpGuiPresets, line 59")
else
call Cdv("Called SotfrpGuiHelperUnitPreset.addAbility on invalid object.","when calling error in SotfrpGuiPresets, line 59")
endif
endif
call bfE(bHE,bjE,"when calling addAbility in SotfrpGuiPresets, line 59")
set EM=EM-1
endfunction
function bkE takes string bKE returns integer
local integer blE
set ZM[EM]=bKE
set EM=EM+1
if lY==0 then
if bY<$8000 then
set bY=bY+1
set blE=bY
set yY[blE]=4850
else
call Cdv("Out of memory: Could not create StringLevelClosure_presetTooltipNormalExtended_Palette_SotfrpGuiHelperUnitPreset_SotfrpGuiPresets.","when calling error in SotfrpGuiPresets, line 71")
set blE=0
endif
else
set lY=lY-1
set blE=OY[lY]
set yY[blE]=4850
endif
set EM=EM-1
return blE
endfunction
function bLE takes integer bmE,integer bME returns nothing
call lva(rQ[bmE],"abpx",0,0,bME)
endfunction
function bpE takes integer bPE,integer bqE,string bQE returns nothing
set ZM[EM]=bQE
set EM=EM+1
if tY[bPE]==0 then
if bPE==0 then
call Cdv("Nullpointer exception when calling AbilityDefinition.setButtonPositionNormalX","when calling error in AbilityObjEditing, line 113")
else
call Cdv("Called AbilityDefinition.setButtonPositionNormalX on invalid object.","when calling error in AbilityObjEditing, line 113")
endif
endif
call bLE(bPE,bqE)
set EM=EM-1
endfunction
function bsE takes integer bSE,integer btE returns nothing
call lva(rQ[bSE],"abpy",0,0,btE)
endfunction
function bTE takes integer buE,integer bUE,string bwE returns nothing
set ZM[EM]=bwE
set EM=EM+1
if tY[buE]==0 then
if buE==0 then
call Cdv("Nullpointer exception when calling AbilityDefinition.setButtonPositionNormalY","when calling error in AbilityObjEditing, line 116")
else
call Cdv("Called AbilityDefinition.setButtonPositionNormalY on invalid object.","when calling error in AbilityObjEditing, line 116")
endif
endif
call bsE(buE,bUE)
set EM=EM-1
endfunction
function bWE takes integer byE,integer bYE,integer bzE,string bZE returns nothing
set ZM[EM]=bZE
set EM=EM+1
call bpE(byE,bYE,"when calling setButtonPositionNormalX in AbilityObjEditing, line 132")
call bTE(byE,bzE,"when calling setButtonPositionNormalY in AbilityObjEditing, line 133")
set EM=EM-1
endfunction
function b_E takes integer b0E,integer b1E,integer b2E,string b3E returns nothing
set ZM[EM]=b3E
set EM=EM+1
if tY[b0E]==0 then
if b0E==0 then
call Cdv("Nullpointer exception when calling AbilityDefinition.presetButtonPosNormal","when calling error in AbilityObjEditing, line 131")
else
call Cdv("Called AbilityDefinition.presetButtonPosNormal on invalid object.","when calling error in AbilityObjEditing, line 131")
endif
endif
call bWE(b0E,b1E,b2E,"when calling presetButtonPosNormal in AbilityObjEditing, line 131")
set EM=EM-1
endfunction
function b4E takes string b5E returns integer
local integer b6E
set ZM[EM]=b5E
set EM=EM+1
if lY==0 then
if bY<$8000 then
set bY=bY+1
set b6E=bY
set yY[b6E]=4819
else
call Cdv("Out of memory: Could not create StringLevelClosure_AbilityDefinition_AbilityObjEditing.","when calling error in AbilityObjEditing, line 284")
set b6E=0
endif
else
set lY=lY-1
set b6E=OY[lY]
set yY[b6E]=4819
endif
set EM=EM-1
return b6E
endfunction
function b7E takes integer b8E,string b9E returns nothing
call h0a(rQ[b8E],"ahky",0,0,b9E)
endfunction
function BvE takes integer BeE,string BxE,string BoE returns nothing
set ZM[EM]=BoE
set EM=EM+1
if tY[BeE]==0 then
if BeE==0 then
call Cdv("Nullpointer exception when calling AbilityDefinition.setHotkeyNormal","when calling error in AbilityObjEditing, line 274")
else
call Cdv("Called AbilityDefinition.setHotkeyNormal on invalid object.","when calling error in AbilityObjEditing, line 274")
endif
endif
call b7E(BeE,BxE)
set EM=EM-1
endfunction
function BrE takes integer BiE,string BaE returns nothing
call h0a(rQ[BiE],"arhk",0,0,BaE)
endfunction
function BnE takes integer BVE,string BEE,string BXE returns nothing
set ZM[EM]=BXE
set EM=EM+1
if tY[BVE]==0 then
if BVE==0 then
call Cdv("Nullpointer exception when calling AbilityDefinition.setHotkeyLearn","when calling error in AbilityObjEditing, line 271")
else
call Cdv("Called AbilityDefinition.setHotkeyLearn on invalid object.","when calling error in AbilityObjEditing, line 271")
endif
endif
call BrE(BVE,BEE)
set EM=EM-1
endfunction
function BOE takes integer BRE,string BIE returns nothing
call h0a(rQ[BRE],"auhk",0,0,BIE)
endfunction
function BAE takes integer BNE,string BbE,string BBE returns nothing
set ZM[EM]=BBE
set EM=EM+1
if tY[BNE]==0 then
if BNE==0 then
call Cdv("Nullpointer exception when calling AbilityDefinition.setHotkeyTurnOff","when calling error in AbilityObjEditing, line 277")
else
call Cdv("Called AbilityDefinition.setHotkeyTurnOff on invalid object.","when calling error in AbilityObjEditing, line 277")
endif
endif
call BOE(BNE,BbE)
set EM=EM-1
endfunction
function BcE takes integer BCE,string BdE,string BDE returns nothing
local integer BfE
local integer BFE
set ZM[EM]=BDE
set EM=EM+1
call BvE(BCE,BdE,"when calling setHotkeyNormal in AbilityObjEditing, line 281")
call BnE(BCE,BdE,"when calling setHotkeyLearn in AbilityObjEditing, line 282")
call BAE(BCE,BdE,"when calling setHotkeyTurnOff in AbilityObjEditing, line 283")
set BFE=b4E("when calling alloc_StringLevelClosure_AbilityDefinition_AbilityObjEditing in AbilityObjEditing, line 284")
set pQ[BFE]=BdE
set BfE=BFE
call hya(BCE,"Hotkey",BfE,"when calling addTooltipProperty in AbilityObjEditing, line 285")
set EM=EM-1
endfunction
function BgE takes integer BGE,string BhE,string BHE returns nothing
set ZM[EM]=BHE
set EM=EM+1
call BcE(BGE,BhE,"when calling presetHotkey in TriggerAbilityPreset, line 23")
set DC[BGE]=BhE
set EM=EM-1
endfunction
function BjE takes integer BJE,string BkE,string BKE returns nothing
set ZM[EM]=BKE
set EM=EM+1
if tY[BJE]==0 then
if BJE==0 then
call Cdv("Nullpointer exception when calling AbilityDefinition.presetHotkey","when calling error in AbilityObjEditing, line 280")
else
call Cdv("Called AbilityDefinition.presetHotkey on invalid object.","when calling error in AbilityObjEditing, line 280")
endif
endif
if tY[BJE]<=320 then
if tY[BJE]<=319 then
call BcE(BJE,BkE,"when calling presetHotkey in AbilityObjEditing, line 280")
else
call BgE(BJE,BkE,"when calling presetHotkey in AbilityObjEditing, line 280")
endif
else
call BcE(BJE,BkE,"when calling presetHotkey in AbilityObjEditing, line 280")
endif
set EM=EM-1
endfunction
function BlE takes integer BLE,integer BmE,string BME returns boolean
local boolean BpE
if BmE<0 or BmE>=$C then
call Cdv("Index out of Bounds",BME)
elseif BmE<=5 then
if BmE<=2 then
if BmE<=1 then
if BmE<=0 then
set BpE=zu[BLE]
else
set BpE=zU[BLE]
endif
else
set BpE=zw[BLE]
endif
elseif BmE<=4 then
if BmE<=3 then
set BpE=zW[BLE]
else
set BpE=zy[BLE]
endif
else
set BpE=zY[BLE]
endif
elseif BmE<=8 then
if BmE<=7 then
if BmE<=6 then
set BpE=vz[BLE]
else
set BpE=ez[BLE]
endif
else
set BpE=xz[BLE]
endif
elseif BmE<=$A then
if BmE<=9 then
set BpE=oz[BLE]
else
set BpE=rz[BLE]
endif
else
set BpE=iz[BLE]
endif
return BpE
endfunction
function BPE takes string rku returns nothing
endfunction
function BqE takes integer BQE,integer BsE,string BSE returns nothing
set ZM[EM]=BSE
set EM=EM+1
call kya(rQ[BQE],"aub1",sQ[BQE],0,BsE,"when calling setLevelsDataString in AbilityObjEditing, line 246")
call hya(BQE,"TooltipNormalExtended",BsE,"when calling addTooltipProperty in AbilityObjEditing, line 247")
set EM=EM-1
endfunction
function BtE takes integer BTE,integer BuE,string BUE returns nothing
set ZM[EM]=BUE
set EM=EM+1
if tY[BTE]==0 then
if BTE==0 then
call Cdv("Nullpointer exception when calling AbilityDefinition.presetTooltipNormalExtended","when calling error in AbilityObjEditing, line 245")
else
call Cdv("Called AbilityDefinition.presetTooltipNormalExtended on invalid object.","when calling error in AbilityObjEditing, line 245")
endif
endif
call BqE(BTE,BuE,"when calling presetTooltipNormalExtended in AbilityObjEditing, line 245")
set EM=EM-1
endfunction
function BwE takes string BWE returns integer
local integer ByE
set ZM[EM]=BWE
set EM=EM+1
if lY==0 then
if bY<$8000 then
set bY=bY+1
set ByE=bY
set yY[ByE]=4857
else
call Cdv("Out of memory: Could not create StringLevelClosure_presetTooltipNormal_Palette_SotfrpGuiHelperUnitPreset_SotfrpGuiPresets.","when calling error in SotfrpGuiPresets, line 69")
set ByE=0
endif
else
set lY=lY-1
set ByE=OY[lY]
set yY[ByE]=4857
endif
set EM=EM-1
return ByE
endfunction
function BYE takes integer BzE,string BZE returns nothing
call h0a(rQ[BzE],"arar",0,0,BZE)
endfunction
function B_E takes integer B0E,string B1E,string B2E returns nothing
set ZM[EM]=B2E
set EM=EM+1
if tY[B0E]==0 then
if B0E==0 then
call Cdv("Nullpointer exception when calling AbilityDefinition.setIconResearch","when calling error in AbilityObjEditing, line 149")
else
call Cdv("Called AbilityDefinition.setIconResearch on invalid object.","when calling error in AbilityObjEditing, line 149")
endif
endif
call BYE(B0E,B1E)
set EM=EM-1
endfunction
function B3E takes integer B4E,string B5E returns nothing
call h0a(rQ[B4E],"aart",0,0,B5E)
endfunction
function B6E takes integer B7E,string B8E,string B9E returns nothing
set ZM[EM]=B9E
set EM=EM+1
if tY[B7E]==0 then
if B7E==0 then
call Cdv("Nullpointer exception when calling AbilityDefinition.setIconNormal","when calling error in AbilityObjEditing, line 143")
else
call Cdv("Called AbilityDefinition.setIconNormal on invalid object.","when calling error in AbilityObjEditing, line 143")
endif
endif
call B3E(B7E,B8E)
set EM=EM-1
endfunction
function cvE takes integer ceE,string cxE,string coE returns nothing
local string crE
set ZM[EM]=coE
set EM=EM+1
set crE=cxE
if GZv(cxE)<20 or(not Xax(cxE,"ReplaceableTextures"))then
set crE="ReplaceableTextures\\CommandButtons\\"+crE
endif
if not pIo(cxE,".blp")then
set crE=crE+".blp"
endif
call B_E(ceE,crE,"when calling setIconResearch in AbilityObjEditing, line 159")
call B6E(ceE,crE,"when calling setIconNormal in AbilityObjEditing, line 160")
set EM=EM-1
endfunction
function ciE takes integer caE,string cnE,string cVE returns nothing
set ZM[EM]=cVE
set EM=EM+1
if tY[caE]==0 then
if caE==0 then
call Cdv("Nullpointer exception when calling AbilityDefinition.presetIcon","when calling error in AbilityObjEditing, line 152")
else
call Cdv("Called AbilityDefinition.presetIcon on invalid object.","when calling error in AbilityObjEditing, line 152")
endif
endif
call cvE(caE,cnE,"when calling presetIcon in AbilityObjEditing, line 152")
set EM=EM-1
endfunction
function cEE takes integer cXE,integer cOE,integer cRE,integer cIE,string cAE,string cNE,string cbE,string cBE returns integer
local integer ccE
local integer cCE
local integer cdE
local integer cDE
local integer cfE
local integer cFE
local integer cgE
local integer cGE
local integer chE
local integer cHE
set ZM[EM]=cBE
set EM=EM+1
set cgE=cOE
set cGE=cRE
set ccE=cgE
set cCE=cGE
if BlE(cXE,JWa(ccE,cCE),"when reading array SotfrpGuiHelperUnitPreset_Palette_isTaken in  in SotfrpGuiPresets, line 64")then
call BPE("Button position ("+SMv(cOE)+", "+SMv(cRE)+") is taken")
endif
call NPE(cXE,JWa(ccE,cCE),true,"when writing array SotfrpGuiHelperUnitPreset_Palette_isTaken in SotfrpGuiPresets, line 66")
call BjE(cIE,Mf[JWa(ccE,cCE)],"when calling presetHotkey in SotfrpGuiPresets, line 67")
if cAE!=null then
set cfE=cIE
set cdE=BwE("when calling alloc_StringLevelClosure_presetTooltipNormal_Palette_SotfrpGuiHelperUnitPreset_SotfrpGuiPresets in SotfrpGuiPresets, line 69")
set QL[cdE]=cAE
set chE=ccE
set cHE=cCE
set WL[cdE]=chE
set EL[cdE]=cHE
call NwE(cfE,cdE,"when calling presetTooltipNormal in SotfrpGuiPresets, line 69")
endif
if cNE!=null then
set cFE=cIE
set cDE=bkE("when calling alloc_StringLevelClosure_presetTooltipNormalExtended_Palette_SotfrpGuiHelperUnitPreset_SotfrpGuiPresets in SotfrpGuiPresets, line 71")
set ZL[cDE]=cNE
call BtE(cFE,cDE,"when calling presetTooltipNormalExtended in SotfrpGuiPresets, line 71")
endif
if cbE!=null then
call ciE(cIE,cbE,"when calling presetIcon in SotfrpGuiPresets, line 73")
endif
call b_E(cIE,ccE,cCE,"when calling presetButtonPosNormal in SotfrpGuiPresets, line 74")
call bhE(cXE,cIE,"when calling addAbility in SotfrpGuiPresets, line 75")
set EM=EM-1
return cIE
endfunction
function cjE takes integer cJE,integer ckE,integer cKE,integer clE,string cLE,string cmE,string cME,string cpE returns integer
local integer cPE
set ZM[EM]=cpE
set EM=EM+1
if uv[cJE]==0 then
if cJE==0 then
call Cdv("Nullpointer exception when calling SotfrpGuiHelperUnitPreset.addButton","when calling error in SotfrpGuiPresets, line 62")
else
call Cdv("Called SotfrpGuiHelperUnitPreset.addButton on invalid object.","when calling error in SotfrpGuiPresets, line 62")
endif
endif
set cPE=cEE(cJE,ckE,cKE,clE,cLE,cmE,cME,"when calling addButton in SotfrpGuiPresets, line 62")
set EM=EM-1
return cPE
endfunction
function cqE takes integer cQE,integer csE,integer cSE,integer ctE,string cTE,string cuE,string cUE returns integer
local integer cwE
set ZM[EM]=cUE
set EM=EM+1
set cwE=cjE(cQE,csE,cSE,ctE,cTE,cuE,null,"when calling addButton in SotfrpGuiPresets, line 83")
set EM=EM-1
return cwE
endfunction
function cWE takes integer cyE,integer cYE,integer czE,integer cZE,string c_E,string c0E,string c1E returns integer
local integer c2E
set ZM[EM]=c1E
set EM=EM+1
if uv[cyE]==0 then
if cyE==0 then
call Cdv("Nullpointer exception when calling SotfrpGuiHelperUnitPreset.addButton","when calling error in SotfrpGuiPresets, line 82")
else
call Cdv("Called SotfrpGuiHelperUnitPreset.addButton on invalid object.","when calling error in SotfrpGuiPresets, line 82")
endif
endif
set c2E=cqE(cyE,cYE,czE,cZE,c_E,c0E,"when calling addButton in SotfrpGuiPresets, line 82")
set EM=EM-1
return c2E
endfunction
function c3E takes integer c4E,string c5E returns nothing
call RgE(gB[c4E],"utyp",c5E)
endfunction
function c6E takes integer c7E,string c8E,string c9E returns nothing
set ZM[EM]=c9E
set EM=EM+1
if uv[c7E]==0 then
if c7E==0 then
call Cdv("Nullpointer exception when calling UnitOrBuildingOrHeroDefinition.setUnitClassification","when calling error in UnitObjEditing, line 274")
else
call Cdv("Called UnitOrBuildingOrHeroDefinition.setUnitClassification on invalid object.","when calling error in UnitObjEditing, line 274")
endif
endif
call c3E(c7E,c8E)
set EM=EM-1
endfunction
function CvE takes integer CeE,real CxE returns nothing
call RzE(gB[CeE],"ussc",CxE)
endfunction
function CoE takes integer CrE,real CiE,string CaE returns nothing
set ZM[EM]=CaE
set EM=EM+1
if uv[CrE]==0 then
if CrE==0 then
call Cdv("Nullpointer exception when calling UnitOrBuildingOrHeroDefinition.setSelectionScale","when calling error in UnitObjEditing, line 360")
else
call Cdv("Called UnitOrBuildingOrHeroDefinition.setSelectionScale on invalid object.","when calling error in UnitObjEditing, line 360")
endif
endif
call CvE(CrE,CiE)
set EM=EM-1
endfunction
function CnE takes string CVE returns integer
local integer CEE
set ZM[EM]=CVE
set EM=EM+1
if DG==0 then
if HG<$8000 then
set HG=HG+1
set CEE=HG
set JG[CEE]=4200
else
call Cdv("Out of memory: Could not create RealLevelClosure_presetDurationNormal_presetDurationHero_presetCastRange_addHiddenAbility_addButton_addButton_SotfrpGuiCoreUnit.","when calling error in SotfrpGuiCoreUnit, line 31")
set CEE=0
endif
else
set DG=DG-1
set CEE=AG[DG]
set JG[CEE]=4200
endif
set EM=EM-1
return CEE
endfunction
function CXE takes string COE returns integer
local integer CRE
set ZM[EM]=COE
set EM=EM+1
if lY==0 then
if bY<$8000 then
set bY=bY+1
set CRE=bY
set yY[CRE]=4822
else
call Cdv("Out of memory: Could not create StringLevelClosure_addTooltipProperty_AbilityDefinition_AbilityObjEditing.","when calling error in AbilityObjEditing, line 77")
set CRE=0
endif
else
set lY=lY-1
set CRE=OY[lY]
set yY[CRE]=4822
endif
set EM=EM-1
return CRE
endfunction
function CIE takes integer CAE,string CNE,integer CbE,string CBE returns nothing
local integer CcE
local integer CCE
local string CdE
set ZM[EM]=CBE
set EM=EM+1
set CCE=CAE
set CdE=CNE
set CcE=CXE("when calling alloc_StringLevelClosure_addTooltipProperty_AbilityDefinition_AbilityObjEditing in AbilityObjEditing, line 77")
set lQ[CcE]=CbE
call hya(CCE,CdE,CcE,"when calling addTooltipProperty in AbilityObjEditing, line 77")
set EM=EM-1
endfunction
function CDE takes integer CfE,string CFE,integer CgE,string CGE returns nothing
set ZM[EM]=CGE
set EM=EM+1
if tY[CfE]==0 then
if CfE==0 then
call Cdv("Nullpointer exception when calling AbilityDefinition.addTooltipProperty","when calling error in AbilityObjEditing, line 76")
else
call Cdv("Called AbilityDefinition.addTooltipProperty on invalid object.","when calling error in AbilityObjEditing, line 76")
endif
endif
call CIE(CfE,CFE,CgE,"when calling addTooltipProperty in AbilityObjEditing, line 76")
set EM=EM-1
endfunction
function ChE takes integer Dku,string Hku,integer Jku,integer Kku,real Lku returns nothing
endfunction
function CHE takes integer CjE,string CJE,integer CkE,integer CKE,integer ClE,string CLE returns nothing
local integer CmE
local integer CME
set ZM[EM]=CLE
set EM=EM+1
set CmE=1
set CME=CkE
loop
exitwhen CmE>CME
call ChE(CjE,CJE,CmE,CKE,j2a(ClE,CmE,"when calling run in ObjEditingNatives, line 98"))
set CmE=CmE+1
endloop
set EM=EM-1
endfunction
function CpE takes integer CPE,integer CqE,string CQE returns nothing
set ZM[EM]=CQE
set EM=EM+1
call CHE(rQ[CPE],"aran",sQ[CPE],0,CqE,"when calling setLevelsDataUnreal in AbilityObjEditing, line 382")
call CDE(CPE,"CastRange",CqE,"when calling addTooltipProperty in AbilityObjEditing, line 383")
set EM=EM-1
endfunction
function CsE takes integer CSE,integer CtE,string CTE returns nothing
set ZM[EM]=CTE
set EM=EM+1
if tY[CSE]==0 then
if CSE==0 then
call Cdv("Nullpointer exception when calling AbilityDefinition.presetCastRange","when calling error in AbilityObjEditing, line 381")
else
call Cdv("Called AbilityDefinition.presetCastRange on invalid object.","when calling error in AbilityObjEditing, line 381")
endif
endif
call CpE(CSE,CtE,"when calling presetCastRange in AbilityObjEditing, line 381")
set EM=EM-1
endfunction
function CuE takes integer bis returns nothing
endfunction
function CUE takes integer CwE,integer CWE returns nothing
call KLa(CwE,CWE,cy)
call CuE(CwE)
endfunction
function CyE takes string CYE returns integer
local integer CzE
set ZM[EM]=CYE
set EM=EM+1
if rY==0 then
if sY<$8000 then
set sY=sY+1
set CzE=sY
set tY[CzE]=394
else
call Cdv("Out of memory: Could not create AbilityDefinitionLoad.","when calling error in AbilityObjEditing, line 10097")
set CzE=0
endif
else
set rY=rY-1
set CzE=uY[rY]
set tY[CzE]=394
endif
set EM=EM-1
return CzE
endfunction
function CZE takes integer C_E,string C0E returns integer
local integer C1E
set ZM[EM]=C0E
set EM=EM+1
set C1E=CyE("when calling alloc_AbilityDefinitionLoad in AbilityObjEditing, line 10098")
call CUE(C1E,C_E)
set EM=EM-1
return C1E
endfunction
function C2E takes integer C3E,real C4E returns nothing
call IXE(gB[C3E],"umvh",C4E)
endfunction
function C5E takes integer C6E,real C7E,string C8E returns nothing
set ZM[EM]=C8E
set EM=EM+1
if uv[C6E]==0 then
if C6E==0 then
call Cdv("Nullpointer exception when calling UnitOrBuildingOrHeroDefinition.setMovementHeight","when calling error in UnitObjEditing, line 501")
else
call Cdv("Called UnitOrBuildingOrHeroDefinition.setMovementHeight on invalid object.","when calling error in UnitObjEditing, line 501")
endif
endif
call C2E(C6E,C7E)
set EM=EM-1
endfunction
function C9E takes integer dvE,integer deE,string dxE returns nothing
set ZM[EM]=dxE
set EM=EM+1
call bRE(dvE,deE,"when calling addAbility in SotfrpGuiPresets, line 119")
set EM=EM-1
endfunction
function doE takes integer drE,integer diE,string daE returns nothing
set ZM[EM]=daE
set EM=EM+1
if uv[drE]==0 then
if drE==0 then
call Cdv("Nullpointer exception when calling SotfrpGuiHelperUnitPreset.addHiddenAbility","when calling error in SotfrpGuiPresets, line 118")
else
call Cdv("Called SotfrpGuiHelperUnitPreset.addHiddenAbility on invalid object.","when calling error in SotfrpGuiPresets, line 118")
endif
endif
call C9E(drE,diE,"when calling addHiddenAbility in SotfrpGuiPresets, line 118")
set EM=EM-1
endfunction
function dnE takes integer dVE,integer dEE returns nothing
call R8E(gB[dVE],"usid",dEE)
endfunction
function dXE takes integer dOE,integer dRE,string dIE returns nothing
set ZM[EM]=dIE
set EM=EM+1
if uv[dOE]==0 then
if dOE==0 then
call Cdv("Nullpointer exception when calling UnitOrBuildingOrHeroDefinition.setSightRadiusDay","when calling error in UnitObjEditing, line 339")
else
call Cdv("Called UnitOrBuildingOrHeroDefinition.setSightRadiusDay on invalid object.","when calling error in UnitObjEditing, line 339")
endif
endif
call dnE(dOE,dRE)
set EM=EM-1
endfunction
function dAE takes string dNE returns integer
local integer dbE
set ZM[EM]=dNE
set EM=EM+1
if rY==0 then
if sY<$8000 then
set sY=sY+1
set dbE=sY
set tY[dbE]=26
else
call Cdv("Out of memory: Could not create AbilityDefinition.","when calling error in AbilityObjEditing, line 38")
set dbE=0
endif
else
set rY=rY-1
set dbE=uY[rY]
set tY[dbE]=26
endif
set EM=EM-1
return dbE
endfunction
function dBE takes integer dcE,integer dCE,string ddE returns integer
local integer dDE
set ZM[EM]=ddE
set EM=EM+1
set dDE=dAE("when calling alloc_AbilityDefinition in AbilityObjEditing, line 57")
call KLa(dDE,dcE,dCE)
set EM=EM-1
return dDE
endfunction
function dfE takes string dFE returns integer
local integer dgE
set ZM[EM]=dFE
set EM=EM+1
if SY==0 then
if cY<$8000 then
set cY=cY+1
set dgE=cY
set oY[dgE]=$C4A
else
call Cdv("Out of memory: Could not create IntLevelClosure_presetCargoCapacity_presetDurationNormal_presetDurationHero_presetCastRange_addHiddenAbility_addButton_addButton_SotfrpGuiCoreUnit.","when calling error in SotfrpGuiCoreUnit, line 31")
set dgE=0
endif
else
set SY=SY-1
set dgE=iY[SY]
set oY[dgE]=$C4A
endif
set EM=EM-1
return dgE
endfunction
function dGE takes string dhE returns integer
local integer dHE
set ZM[EM]=dhE
set EM=EM+1
if DG==0 then
if HG<$8000 then
set HG=HG+1
set dHE=HG
set JG[dHE]=4194
else
call Cdv("Out of memory: Could not create RealLevelClosure_presetDurationHero_presetCastRange_addHiddenAbility_addButton_addButton_SotfrpGuiCoreUnit.","when calling error in SotfrpGuiCoreUnit, line 31")
set dHE=0
endif
else
set DG=DG-1
set dHE=AG[DG]
set JG[dHE]=4194
endif
set EM=EM-1
return dHE
endfunction
function djE takes string dJE returns integer
local integer dkE
set ZM[EM]=dJE
set EM=EM+1
if DG==0 then
if HG<$8000 then
set HG=HG+1
set dkE=HG
set JG[dkE]=4179
else
call Cdv("Out of memory: Could not create RealLevelClosure_presetCastRange_addHiddenAbility_addButton_addButton_SotfrpGuiCoreUnit.","when calling error in SotfrpGuiCoreUnit, line 31")
set dkE=0
endif
else
set DG=DG-1
set dkE=AG[DG]
set JG[dkE]=4179
endif
set EM=EM-1
return dkE
endfunction
function dKE takes nothing returns integer
return Cf
endfunction
function dlE takes integer dLE,integer dmE,string dME returns nothing
set ZM[EM]=dME
set EM=EM+1
call CHE(rQ[dLE],"adur",sQ[dLE],0,dmE,"when calling setLevelsDataUnreal in AbilityObjEditing, line 347")
call CDE(dLE,"DurationNormal",dmE,"when calling addTooltipProperty in AbilityObjEditing, line 348")
set EM=EM-1
endfunction
function dpE takes integer dPE,integer dqE,string dQE returns nothing
set ZM[EM]=dQE
set EM=EM+1
if tY[dPE]==0 then
if dPE==0 then
call Cdv("Nullpointer exception when calling AbilityDefinition.presetDurationNormal","when calling error in AbilityObjEditing, line 346")
else
call Cdv("Called AbilityDefinition.presetDurationNormal on invalid object.","when calling error in AbilityObjEditing, line 346")
endif
endif
call dlE(dPE,dqE,"when calling presetDurationNormal in AbilityObjEditing, line 346")
set EM=EM-1
endfunction
function dsE takes integer dSE,integer dtE,string dTE returns nothing
set ZM[EM]=dTE
set EM=EM+1
call bhE(dSE,dtE,"when calling addAbility in SotfrpGuiPresets, line 116")
set EM=EM-1
endfunction
function duE takes integer dUE,integer dwE,string dWE returns nothing
set ZM[EM]=dWE
set EM=EM+1
if uv[dUE]==0 then
if dUE==0 then
call Cdv("Nullpointer exception when calling SotfrpGuiHelperUnitPreset.addHiddenAbility","when calling error in SotfrpGuiPresets, line 115")
else
call Cdv("Called SotfrpGuiHelperUnitPreset.addHiddenAbility on invalid object.","when calling error in SotfrpGuiPresets, line 115")
endif
endif
call dsE(dUE,dwE,"when calling addHiddenAbility in SotfrpGuiPresets, line 115")
set EM=EM-1
endfunction
function dyE takes integer dYE,integer dzE returns nothing
call R8E(gB[dYE],"usin",dzE)
endfunction
function dZE takes integer d_E,integer d0E,string d1E returns nothing
set ZM[EM]=d1E
set EM=EM+1
if uv[d_E]==0 then
if d_E==0 then
call Cdv("Nullpointer exception when calling UnitOrBuildingOrHeroDefinition.setSightRadiusNight","when calling error in UnitObjEditing, line 336")
else
call Cdv("Called UnitOrBuildingOrHeroDefinition.setSightRadiusNight on invalid object.","when calling error in UnitObjEditing, line 336")
endif
endif
call dyE(d_E,d0E)
set EM=EM-1
endfunction
function d2E takes integer d3E,integer d4E,string d5E returns nothing
set ZM[EM]=d5E
set EM=EM+1
call CHE(rQ[d3E],"ahdu",sQ[d3E],0,d4E,"when calling setLevelsDataUnreal in AbilityObjEditing, line 354")
call CDE(d3E,"DurationHero",d4E,"when calling addTooltipProperty in AbilityObjEditing, line 355")
set EM=EM-1
endfunction
function d6E takes integer d7E,integer d8E,string d9E returns nothing
set ZM[EM]=d9E
set EM=EM+1
if tY[d7E]==0 then
if d7E==0 then
call Cdv("Nullpointer exception when calling AbilityDefinition.presetDurationHero","when calling error in AbilityObjEditing, line 353")
else
call Cdv("Called AbilityDefinition.presetDurationHero on invalid object.","when calling error in AbilityObjEditing, line 353")
endif
endif
call d2E(d7E,d8E,"when calling presetDurationHero in AbilityObjEditing, line 353")
set EM=EM-1
endfunction
function DvE takes string DeE returns integer
local integer DxE
set ZM[EM]=DeE
set EM=EM+1
if DG==0 then
if HG<$8000 then
set HG=HG+1
set DxE=HG
set JG[DxE]=4177
else
call Cdv("Out of memory: Could not create RealLevelClosure_presetCastRange_addButton_addButton_SotfrpGuiCoreUnit.","when calling error in SotfrpGuiCoreUnit, line 32")
set DxE=0
endif
else
set DG=DG-1
set DxE=AG[DG]
set JG[DxE]=4177
endif
set EM=EM-1
return DxE
endfunction
function DoE takes integer DrE,real DiE returns nothing
call IXE(gB[DrE],"umvr",DiE)
endfunction
function DaE takes integer DnE,real DVE,string DEE returns nothing
set ZM[EM]=DEE
set EM=EM+1
if uv[DnE]==0 then
if DnE==0 then
call Cdv("Nullpointer exception when calling UnitOrBuildingOrHeroDefinition.setTurnRate","when calling error in UnitObjEditing, line 280")
else
call Cdv("Called UnitOrBuildingOrHeroDefinition.setTurnRate on invalid object.","when calling error in UnitObjEditing, line 280")
endif
endif
call DoE(DnE,DVE)
set EM=EM-1
endfunction
function DXE takes integer gts returns nothing
endfunction
function DOE takes integer DRE,integer DIE returns nothing
call KLa(DRE,DIE,'Sch3')
call DXE(DRE)
endfunction
function DAE takes string DNE returns integer
local integer DbE
set ZM[EM]=DNE
set EM=EM+1
if rY==0 then
if sY<$8000 then
set sY=sY+1
set DbE=sY
set tY[DbE]=$9D
else
call Cdv("Out of memory: Could not create AbilityDefinitionCargoHoldTransport.","when calling error in AbilityObjEditing, line 3392")
set DbE=0
endif
else
set rY=rY-1
set DbE=uY[rY]
set tY[DbE]=$9D
endif
set EM=EM-1
return DbE
endfunction
function DBE takes integer DcE,string DCE returns integer
local integer DdE
set ZM[EM]=DCE
set EM=EM+1
set DdE=DAE("when calling alloc_AbilityDefinitionCargoHoldTransport in AbilityObjEditing, line 3393")
call DOE(DdE,DcE)
set EM=EM-1
return DdE
endfunction
function DDE takes string DfE returns integer
local integer DFE
local integer DgE
local integer DGE
local integer DhE
local integer DHE
local integer DjE
local integer DJE
local integer DkE
local integer DKE
local integer DlE
local integer DLE
local integer DmE
local integer DME
local integer DpE
local integer DPE
local integer DqE
local integer DQE
local integer DsE
local integer DSE
local integer DtE
local integer DTE
local integer DuE
local integer DUE
local integer DwE
local integer DWE
local integer DyE
local integer DYE
local integer DzE
local integer DZE
local integer D_E
local integer D0E
local integer D1E
local integer D2E
local integer D3E
local integer D4E
local integer D5E
local integer D6E
local integer D7E
local integer D8E
set ZM[EM]=DfE
set EM=EM+1
set DFE=NbE("when calling new_SotfrpGuiHelperUnitPreset in SotfrpGuiCoreUnit, line 16")
call RjE(DFE,"Ядро","when calling setName in SotfrpGuiCoreUnit, line 17")
set DgE=DFE
call NfE(DgE,"ReplaceableTextures\\WorldEditUI\\StartingLocation.blp","when calling setIconGameInterface in SotfrpGuiCoreUnit, line 18")
set DGE=DgE
call RTE(DGE,nq,"when calling setModelFile in SotfrpGuiCoreUnit, line 19")
set DhE=DGE
call R1E(DhE,.33,"when calling setScalingValue in SotfrpGuiCoreUnit, line 20")
set DHE=DhE
call CoE(DHE,1.75,"when calling setSelectionScale in SotfrpGuiCoreUnit, line 21")
set DjE=DHE
call c6E(DjE,"peon","when calling setUnitClassification in SotfrpGuiCoreUnit, line 22")
set DJE=DjE
call DaE(DJE,3.,"when calling setTurnRate in SotfrpGuiCoreUnit, line 23")
set DkE=DJE
call dXE(DkE,$5DC,"when calling setSightRadiusDay in SotfrpGuiCoreUnit, line 24")
set DKE=DkE
call dZE(DKE,$5DC,"when calling setSightRadiusNight in SotfrpGuiCoreUnit, line 25")
set DlE=DKE
call C5E(DlE,300.,"when calling setMovementHeight in SotfrpGuiCoreUnit, line 26")
set DLE=DlE
call NLE(DLE,3,"when calling setMovementType in SotfrpGuiCoreUnit, line 27")
set DmE=DLE
call doE(DmE,Sy,"when calling addHiddenAbility in SotfrpGuiCoreUnit, line 28")
set DME=DmE
call doE(DME,iy,"when calling addHiddenAbility in SotfrpGuiCoreUnit, line 29")
set DpE=DME
call duE(DpE,dKE(),"when calling addHiddenAbility in SotfrpGuiCoreUnit, line 30")
set DUE=DpE
set D4E=DUE
set DqE=DBE(l0a(qq,"when calling next in SotfrpGuiCoreUnit, line 31"),"when calling new_AbilityDefinitionCargoHoldTransport in SotfrpGuiCoreUnit, line 31")
set D0E=DqE
set DPE=dfE("when calling alloc_IntLevelClosure_presetCargoCapacity_presetDurationNormal_presetDurationHero_presetCastRange_addHiddenAbility_addButton_addButton_SotfrpGuiCoreUnit in SotfrpGuiCoreUnit, line 31")
call RpE(D0E,DPE,"when calling presetCargoCapacity in SotfrpGuiCoreUnit, line 31")
set DsE=DqE
set D1E=DsE
set DQE=CnE("when calling alloc_RealLevelClosure_presetDurationNormal_presetDurationHero_presetCastRange_addHiddenAbility_addButton_addButton_SotfrpGuiCoreUnit in SotfrpGuiCoreUnit, line 31")
call dpE(D1E,DQE,"when calling presetDurationNormal in SotfrpGuiCoreUnit, line 31")
set DtE=DsE
set D2E=DtE
set DSE=dGE("when calling alloc_RealLevelClosure_presetDurationHero_presetCastRange_addHiddenAbility_addButton_addButton_SotfrpGuiCoreUnit in SotfrpGuiCoreUnit, line 31")
call d6E(D2E,DSE,"when calling presetDurationHero in SotfrpGuiCoreUnit, line 31")
set DuE=DtE
set D3E=DuE
set DTE=djE("when calling alloc_RealLevelClosure_presetCastRange_addHiddenAbility_addButton_addButton_SotfrpGuiCoreUnit in SotfrpGuiCoreUnit, line 31")
call CsE(D3E,DTE,"when calling presetCastRange in SotfrpGuiCoreUnit, line 31")
call duE(D4E,DuE,"when calling addHiddenAbility in SotfrpGuiCoreUnit, line 31")
set DyE=DUE
set D6E=DyE
set DWE=CZE(l0a(qq,"when calling next in SotfrpGuiCoreUnit, line 32"),"when calling new_AbilityDefinitionLoad in SotfrpGuiCoreUnit, line 32")
set D5E=DWE
set DwE=DvE("when calling alloc_RealLevelClosure_presetCastRange_addButton_addButton_SotfrpGuiCoreUnit in SotfrpGuiCoreUnit, line 32")
call CsE(D5E,DwE,"when calling presetCastRange in SotfrpGuiCoreUnit, line 32")
call cWE(D6E,0,2,DWE,"Погрузка","Погрузка дружественных наземных войск.","when calling addButton in SotfrpGuiCoreUnit, line 32")
set DZE=DyE
set D8E=DZE
set DzE=dBE(l0a(qq,"when calling next in SotfrpGuiCoreUnit, line 33"),Oy,"when calling new_AbilityDefinition in SotfrpGuiCoreUnit, line 33")
set D7E=DzE
set DYE=RWE("when calling alloc_RealLevelClosure_presetCastRange_addButton_SotfrpGuiCoreUnit in SotfrpGuiCoreUnit, line 33")
call CsE(D7E,DYE,"when calling presetCastRange in SotfrpGuiCoreUnit, line 33")
call cWE(D8E,1,2,DzE,"Выгрузка","Выгрузка дружественных наземных войск.","when calling addButton in SotfrpGuiCoreUnit, line 33")
set D_E=DZE
set EM=EM-1
return D_E
endfunction
function D9E takes string fvE returns integer
local integer feE
set ZM[EM]=fvE
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set feE=Yj
set Gj[feE]=$B1B
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_SotfrpGuiCoreUnit.","when calling error in SotfrpGuiCoreUnit, line 113")
set feE=0
endif
else
set Tj=Tj-1
set feE=Rj[Tj]
set Gj[feE]=$B1B
endif
set EM=EM-1
return feE
endfunction
function fxE takes string foE returns integer
local integer frE
set ZM[EM]=foE
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set frE=Yj
set Gj[frE]=$B97
else
call Cdv("Out of memory: Could not create IBuiltin_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_SotfrpGuiCoreUnit.","when calling error in SotfrpGuiCoreUnit, line 84")
set frE=0
endif
else
set Tj=Tj-1
set frE=Rj[Tj]
set Gj[frE]=$B97
endif
set EM=EM-1
return frE
endfunction
function fiE takes string faE returns integer
local integer fnE
set ZM[EM]=faE
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set fnE=Yj
set Gj[fnE]=$A35
else
call Cdv("Out of memory: Could not create IBuiltin_registerProtectedBuiltin_SotfrpGuiCoreUnit.","when calling error in SotfrpGuiCoreUnit, line 80")
set fnE=0
endif
else
set Tj=Tj-1
set fnE=Rj[Tj]
set Gj[fnE]=$A35
endif
set EM=EM-1
return fnE
endfunction
function fVE takes string fEE returns boolean
local integer fXE
local integer fOE
local integer fRE
local group fIE
local group fAE
local group fNE
local group fbE
local integer fBE
local integer fcE
local integer fCE
local integer fdE
local integer fDE
local integer ffE
local integer fFE
local integer fgE
local integer fGE
local integer fhE
local integer fHE
local integer fjE
local integer fJE
local integer fkE
local integer fKE
local integer flE
local integer fLE
local playerevent fmE
local integer fME
local integer fpE
set ZM[EM]=fEE
set EM=EM+1
if me then
call DDE("when calling generateCore in SotfrpGuiCoreUnit, line 35")
endif
set xf='x003'
call LHa(RaE(),"when calling protectUnitType in SotfrpGuiCoreUnit, line 56")
set fXE=0
set fOE=bj_MAX_PLAYERS-1
loop
exitwhen fXE>fOE
if wRx(sa[fXE])then
set vf[fXE]=RXE(fXE,"when calling initCore in SotfrpGuiCoreUnit, line 59")
endif
set fXE=fXE+1
endloop
set fmE=EVENT_PLAYER_LEAVE
set fRE=OYE("when calling alloc_EventListener_add_SotfrpGuiCoreUnit in SotfrpGuiCoreUnit, line 60")
call Zen(fRE)
call ZCn(fmE,fRE,"when calling add in SotfrpGuiCoreUnit, line 60")
call RvE(0,2)
set fAE=CreateGroup()
call OTE(fAE,We)
set fIE=fAE
call ForGroup(fIE,Rvv)
set fNE=fIE
call J5e(fNE)
set fbE=fNE
call kcv(fbE)
set fBE=O_E("when calling alloc_IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_SotfrpGuiCoreUnit in SotfrpGuiCoreUnit, line 69")
set fcE=OPo(fBE,"when calling new_BuiltinData in SotfrpGuiCoreUnit, line 69")
call O4E(fcE,"when calling setArgumentsTypes in SotfrpGuiCoreUnit, line 72")
set fCE=fcE
call LWV(fCE,"when calling setRequiringEnumUnit in SotfrpGuiCoreUnit, line 72")
set ffE=ILo(fCE,"when calling new_BuiltinFunction in SotfrpGuiCoreUnit, line 69")
set fME=ffE
set fdE=OwE("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_SotfrpGuiCoreUnit in SotfrpGuiCoreUnit, line 72")
set fDE=OPo(fdE,"when calling new_BuiltinData in SotfrpGuiCoreUnit, line 72")
call Rxo(fDE,e4V(),"when calling setArgumentsTypes in SotfrpGuiCoreUnit, line 75")
call IFo(fME,fDE,"when calling addOverload in SotfrpGuiCoreUnit, line 72")
call Foa(ffE,"fs","when calling registerProtectedBuiltin in SotfrpGuiCoreUnit, line 69")
set fFE=O7E("when calling alloc_IBuiltin_registerProtectedBuiltin_SotfrpGuiCoreUnit in SotfrpGuiCoreUnit, line 77")
call Foa(ILo(OPo(fFE,"when calling new_BuiltinData in SotfrpGuiCoreUnit, line 77"),"when calling new_BuiltinFunction in SotfrpGuiCoreUnit, line 77"),"getcorex","when calling registerProtectedBuiltin in SotfrpGuiCoreUnit, line 77")
set fgE=fiE("when calling alloc_IBuiltin_registerProtectedBuiltin_SotfrpGuiCoreUnit in SotfrpGuiCoreUnit, line 80")
call Foa(ILo(OPo(fgE,"when calling new_BuiltinData in SotfrpGuiCoreUnit, line 80"),"when calling new_BuiltinFunction in SotfrpGuiCoreUnit, line 80"),"getcorey","when calling registerProtectedBuiltin in SotfrpGuiCoreUnit, line 80")
set fGE=fxE("when calling alloc_IBuiltin_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_SotfrpGuiCoreUnit in SotfrpGuiCoreUnit, line 84")
set fhE=OPo(fGE,"when calling new_BuiltinData in SotfrpGuiCoreUnit, line 84")
call LWV(fhE,"when calling setRequiringEnumUnit in SotfrpGuiCoreUnit, line 92")
set fJE=ILo(fhE,"when calling new_BuiltinFunction in SotfrpGuiCoreUnit, line 84")
set fpE=fJE
set fHE=RcE("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_SotfrpGuiCoreUnit in SotfrpGuiCoreUnit, line 92")
set fjE=OPo(fHE,"when calling new_BuiltinData in SotfrpGuiCoreUnit, line 92")
call Rxo(fjE,e4V(),"when calling setArgumentsTypes in SotfrpGuiCoreUnit, line 100")
call IFo(fpE,fjE,"when calling addOverload in SotfrpGuiCoreUnit, line 92")
call Foa(fJE,"duplicate","when calling registerProtectedBuiltin in SotfrpGuiCoreUnit, line 84")
set fkE=RDE("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_SotfrpGuiCoreUnit in SotfrpGuiCoreUnit, line 110")
set fKE=OPo(fkE,"when calling new_BuiltinData in SotfrpGuiCoreUnit, line 110")
call FRa(fKE,f3a(),OFo(),"when calling setArgumentsTypes in SotfrpGuiCoreUnit, line 112")
call Foa(ILo(fKE,"when calling new_BuiltinFunction in SotfrpGuiCoreUnit, line 110"),"spawn","when calling registerProtectedBuiltin in SotfrpGuiCoreUnit, line 110")
set flE=D9E("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_SotfrpGuiCoreUnit in SotfrpGuiCoreUnit, line 113")
set fLE=OPo(flE,"when calling new_BuiltinData in SotfrpGuiCoreUnit, line 113")
call FRa(fLE,f3a(),OFo(),"when calling setArgumentsTypes in SotfrpGuiCoreUnit, line 115")
call Foa(ILo(fLE,"when calling new_BuiltinFunction in SotfrpGuiCoreUnit, line 113"),"mnstr","when calling registerProtectedBuiltin in SotfrpGuiCoreUnit, line 113")
set EM=EM-1
set fIE=null
set fAE=null
set fNE=null
set fbE=null
set fmE=null
return true
endfunction
function fPE takes nothing returns boolean
set EM=0
return fVE("SotfrpGuiCoreUnit, line 1")
endfunction
function fqE takes nothing returns boolean
return(Mu==1)
endfunction
function fQE takes nothing returns boolean
return(CountUnitsInGroup(lr[rr])==0)
endfunction
function fsE takes nothing returns boolean
return(GetUnitFlyHeight(GetEnumUnit())<5.)
endfunction
function fSE takes nothing returns boolean
return(Mu==2)
endfunction
function ftE takes nothing returns boolean
return(er<=100.)
endfunction
function fTE takes nothing returns nothing
set Ju[2]=GetUnitLoc(Nu)
set er=LoadRealBJ(1,GetHandleIdBJ(GetEnumUnit()),Au)
set qr=LoadRealBJ(2,GetHandleIdBJ(GetEnumUnit()),Au)
set ar=LoadRealBJ(3,GetHandleIdBJ(GetEnumUnit()),Au)
if ftE()then
set Ju[3]=PolarProjectionBJ(Ju[2],er+2.,qr+10.)
call SaveRealBJ(er+2.,1,GetHandleIdBJ(GetEnumUnit()),Au)
else
set Ju[3]=PolarProjectionBJ(Ju[2],er,qr+5.)
endif
call SaveRealBJ(qr+10.,2,GetHandleIdBJ(GetEnumUnit()),Au)
call SaveRealBJ(ar+3.,3,GetHandleIdBJ(GetEnumUnit()),Au)
call SetUnitPositionLocFacingBJ(GetEnumUnit(),Ju[3],qr+90.)
call SetUnitFlyHeightBJ(GetEnumUnit(),GetUnitFlyHeight(GetEnumUnit())-3.,.0)
call SetUnitScalePercent(GetEnumUnit(),ar,ar,ar)
if fsE()then
call KillUnit(GetEnumUnit())
call GroupRemoveUnitSimple(GetEnumUnit(),lr[rr])
call GroupAddUnitSimple(GetEnumUnit(),Ku)
call SaveIntegerBJ(Du+1,0,GetHandleIdBJ(GetEnumUnit()),Au)
if fqE()then
call AddSpecialEffectLocBJ(Ju[3],"Abilities\\Weapons\\LichMissile\\LichMissile.mdl")
elseif fSE()then
call AddSpecialEffectLocBJ(Ju[3],"Abilities\\Weapons\\RedDragonBreath\\RedDragonMissile.mdl")
else
call AddSpecialEffectLocBJ(Ju[3],"Abilities\\Weapons\\FarseerMissile\\FarseerMissile.mdl")
endif
call DestroyEffectBJ(GetLastCreatedEffectBJ())
if fQE()then
call SaveIntegerBJ(0,$A,Bu,Au)
call SaveIntegerBJ(3,7,Bu,Au)
endif
endif
call RemoveLocation(Ju[2])
call RemoveLocation(Ju[3])
endfunction
function fuE takes nothing returns boolean
if GetSpellAbilityId()=='AOww' then
return true
else
return false
endif
endfunction
function fUE takes nothing returns nothing
call GroupRemoveUnit(ps,GetSpellAbilityUnit())
endfunction
function fwE takes nothing returns boolean
return(GetSpellAbilityId()=='A0G5')
endfunction
function fWE takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),1,6)=="height")
endfunction
function fyE takes integer fYE returns nothing
set Pb[fYE]=Pb[0]
set Pb[0]=fYE
endfunction
function fzE takes integer fZE returns nothing
set sy=fZE
call TriggerEvaluate(mb[xb[fZE]])
endfunction
function f_E takes nothing returns nothing
local integer f0E=LoadInteger(i,y,GetHandleId(GetExpiredTimer()))
call SetUnitX(Zb[f0E],GetUnitX(Zb[f0E])+Wb[f0E])
call SetUnitY(Zb[f0E],GetUnitY(Zb[f0E])+Eb[f0E])
set Qb[f0E]=Qb[f0E]-1
if Qb[f0E]==0 then
call Gmv(GetExpiredTimer())
call fzE(Ub[f0E])
call fyE(f0E)
endif
endfunction
function f1E takes nothing returns nothing
local location f2E=Location(GetSpellTargetX(),GetSpellTargetY())
local integer f3E=GetSpellAbilityId()
if f3E=='AcE1' then
call DestroyEffect(AddSpecialEffectLoc("Objects\\Spawnmodels\\Other\\NeutralBuildingExplosion\\NeutralBuildingExplosion.mdl",f2E))
endif
if f3E=='AcE2' then
call DestroyEffect(AddSpecialEffectLoc("Abilities\\Spells\\Other\\Doom\\DoomDeath.mdl",f2E))
endif
if f3E=='AcE3' then
call DestroyEffect(AddSpecialEffectLoc("Abilities\\Spells\\Human\\ReviveHuman\\ReviveHuman.mdl",f2E))
endif
if f3E=='AcE4' then
call DestroyEffect(AddSpecialEffectLoc("Objects\\Spawnmodels\\Undead\\UndeadDissipate\\UndeadDissipate.mdl",f2E))
endif
if f3E=='AcE5' then
call DestroyEffect(AddSpecialEffectLoc("Objects\\Spawnmodels\\Naga\\NagaDeath\\NagaDeath.mdl",f2E))
endif
if f3E=='AcE6' then
call DestroyEffect(AddSpecialEffectLoc("Objects\\Spawnmodels\\NightElf\\NEDeathMedium\\NEDeath.mdl",f2E))
endif
if f3E=='AcE7' then
call DestroyEffect(AddSpecialEffectLoc("Objects\\Spawnmodels\\Undead\\UDeathMedium\\UDeath.mdl",f2E))
endif
set f3E=0
call RemoveLocation(f2E)
set f2E=null
set f2E=null
endfunction
function f4E takes nothing returns nothing
local unit f5E=GetSpellAbilityUnit()
if GetSpellAbilityId()=='AcS7' then
call UnitRemoveAbility(f5E,'AcB7')
call UnitAddAbility(f5E,'AcB8')
call UnitMakeAbilityPermanent(f5E,true,'AcB8')
call UnitRemoveAbility(f5E,'AcLo')
call UnitRemoveAbility(f5E,'AcUL')
else
call UnitRemoveAbility(f5E,'AcB8')
call UnitAddAbility(f5E,'AcB7')
call UnitMakeAbilityPermanent(f5E,true,'AcB7')
call UnitAddAbility(f5E,'AcLo')
call UnitMakeAbilityPermanent(f5E,true,'AcLo')
call UnitAddAbility(f5E,'AcUL')
call UnitMakeAbilityPermanent(f5E,true,'AcUL')
endif
set f5E=null
set f5E=null
endfunction
function f6E takes nothing returns boolean
return(GetUnitTypeId(GetEnumUnit())!='h000')and(GetUnitTypeId(GetEnumUnit())!='h0KW')and(IsUnitSelected(GetEnumUnit(),GetTriggerPlayer()))
endfunction
function f7E takes nothing returns nothing
if f6E()then
call UnitRemoveTypeBJ(UNIT_TYPE_UNDEAD,GetEnumUnit())
endif
endfunction
function f8E takes nothing returns boolean
return(IsUnitInRangeLoc(GetFilterUnit(),GetUnitLoc(Os),50.)==false and IsUnitType(GetFilterUnit(),UNIT_TYPE_FLYING)==false and IsUnitAlly(GetFilterUnit(),GetOwningPlayer(Os))==false and GetOwningPlayer(GetFilterUnit())!=GetOwningPlayer(Os))!=null
endfunction
function f9E takes nothing returns boolean
set sp=CreateGroup()
set ip=0
set Sp=je
set cp=0
set op=Filter(OPv)
set lp=0
call Rect(.0,.0,.0,.0)
return true
endfunction
function FvE takes nothing returns nothing
local group FeE=GetUnitsOfPlayerMatching(GetTriggerPlayer(),Condition(r9v))
if GetEventPlayerChatString()=="'immunitytoprolongedlossofcontrol" then
call ForGroup(FeE,ivv)
elseif GetEventPlayerChatString()=="@immunitytoprolongedlossofcontrol" then
call ForGroup(FeE,iev)
endif
call DestroyGroup(FeE)
set FeE=null
set FeE=null
endfunction
function FxE takes nothing returns boolean
return(GetEventPlayerChatString()=="item truemage'sstaff")
endfunction
function FoE takes nothing returns nothing
set g[GetConvertedPlayerId(GetTriggerPlayer())]=GetUnitsOfPlayerAndTypeId(GetTriggerPlayer(),'h000')
if FxE()then
call ForGroupBJ(g[GetConvertedPlayerId(GetTriggerPlayer())],rdv)
endif
call DestroyGroup(g[GetPlayerId(GetTriggerPlayer())+1])
endfunction
function FrE takes nothing returns boolean
return(GetUnitTypeId(GetEnumUnit())!='h000')and(IsUnitSelected(GetEnumUnit(),GetTriggerPlayer()))
endfunction
function FiE takes nothing returns boolean
return(FrE())
endfunction
function FaE takes nothing returns nothing
if FiE()then
call AddSpecialEffectTargetUnitBJ(Q[S2I(SubStringBJ(GetEventPlayerChatString(),7,7))],GetEnumUnit(),m[S2I(SubStringBJ(GetEventPlayerChatString(),5,6))])
set X[GetConvertedPlayerId(GetTriggerPlayer())]=X[GetConvertedPlayerId(GetTriggerPlayer())]+1
if GetTriggerPlayer()==Player(0)then
set W[X[GetConvertedPlayerId(GetTriggerPlayer())]]=GetLastCreatedEffectBJ()
endif
if GetTriggerPlayer()==Player(1)then
set E[X[GetConvertedPlayerId(GetTriggerPlayer())]]=GetLastCreatedEffectBJ()
endif
if GetTriggerPlayer()==Player(2)then
set J[X[GetConvertedPlayerId(GetTriggerPlayer())]]=GetLastCreatedEffectBJ()
endif
if GetTriggerPlayer()==Player(3)then
set H[X[GetConvertedPlayerId(GetTriggerPlayer())]]=GetLastCreatedEffectBJ()
endif
if GetTriggerPlayer()==Player(4)then
set D[X[GetConvertedPlayerId(GetTriggerPlayer())]]=GetLastCreatedEffectBJ()
endif
if GetTriggerPlayer()==Player(5)then
set A[X[GetConvertedPlayerId(GetTriggerPlayer())]]=GetLastCreatedEffectBJ()
endif
if GetTriggerPlayer()==Player(6)then
set P[X[GetConvertedPlayerId(GetTriggerPlayer())]]=GetLastCreatedEffectBJ()
endif
if GetTriggerPlayer()==Player(7)then
set I[X[GetConvertedPlayerId(GetTriggerPlayer())]]=GetLastCreatedEffectBJ()
endif
if GetTriggerPlayer()==Player(8)then
set U[X[GetConvertedPlayerId(GetTriggerPlayer())]]=GetLastCreatedEffectBJ()
endif
if GetTriggerPlayer()==Player(9)then
set Z[X[GetConvertedPlayerId(GetTriggerPlayer())]]=GetLastCreatedEffectBJ()
endif
if GetTriggerPlayer()==Player($A)then
set L[X[GetConvertedPlayerId(GetTriggerPlayer())]]=GetLastCreatedEffectBJ()
endif
if GetTriggerPlayer()==Player($B)then
set K[X[GetConvertedPlayerId(GetTriggerPlayer())]]=GetLastCreatedEffectBJ()
endif
endif
endfunction
function FnE takes string FVE returns integer
local integer FEE
set ZM[EM]=FVE
set EM=EM+1
if iF==0 then
if SF<$8000 then
set SF=SF+1
set FEE=SF
else
call Cdv("Out of memory: Could not create Comparator_LinkedList.","when calling error in LinkedList, line 526")
set FEE=0
endif
else
set iF=iF-1
set FEE=tF[iF]
endif
set EM=EM-1
return FEE
endfunction
function FXE takes string FOE returns integer
local integer FRE
set ZM[EM]=FOE
set EM=EM+1
if iF==0 then
if SF<$8000 then
set SF=SF+1
set FRE=SF
else
call Cdv("Out of memory: Could not create Comparator_LinkedList.","when calling error in LinkedList, line 530")
set FRE=0
endif
else
set iF=iF-1
set FRE=tF[iF]
endif
set EM=EM-1
return FRE
endfunction
function FIE takes string FAE returns boolean
set ZM[EM]=FAE
set EM=EM+1
call FnE("when calling alloc_Comparator_LinkedList in LinkedList, line 526")
call FXE("when calling alloc_Comparator_LinkedList in LinkedList, line 530")
call ALo(.0)
set EM=EM-1
return true
endfunction
function FNE takes nothing returns boolean
set EM=0
return FIE("LinkedList, line 1")
endfunction
function FbE takes nothing returns nothing
call CameraClearNoiseForPlayer(GetEnumPlayer())
endfunction
function FBE takes nothing returns nothing
call IssueImmediateOrderBJ(GetOrderedUnit(),"stop")
endfunction
function FcE takes string FCE returns integer
local integer FdE
set ZM[EM]=FCE
set EM=EM+1
if Jx==0 then
if Kx<$8000 then
set Kx=Kx+1
set FdE=Kx
set Lx[FdE]=$C40
else
call Cdv("Out of memory: Could not create InputStreamProcessor_registerInputStreamProcessor_SotFRP_SaveLoad.","when calling error in SotFRP_SaveLoad, line 121")
set FdE=0
endif
else
set Jx=Jx-1
set FdE=Hx[Jx]
set Lx[FdE]=$C40
endif
set EM=EM-1
return FdE
endfunction
function FDE takes string FfE returns integer
local integer FFE
set ZM[EM]=FfE
set EM=EM+1
if Jx==0 then
if Kx<$8000 then
set Kx=Kx+1
set FFE=Kx
set Lx[FFE]=$C41
else
call Cdv("Out of memory: Could not create InputStreamProcessor_registerInputStreamProcessor_SotFRP_SaveLoad.","when calling error in SotFRP_SaveLoad, line 122")
set FFE=0
endif
else
set Jx=Jx-1
set FFE=Hx[Jx]
set Lx[FFE]=$C41
endif
set EM=EM-1
return FFE
endfunction
function FgE takes integer FGE,string FhE,string FHE,string FjE returns nothing
set ZM[EM]=FjE
set EM=EM+1
call ZWv(kd,FhE,FGE,"when calling put in ScmdReader, line 48")
call fqv(jd,FGE,KCv(FHE,"when calling stringToIndex in ScmdReader, line 49"),"when calling put in ScmdReader, line 49")
set EM=EM-1
endfunction
function FJE takes string FkE returns integer
local integer FKE
set ZM[EM]=FkE
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set FKE=Yj
set Gj[FKE]=$B19
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_SotFRP_SaveLoad.","when calling error in SotFRP_SaveLoad, line 152")
set FKE=0
endif
else
set Tj=Tj-1
set FKE=Rj[Tj]
set Gj[FKE]=$B19
endif
set EM=EM-1
return FKE
endfunction
function FlE takes string FLE returns integer
local integer FmE
set ZM[EM]=FLE
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set FmE=Yj
set Gj[FmE]=$B16
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_SotFRP_SaveLoad.","when calling error in SotFRP_SaveLoad, line 131")
set FmE=0
endif
else
set Tj=Tj-1
set FmE=Rj[Tj]
set Gj[FmE]=$B16
endif
set EM=EM-1
return FmE
endfunction
function FME takes string FpE returns integer
local integer FPE
set ZM[EM]=FpE
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set FPE=Yj
set Gj[FPE]=$B17
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_SotFRP_SaveLoad.","when calling error in SotFRP_SaveLoad, line 138")
set FPE=0
endif
else
set Tj=Tj-1
set FPE=Rj[Tj]
set Gj[FPE]=$B17
endif
set EM=EM-1
return FPE
endfunction
function FqE takes string FQE returns integer
local integer FsE
set ZM[EM]=FQE
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set FsE=Yj
set Gj[FsE]=$B18
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_SotFRP_SaveLoad.","when calling error in SotFRP_SaveLoad, line 145")
set FsE=0
endif
else
set Tj=Tj-1
set FsE=Rj[Tj]
set Gj[FsE]=$B18
endif
set EM=EM-1
return FsE
endfunction
function FSE takes string FtE returns integer
local integer FTE
set ZM[EM]=FtE
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set FTE=Yj
set Gj[FTE]=$B15
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_SotFRP_SaveLoad.","when calling error in SotFRP_SaveLoad, line 124")
set FTE=0
endif
else
set Tj=Tj-1
set FTE=Rj[Tj]
set Gj[FTE]=$B15
endif
set EM=EM-1
return FTE
endfunction
function FuE takes string FUE returns integer
local integer FwE
set ZM[EM]=FUE
set EM=EM+1
if Jx==0 then
if Kx<$8000 then
set Kx=Kx+1
set FwE=Kx
set Lx[FwE]=$C42
else
call Cdv("Out of memory: Could not create InputStreamProcessor_registerInputStreamProcessor_SotFRP_SaveLoad.","when calling error in SotFRP_SaveLoad, line 123")
set FwE=0
endif
else
set Jx=Jx-1
set FwE=Hx[Jx]
set Lx[FwE]=$C42
endif
set EM=EM-1
return FwE
endfunction
function FWE takes string FyE returns boolean
local integer FYE
local integer FzE
local integer FZE
local integer F_E
local integer F0E
local integer F1E
local integer F2E
local integer F3E
local integer F4E
local integer F5E
local integer F6E
local integer F7E
local integer F8E
set ZM[EM]=FyE
set EM=EM+1
set df=$7F
set ff="b77309638b2ca9b47c980644e2829e4731a02e228f7aa11c00d439c6513a3db7ce942591fafcc1bca5d4173882e5151247b94aa5cd07258db7bbbed960e57d1"
set Rf="ce942591fafcc1bca5d4173882e5151247b94aa5cd07258db7bbbed960e57d1cb77309638b2ca9b47c980644e2829e4731a02e228f7aa11c00d439c6513a3db"
set Tf="7f9e32f1c81c0e01ac0acd1e3cc932913e0a9148edf84f07cd8f39303f40cad14674228e77218f7db8d29805025ecc0dface13ad2e8db22fccf4bc7d81db125"
set Yf="4674228e77218f7db8d29805025ecc0dface13ad2e8db22fccf4bc7d81db12597f9e32f1c81c0e01ac0acd1e3cc932913e0a9148edf84f07cd8f39303f40cad"
set Gf="d358b08524f8991086413b107128cf8d6fd89225f1c3fc7e8738e33dab4cc509ef3d47f638e9e9bc140e22e5547df108ca76117c97a55a724196873d1a5f52a"
set gf="ef3d47f638e9e9bc140e22e5547df108ca76117c97a55a724196873d1a5f52a1d358b08524f8991086413b107128cf8d6fd89225f1c3fc7e8738e33dab4cc50"
set hf=" !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
set jf=Filter(O6v)
set FYE=FcE("when calling alloc_InputStreamProcessor_registerInputStreamProcessor_SotFRP_SaveLoad in SotFRP_SaveLoad, line 121")
call FgE(FYE,ff,Rf,"when calling registerInputStreamProcessor in SotFRP_SaveLoad, line 121")
set FzE=FDE("when calling alloc_InputStreamProcessor_registerInputStreamProcessor_SotFRP_SaveLoad in SotFRP_SaveLoad, line 122")
call FgE(FzE,Gf,gf,"when calling registerInputStreamProcessor in SotFRP_SaveLoad, line 122")
set FZE=FuE("when calling alloc_InputStreamProcessor_registerInputStreamProcessor_SotFRP_SaveLoad in SotFRP_SaveLoad, line 123")
call FgE(FZE,Tf,Yf,"when calling registerInputStreamProcessor in SotFRP_SaveLoad, line 123")
set F_E=FSE("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_SotFRP_SaveLoad in SotFRP_SaveLoad, line 124")
set F0E=OPo(F_E,"when calling new_BuiltinData in SotFRP_SaveLoad, line 124")
call Rxo(F0E,e5V(),"when calling setArgumentsTypes in SotFRP_SaveLoad, line 130")
call Foa(ILo(F0E,"when calling new_BuiltinFunction in SotFRP_SaveLoad, line 124"),"setloadingrect","when calling registerProtectedBuiltin in SotFRP_SaveLoad, line 124")
set F1E=FlE("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_SotFRP_SaveLoad in SotFRP_SaveLoad, line 131")
set F2E=OPo(F1E,"when calling new_BuiltinData in SotFRP_SaveLoad, line 131")
call FRa(F2E,e5V(),OFo(),"when calling setArgumentsTypes in SotFRP_SaveLoad, line 137")
call Foa(ILo(F2E,"when calling new_BuiltinFunction in SotFRP_SaveLoad, line 131"),"saveunits","when calling registerProtectedBuiltin in SotFRP_SaveLoad, line 131")
set F3E=FME("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_SotFRP_SaveLoad in SotFRP_SaveLoad, line 138")
set F4E=OPo(F3E,"when calling new_BuiltinData in SotFRP_SaveLoad, line 138")
call FRa(F4E,e5V(),OFo(),"when calling setArgumentsTypes in SotFRP_SaveLoad, line 144")
call Foa(ILo(F4E,"when calling new_BuiltinFunction in SotFRP_SaveLoad, line 138"),"savedestructables","when calling registerProtectedBuiltin in SotFRP_SaveLoad, line 138")
set F5E=FqE("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_SotFRP_SaveLoad in SotFRP_SaveLoad, line 145")
set F6E=OPo(F5E,"when calling new_BuiltinData in SotFRP_SaveLoad, line 145")
call FRa(F6E,e5V(),OFo(),"when calling setArgumentsTypes in SotFRP_SaveLoad, line 151")
call Foa(ILo(F6E,"when calling new_BuiltinFunction in SotFRP_SaveLoad, line 145"),"saveitems","when calling registerProtectedBuiltin in SotFRP_SaveLoad, line 145")
set F7E=FJE("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_SotFRP_SaveLoad in SotFRP_SaveLoad, line 152")
set F8E=OPo(F7E,"when calling new_BuiltinData in SotFRP_SaveLoad, line 152")
call FRa(F8E,e5V(),OFo(),"when calling setArgumentsTypes in SotFRP_SaveLoad, line 161")
call Foa(ILo(F8E,"when calling new_BuiltinFunction in SotFRP_SaveLoad, line 152"),"savehandles","when calling registerProtectedBuiltin in SotFRP_SaveLoad, line 152")
set EM=EM-1
return true
endfunction
function F9E takes nothing returns boolean
set EM=0
return FWE("SotFRP_SaveLoad, line 1")
endfunction
function gvE takes nothing returns boolean
return true
endfunction
function geE takes nothing returns nothing
local unit gxE=GetSpellTargetUnit()
local integer goE=0
local integer grE=GetUnitAbilityLevel(GetSpellAbilityUnit(),'A0ES')
if IsUnitInGroup(gxE,Bs) then
call GroupRemoveUnit(Bs,gxE)
call pAa(1.)
endif
call GroupAddUnit(Bs,gxE)
call UnitAddAbility(gxE,'A0J4')
call UnitMakeAbilityPermanent(gxE,true,'A0J4')
call SetUnitAbilityLevel(gxE,'A0J4',grE)
loop
exitwhen IsUnitInGroup(gxE,Bs)==false
call DestroyEffect(AddSpecialEffectTarget("Units\\NightElf\\Wisp\\WispExplode.mdl",gxE,"origin"))
call pAa(1.)
set goE=goE+1
if goE==8 or GetUnitState(gxE,UNIT_STATE_LIFE)<=.0 then
call GroupRemoveUnit(Bs,gxE)
endif
endloop
call UnitRemoveAbility(gxE,'A0J4')
call UnitRemoveAbility(gxE,'B00R')
set gxE=null
set goE=0
set gxE=null
endfunction
function giE takes nothing returns boolean
return(GetSpellAbilityId()=='AHmt')
endfunction
function gaE takes nothing returns boolean
return(GetSpellAbilityId()=='A0F6')
endfunction
function gnE takes nothing returns boolean
if GetSpellAbilityId()=='A0KM' then
return true
else
return false
endif
endfunction
function gVE takes nothing returns nothing
local group gEE=CreateGroup()
call GroupEnumUnitsInRangeOfLoc(gEE,GetSpellTargetLoc(),300.,Condition(nzv))
call ForGroup(gEE,nZv)
call DestroyGroup(gEE)
set gEE=null
set gEE=null
endfunction
function gXE takes nothing returns nothing
call UnitRemoveAbilityBJ('Aspi',GetSpellAbilityUnit())
call UnitAddAbilityBJ('A0CV',GetSpellAbilityUnit())
call UnitRemoveAbilityBJ('A0CW',GetSpellAbilityUnit())
endfunction
function gOE takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),1,3)=="sky")
endfunction
function gRE takes nothing returns nothing
set G=GetUnitLoc(GetEnumUnit())
if SubStringBJ(GetEventPlayerChatString(),6,7)=="a1" then
call CreateDestructableLoc('ATtr',GetUnitLoc(GetEnumUnit()),GetRandomDirectionDeg(),1.,GetRandomInt(0,4))
endif
if SubStringBJ(GetEventPlayerChatString(),6,7)=="a2" then
call CreateDestructableLoc('ATtc',GetUnitLoc(GetEnumUnit()),GetRandomDirectionDeg(),1.,GetRandomInt(0,2))
endif
if SubStringBJ(GetEventPlayerChatString(),6,7)=="b1" then
call CreateDestructableLoc('BTtw',GetUnitLoc(GetEnumUnit()),GetRandomDirectionDeg(),1.,GetRandomInt(0,9))
endif
if SubStringBJ(GetEventPlayerChatString(),6,7)=="b2" then
call CreateDestructableLoc('BTtc',GetUnitLoc(GetEnumUnit()),GetRandomDirectionDeg(),1.,GetRandomInt(0,2))
endif
if SubStringBJ(GetEventPlayerChatString(),6,7)=="o1" then
call CreateDestructableLoc('OTtw',GetUnitLoc(GetEnumUnit()),GetRandomDirectionDeg(),1.,GetRandomInt(0,9))
endif
if SubStringBJ(GetEventPlayerChatString(),6,7)=="c1" then
call CreateDestructableLoc('YTft',GetUnitLoc(GetEnumUnit()),GetRandomDirectionDeg(),1.,GetRandomInt(0,1))
endif
if SubStringBJ(GetEventPlayerChatString(),6,7)=="c2" then
call CreateDestructableLoc('YTst',GetUnitLoc(GetEnumUnit()),GetRandomDirectionDeg(),1.,GetRandomInt(0,1))
endif
if SubStringBJ(GetEventPlayerChatString(),6,7)=="c3" then
call CreateDestructableLoc('YTct',GetUnitLoc(GetEnumUnit()),GetRandomDirectionDeg(),1.,GetRandomInt(0,1))
endif
if SubStringBJ(GetEventPlayerChatString(),6,7)=="c4" then
call CreateDestructableLoc('JTct',GetUnitLoc(GetEnumUnit()),GetRandomDirectionDeg(),1.,GetRandomInt(0,1))
endif
if SubStringBJ(GetEventPlayerChatString(),6,7)=="c5" then
call CreateDestructableLoc('JTtw',GetUnitLoc(GetEnumUnit()),GetRandomDirectionDeg(),1.,GetRandomInt(0,9))
endif
if SubStringBJ(GetEventPlayerChatString(),6,7)=="d1" then
call CreateDestructableLoc('DTsh',GetUnitLoc(GetEnumUnit()),GetRandomDirectionDeg(),1.,GetRandomInt(0,7))
endif
if SubStringBJ(GetEventPlayerChatString(),6,7)=="f1" then
call CreateDestructableLoc('CTtr',GetUnitLoc(GetEnumUnit()),GetRandomDirectionDeg(),1.,GetRandomInt(0,4))
endif
if SubStringBJ(GetEventPlayerChatString(),6,7)=="f2" then
call CreateDestructableLoc('CTtc',GetUnitLoc(GetEnumUnit()),GetRandomDirectionDeg(),1.,GetRandomInt(0,2))
endif
if SubStringBJ(GetEventPlayerChatString(),6,7)=="i1" then
call CreateDestructableLoc('ITtw',GetUnitLoc(GetEnumUnit()),GetRandomDirectionDeg(),1.,GetRandomInt(0,9))
endif
if SubStringBJ(GetEventPlayerChatString(),6,7)=="i2" then
call CreateDestructableLoc('ITtc',GetUnitLoc(GetEnumUnit()),GetRandomDirectionDeg(),1.,GetRandomInt(0,2))
endif
if SubStringBJ(GetEventPlayerChatString(),6,7)=="l1" then
call CreateDestructableLoc('FTtw',GetUnitLoc(GetEnumUnit()),GetRandomDirectionDeg(),1.,GetRandomInt(0,9))
endif
if SubStringBJ(GetEventPlayerChatString(),6,7)=="l2" then
call CreateDestructableLoc('LTlt',GetUnitLoc(GetEnumUnit()),GetRandomDirectionDeg(),1.,GetRandomInt(0,9))
endif
if SubStringBJ(GetEventPlayerChatString(),6,7)=="l3" then
call CreateDestructableLoc('WTst',GetUnitLoc(GetEnumUnit()),GetRandomDirectionDeg(),1.,GetRandomInt(0,9))
endif
if SubStringBJ(GetEventPlayerChatString(),6,7)=="l4" then
call CreateDestructableLoc('WTtw',GetUnitLoc(GetEnumUnit()),GetRandomDirectionDeg(),1.,GetRandomInt(0,9))
endif
if SubStringBJ(GetEventPlayerChatString(),6,7)=="n1" then
call CreateDestructableLoc('NTtw',GetUnitLoc(GetEnumUnit()),GetRandomDirectionDeg(),1.,GetRandomInt(0,9))
endif
if SubStringBJ(GetEventPlayerChatString(),6,7)=="n2" then
call CreateDestructableLoc('NTtc',GetUnitLoc(GetEnumUnit()),GetRandomDirectionDeg(),1.,GetRandomInt(0,2))
endif
if SubStringBJ(GetEventPlayerChatString(),6,7)=="s1" then
call CreateDestructableLoc('ZTtw',GetUnitLoc(GetEnumUnit()),GetRandomDirectionDeg(),1.,GetRandomInt(0,9))
endif
if SubStringBJ(GetEventPlayerChatString(),6,7)=="s2" then
call CreateDestructableLoc('ZTtc',GetUnitLoc(GetEnumUnit()),GetRandomDirectionDeg(),1.,GetRandomInt(0,2))
endif
if SubStringBJ(GetEventPlayerChatString(),6,7)=="u1" then
call CreateDestructableLoc('GTsh',GetUnitLoc(GetEnumUnit()),GetRandomDirectionDeg(),1.,GetRandomInt(0,7))
endif
if SubStringBJ(GetEventPlayerChatString(),6,7)=="wI" then
call CreateDestructableLoc('LTw2',GetUnitLoc(GetEnumUnit()),GetRandomDirectionDeg(),1.,2)
endif
if SubStringBJ(GetEventPlayerChatString(),6,7)=="w\\" then
call CreateDestructableLoc('LTw1',GetUnitLoc(GetEnumUnit()),GetRandomDirectionDeg(),1.,2)
endif
if SubStringBJ(GetEventPlayerChatString(),6,7)=="w/" then
call CreateDestructableLoc('LTw3',GetUnitLoc(GetEnumUnit()),GetRandomDirectionDeg(),1.,2)
endif
if SubStringBJ(GetEventPlayerChatString(),6,7)=="w-" then
call CreateDestructableLoc('LTw0',GetUnitLoc(GetEnumUnit()),GetRandomDirectionDeg(),1.,2)
endif
if SubStringBJ(GetEventPlayerChatString(),6,$A)=="rock0" then
call CreateDestructableLoc('LTrc',GetUnitLoc(GetEnumUnit()),GetRandomDirectionDeg(),1.,0)
endif
if SubStringBJ(GetEventPlayerChatString(),6,$A)=="rock1" then
call CreateDestructableLoc('LTrc',GetUnitLoc(GetEnumUnit()),GetRandomDirectionDeg(),1.,1)
endif
if SubStringBJ(GetEventPlayerChatString(),6,$A)=="rock2" then
call CreateDestructableLoc('LTrc',GetUnitLoc(GetEnumUnit()),GetRandomDirectionDeg(),1.,2)
endif
if SubStringBJ(GetEventPlayerChatString(),6,$A)=="rock3" then
call CreateDestructableLoc('LTrc',GetUnitLoc(GetEnumUnit()),GetRandomDirectionDeg(),1.,3)
endif
if SubStringBJ(GetEventPlayerChatString(),6,$A)=="rock4" then
call CreateDestructableLoc('LTrc',GetUnitLoc(GetEnumUnit()),GetRandomDirectionDeg(),1.,4)
endif
if SubStringBJ(GetEventPlayerChatString(),6,$A)=="rock5" then
call CreateDestructableLoc('LTrc',GetUnitLoc(GetEnumUnit()),GetRandomDirectionDeg(),1.,5)
endif
if SubStringBJ(GetEventPlayerChatString(),6,$A)=="sm" then
call CreateDestructableLoc('B01S',GetUnitLoc(GetEnumUnit()),GetRandomDirectionDeg(),1.,5)
endif
call RemoveLocation(G)
endfunction
function gIE takes nothing returns nothing
local unit gAE
local timer gNE
if GetUnitAbilityLevel(GetEventDamageSource(),'BOer')==0 or GetEventDamage()==.0 or IsUnitInGroup(GetEventDamageSource(),ql)then
set gAE=null
set gNE=null
return
endif
set gAE=GetEventDamageSource()
call SetWidgetLife(gAE,GetWidgetLife(gAE)+25*LoadInteger(i,al,GetHandleId(gAE)))
call DestroyEffect(AddSpecialEffectTarget("Abilities\\Spells\\Undead\\VampiricAura\\VampiricAuraTarget.mdl",gAE,"origin"))
call GroupAddUnit(ql,gAE)
set gNE=cFv()
call SaveUnitHandle(i,y,GetHandleId(gNE),gAE)
call TimerStart(gNE,.5,false,uz)
set gNE=null
set gAE=null
set gAE=null
set gNE=null
endfunction
function gbE takes nothing returns nothing
endfunction
function gBE takes nothing returns boolean
call gbE()
return true
endfunction
function gcE takes nothing returns boolean
return GetDestructableTypeId(GetTriggerDestructable())=='DTlv'
endfunction
function gCE takes nothing returns nothing
local unit gdE=GetSpellTargetUnit()
local location gDE=null
local real gfE=.0
local real gFE=.0
local effect ggE=null
local integer gGE=0
if IsUnitInGroup(gdE,tt) then
call GroupRemoveUnit(St,gdE)
call GroupRemoveUnit(tt,gdE)
call pAa(1.)
endif
set gDE=GetUnitLoc(GetSpellTargetUnit())
set gfE=GetUnitState(GetSpellTargetUnit(),UNIT_STATE_LIFE)
set gFE=GetUnitState(GetSpellTargetUnit(),UNIT_STATE_MANA)
set ggE=AddSpecialEffectTarget("Abilities\\Spells\\Human\\ManaFlare\\ManaFlareTarget.mdl",GetSpellTargetUnit(),"overhead")
call UnitDamageTarget(GetSpellAbilityUnit(),GetSpellTargetUnit(),625.,true,true,ATTACK_TYPE_NORMAL,DAMAGE_TYPE_MAGIC,WEAPON_TYPE_WHOKNOWS)
call GroupAddUnit(tt,gdE)
call GroupAddUnit(St,gdE)
call UnitAddAbility(gdE,'A0JT')
call UnitMakeAbilityPermanent(gdE,true,'A0JT')
loop
exitwhen IsUnitInGroup(gdE,tt)==false
call pAa(1.)
set gGE=gGE+1
if gGE==$A then
call GroupRemoveUnit(tt,gdE)
endif
endloop
call DestroyEffect(ggE)
if IsUnitInGroup(gdE,St) and GetUnitState(gdE,UNIT_STATE_LIFE)>.0 then
call DestroyEffect(AddSpecialEffectLoc("Abilities\\Spells\\Human\\MassTeleport\\MassTeleportCaster.mdl",GetUnitLoc(gdE)))
call SetUnitPositionLoc(gdE,gDE)
call DestroyEffect(AddSpecialEffectLoc("Abilities\\Spells\\Human\\MassTeleport\\MassTeleportCaster.mdl",GetUnitLoc(gdE)))
call SetUnitState(gdE,UNIT_STATE_LIFE,gfE)
call SetUnitState(gdE,UNIT_STATE_MANA,gFE)
endif
call UnitRemoveAbility(gdE,'A0JT')
call UnitRemoveAbility(gdE,'B04G')
call GroupRemoveUnit(St,gdE)
call GroupRemoveUnit(tt,gdE)
call RemoveLocation(gDE)
set gdE=null
set gDE=null
set gfE=.0
set gFE=.0
set ggE=null
set gGE=0
set gdE=null
set gDE=null
set ggE=null
endfunction
function ghE takes nothing returns boolean
return GetSpellAbilityId()=='A0HO'
endfunction
function gHE takes nothing returns boolean
return GetUnitAbilityLevel(GetDyingUnit(),'AaI0')>0 or GetUnitAbilityLevel(GetDyingUnit(),'AaI1')>0
endfunction
function gjE takes string gea returns nothing
set ZM[EM]=gea
set EM=EM+1
call Kxv(RT,0,"","when calling saveString in TypeCasting, line 12")
set EM=EM-1
endfunction
function gJE takes string gkE returns boolean
set ZM[EM]=gkE
set EM=EM+1
set RT=a6x("when calling new_Table in TypeCasting, line 7")
set TT=1000.
call gjE("when calling initTypecastData in TypeCasting, line 15")
set EM=EM-1
return true
endfunction
function gKE takes nothing returns boolean
set EM=0
return gJE("TypeCasting, line 1")
endfunction
function glE takes nothing returns boolean
return(Mu==1)
endfunction
function gLE takes nothing returns boolean
return(Mu==2)
endfunction
function gmE takes nothing returns nothing
if glE()then
call UnitDamageTargetBJ(Nu,GetEnumUnit(),xu,ATTACK_TYPE_NORMAL,DAMAGE_TYPE_COLD)
call AddSpecialEffectTargetUnitBJ("chest",GetEnumUnit(),"Abilities\\Weapons\\LichMissile\\LichMissile.mdl")
elseif gLE()then
call UnitDamageTargetBJ(Nu,GetEnumUnit(),vu,ATTACK_TYPE_NORMAL,DAMAGE_TYPE_FIRE)
call AddSpecialEffectTargetUnitBJ("chest",GetEnumUnit(),"Abilities\\Weapons\\RedDragonBreath\\RedDragonMissile.mdl")
else
call UnitDamageTargetBJ(Nu,GetEnumUnit(),mu,ATTACK_TYPE_NORMAL,DAMAGE_TYPE_LIGHTNING)
call AddSpecialEffectTargetUnitBJ("chest",GetEnumUnit(),"Abilities\\Weapons\\FarseerMissile\\FarseerMissile.mdl")
endif
call DestroyEffectBJ(GetLastCreatedEffectBJ())
endfunction
function gME takes nothing returns boolean
return(GetIssuedOrderIdBJ()==$D0010)
endfunction
function gpE takes string gPE returns integer
local integer gqE
set ZM[EM]=gPE
set EM=EM+1
if Jx==0 then
if Kx<$8000 then
set Kx=Kx+1
set gqE=Kx
set Lx[gqE]=$C3F
else
call Cdv("Out of memory: Could not create InputStreamProcessor_registerInputStreamProcessor_SotFRP_LegacyLoad.","when calling error in SotFRP_LegacyLoad, line 228")
set gqE=0
endif
else
set Jx=Jx-1
set gqE=Hx[Jx]
set Lx[gqE]=$C3F
endif
set EM=EM-1
return gqE
endfunction
function gQE takes string gsE returns integer
local integer gSE
set ZM[EM]=gsE
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set gSE=Yj
set Gj[gSE]=$B14
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_SotFRP_LegacyLoad.","when calling error in SotFRP_LegacyLoad, line 229")
set gSE=0
endif
else
set Tj=Tj-1
set gSE=Rj[Tj]
set Gj[gSE]=$B14
endif
set EM=EM-1
return gSE
endfunction
function gtE takes string gTE returns integer
local integer guE
set ZM[EM]=gTE
set EM=EM+1
if Jx==0 then
if Kx<$8000 then
set Kx=Kx+1
set guE=Kx
set Lx[guE]=$C3E
else
call Cdv("Out of memory: Could not create InputStreamProcessor_registerInputStreamProcessor_SotFRP_LegacyLoad.","when calling error in SotFRP_LegacyLoad, line 227")
set guE=0
endif
else
set Jx=Jx-1
set guE=Hx[Jx]
set Lx[guE]=$C3E
endif
set EM=EM-1
return guE
endfunction
function gUE takes string gwE returns boolean
local integer gWE
local integer gyE
local integer gYE
local integer gzE
set ZM[EM]=gwE
set EM=EM+1
set Nd="nEaPy9rLwNfVqb0Qizj3DkGc1OhTU4XsZgMpYKBtl26JI5FmxCoAv8euWRdH7S"
set Md=GZv(Nd)
set wf=16
set uf=17
set rf=18
set sf=19
set tf=20
set Sf=21
set cf=22
set of=23
set Of=24
set lf=25
set bf=26
set yf=27
set pf=28
set gWE=gtE("when calling alloc_InputStreamProcessor_registerInputStreamProcessor_SotFRP_LegacyLoad in SotFRP_LegacyLoad, line 227")
call FgE(gWE,"516b1b971d90fd815f889fd50ac4e3a2a8d0dc5b28736ce07441aef387cdb54968a8666ee1dd2dc47e308adc87e4e8be60ca0d2359b31efa0f671370f1cf4av","91f155fb26f5616f2df290e8d6ba88bd64225e28f73784bc6c61ff61595b8ee9dcfc5b1ce2106a7b500a92b9c08dd64be8cf9c7e36b14e28445989a0a0bf72p","when calling registerInputStreamProcessor in SotFRP_LegacyLoad, line 227")
set gyE=gpE("when calling alloc_InputStreamProcessor_registerInputStreamProcessor_SotFRP_LegacyLoad in SotFRP_LegacyLoad, line 228")
call FgE(gyE,"VGxSRk1sbHFSbWxQVkdONFdrUnJkMXB0VVRSTlZGWnRUMFJuTlZwdFVURk5SMFpxVGtkVmVsbFVTbWhQUjFGM1drZE5NVmxxU1RST2VrMHlXVEpWZDA1NlVUQk5WMFp","NTE2YjFiOTcxZDkwZmQ4MTVmODg5ZmQ1MGFjNGUzYTJhOGQwZGM1YjI4NzM2Y2UwNzQ0MWFlZjM4N2NkYjU0OTY4YTg2NjZlZTFkZDJkYzQ3ZTMwOGFkYzg3ZTRlOGJ","when calling registerInputStreamProcessor in SotFRP_LegacyLoad, line 228")
set gYE=gQE("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_SotFRP_LegacyLoad in SotFRP_LegacyLoad, line 229")
set gzE=OPo(gYE,"when calling new_BuiltinData in SotFRP_LegacyLoad, line 229")
call Rxo(gzE,e5V(),"when calling setArgumentsTypes in SotFRP_LegacyLoad, line 235")
call Foa(ILo(gzE,"when calling new_BuiltinFunction in SotFRP_LegacyLoad, line 229"),"setlegacyloadingrect","when calling registerProtectedBuiltin in SotFRP_LegacyLoad, line 229")
set EM=EM-1
return true
endfunction
function gZE takes nothing returns boolean
set EM=0
return gUE("SotFRP_LegacyLoad, line 1")
endfunction
function g_E takes nothing returns nothing
call CameraClearNoiseForPlayer(GetEnumPlayer())
endfunction
function g0E takes nothing returns boolean
if GetSpellAbilityId()=='Aens' or GetSpellAbilityId()=='Aweb' or GetSpellAbilityId()=='ANfd' or GetSpellAbilityId()=='ANdo' or GetSpellAbilityId()=='ANtm' or GetSpellAbilityId()=='Amls' or GetSpellAbilityId()=='AHdr' or GetSpellAbilityId()=='ANdr' or GetSpellAbilityId()=='ANch' or GetSpellAbilityId()=='ACch' then
return false
else
return true
endif
endfunction
function g1E takes nothing returns boolean
if GetSpellAbilityId()=='A0FD' or GetSpellAbilityId()=='A0FC' or GetSpellAbilityId()=='A0F6' or GetSpellAbilityId()=='A0EK' or GetSpellAbilityId()=='A06O' or GetSpellAbilityId()=='A03K' or GetSpellAbilityId()=='A0DM' or GetSpellAbilityId()=='A03L' or GetSpellAbilityId()=='A0DG' or GetSpellAbilityId()=='A0EU' or GetSpellAbilityId()=='A09T' or GetSpellAbilityId()=='A062' or GetSpellAbilityId()=='A0DT' then
return false
else
return true
endif
endfunction
function g2E takes nothing returns nothing
local unit g3E=GetSpellAbilityUnit()
local unit g4E=GetSpellTargetUnit()
local unit g5E
local effect g6E
local effect g7E
if GetSpellAbilityId()=='Ansi' or GetSpellAbilityId()=='ACsi' then
call ForGroup(GetUnitsInRangeOfLocMatching($C8+75*(GetUnitAbilityLevel(g3E,'Ansi')-1),GetSpellTargetLoc(),Condition(nFv)),ngv)
elseif(GetUnitAbilityLevel(g4E,'A07E')==3 and GetRandomInt(1,'d')<=30)or(GetUnitAbilityLevel(g4E,'A07E')==2 and GetRandomInt(1,'d')<=20)or(GetUnitAbilityLevel(g4E,'A07E')==1 and GetRandomInt(1,'d')<=$A)and g0E()and g1E()then
set g5E=CreateUnitAtLoc(GetOwningPlayer(g4E),'h0JO',GetUnitLoc(g4E),270.)
set g6E=AddSpecialEffectTarget("Abilities\\Spells\\Items\\SpellShieldAmulet\\SpellShieldCaster.mdl",g4E,"origin")
set g7E=AddSpecialEffectTarget("Abilities\\Spells\\Other\\Silence\\SilenceTarget.mdl",g3E,"overhead")
call UnitAddAbility(g5E,GetSpellAbilityId())
call SetUnitAbilityLevel(g5E,GetSpellAbilityId(),GetUnitAbilityLevel(g3E,GetSpellAbilityId()))
call IssueTargetOrderById(g5E,GetUnitCurrentOrder(g3E),g3E)
call TriggerSleepAction(3.)
call RemoveUnit(g5E)
call DestroyEffect(g6E)
call DestroyEffect(g7E)
endif
set g3E=null
set g4E=null
set g5E=null
set g6E=null
set g7E=null
set g3E=null
set g4E=null
set g5E=null
set g6E=null
set g7E=null
endfunction
function g8E takes nothing returns nothing
local unit g9E=GetSpellTargetUnit()
local unit GvE=GetSpellAbilityUnit()
local integer GeE=0
local effect GxE=null
local effect GoE=null
local group GrE=CreateGroup()
if GetSpellAbilityId()=='A0K6' then
call UnitAddAbility(GvE,'A0K9')
call UnitMakeAbilityPermanent(GvE,true,'A0K9')
call UnitMakeAbilityPermanent(GvE,true,'A0K8')
call UnitMakeAbilityPermanent(GvE,true,'A0KA')
call UnitAddAbility(GvE,'A0K7')
call UnitMakeAbilityPermanent(GvE,true,'A0K7')
call GroupAddUnit(yt,GvE)
if IsUnitInGroup(g9E,pt) then
call GroupRemoveUnit(pt,g9E)
call pAa(1.)
endif
call UnitAddAbility(g9E,'A0KD')
call UnitMakeAbilityPermanent(g9E,true,'A0KD')
call GroupAddUnit(pt,g9E)
set GxE=AddSpecialEffectTarget("Abilities\\Spells\\Other\\Incinerate\\IncinerateBuff.mdl",g9E,"chest")
set GoE=AddSpecialEffectTarget("Abilities\\Spells\\Other\\TalkToMe\\TalkToMe.mdl",g9E,"overhead")
loop
exitwhen IsUnitInGroup(GvE,yt)==false
set GeE=GeE+1
if GeE==30 or IsUnitInGroup(g9E,pt)==false then
call GroupRemoveUnit(yt,GvE)
call UnitRemoveAbility(GvE,'A0K7')
call UnitRemoveAbility(GvE,'A0K9')
endif
call pAa(.125)
endloop
set GeE=0
if IsUnitInGroup(g9E,pt) then
call DestroyEffect(AddSpecialEffectTarget("Objects\\Spawnmodels\\Human\\FragmentationShards\\FragBoomSpawn.mdl",g9E,"origin"))
call DestroyEffect(AddSpecialEffectTarget("Objects\\Spawnmodels\\Other\\NeutralBuildingExplosion\\NeutralBuildingExplosion.mdl",g9E,"origin"))
call UnitDamagePoint(GvE,.0,200.,GetUnitX(g9E),GetUnitY(g9E),475.,true,true,ATTACK_TYPE_SIEGE,DAMAGE_TYPE_DEMOLITION,WEAPON_TYPE_WHOKNOWS)
call GroupEnumUnitsInRangeOfLoc(GrE,GetUnitLoc(g9E),200.,null)
call ForGroup(GrE,Vev)
call DestroyGroup(GrE)
set GrE=null
call GroupRemoveUnit(pt,g9E)
endif
call UnitRemoveAbility(g9E,'A0KD')
call UnitRemoveAbility(g9E,'B04K')
call DestroyEffect(GxE)
call DestroyEffect(GoE)
set GxE=null
set GoE=null
else
call GroupRemoveUnit(yt,GvE)
call UnitRemoveAbility(GvE,'A0K7')
call UnitRemoveAbility(GvE,'A0K9')
endif
set g9E=null
set GvE=null
set g9E=null
set GvE=null
set GxE=null
set GoE=null
set GrE=null
endfunction
function GiE takes nothing returns boolean
return IsUnitEnemy(GetFilterUnit(),GetOwningPlayer(GetSpellAbilityUnit()))
endfunction
function GaE takes nothing returns boolean
set Ca=true
return true
endfunction
function GnE takes nothing returns boolean
return(GetOwningPlayer(GetEnumUnit())==GetTriggerPlayer())
endfunction
function GVE takes nothing returns nothing
if GnE()then
set G=GetUnitLoc(GetEnumUnit())
call EnumDestructablesInCircleBJ(256.,G,xhv)
call RemoveLocation(G)
endif
endfunction
function GEE takes nothing returns boolean
return(vt[GetConvertedPlayerId(GetOwningPlayer(GetSpellAbilityUnit()))-1]==3)
endfunction
function GXE takes nothing returns boolean
return(GEE())
endfunction
function GOE takes nothing returns boolean
return(GetSpellAbilityId()=='TMd2')
endfunction
function GRE takes nothing returns boolean
return(GetSpellAbilityId()=='TMd4')
endfunction
function GIE takes nothing returns boolean
return(GetSpellAbilityId()=='TMd2')
endfunction
function GAE takes nothing returns boolean
return(vt[GetConvertedPlayerId(GetOwningPlayer(GetSpellAbilityUnit()))-1]==6)
endfunction
function GNE takes nothing returns boolean
return(GAE())
endfunction
function GbE takes nothing returns boolean
return(GetSpellAbilityId()=='TMd1')
endfunction
function GBE takes nothing returns boolean
return(GetSpellAbilityId()=='TMd4')
endfunction
function GcE takes nothing returns boolean
return(GetSpellAbilityId()=='TMd4')
endfunction
function GCE takes nothing returns boolean
return(RectContainsLoc(It,GetSpellTargetLoc())==false)
endfunction
function GdE takes nothing returns boolean
return(vt[GetConvertedPlayerId(GetOwningPlayer(GetSpellAbilityUnit()))-1]==4)
endfunction
function GDE takes nothing returns boolean
return(GdE())
endfunction
function GfE takes nothing returns boolean
return(GetSpellAbilityId()=='TMd2')
endfunction
function GFE takes nothing returns boolean
return(vt[GetConvertedPlayerId(GetOwningPlayer(GetSpellAbilityUnit()))-1]==6)
endfunction
function GgE takes nothing returns boolean
return(GFE())
endfunction
function GGE takes nothing returns boolean
return(GetSpellAbilityId()=='TMd2')
endfunction
function GhE takes nothing returns boolean
return(GetSpellAbilityId()=='TMd1')
endfunction
function GHE takes nothing returns boolean
return(GetSpellAbilityId()=='TMd3')
endfunction
function GjE takes nothing returns boolean
return(GetSpellAbilityId()=='TMd3')
endfunction
function GJE takes nothing returns boolean
return(GetSpellAbilityId()=='TMd1')
endfunction
function GkE takes nothing returns boolean
return(GetSpellAbilityId()=='TMd3')
endfunction
function GKE takes nothing returns boolean
return(GetSpellAbilityId()=='TMd3')
endfunction
function GlE takes nothing returns boolean
return(vt[GetConvertedPlayerId(GetOwningPlayer(GetSpellAbilityUnit()))-1]==5)
endfunction
function GLE takes nothing returns boolean
return(GlE())
endfunction
function GmE takes nothing returns boolean
return(GetSpellAbilityId()=='TMd1')
endfunction
function GME takes nothing returns boolean
return(vt[GetConvertedPlayerId(GetOwningPlayer(GetSpellAbilityUnit()))-1]==0)
endfunction
function GpE takes nothing returns boolean
return(GetSpellAbilityId()=='TMd1')
endfunction
function GPE takes nothing returns boolean
return(vt[GetConvertedPlayerId(GetOwningPlayer(GetSpellAbilityUnit()))-1]==1)and(Vw)
endfunction
function GqE takes nothing returns boolean
return(GPE())
endfunction
function GQE takes nothing returns boolean
return(GetSpellAbilityId()=='TMd4')
endfunction
function GsE takes nothing returns boolean
return(GetSpellAbilityId()=='TMd2')
endfunction
function GSE takes nothing returns boolean
return(GetSpellAbilityId()=='TMd3')
endfunction
function GtE takes nothing returns nothing
set G=GetSpellTargetLoc()
if GCE()then
if GME()then
if GJE()then
call SetTerrainTypeBJ(G,Tw[GetConvertedPlayerId(GetTriggerPlayer())],-1,1,0)
elseif GfE()then
call SetTerrainTypeBJ(G,Tw[GetConvertedPlayerId(GetTriggerPlayer())],-1,2,0)
elseif GKE()then
call SetTerrainTypeBJ(G,Tw[GetConvertedPlayerId(GetTriggerPlayer())],-1,3,0)
elseif GQE()then
call SetTerrainTypeBJ(G,Tw[GetConvertedPlayerId(GetTriggerPlayer())],-1,4,0)
endif
elseif GqE()then
if GpE()then
call TerrainDeformationCraterBJ(.1,true,G,92.,-(1.*Gw[GetConvertedPlayerId(GetTriggerPlayer())]))
elseif GsE()then
call TerrainDeformationCraterBJ(.1,true,G,220.,-(1.*Gw[GetConvertedPlayerId(GetTriggerPlayer())]))
elseif GSE()then
call TerrainDeformationCraterBJ(.1,true,G,380.,-(1.*Gw[GetConvertedPlayerId(GetTriggerPlayer())]))
elseif GcE()then
call TerrainDeformationCraterBJ(.1,true,G,572.,-(1.*Gw[GetConvertedPlayerId(GetTriggerPlayer())]))
endif
elseif GXE()then
if GhE()then
call ForForce(GetPlayersAll(),vMv)
elseif GOE()then
call ForForce(GetPlayersAll(),vpv)
elseif GHE()then
call ForForce(GetPlayersAll(),vPv)
elseif GBE()then
call ForForce(GetPlayersAll(),vqv)
endif
elseif GDE()then
if GbE()then
call ForForce(GetPlayersAll(),vQv)
elseif GGE()then
call ForForce(GetPlayersAll(),vsv)
elseif GjE()then
call ForForce(GetPlayersAll(),vSv)
elseif GRE()then
call ForForce(GetPlayersAll(),vtv)
endif
elseif GLE()then
if GmE()then
call SetBlightRadiusLocBJ(true,Player(bj_PLAYER_NEUTRAL_VICTIM),G,92.)
call SetBlightRadiusLocBJ(false,Player(bj_PLAYER_NEUTRAL_VICTIM),G,92.)
elseif GIE()then
call SetBlightRadiusLocBJ(true,Player(bj_PLAYER_NEUTRAL_VICTIM),G,220.)
call SetBlightRadiusLocBJ(false,Player(bj_PLAYER_NEUTRAL_VICTIM),G,220.)
elseif GkE()then
call SetBlightRadiusLocBJ(true,Player(bj_PLAYER_NEUTRAL_VICTIM),G,380.)
call SetBlightRadiusLocBJ(false,Player(bj_PLAYER_NEUTRAL_VICTIM),G,380.)
else
call SetBlightRadiusLocBJ(true,Player(bj_PLAYER_NEUTRAL_VICTIM),G,572.)
call SetBlightRadiusLocBJ(false,Player(bj_PLAYER_NEUTRAL_VICTIM),G,572.)
endif
elseif GNE()then
set Tw[GetConvertedPlayerId(GetTriggerPlayer())]=GetTerrainTypeBJ(G)
endif
elseif GgE()then
set Tw[GetConvertedPlayerId(GetTriggerPlayer())]=GetTerrainTypeBJ(G)
endif
call RemoveLocation(G)
endfunction
function GTE takes nothing returns boolean
return GetSpellAbilityId()=='A0H6'
endfunction
function GuE takes nothing returns boolean
return GetUnitTypeId(GetOrderedUnit())=='h000' and GetIssuedOrderId()!=$D0003
endfunction
function GUE takes integer GwE,string GWE returns nothing
set ab[GwE]=GWE
call HQV(GwE)
endfunction
function GyE takes integer GYE,integer GzE returns nothing
call SaveInteger(i,Kl[GYE],Ll[GYE],GzE)
set Ll[GYE]=Ll[GYE]+1
endfunction
function GZE takes nothing returns nothing
local integer G_E=GetPlayerId(GetTriggerPlayer())
local unit G0E=GetOrderedUnit()
if GetUnitTypeId(G0E)=='h000' and OrderId2String(GetIssuedOrderId())=="replenishlifeon" then
call PauseUnit(G0E,true)
call IssueImmediateOrderById(G0E,$D0004)
call PauseUnit(G0E,false)
call GUE(Fl[G_E],"DRAM")
call GyE(hl[G_E],Fl[G_E])
set Fl[G_E]=0
set xl[G_E]=false
call jNV(G_E,false)
endif
set G0E=null
set G0E=null
endfunction
function G1E takes nothing returns boolean
return(gs[1]==0)
endfunction
function G2E takes nothing returns nothing
if G1E()then
call EnableTrigger(XS)
endif
set gs[1]=gs[1]+1
set gs[2]=gs[2]+1
set xs[1]=GetUnitLoc(As)
set Rs[gs[2]]=DistanceBetweenPoints(xs[1],Ps)
set Fs[gs[2]]=.0
set js[gs[2]]=Is
set ms[gs[2]]=As
set ds[gs[2]]=AngleBetweenPoints(xs[1],Ps)
set Ts[gs[2]]=Us
set fs[gs[2]]=Qs
set vs[gs[2]]=Es
set Gs[gs[2]]=Zs*Rs[gs[2]]
set Hs[gs[2]]=Ds
set Ks[gs[2]]=Js
call SetUnitPathing(As,false)
call SetUnitTimeScalePercent(As,Ws*100.)
call SetUnitAnimation(As,Qs)
call GroupAddUnitSimple(As,Ys)
call UnitAddAbilityBJ('Arav',xr)
call UnitRemoveAbilityBJ('Arav',xr)
call RemoveLocation(xs[1])
call RemoveLocation(Ps)
endfunction
function G3E takes nothing returns nothing
call SetUnitExploded(GetSpellTargetUnit(),true)
call KillUnit(GetSpellTargetUnit())
endfunction
function G4E takes nothing returns nothing
local integer G5E=GetUnitAbilityLevel(GetSpellAbilityUnit(),'A0G4')
local unit G6E=GetSpellAbilityUnit()
local location G7E=GetUnitLoc(GetSpellAbilityUnit())
local real G8E=GetUnitState(GetSpellAbilityUnit(),UNIT_STATE_LIFE)
local real G9E=GetUnitState(GetSpellAbilityUnit(),UNIT_STATE_MANA)
local effect hvE=AddSpecialEffectTarget("Abilities\\Spells\\Human\\ManaFlare\\ManaFlareTarget.mdl",GetSpellAbilityUnit(),"overhead")
local integer heE=0
call GroupAddUnit(ws,G6E)
call GroupAddUnit(us,G6E)
call UnitAddAbility(G6E,'A0G5')
call UnitMakeAbilityPermanent(G6E,true,'A0G5')
call SetUnitAbilityLevel(G6E,'A0G5',G5E)
call UnitAddAbility(G6E,'A0JS')
call UnitMakeAbilityPermanent(G6E,true,'A0JS')
call SetUnitAbilityLevel(G6E,'A0JS',G5E)
call UnitAddAbility(G6E,'A0G8')
call UnitMakeAbilityPermanent(G6E,true,'A0G8')
loop
exitwhen IsUnitInGroup(G6E,ws)==false
call pAa(1.)
set heE=heE+1
if heE==$A then
call GroupRemoveUnit(ws,G6E)
endif
endloop
call DestroyEffect(hvE)
if IsUnitInGroup(G6E,us) and GetUnitState(G6E,UNIT_STATE_LIFE)>.0 then
call DestroyEffect(AddSpecialEffectLoc("Abilities\\Spells\\Human\\MassTeleport\\MassTeleportCaster.mdl",GetUnitLoc(G6E)))
call SetUnitPositionLoc(G6E,G7E)
call DestroyEffect(AddSpecialEffectLoc("Abilities\\Spells\\Human\\MassTeleport\\MassTeleportCaster.mdl",GetUnitLoc(G6E)))
call SetUnitState(G6E,UNIT_STATE_LIFE,G8E)
call SetUnitState(G6E,UNIT_STATE_MANA,G9E-('}'-25*G5E))
endif
call UnitRemoveAbility(G6E,'A0G8')
call UnitRemoveAbility(G6E,'A0JS')
call UnitRemoveAbility(G6E,'A0G5')
call UnitRemoveAbility(G6E,'B03E')
call GroupRemoveUnit(us,G6E)
call GroupRemoveUnit(ws,G6E)
call RemoveLocation(G7E)
set G6E=null
set G7E=null
set G8E=.0
set G9E=.0
set hvE=null
set G5E=0
set heE=0
set G6E=null
set G7E=null
set hvE=null
endfunction
function hxE takes nothing returns boolean
return(GetEventPlayerChatString()=="'heroaltertime")
endfunction
function hoE takes nothing returns boolean
return(GetEventPlayerChatString()=="@heroaltertime")
endfunction
function hrE takes nothing returns nothing
set g[GetConvertedPlayerId(GetTriggerPlayer())]=GetUnitsOfPlayerMatching(GetTriggerPlayer(),Condition(rzv))
if hxE()then
call ForGroupBJ(g[GetConvertedPlayerId(GetTriggerPlayer())],rZv)
elseif hoE()then
call ForGroupBJ(g[GetConvertedPlayerId(GetTriggerPlayer())],r_v)
endif
call DestroyGroup(g[GetPlayerId(GetTriggerPlayer())+1])
endfunction
function hiE takes nothing returns nothing
call TriggerRegisterUnitEvent(R,GetFilterUnit(),EVENT_UNIT_DAMAGED)
endfunction
function haE takes nothing returns nothing
local player hnE=GetEnumPlayer()
local player hVE=null
if GetPlayerController(hnE)==MAP_CONTROL_USER and GetPlayerSlotState(hnE)==PLAYER_SLOT_STATE_PLAYING then
call GetPlayerId(hnE)
call CreateUnitAtLoc(hnE,'h000',GetStartLocationLoc(GetPlayerStartLocation(hnE)),bj_UNIT_FACING)
endif
call SetPlayerTechResearched(hnE,'Rosp',1)
call SetPlayerTechResearched(hnE,'Rorb',1)
call SetPlayerTechResearched(hnE,'ROd3',1)
call SetPlayerAbilityAvailable(hnE,'A0EV',false)
call SetPlayerAbilityAvailable(hnE,'A0FB',false)
call SetPlayerAbilityAvailable(hnE,'A0FF',false)
call SetPlayerAbilityAvailable(hnE,'A0G7',false)
call SetPlayerAbilityAvailable(hnE,'A0G8',false)
call SetPlayerAbilityAvailable(hnE,'A0GI',false)
call SetPlayerAbilityAvailable(hnE,'A0GO',false)
call SetPlayerAbilityAvailable(hnE,'A0HV',false)
call SetPlayerAbilityAvailable(hnE,'A0I0',false)
call SetPlayerAbilityAvailable(hnE,'A0J0',false)
call SetPlayerAbilityAvailable(hnE,'A0KA',false)
call SetPlayerAbilityAvailable(hnE,'A0K9',false)
call SetPlayerAbilityAvailable(hnE,'A03T',false)
call SetPlayerAbilityAvailable(hnE,'AcB1',false)
call SetPlayerAbilityAvailable(hnE,'AcB2',false)
call SetPlayerAbilityAvailable(hnE,'AcB3',false)
call SetPlayerAbilityAvailable(hnE,'AcB4',false)
call SetPlayerAbilityAvailable(hnE,'AcB5',false)
call SetPlayerAbilityAvailable(hnE,'AcB6',false)
call SetPlayerAbilityAvailable(hnE,'AcB7',false)
call SetPlayerAbilityAvailable(hnE,'AcB8',false)
call SetPlayerAbilityAvailable(hnE,'AcTS',false)
call SetPlayerTechMaxAllowed(hnE,'HERO',-1)
call SetPlayerState(hnE,PLAYER_STATE_RESOURCE_GOLD,$3B9ACA00)
call SetPlayerState(hnE,PLAYER_STATE_RESOURCE_LUMBER,$3B9ACA00)
call SetPlayerState(hnE,PLAYER_STATE_RESOURCE_FOOD_CAP,300)
call SetPlayerState(hnE,PLAYER_STATE_FOOD_CAP_CEILING,300)
set hVE=Player(0)
if hnE!=hVE then
call SetPlayerAlliance(hnE,hVE,ALLIANCE_PASSIVE,true)
call SetPlayerAlliance(hnE,hVE,ALLIANCE_HELP_REQUEST,true)
call SetPlayerAlliance(hnE,hVE,ALLIANCE_HELP_RESPONSE,true)
call SetPlayerAlliance(hnE,hVE,ALLIANCE_SHARED_XP,true)
call SetPlayerAlliance(hnE,hVE,ALLIANCE_SHARED_SPELLS,true)
call SetPlayerAlliance(hnE,hVE,ALLIANCE_SHARED_VISION,false)
call SetPlayerAlliance(hnE,hVE,ALLIANCE_SHARED_CONTROL,false)
call SetPlayerAlliance(hnE,hVE,ALLIANCE_SHARED_ADVANCED_CONTROL,false)
call SetPlayerAlliance(hVE,hnE,ALLIANCE_PASSIVE,true)
call SetPlayerAlliance(hVE,hnE,ALLIANCE_HELP_REQUEST,true)
call SetPlayerAlliance(hVE,hnE,ALLIANCE_HELP_RESPONSE,true)
call SetPlayerAlliance(hVE,hnE,ALLIANCE_SHARED_XP,true)
call SetPlayerAlliance(hVE,hnE,ALLIANCE_SHARED_SPELLS,true)
call SetPlayerAlliance(hVE,hnE,ALLIANCE_SHARED_VISION,false)
call SetPlayerAlliance(hVE,hnE,ALLIANCE_SHARED_CONTROL,false)
call SetPlayerAlliance(hVE,hnE,ALLIANCE_SHARED_ADVANCED_CONTROL,false)
endif
set hVE=Player(bj_PLAYER_NEUTRAL_VICTIM)
call SetPlayerAlliance(hVE,hnE,ALLIANCE_PASSIVE,true)
call SetPlayerAlliance(hVE,hnE,ALLIANCE_HELP_REQUEST,true)
call SetPlayerAlliance(hVE,hnE,ALLIANCE_HELP_RESPONSE,true)
call SetPlayerAlliance(hVE,hnE,ALLIANCE_SHARED_XP,true)
call SetPlayerAlliance(hVE,hnE,ALLIANCE_SHARED_SPELLS,true)
call SetPlayerAlliance(hVE,hnE,ALLIANCE_SHARED_VISION,true)
call SetPlayerAlliance(hVE,hnE,ALLIANCE_SHARED_CONTROL,true)
call SetPlayerAlliance(hVE,hnE,ALLIANCE_SHARED_ADVANCED_CONTROL,true)
call SetPlayerName(hVE,"_________ ____")
set hVE=null
set ss[GetPlayerId(hnE)]=CreateUnitAtLoc(hnE,'h0Q7',GetRectCenter(GetPlayableMapRect()),270.)
call GetPlayerId(hnE)
call CreateUnitAtLoc(hnE,'tcR9',GetRectCenter(GetPlayableMapRect()),270.)
call StoreString(xt,I2S(GetPlayerId(hnE)),"a!","______")
call StoreString(xt,I2S(GetPlayerId(hnE)),"a%","______")
set hnE=null
set hnE=null
set hVE=null
endfunction
function hEE takes integer hXE returns nothing
if hXE==0 then
return
elseif jb[hXE]!=-1 then
return
endif
set sy=hXE
call TriggerEvaluate(vb[xb[hXE]])
set jb[hXE]=Fb
set Fb=hXE
endfunction
function hOE takes nothing returns boolean
local integer hRE=sy
call nYV(Db[hRE],Hb[hRE])
call hEE(hRE)
return true
endfunction
function hIE takes string hAE returns nothing
local timer hNE
local integer hbE
local integer hBE
set ZM[EM]=hAE
set EM=EM+1
set hNE=GetExpiredTimer()
set hbE=aqn(hNE,"when calling getData in BuffsJurst, line 86")
set hBE=a5V(XQ[KQ[hbE]],GetHandleId(hNE),"when calling loadInteger in BuffsJurst, line 87")
if hBE==0 then
call atn(hNE,"when calling release in BuffsJurst, line 89")
call iin(XQ[KQ[hbE]],GetHandleId(LQ[hbE]),"when calling removeHandle in BuffsJurst, line 90")
if NQ[KQ[hbE]]!=0 then
call aln(NQ[KQ[hbE]],LQ[hbE],"when calling evaluate in BuffsJurst, line 92")
endif
if MQ[KQ[hbE]]!=0 then
call aln(MQ[KQ[hbE]],LQ[hbE],"when calling evaluate in BuffsJurst, line 95")
endif
call ifn(hbE,"when calling destroy in BuffsJurst, line 97")
set EM=EM-1
set hNE=null
return
endif
if wW[KQ[hbE]]!=0 then
call aln(wW[KQ[hbE]],LQ[hbE],"when calling evaluate in BuffsJurst, line 101")
endif
call izn(XQ[KQ[hbE]],GetHandleId(hNE),hBE-1,"when calling saveInteger in BuffsJurst, line 103")
set EM=EM-1
set hNE=null
endfunction
function hcE takes nothing returns nothing
set EM=0
call hIE("BuffsJurst, line 142")
endfunction
function hCE takes nothing returns boolean
return(GetEventPlayerChatString()=="set 1")or(GetEventPlayerChatString()=="set 2")or(GetEventPlayerChatString()=="set 3")
endfunction
function hdE takes nothing returns boolean
return(hCE())
endfunction
function hDE takes string hfE returns integer
local integer hFE
set ZM[EM]=hfE
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set hFE=Yj
set Gj[hFE]=$AD4
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdCameraSetupBuiltins.","when calling error in ScmdCameraSetupBuiltins, line 32")
set hFE=0
endif
else
set Tj=Tj-1
set hFE=Rj[Tj]
set Gj[hFE]=$AD4
endif
set EM=EM-1
return hFE
endfunction
function hgE takes nothing returns integer
return Pn
endfunction
function hGE takes string hhE returns integer
local integer hHE
set ZM[EM]=hhE
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set hHE=Yj
set Gj[hHE]=$AD0
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdCameraSetupBuiltins.","when calling error in ScmdCameraSetupBuiltins, line 13")
set hHE=0
endif
else
set Tj=Tj-1
set hHE=Rj[Tj]
set Gj[hHE]=$AD0
endif
set EM=EM-1
return hHE
endfunction
function hjE takes string hJE returns integer
local integer hkE
set ZM[EM]=hJE
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set hkE=Yj
set Gj[hkE]=$A2B
else
call Cdv("Out of memory: Could not create IBuiltin_registerProtectedBuiltin_ScmdCameraSetupBuiltins.","when calling error in ScmdCameraSetupBuiltins, line 6")
set hkE=0
endif
else
set Tj=Tj-1
set hkE=Rj[Tj]
set Gj[hkE]=$A2B
endif
set EM=EM-1
return hkE
endfunction
function hKE takes string hlE returns integer
local integer hLE
set ZM[EM]=hlE
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set hLE=Yj
set Gj[hLE]=$ACF
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdCameraSetupBuiltins.","when calling error in ScmdCameraSetupBuiltins, line 9")
set hLE=0
endif
else
set Tj=Tj-1
set hLE=Rj[Tj]
set Gj[hLE]=$ACF
endif
set EM=EM-1
return hLE
endfunction
function hmE takes string hME returns integer
local integer hpE
set ZM[EM]=hME
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set hpE=Yj
set Gj[hpE]=$AD1
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdCameraSetupBuiltins.","when calling error in ScmdCameraSetupBuiltins, line 17")
set hpE=0
endif
else
set Tj=Tj-1
set hpE=Rj[Tj]
set Gj[hpE]=$AD1
endif
set EM=EM-1
return hpE
endfunction
function hPE takes string hqE returns integer
local integer hQE
set ZM[EM]=hqE
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set hQE=Yj
set Gj[hQE]=$AD2
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdCameraSetupBuiltins.","when calling error in ScmdCameraSetupBuiltins, line 22")
set hQE=0
endif
else
set Tj=Tj-1
set hQE=Rj[Tj]
set Gj[hQE]=$AD2
endif
set EM=EM-1
return hQE
endfunction
function hsE takes string hSE returns integer
local integer htE
set ZM[EM]=hSE
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set htE=Yj
set Gj[htE]=$AD3
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdCameraSetupBuiltins.","when calling error in ScmdCameraSetupBuiltins, line 27")
set htE=0
endif
else
set Tj=Tj-1
set htE=Rj[Tj]
set Gj[htE]=$AD3
endif
set EM=EM-1
return htE
endfunction
function hTE takes string huE returns boolean
local integer hUE
local integer hwE
local integer hWE
local integer hyE
local integer hYE
local integer hzE
local integer hZE
local integer h_E
local integer h0E
local integer h1E
local integer h2E
local integer h3E
local integer h4E
set ZM[EM]=huE
set EM=EM+1
set hUE=hjE("when calling alloc_IBuiltin_registerProtectedBuiltin_ScmdCameraSetupBuiltins in ScmdCameraSetupBuiltins, line 6")
call Foa(ILo(OPo(hUE,"when calling new_BuiltinData in ScmdCameraSetupBuiltins, line 6"),"when calling new_BuiltinFunction in ScmdCameraSetupBuiltins, line 6"),"camerasetup","when calling registerProtectedBuiltin in ScmdCameraSetupBuiltins, line 6")
set hwE=hKE("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdCameraSetupBuiltins in ScmdCameraSetupBuiltins, line 9")
set hWE=OPo(hwE,"when calling new_BuiltinData in ScmdCameraSetupBuiltins, line 9")
call glV(hWE,hgE(),f3a(),gQV(),gQV(),"when calling setArgumentsTypes in ScmdCameraSetupBuiltins, line 12")
call Foa(ILo(hWE,"when calling new_BuiltinFunction in ScmdCameraSetupBuiltins, line 9"),"camerasetupsetfield","when calling registerProtectedBuiltin in ScmdCameraSetupBuiltins, line 9")
set hyE=hGE("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdCameraSetupBuiltins in ScmdCameraSetupBuiltins, line 13")
set hYE=OPo(hyE,"when calling new_BuiltinData in ScmdCameraSetupBuiltins, line 13")
call glV(hYE,hgE(),gQV(),gQV(),gQV(),"when calling setArgumentsTypes in ScmdCameraSetupBuiltins, line 16")
call Foa(ILo(hYE,"when calling new_BuiltinFunction in ScmdCameraSetupBuiltins, line 13"),"camerasetupsetdestposition","when calling registerProtectedBuiltin in ScmdCameraSetupBuiltins, line 13")
set hzE=hmE("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdCameraSetupBuiltins in ScmdCameraSetupBuiltins, line 17")
set hZE=OPo(hzE,"when calling new_BuiltinData in ScmdCameraSetupBuiltins, line 17")
call etV(hZE,hgE(),d_V(),d_V(),"when calling setArgumentsTypes in ScmdCameraSetupBuiltins, line 21")
call Foa(ILo(hZE,"when calling new_BuiltinFunction in ScmdCameraSetupBuiltins, line 17"),"camerasetupapply","when calling registerProtectedBuiltin in ScmdCameraSetupBuiltins, line 17")
set h_E=hPE("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdCameraSetupBuiltins in ScmdCameraSetupBuiltins, line 22")
set h0E=OPo(h_E,"when calling new_BuiltinData in ScmdCameraSetupBuiltins, line 22")
call FRa(h0E,hgE(),gQV(),"when calling setArgumentsTypes in ScmdCameraSetupBuiltins, line 26")
call Foa(ILo(h0E,"when calling new_BuiltinFunction in ScmdCameraSetupBuiltins, line 22"),"camerasetupapplywithz","when calling registerProtectedBuiltin in ScmdCameraSetupBuiltins, line 22")
set h1E=hsE("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdCameraSetupBuiltins in ScmdCameraSetupBuiltins, line 27")
set h2E=OPo(h1E,"when calling new_BuiltinData in ScmdCameraSetupBuiltins, line 27")
call etV(h2E,hgE(),d_V(),gQV(),"when calling setArgumentsTypes in ScmdCameraSetupBuiltins, line 31")
call Foa(ILo(h2E,"when calling new_BuiltinFunction in ScmdCameraSetupBuiltins, line 27"),"camerasetupapplyforceduration","when calling registerProtectedBuiltin in ScmdCameraSetupBuiltins, line 27")
set h3E=hDE("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdCameraSetupBuiltins in ScmdCameraSetupBuiltins, line 32")
set h4E=OPo(h3E,"when calling new_BuiltinData in ScmdCameraSetupBuiltins, line 32")
call etV(h4E,hgE(),gQV(),gQV(),"when calling setArgumentsTypes in ScmdCameraSetupBuiltins, line 36")
call Foa(ILo(h4E,"when calling new_BuiltinFunction in ScmdCameraSetupBuiltins, line 32"),"camerasetupapplyforcedurationwithz","when calling registerProtectedBuiltin in ScmdCameraSetupBuiltins, line 32")
set EM=EM-1
return true
endfunction
function h5E takes nothing returns boolean
set EM=0
return hTE("ScmdCameraSetupBuiltins, line 1")
endfunction
function h6E takes nothing returns nothing
local unit h7E=GetSpellAbilityUnit()
local integer h8E=0
local integer h9E=GetUnitAbilityLevel(h7E,'A0F6')
if IsUnitInGroup(h7E,ot) then
call GroupRemoveUnit(ot,h7E)
call pAa(1.)
endif
call GroupAddUnit(ot,h7E)
call DestroyEffect(AddSpecialEffectTarget("Abilities\\Spells\\Orc\\MirrorImage\\MirrorImageCaster.mdl",h7E,"chest"))
call UnitAddAbility(h7E,'A0FB')
call UnitMakeAbilityPermanent(h7E,true,'A0FB')
call SetUnitAbilityLevel(h7E,'A0FB',h9E)
call UnitAddAbility(h7E,'A0JU')
call UnitMakeAbilityPermanent(h7E,true,'A0JU')
call SetUnitAbilityLevel(h7E,'A0JU',h9E)
set h9E=0
loop
exitwhen IsUnitInGroup(h7E,ot)==false
call pAa(1.)
set h8E=h8E+1
if h8E==6 or GetUnitState(h7E,UNIT_STATE_LIFE)<=.0 then
call GroupRemoveUnit(ot,h7E)
endif
endloop
call UnitRemoveAbility(h7E,'A0FB')
call UnitRemoveAbility(h7E,'A0JU')
call UnitRemoveAbility(h7E,'B032')
set h7E=null
set h8E=0
set h7E=null
endfunction
function HvE takes boolean HeE returns integer
if HeE then
return 1
else
return 0
endif
endfunction
function HxE takes nothing returns nothing
local unit HoE=GetSpellAbilityUnit()
local unit HrE=GetSpellTargetUnit()
local timer HiE=LoadTimerHandle(nr,GetHandleId(HrE),StringHash("daT"))
local effect HaE=null
if HiE!=null then
set HaE=LoadEffectHandle(nr,GetHandleId(HiE),StringHash("e"))
call FlushChildHashtable(nr,GetHandleId(HiE))
call DestroyTimer(HiE)
else
call UnitAddAbility(HrE,'AOde')
call UnitMakeAbilityPermanent(HrE,true,'AOde')
endif
set HiE=CreateTimer()
call SaveTimerHandle(nr,GetHandleId(HrE),StringHash("daT"),HiE)
call SaveUnitHandle(nr,GetHandleId(HiE),StringHash("s"),HrE)
if HaE==null then
call SaveEffectHandle(nr,GetHandleId(HiE),StringHash("e"),AddSpecialEffectTarget("Abilities\\Spells\\Other\\Disarm\\Disarm.mdx",HrE,"overhead"))
else
call SaveEffectHandle(nr,GetHandleId(HiE),StringHash("e"),HaE)
set HaE=null
endif
call TimerStart(HiE,30*GetUnitAbilityLevel(HoE,'AOda')/(1+9*HvE(IsUnitType(HrE,UNIT_TYPE_HERO))),false,Vmv)
set HoE=null
set HrE=null
set HiE=null
set HoE=null
set HrE=null
set HiE=null
set HaE=null
endfunction
function HnE takes nothing returns nothing
set G=GetUnitLoc(GetEnumUnit())
call EnumDestructablesInCircleBJ(256.,G,xMv)
call RemoveLocation(G)
endfunction
function HVE takes real HEE,real HXE,real HOE returns real
set l1=HEE*HOE
set b1=HXE*HOE
return l1
endfunction
function HRE takes nothing returns nothing
local rect HIE
local region HAE
local rect HNE
local region HbE
local real HBE
local real HcE
local real HCE
local real HdE
local real HDE
local real HfE
local real HFE
local real HgE
if me then
set HIE=Rect(-1024.,-1024.,1024.,1024.)
else
set HIE=GetPlayableMapRect()
endif
set Qe=HIE
set HAE=CreateRegion()
call YKo(HAE,Qe)
if me then
set HNE=Rect(-1536.,-1536.,1536.,1536.)
else
set HNE=GetWorldBounds()
endif
set We=HNE
set HbE=CreateRegion()
call YKo(HbE,We)
set Ee=HbE
set HBE=fee(Qe)
set HcE=foe(Qe)
set Ze=HBE
set Ue=HcE
set HCE=fie(Qe)
set HdE=D9e(Qe)
set Ie=HCE
set Pe=HdE
set HDE=fee(We)
set HfE=foe(We)
set Ae=HDE
set De=HfE
set HFE=fie(We)
set HgE=D9e(We)
set He=HFE
set Je=HgE
call HVE(I_e(Ze,Ue,Ie,Pe),O1,.5)
call HVE(I_e(Ae,De,He,Je),O1,.5)
endfunction
function HGE takes nothing returns boolean
call HRE()
return true
endfunction
function HhE takes nothing returns boolean
return(GetEventPlayerChatString()=="*"+nw[GetForLoopIndexA()])
endfunction
function HHE takes nothing returns nothing
set g[GetConvertedPlayerId(GetTriggerPlayer())]=GetUnitsOfPlayerAll(GetTriggerPlayer())
set bj_forLoopAIndex=0
set bj_forLoopAIndexEnd=dw
loop
exitwhen bj_forLoopAIndex>bj_forLoopAIndexEnd
if HhE()then
call ForGroupBJ(g[GetConvertedPlayerId(GetTriggerPlayer())],eZv)
endif
set bj_forLoopAIndex=bj_forLoopAIndex+1
endloop
call DestroyGroup(g[GetPlayerId(GetTriggerPlayer())+1])
endfunction
function HjE takes nothing returns boolean
return(kr[1]==0)
endfunction
function HJE takes nothing returns nothing
if HjE()then
call EnableTrigger(PS)
endif
set kr[1]=kr[1]+1
set kr[2]=kr[2]+1
set jr[1]=GetUnitLoc(xr)
set vr[kr[2]]=DistanceBetweenPoints(jr[1],mr)
set Qr[kr[2]]=.0
set Wr[kr[2]]=Er
set Zr[kr[2]]=xr
set Qt[kr[2]]=mt
set Ur[kr[2]]=AngleBetweenPoints(jr[1],mr)
set Ir[kr[2]]=Pr
set Ar[kr[2]]=Dr
set Hr[kr[2]]=Jr
set Kr[kr[2]]=Lr*vr[kr[2]]
call SetUnitPathing(xr,false)
call SetUnitTimeScalePercent(xr,Xr*100.)
call SetUnitAnimation(xr,Dr)
call GroupAddUnitSimple(xr,Cr)
call UnitAddAbilityBJ('Arav',xr)
call UnitRemoveAbilityBJ('Arav',xr)
call RemoveLocation(jr[1])
call RemoveLocation(mr)
endfunction
function HkE takes nothing returns boolean
return(GetEventPlayerChatString()=="~undead")
endfunction
function HKE takes nothing returns boolean
return(GetEventPlayerChatString()=="@undead")
endfunction
function HlE takes nothing returns nothing
set g[GetConvertedPlayerId(GetTriggerPlayer())]=GetUnitsOfPlayerMatching(GetTriggerPlayer(),Condition(o5v))
if HkE()then
call ForGroupBJ(g[GetConvertedPlayerId(GetTriggerPlayer())],o6v)
elseif HKE()then
call ForGroupBJ(g[GetConvertedPlayerId(GetTriggerPlayer())],o7v)
endif
call DestroyGroup(g[GetPlayerId(GetTriggerPlayer())+1])
endfunction
function HLE takes nothing returns nothing
local timer HmE=GetExpiredTimer()
call SaveTimerHandle(nr,GetHandleId(LoadUnitHandle(nr,GetHandleId(HmE),StringHash("aiRu"))),StringHash("aiR"),null)
call SaveUnitHandle(nr,GetHandleId(HmE),StringHash("aiRu"),null)
call DestroyTrigger(LoadTriggerHandle(nr,GetHandleId(HmE),StringHash("aiR")))
call SaveTriggerHandle(nr,GetHandleId(HmE),StringHash("aiR"),null)
call DestroyTimer(HmE)
set HmE=null
set HmE=null
endfunction
function HME takes nothing returns nothing
if GetUnitTypeId(GetEnumUnit())!='h000' and IsUnitSelected(GetEnumUnit(),GetTriggerPlayer()) then
call GroupAddUnit(Yt,GetEnumUnit())
endif
endfunction
function HpE takes nothing returns nothing
call SetBlightRadiusLocBJ(true,GetEnumPlayer(),G,220.)
endfunction
function HPE takes nothing returns nothing
set G=GetUnitLoc(GetEnumUnit())
call CreateItemLoc('I06Z',G)
call RemoveLocation(G)
endfunction
function HqE takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),1,3)=="afx")
endfunction
function HQE takes string HsE returns boolean
set ZM[EM]=HsE
set EM=EM+1
set sT=0
set tT=a6x("when calling new_Table in TimerUtils, line 13")
set iT=$28829022
call Ctv("when calling new_HashMap in TimerUtils, line 59")
set EM=EM-1
return true
endfunction
function HSE takes nothing returns boolean
set EM=0
return HQE("TimerUtils, line 1")
endfunction
function HtE takes nothing returns boolean
return(GetSpellAbilityId()=='Abrf')or(GetSpellAbilityId()=='Abur')or(GetSpellAbilityId()=='Abu5')or(GetSpellAbilityId()=='Abu2')or(GetSpellAbilityId()=='Abu3')or(GetSpellAbilityId()=='Acpf')or(GetSpellAbilityId()=='Aave')or(GetSpellAbilityId()=='Aetf')or(GetSpellAbilityId()=='AEme')or(GetSpellAbilityId()=='AEvi')or(GetSpellAbilityId()=='AEIl')or(GetSpellAbilityId()=='Asb1')or(GetSpellAbilityId()=='Asb2')or(GetSpellAbilityId()=='Asb3')or(GetSpellAbilityId()=='Astn')or(GetSpellAbilityId()=='Arav')or(GetSpellAbilityId()=='Amrf')
endfunction
function HTE takes nothing returns boolean
return(HtE())
endfunction
function HuE takes string HUE returns boolean
set ZM[EM]=HUE
set EM=EM+1
call DOa("when calling create in TypeCastingJurst, line 4")
set EM=EM-1
return true
endfunction
function HwE takes nothing returns boolean
set EM=0
return HuE("TypeCastingJurst, line 1")
endfunction
function HWE takes trigger HyE returns nothing
call TriggerExecute(HyE)
endfunction
function HYE takes nothing returns nothing
local unit HzE=GetTriggerUnit()
if USv(HzE,xq)==0 then
call itV(HzE)
call HWE(hq)
call iuV()
endif
set HzE=null
endfunction
function HZE takes nothing returns boolean
return(GetSpellAbilityId()=='A07X')
endfunction
function H_E takes nothing returns boolean
return(GetSpellAbilityId()=='A0HX')
endfunction
function H0E takes nothing returns boolean
return(GetSpellAbilityId()=='A0JH')
endfunction
function H1E takes nothing returns nothing
call IssueImmediateOrderBJ(GetEnumUnit(),"stop")
endfunction
function H2E takes nothing returns nothing
local unit H3E=GetEnumUnit()
local unit H4E=CreateUnitAtLoc(Player($F),'h0JO',GetUnitLoc(H3E),270.)
call UnitAddAbility(H4E,'A093')
call SetUnitAbilityLevel(H4E,'A093',GetUnitAbilityLevel(GetSpellAbilityUnit(),'A092'))
call IssueTargetOrderById(H4E,$D00B0,H3E)
call oLn(H4E,3.)
set H3E=null
set H4E=null
set H3E=null
set H4E=null
endfunction
function H5E takes nothing returns boolean
return SubString(GetEventPlayerChatString(),0,4)=="roll"
endfunction
function H6E takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),4,$E)=="itemcharges")
endfunction
function H7E takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),4,7)=="mana")
endfunction
function H8E takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),4,6)=="int")
endfunction
function H9E takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),4,6)=="arm")
endfunction
function jvE takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),4,6)=="str")
endfunction
function jeE takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),4,6)=="dam")
endfunction
function jxE takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),4,7)=="life")
endfunction
function joE takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),4,6)=="agi")
endfunction
function jrE takes nothing returns nothing
if H6E()then
call S2I(SubStringBJ(GetEventPlayerChatString(),16,StringLength(GetEventPlayerChatString())))
endif
if jvE()then
call S2I(SubStringBJ(GetEventPlayerChatString(),8,StringLength(GetEventPlayerChatString())))
endif
if H8E()then
call S2I(SubStringBJ(GetEventPlayerChatString(),8,StringLength(GetEventPlayerChatString())))
endif
if joE()then
call S2I(SubStringBJ(GetEventPlayerChatString(),8,StringLength(GetEventPlayerChatString())))
endif
if jeE()then
call S2I(SubStringBJ(GetEventPlayerChatString(),8,StringLength(GetEventPlayerChatString())))
endif
if H9E()then
call S2I(SubStringBJ(GetEventPlayerChatString(),8,StringLength(GetEventPlayerChatString())))
endif
if jxE()then
call S2I(SubStringBJ(GetEventPlayerChatString(),9,StringLength(GetEventPlayerChatString())))
endif
if H7E()then
call S2I(SubStringBJ(GetEventPlayerChatString(),9,StringLength(GetEventPlayerChatString())))
endif
endfunction
function jiE takes unit SRw returns nothing
endfunction
function jaE takes nothing returns nothing
local integer jnE=0
local unit jVE=GetTriggerUnit()
if GetUnitTypeId(jVE)=='cduw' then
call SetUnitAcquireRange(jVE,1.)
endif
if HaveStoredInteger(xt,UnitId2String(GetUnitTypeId(jVE)),"UNIT_STATE_MAX_LIFE")==false then
if IsUnitType(jVE,UNIT_TYPE_HERO)then
set jnE=GetHeroStr(jVE,false)
call SetHeroStr(jVE,0,true)
call StoreInteger(xt,UnitId2String(GetUnitTypeId(jVE)),"UNIT_STATE_MAX_LIFE",R2I(GetUnitState(jVE,UNIT_STATE_MAX_LIFE)))
call SetHeroStr(jVE,jnE,true)
set jnE=0
else
call StoreInteger(xt,UnitId2String(GetUnitTypeId(jVE)),"UNIT_STATE_MAX_LIFE",R2I(GetUnitState(jVE,UNIT_STATE_MAX_LIFE)))
endif
endif
if HaveStoredInteger(xt,UnitId2String(GetUnitTypeId(jVE)),"UNIT_STATE_MAX_MANA")==false then
if IsUnitType(jVE,UNIT_TYPE_HERO)then
set jnE=GetHeroInt(jVE,false)
call SetHeroInt(jVE,0,true)
call StoreInteger(xt,UnitId2String(GetUnitTypeId(jVE)),"UNIT_STATE_MAX_MANA",R2I(GetUnitState(jVE,UNIT_STATE_MAX_MANA)))
call SetHeroInt(jVE,jnE,true)
set jnE=0
else
call StoreInteger(xt,UnitId2String(GetUnitTypeId(jVE)),"UNIT_STATE_MAX_MANA",R2I(GetUnitState(jVE,UNIT_STATE_MAX_MANA)))
endif
endif
call jiE(jVE)
call AddUnitAnimationProperties(jVE,null,true)
call TriggerRegisterUnitEvent(dO,jVE,EVENT_UNIT_DAMAGED)
call UnitAddAbility(jVE,'Amrf')
call UnitRemoveAbility(jVE,'Amrf')
call SetUnitUseFood(jVE,false)
call SetPlayerState(GetOwningPlayer(jVE),PLAYER_STATE_RESOURCE_GOLD,$3B9ACA00)
call SetPlayerState(GetOwningPlayer(jVE),PLAYER_STATE_RESOURCE_LUMBER,$3B9ACA00)
call SetPlayerState(GetOwningPlayer(jVE),PLAYER_STATE_RESOURCE_FOOD_USED,0)
if GetUnitTypeId(jVE)=='ngol' then
call SetResourceAmount(jVE,$98967F)
endif
loop
exitwhen jnE>V
call UnitMakeAbilityPermanent(jVE,true,C[jnE])
set jnE=jnE+1
endloop
set jnE=0
loop
exitwhen jnE>fw
call UnitMakeAbilityPermanent(jVE,true,Rw[jnE])
set jnE=jnE+1
endloop
set jnE=0
call UnitMakeAbilityPermanent(GetEnumUnit(),true,'Arav')
call UnitMakeAbilityPermanent(GetEnumUnit(),true,'Abrf')
if IsUnitType(jVE,UNIT_TYPE_STRUCTURE) and IsUnitType(jVE,UNIT_TYPE_ANCIENT)==false and IsUnitType(jVE,UNIT_TYPE_SUMMONED) then
call UnitRemoveAbility(jVE,'Amov')
endif
set jVE=null
set jVE=null
endfunction
function jEE takes unit jXE returns nothing
local unit jOE=LoadUnitHandle(i,NO,GetHandleId(jXE))
local group jRE=LoadGroupHandle(i,BO,GetHandleId(jOE))
call GroupRemoveUnit(jRE,jXE)
if FirstOfGroup(jRE)==null then
call DestroyGroup(jRE)
call SaveGroupHandle(i,BO,GetHandleId(jOE),null)
endif
set jRE=null
set jOE=null
set jOE=null
set jRE=null
endfunction
function jIE takes nothing returns boolean
call jEE(ry)
return true
endfunction
function jAE takes integer jNE,string jbE returns nothing
set ZM[EM]=jbE
set EM=EM+1
call rax(tX[jNE],"when calling dispatch_RegionData_destroyRegionData in SotfrpGuiRegions, line 177")
set EM=EM-1
endfunction
function jBE takes integer jcE,integer jCE,string jdE returns nothing
set ZM[EM]=jdE
set EM=EM+1
call van(iJ[jcE],jCE,"when calling remove in SLangChatSystem, line 103")
set EM=EM-1
endfunction
function jDE takes integer jfE,integer jFE,string jgE returns nothing
set ZM[EM]=jgE
set EM=EM+1
if mj[jfE]==0 then
if jfE==0 then
call Cdv("Nullpointer exception when calling Log.untie","when calling error in SLangChatSystem, line 102")
else
call Cdv("Called Log.untie on invalid object.","when calling error in SLangChatSystem, line 102")
endif
endif
call jBE(jfE,jFE,"when calling untie in SLangChatSystem, line 102")
set EM=EM-1
endfunction
function jGE takes integer jhE,integer jHE,string jjE returns nothing
set ZM[EM]=jjE
set EM=EM+1
call rOa(iJ[jhE],jHE,"when calling add in SLangChatSystem, line 100")
set EM=EM-1
endfunction
function jJE takes integer jkE,integer jKE,string jlE returns nothing
set ZM[EM]=jlE
set EM=EM+1
if mj[jkE]==0 then
if jkE==0 then
call Cdv("Nullpointer exception when calling Log.tie","when calling error in SLangChatSystem, line 99")
else
call Cdv("Called Log.tie on invalid object.","when calling error in SLangChatSystem, line 99")
endif
endif
call jGE(jkE,jKE,"when calling tie in SLangChatSystem, line 99")
set EM=EM-1
endfunction
function jLE takes integer jmE,integer jME,string jpE returns nothing
local integer jPE
local integer jqE
set ZM[EM]=jpE
set EM=EM+1
if lJ[jmE]!=0 then
call jDE(lJ[jmE],jmE,"when calling untie in SLangChatSystem, line 60")
endif
if jME!=0 then
set jPE=jME
call jJE(jPE,jmE,"when calling tie in SLangChatSystem, line 61")
set jqE=jPE
else
set jqE=0
endif
set lJ[jmE]=jqE
set EM=EM-1
endfunction
function jQE takes integer jsE,integer jSE,string jtE returns nothing
set ZM[EM]=jtE
set EM=EM+1
if Zj[jsE]==0 then
if jsE==0 then
call Cdv("Nullpointer exception when calling LogBoard.tie","when calling error in SLangChatSystem, line 58")
else
call Cdv("Called LogBoard.tie on invalid object.","when calling error in SLangChatSystem, line 58")
endif
endif
call jLE(jsE,jSE,"when calling tie in SLangChatSystem, line 58")
set EM=EM-1
endfunction
function jTE takes integer Pqt returns nothing
endfunction
function juE takes integer jUE,string jwE returns nothing
set ZM[EM]=jwE
set EM=EM+1
if Zj[jUE]==0 then
if jUE==0 then
call Cdv("Nullpointer exception when calling LogBoard.show","when calling error in SLangChatSystem, line 49")
else
call Cdv("Called LogBoard.show on invalid object.","when calling error in SLangChatSystem, line 49")
endif
endif
call jTE(jUE)
set EM=EM-1
endfunction
function jWE takes string jyE returns integer
local integer jYE
set ZM[EM]=jyE
set EM=EM+1
if Wj==0 then
if Ej<$8000 then
set Ej=Ej+1
set jYE=Ej
set Zj[jYE]=$D47
else
call Cdv("Out of memory: Could not create LogBoard.","when calling error in SLangChatSystem, line 11")
set jYE=0
endif
else
set Wj=Wj-1
set jYE=Qj[Wj]
set Zj[jYE]=$D47
endif
set EM=EM-1
return jYE
endfunction
function jzE takes string jZE returns framehandle
return BlzCreateFrame(jZE,ie,0,0)
endfunction
function j_E takes framehandle j0E,framepointtype j1E,real j2E,real j3E returns nothing
call BlzFrameSetAbsPoint(j0E,j1E,j2E,j3E)
endfunction
function j4E takes integer j5E returns nothing
set vW[j5E]=0
endfunction
function j6E takes integer j7E returns nothing
call j4E(j7E)
endfunction
function j8E takes trigger j9E,framehandle JvE,frameeventtype JeE returns event
return BlzTriggerRegisterFrameEvent(j9E,JvE,JeE)
endfunction
function JxE takes integer JoE,framehandle JrE,frameeventtype JiE,string JaE returns integer
local integer JnE
local integer JVE
set ZM[EM]=JaE
set EM=EM+1
call j8E(bp,JrE,JiE)
set xW[JoE]=JiE
set JnE=C0v(JrE)
set JVE=f3v(yp,JnE,"when calling get in ClosureFrames, line 82")
if JVE!=0 then
set vW[JoE]=JVE
endif
call fqv(yp,JnE,JoE,"when calling put in ClosureFrames, line 86")
set EM=EM-1
return JoE
endfunction
function JEE takes framehandle JXE,integer JOE,string JRE returns integer
local integer JIE
set ZM[EM]=JRE
set EM=EM+1
set JIE=JxE(JOE,JXE,FRAMEEVENT_CONTROL_CLICK,"when calling addListenerForFrame in ClosureFrames, line 36")
set EM=EM-1
return JIE
endfunction
function JAE takes string JNE returns integer
local integer JbE
set ZM[EM]=JNE
set EM=EM+1
if Og==0 then
if lg<$8000 then
set lg=lg+1
set JbE=lg
set bg[JbE]=$8A2
else
call Cdv("Out of memory: Could not create FrameHandleListener_onClick_LogBoard_SLangChatSystem.","when calling error in SLangChatSystem, line 30")
set JbE=0
endif
else
set Og=Og-1
set JbE=og[Og]
set bg[JbE]=$8A2
endif
set EM=EM-1
return JbE
endfunction
function JBE takes framehandle JcE,real JCE,real JdE returns nothing
call BlzFrameSetSize(JcE,JCE,JdE)
endfunction
function JDE takes integer JfE,string JFE returns nothing
set ZM[EM]=JFE
set EM=EM+1
set lJ[JfE]=0
set bJ[JfE]=0
set yJ[JfE]=0
set pJ[JfE]=true
set eJ[JfE]=yTv("when calling new_LinkedList in SLangChatSystem, line 23")
set EM=EM-1
endfunction
function JgE takes integer JGE,string JhE returns nothing
local framehandle JHE
local framehandle JjE
local integer JJE
local framehandle JkE
local framehandle JKE
local framehandle JlE
local framehandle JLE
local framehandle JmE
set ZM[EM]=JhE
set EM=EM+1
call JDE(JGE,"when calling LogBoard_init in SLangChatSystem, line 26")
set JHE=jzE(te)
call j_E(JHE,FRAMEPOINT_TOPRIGHT,Se,ce)
set JjE=JHE
call JBE(JjE,.175,.025)
set JkE=JjE
set JmE=JkE
set JJE=JAE("when calling alloc_FrameHandleListener_onClick_LogBoard_SLangChatSystem in SLangChatSystem, line 30")
call j6E(JJE)
set qJ[JJE]=JGE
call JEE(JmE,JJE,"when calling onClick in SLangChatSystem, line 30")
set cJ[JGE]=JkE
set JKE=ZMn("ScriptDialogButtonText")
call Gte(JKE,"Hide Log")
set oJ[JGE]=JKE
set JlE=jzE("EscMenuTextAreaTemplate")
call j_E(JlE,FRAMEPOINT_TOPRIGHT,DRv(Se,ce,.0,.025),d9)
set JLE=JlE
call JBE(JLE,.35,.4)
set OJ[JGE]=JLE
set EM=EM-1
set JHE=null
set JjE=null
set JkE=null
set JKE=null
set JlE=null
set JLE=null
set JmE=null
endfunction
function JME takes string JpE returns integer
local integer JPE
set ZM[EM]=JpE
set EM=EM+1
set JPE=jWE("when calling alloc_LogBoard in SLangChatSystem, line 26")
call JgE(JPE,"when calling construct_LogBoard in SLangChatSystem, line 26")
set EM=EM-1
return JPE
endfunction
function JqE takes integer Uyt,string JQE returns nothing
local integer JsE
set ZM[EM]=JQE
set EM=EM+1
set JsE=JME("when calling new_LogBoard in SLangChatSystem, line 169")
call juE(JsE,"when calling show in SLangChatSystem, line 170")
call jQE(JsE,tIo(Ha,"when calling log in SLangChatSystem, line 171"),"when calling tie in SLangChatSystem, line 171")
set EM=EM-1
endfunction
function JSE takes integer JtE,string JTE returns nothing
set ZM[EM]=JTE
set EM=EM+1
call SetTerrainType(Vd[nL[JtE]]+Oba(X6a(dL[JtE],"when calling nextToken in SotFRP_LegacyLoad, line 222"))*$80,Bd[nL[JtE]]+Oba(X6a(dL[JtE],"when calling nextToken in SotFRP_LegacyLoad, line 222"))*$80,Oba(X6a(dL[JtE],"when calling nextToken in SotFRP_LegacyLoad, line 222")),Oba(X6a(dL[JtE],"when calling nextToken in SotFRP_LegacyLoad, line 222")),1,0)
call OLa(dL[JtE],"when calling dispatch_StringTokenizer_destroyStringTokenizer in SotFRP_LegacyLoad, line 223")
set EM=EM-1
endfunction
function JuE takes integer hRs returns nothing
set pp=pp*2
endfunction
function JUE takes integer rQi,string JwE returns nothing
local integer JWE
local integer JyE
set ZM[EM]=JwE
set EM=EM+1
set JWE=0
set JyE=bj_MAX_PLAYER_SLOTS
loop
exitwhen JWE>JyE
call Xsx(sa[JWE],ef,"when calling setLocale in SotFRP_Locale, line 36")
set JWE=JWE+1
endloop
set EM=EM-1
endfunction
function JYE takes integer JzE,string JZE returns nothing
set ZM[EM]=JZE
set EM=EM+1
if Zg[JzE]==0 then
call Cdv("Double free: object of type DummyCaster","when calling error in DummyCaster, line 28")
else
set Qg[Wg]=JzE
set Wg=Wg+1
set Zg[JzE]=0
endif
set EM=EM-1
endfunction
function J_E takes integer uks returns nothing
endfunction
function J0E takes integer J1E,string J2E returns nothing
set ZM[EM]=J2E
set EM=EM+1
call J_E(J1E)
call JYE(J1E,"when calling dealloc_DummyCaster in DummyCaster, line 28")
set EM=EM-1
endfunction
function J3E takes integer J4E,string J5E returns nothing
set ZM[EM]=J5E
set EM=EM+1
if Zg[J4E]==0 then
if J4E==0 then
call Cdv("Nullpointer exception when calling DummyCaster.DummyCaster","when calling error in DummyCaster, line 28")
else
call Cdv("Called DummyCaster.DummyCaster on invalid object.","when calling error in DummyCaster, line 28")
endif
endif
call J0E(J4E,"when calling destroyDummyCaster in DummyCaster, line 28")
set EM=EM-1
endfunction
function J6E takes integer J7E,string J8E returns nothing
local unit J9E
set ZM[EM]=J8E
set EM=EM+1
set J9E=AE[J7E]
call Tlv(J9E,DE[J7E])
call Pia(AE[J7E],"when calling recycle in DummyCaster, line 91")
set ZE[HE[J7E]]=ZE[HE[J7E]]-1
if ZE[HE[J7E]]==0 then
call J3E(HE[J7E],"when calling dispatch_DummyCaster_destroyDummyCaster in DummyCaster, line 94")
endif
set EM=EM-1
set J9E=null
endfunction
function kvE takes integer keE,string kxE returns nothing
set ZM[EM]=kxE
set EM=EM+1
if Gg[keE]==0 then
call Cdv("Double free: object of type LegacySaveData","when calling error in LegacySaveData, line 21")
else
set Rg[Tg]=keE
set Tg=Tg+1
set Gg[keE]=0
endif
set EM=EM-1
endfunction
function koE takes integer krE,string kiE returns nothing
set ZM[EM]=kiE
set EM=EM+1
if Mh[krE]==0 then
call Cdv("Double free: object of type LegacyPositionedUnitData","when calling error in LegacyUnitData, line 390")
else
set Vh[Bh]=krE
set Bh=Bh+1
set Mh[krE]=0
endif
set EM=EM-1
endfunction
function kaE takes integer knE,string kVE returns nothing
set ZM[EM]=kVE
set EM=EM+1
if sF[knE]==0 then
call Cdv("Double free: object of type LegacySingleUnitDataPositioned","when calling error in LegacyUnitData, line 369")
else
set wF[uF]=knE
set uF=uF+1
set sF[knE]=0
endif
set EM=EM-1
endfunction
function kEE takes integer kXE,string kOE returns nothing
set ZM[EM]=kOE
set EM=EM+1
call JEv(XI[kXE],"when calling dispatch_HashList_destroyHashList in LegacyUnitData, line 167")
call JEv(CI[kXE],"when calling dispatch_HashList_destroyHashList in LegacyUnitData, line 168")
call JEv(VI[kXE],"when calling dispatch_HashList_destroyHashList in LegacyUnitData, line 169")
set EM=EM-1
endfunction
function kRE takes integer kIE,string kAE returns nothing
set ZM[EM]=kAE
set EM=EM+1
call kEE(kIE,"when calling LegacySingleUnitData_onDestroy in LegacyUnitData, line 369")
set EM=EM-1
endfunction
function kNE takes integer kbE,string kBE returns nothing
set ZM[EM]=kBE
set EM=EM+1
call kRE(kbE,"when calling LegacySingleUnitDataPositioned_onDestroy in LegacyUnitData, line 369")
call kaE(kbE,"when calling dealloc_LegacySingleUnitDataPositioned in LegacyUnitData, line 369")
set EM=EM-1
endfunction
function kcE takes integer kCE,string kdE returns nothing
set ZM[EM]=kdE
set EM=EM+1
if sF[kCE]==0 then
if kCE==0 then
call Cdv("Nullpointer exception when calling LegacySingleUnitDataPositioned.LegacySingleUnitDataPositioned","when calling error in LegacyUnitData, line 369")
else
call Cdv("Called LegacySingleUnitDataPositioned.LegacySingleUnitDataPositioned on invalid object.","when calling error in LegacyUnitData, line 369")
endif
endif
call kNE(kCE,"when calling destroyLegacySingleUnitDataPositioned in LegacyUnitData, line 369")
set EM=EM-1
endfunction
function kDE takes integer kfE,string kFE returns nothing
local integer kgE
local integer kGE
set ZM[EM]=kFE
set EM=EM+1
set kgE=jdv(pI[kfE],"when calling iterator in LegacyUnitData, line 418")
loop
exitwhen not Jgv(kgE,"when calling hasNext in LegacyUnitData, line 418")
set kGE=jTv(kgE,"when calling next in LegacyUnitData, line 418")
call kcE(kGE,"when calling dispatch_LegacySingleUnitDataPositioned_destroyLegacySingleUnitDataPositioned in LegacyUnitData, line 419")
endloop
call Jqv(kgE,"when calling close in LegacyUnitData, line 418")
call JEv(pI[kfE],"when calling dispatch_HashList_destroyHashList in LegacyUnitData, line 420")
set EM=EM-1
endfunction
function khE takes integer kHE,string kjE returns nothing
set ZM[EM]=kjE
set EM=EM+1
call kDE(kHE,"when calling LegacyPositionedUnitData_onDestroy in LegacyUnitData, line 417")
call koE(kHE,"when calling dealloc_LegacyPositionedUnitData in LegacyUnitData, line 417")
set EM=EM-1
endfunction
function kJE takes integer kkE,string kKE returns nothing
set ZM[EM]=kKE
set EM=EM+1
if Mh[kkE]==0 then
if kkE==0 then
call Cdv("Nullpointer exception when calling LegacyPositionedUnitData.LegacyPositionedUnitData","when calling error in LegacyUnitData, line 390")
else
call Cdv("Called LegacyPositionedUnitData.LegacyPositionedUnitData on invalid object.","when calling error in LegacyUnitData, line 390")
endif
endif
call khE(kkE,"when calling destroyLegacyPositionedUnitData in LegacyUnitData, line 390")
set EM=EM-1
endfunction
function klE takes integer kLE,string kmE returns nothing
set ZM[EM]=kmE
set EM=EM+1
call Ode(tI[kLE],"when calling dispatch_StringHashMap_destroyStringHashMap in LegacyStringTable, line 62")
set EM=EM-1
endfunction
function kME takes integer kpE,string kPE returns nothing
set ZM[EM]=kPE
set EM=EM+1
if Gg[kpE]==0 then
call Cdv("Double free: object of type StringTable","when calling error in LegacyStringTable, line 15")
else
set Rg[Tg]=kpE
set Tg=Tg+1
set Gg[kpE]=0
endif
set EM=EM-1
endfunction
function kqE takes integer kQE,string ksE returns nothing
set ZM[EM]=ksE
set EM=EM+1
call klE(kQE,"when calling StringTable_onDestroy in LegacyStringTable, line 61")
call kME(kQE,"when calling dealloc_StringTable in LegacyStringTable, line 61")
set EM=EM-1
endfunction
function kSE takes integer ktE,string kTE returns nothing
set ZM[EM]=kTE
set EM=EM+1
if Gg[ktE]==0 then
if ktE==0 then
call Cdv("Nullpointer exception when calling StringTable.StringTable","when calling error in LegacyStringTable, line 15")
else
call Cdv("Called StringTable.StringTable on invalid object.","when calling error in LegacyStringTable, line 15")
endif
endif
call kqE(ktE,"when calling destroyStringTable in LegacyStringTable, line 15")
set EM=EM-1
endfunction
function kuE takes integer kUE,string kwE returns nothing
set ZM[EM]=kwE
set EM=EM+1
call kSE(MU[kUE],"when calling dispatch_StringTable_destroyStringTable in LegacySaveData, line 78")
call kJE(wI[kUE],"when calling dispatch_LegacyPositionedUnitData_destroyLegacyPositionedUnitData in LegacySaveData, line 79")
call o7x(kUE,"when calling Persistable_onDestroy in LegacySaveData, line 21")
set EM=EM-1
endfunction
function kWE takes integer kyE,string kYE returns nothing
set ZM[EM]=kYE
set EM=EM+1
call kuE(kyE,"when calling LegacySaveData_onDestroy in LegacySaveData, line 77")
call kvE(kyE,"when calling dealloc_LegacySaveData in LegacySaveData, line 77")
set EM=EM-1
endfunction
function kzE takes integer kZE,string k_E returns nothing
set ZM[EM]=k_E
set EM=EM+1
if Gg[kZE]==0 then
if kZE==0 then
call Cdv("Nullpointer exception when calling LegacySaveData.LegacySaveData","when calling error in LegacySaveData, line 21")
else
call Cdv("Called LegacySaveData.LegacySaveData on invalid object.","when calling error in LegacySaveData, line 21")
endif
endif
call kWE(kZE,"when calling destroyLegacySaveData in LegacySaveData, line 21")
set EM=EM-1
endfunction
function k0E takes integer k1E,string k2E returns nothing
set ZM[EM]=k2E
set EM=EM+1
call kzE(yX[k1E],"when calling dispatch_LegacySaveData_destroyLegacySaveData in SotfrpGuiRegions, line 199")
set EM=EM-1
endfunction
function k3E takes integer k4E,string k5E returns nothing
set ZM[EM]=k5E
set EM=EM+1
call rax(sX[k4E],"when calling dispatch_RegionData_destroyRegionData in SotfrpGuiRegions, line 170")
set EM=EM-1
endfunction
function k6E takes integer Ofs returns nothing
local integer k7E
local integer k8E
local trigger k9E
local trigger KvE
local trigger KeE
local trigger KxE
local trigger KoE
local trigger KrE
local trigger KiE
local trigger KaE
local trigger KnE
local trigger KVE
call cQv(Ly,RXv)
call cQv(Xy,ROv)
call cQv(Cy,RRv)
set k7E=0
set k8E=bj_MAX_PLAYERS-1
loop
exitwhen k7E>k8E
call qCa(Xy,sa[k7E],EVENT_PLAYER_LEAVE)
set k9E=Cy
call qCa(k9E,sa[k7E],EVENT_PLAYER_ARROW_DOWN_DOWN)
set KvE=k9E
call qCa(KvE,sa[k7E],EVENT_PLAYER_ARROW_DOWN_UP)
set KeE=KvE
call qCa(KeE,sa[k7E],EVENT_PLAYER_ARROW_UP_DOWN)
set KxE=KeE
call qCa(KxE,sa[k7E],EVENT_PLAYER_ARROW_UP_UP)
set KoE=KxE
call qCa(KoE,sa[k7E],EVENT_PLAYER_ARROW_LEFT_DOWN)
set KrE=KoE
call qCa(KrE,sa[k7E],EVENT_PLAYER_ARROW_LEFT_UP)
set KiE=KrE
call qCa(KiE,sa[k7E],EVENT_PLAYER_ARROW_RIGHT_DOWN)
set KaE=KiE
call qCa(KaE,sa[k7E],EVENT_PLAYER_ARROW_RIGHT_UP)
set KnE=KaE
call qCa(KnE,sa[k7E],EVENT_PLAYER_END_CINEMATIC)
set KVE=KnE
call g4v(KVE,sa[k7E],"",false)
set k7E=k7E+1
endloop
call qja(EVENT_PLAYER_UNIT_SPELL_EFFECT,null,RIv,null)
set k9E=null
set KvE=null
set KeE=null
set KxE=null
set KoE=null
set KrE=null
set KiE=null
set KaE=null
set KnE=null
set KVE=null
endfunction
function KEE takes integer KXE,string KOE returns nothing
set ZM[EM]=KOE
set EM=EM+1
if Lg[KXE]==0 then
call Cdv("Double free: object of type SimpleFormationData","when calling error in Formations, line 63")
else
set Kg=Kg+1
set Lg[KXE]=0
endif
set EM=EM-1
endfunction
function KRE takes hashtable KIE,integer KAE,integer KNE returns unit
return LoadUnitHandle(KIE,KAE,KNE)
endfunction
function KbE takes integer KBE,integer KcE returns unit
return KRE(XR,KBE,KcE)
endfunction
function KCE takes integer KdE,integer KDE,string KfE returns unit
local unit KFE
set ZM[EM]=KfE
set EM=EM+1
if ph[KdE]==0 then
if KdE==0 then
call Cdv("Nullpointer exception when calling Table.loadUnit","when calling error in Table, line 75")
else
call Cdv("Called Table.loadUnit on invalid object.","when calling error in Table, line 75")
endif
endif
set KFE=KbE(KdE,KDE)
set EM=EM-1
set Isv=KFE
set KFE=null
return Isv
endfunction
function KgE takes integer KGE,string KhE returns unit
local unit KHE
set ZM[EM]=KhE
set EM=EM+1
call zix(RT,0,ConvertFogState(KGE),"when calling saveFogState in TypeCasting, line 53")
set KHE=KCE(RT,0,"when calling loadUnit in TypeCasting, line 54")
set EM=EM-1
set R_v=KHE
set KHE=null
return R_v
endfunction
function KjE takes integer KJE,string KkE returns nothing
local integer KKE
local unit KlE
set ZM[EM]=KkE
set EM=EM+1
set KKE=Xle(sZ[KJE],"when calling iterator in Formations, line 86")
loop
exitwhen not Xie(KKE)
set KlE=KgE(E3e(KKE),"when calling unitFromIndex in Formations, line 86")
call UHx(KlE)
endloop
call Xpe(KKE,"when calling close in Formations, line 86")
call Hcv(sZ[KJE],"when calling dispatch_LinkedList_destroyLinkedList in Formations, line 89")
call xPx(tZ[KJE],"when calling dispatch_HashMap_destroyHashMap in Formations, line 90")
call xPx(iZ[KJE],"when calling dispatch_HashMap_destroyHashMap in Formations, line 91")
set EM=EM-1
set KlE=null
endfunction
function KLE takes integer KmE,string KME returns nothing
set ZM[EM]=KME
set EM=EM+1
call KjE(KmE,"when calling SimpleFormationData_onDestroy in Formations, line 85")
call KEE(KmE,"when calling dealloc_SimpleFormationData in Formations, line 85")
set EM=EM-1
endfunction
function KpE takes integer KPE,string KqE returns nothing
set ZM[EM]=KqE
set EM=EM+1
if Lg[KPE]==0 then
if KPE==0 then
call Cdv("Nullpointer exception when calling SimpleFormationData.SimpleFormationData","when calling error in Formations, line 63")
else
call Cdv("Called SimpleFormationData.SimpleFormationData on invalid object.","when calling error in Formations, line 63")
endif
endif
call KLE(KPE,"when calling destroySimpleFormationData in Formations, line 63")
set EM=EM-1
endfunction
function KQE takes string KsE returns integer
local integer KSE
set ZM[EM]=KsE
set EM=EM+1
if jG==0 then
if xG<$8000 then
set xG=xG+1
set KSE=xG
set vG[KSE]=$475
else
call Cdv("Out of memory: Could not create CallbackSingle_nullTimer_SimpleFormationData_Formations.","when calling error in Formations, line 123")
set KSE=0
endif
else
set jG=jG-1
set KSE=kG[jG]
set vG[KSE]=$475
endif
set EM=EM-1
return KSE
endfunction
function KtE takes integer KTE,string KuE returns nothing
local real KUE
local real KwE
local integer KWE
local integer KyE
local integer KYE
local unit KzE
local integer KZE
local integer K_E
local integer K0E
local unit K1E
local integer K2E
local real K3E
local real K4E
local real K5E
local real K6E
set ZM[EM]=KuE
set EM=EM+1
set K3E=.0
set K4E=.0
set KUE=K3E
set KwE=K4E
set KWE=hye(sZ[KTE],"when calling size in Formations, line 107")
set KyE=0
set KYE=Xle(sZ[KTE],"when calling iterator in Formations, line 110")
loop
exitwhen not Xie(KYE)
set KzE=KgE(E3e(KYE),"when calling unitFromIndex in Formations, line 110")
set KZE=UHx(KzE)
set KUE=KUE+mix(f3v(tZ[KTE],KZE,"when calling get in Formations, line 112"))
set KwE=KwE+mix(f3v(iZ[KTE],KZE,"when calling get in Formations, line 113"))
call z8a(KzE,Eq)
call Npe(KzE,false)
endloop
call Xpe(KYE,"when calling close in Formations, line 110")
set KUE=KUE/KWE
set KwE=KwE/KWE
set K_E=se[Hme(oZ[KTE])]
set K0E=Xle(sZ[KTE],"when calling iterator in Formations, line 122")
loop
exitwhen not Xie(K0E)
set K1E=KgE(E3e(K0E),"when calling unitFromIndex in Formations, line 122")
set K2E=KQE("when calling alloc_CallbackSingle_nullTimer_SimpleFormationData_Formations in Formations, line 123")
call EUx(K2E)
set lZ[K2E]=K1E
set bZ[K2E]=K_E
set yZ[K2E]=KWE
set pZ[K2E]=KyE
set eZ[K2E]=KTE
set K5E=KUE
set K6E=KwE
set qZ[K2E]=K5E
set aZ[K2E]=K6E
call Lsx(K2E,"when calling nullTimer in Formations, line 123")
set KyE=KyE+1
endloop
call Xpe(K0E,"when calling close in Formations, line 122")
call KpE(KTE,"when calling dispatch_SimpleFormationData_destroySimpleFormationData in Formations, line 127")
set EM=EM-1
set KzE=null
set K1E=null
endfunction
function K7E takes integer K8E,string K9E returns nothing
set ZM[EM]=K9E
set EM=EM+1
if Lg[K8E]==0 then
if K8E==0 then
call Cdv("Nullpointer exception when calling SimpleFormationData.issueOrders","when calling error in Formations, line 105")
else
call Cdv("Called SimpleFormationData.issueOrders on invalid object.","when calling error in Formations, line 105")
endif
endif
call KtE(K8E,"when calling issueOrders in Formations, line 105")
set EM=EM-1
endfunction
function lvE takes integer leE,string lxE returns nothing
set ZM[EM]=lxE
set EM=EM+1
call K7E(OZ[leE],"when calling issueOrders in Formations, line 103")
set EM=EM-1
endfunction
function loE takes integer lrE,string liE returns nothing
set ZM[EM]=liE
set EM=EM+1
call kzE(bX[lrE],"when calling dispatch_LegacySaveData_destroyLegacySaveData in SotfrpGuiRegions, line 192")
set EM=EM-1
endfunction
function laE takes integer sSt returns nothing
endfunction
function lnE takes integer FYs returns nothing
endfunction
function lVE takes integer lEE,string lXE returns nothing
set ZM[EM]=lXE
set EM=EM+1
call lnE(lEE)
call BQa("when calling new_HashSet in CustomUnitTypes, line 105")
call BQa("when calling new_HashSet in CustomUnitTypes, line 106")
call BQa("when calling new_HashSet in CustomUnitTypes, line 107")
call tLe(lEE,"when calling reset in CustomUnitTypes, line 108")
set EM=EM-1
endfunction
function lOE takes string lRE returns integer
local integer lIE
set ZM[EM]=lRE
set EM=EM+1
if Tg==0 then
if Yg<$8000 then
set Yg=Yg+1
set lIE=Yg
set Gg[lIE]=$6D2
else
call Cdv("Out of memory: Could not create CustomUnitType.","when calling error in CustomUnitTypes, line 73")
set lIE=0
endif
else
set Tg=Tg-1
set lIE=Rg[Tg]
set Gg[lIE]=$6D2
endif
set EM=EM-1
return lIE
endfunction
function lAE takes string lNE returns integer
local integer lbE
set ZM[EM]=lNE
set EM=EM+1
set lbE=lOE("when calling alloc_CustomUnitType in CustomUnitTypes, line 104")
call lVE(lbE,"when calling construct_CustomUnitType in CustomUnitTypes, line 104")
set EM=EM-1
return lbE
endfunction
function lBE takes integer lcE,player lCE,string ldE returns nothing
local integer lDE
local integer lfE
set ZM[EM]=ldE
set EM=EM+1
call NQx(lcE,lCE)
call laE(lcE)
set yH[lcE]=Mq*Hme(lCE)
set lDE=yH[lcE]
set lfE=yH[lcE]+Mq-1
loop
exitwhen lDE>lfE
set wa[lDE]=lAE("when calling new_CustomUnitType in PlayerDefinedUnitTypes, line 21")
set lDE=lDE+1
endloop
set EM=EM-1
endfunction
function lFE takes string lgE returns integer
local integer lGE
set ZM[EM]=lgE
set EM=EM+1
if Tg==0 then
if Yg<$8000 then
set Yg=Yg+1
set lGE=Yg
set Gg[lGE]=$6D5
else
call Cdv("Out of memory: Could not create PlayerDefinedUnitTypes.","when calling error in PlayerDefinedUnitTypes, line 9")
set lGE=0
endif
else
set Tg=Tg-1
set lGE=Rg[Tg]
set Gg[lGE]=$6D5
endif
set EM=EM-1
return lGE
endfunction
function lhE takes player lHE,string ljE returns integer
local integer lJE
set ZM[EM]=ljE
set EM=EM+1
set lJE=lFE("when calling alloc_PlayerDefinedUnitTypes in PlayerDefinedUnitTypes, line 17")
call lBE(lJE,lHE,"when calling construct_PlayerDefinedUnitTypes in PlayerDefinedUnitTypes, line 17")
set EM=EM-1
return lJE
endfunction
function lkE takes string lKE returns integer
local integer llE
set ZM[EM]=lKE
set EM=EM+1
if Tk==0 then
if Yk<$8000 then
set Yk=Yk+1
set llE=Yk
set Gk[llE]=$FE1
else
call Cdv("Out of memory: Could not create PersistableLoadCallback_load_doAfter_PlayerDefinedUnitTypes.","when calling error in PlayerDefinedUnitTypes, line 91")
set llE=0
endif
else
set Tk=Tk-1
set llE=Rk[Tk]
set Gk[llE]=$FE1
endif
set EM=EM-1
return llE
endfunction
function lLE takes integer bit,string lmE returns nothing
local integer lME
local integer lpE
local integer lPE
local integer lqE
local integer lQE
set ZM[EM]=lmE
set EM=EM+1
set lME=0
set lpE=bj_MAX_PLAYERS-1
loop
exitwhen lME>lpE
set lqE=lhE(sa[lME],"when calling new_PlayerDefinedUnitTypes in PlayerDefinedUnitTypes, line 91")
set lQE=lqE
set lPE=lkE("when calling alloc_PersistableLoadCallback_load_doAfter_PlayerDefinedUnitTypes in PlayerDefinedUnitTypes, line 91")
set bH[lPE]=lME
call YFx(lQE,lPE,"when calling load in PlayerDefinedUnitTypes, line 91")
set Vq[lME]=lqE
set lME=lME+1
endloop
set EM=EM-1
endfunction
function lsE takes integer GRs returns nothing
set pp=pp+50
endfunction
function lSE takes group ltE,integer lTE,string luE returns nothing
local unit lUE
local group lwE
set ZM[EM]=luE
set EM=EM+1
set lwE=ltE
loop
exitwhen not F9e(lwE)
set lUE=F6e(lwE)
call rWV(lTE,lUE,"when calling callback in ClosureForGroups, line 40")
endloop
call J2e(lTE,"when calling dispatch_ForGroupCallback_destroyForGroupCallback in ClosureForGroups, line 41")
set EM=EM-1
set lUE=null
set lwE=null
endfunction
function lWE takes string lyE returns integer
local integer lYE
set ZM[EM]=lyE
set EM=EM+1
if ug==0 then
if rg<$8000 then
set rg=rg+1
set lYE=rg
set sg[lYE]=$875
else
call Cdv("Out of memory: Could not create ForGroupCallback_forEachFrom_Preloader.","when calling error in Preloader, line 46")
set lYE=0
endif
else
set ug=ug-1
set lYE=wg[ug]
set sg[lYE]=$875
endif
set EM=EM-1
return lYE
endfunction
function lzE takes string lZE returns nothing
local integer l_E
local group l0E
set ZM[EM]=lZE
set EM=EM+1
call PFv(Ga)
set l0E=Ya
set l_E=lWE("when calling alloc_ForGroupCallback_forEachFrom_Preloader in Preloader, line 46")
call lSE(l0E,l_E,"when calling forEachFrom in Preloader, line 46")
call kcv(Ya)
set Ya=null
set EM=EM-1
set l0E=null
endfunction
function l1E takes integer YSt,string l2E returns nothing
set ZM[EM]=l2E
set EM=EM+1
call lzE("when calling finishPreload in Preloader, line 55")
set EM=EM-1
endfunction
function l3E takes real l4E returns real
return Cos(l4E)
endfunction
function l5E takes real l6E returns real
return Sin(l6E)
endfunction
function l7E takes real l8E,real l9E,real LvE returns real
local real LeE=l3E(LvE)
local real LxE=l5E(LvE)
local real LoE=l8E*LeE-l9E*LxE
local real LrE=l8E*LxE+l9E*LeE
set T9=LoE
set Y9=LrE
return T9
endfunction
function LiE takes real LaE,real LnE returns real
return SquareRoot(LaE*LaE+LnE*LnE)
endfunction
function LVE takes real LEE,real LXE returns real
local real LOE=LiE(LEE,LXE)
local real LRE=.0
local real LIE=.0
if LOE>.0 then
set LRE=LEE/LOE
set LIE=LXE/LOE
endif
set f9=LRE
set R9=LIE
return f9
endfunction
function LAE takes integer LNE,integer LbE,integer LBE,real LcE,real LCE,real LdE,real LDE returns real
local real LfE=LVE(DRv(LdE,LDE,LcE,LCE),d9)
local real LFE=R9
local real LgE=LfE
local real LGE=LFE
local real LhE=l7E(LgE,LGE,vde(90.))
local real LHE=Y9
local real LjE=LhE
local real LJE=LHE
local real LkE=LdE
local real LKE=LDE
local real LlE=LkE
local real LLE=LKE
local integer LmE=ModuloInteger(LbE,wZ[LNE])
local real LME=.0
local real LpE
local real LPE
local real LqE
local real LQE
local real LsE
local real LSE
if LmE==0 then
set LME=DQv(LBE/wZ[LNE])
elseif LBE>=LmE then
set LME=DQv((LBE-LmE)/wZ[LNE]+1)
endif
set LpE=.0
if LmE!=0 and LME==.0 and LmE!=wZ[LNE]then
set LPE=(wZ[LNE]-1)*1./LmE
set LpE=LpE+LPE/2.+LPE*LBE
else
set LpE=DQv(ModuloInteger(LBE-LmE,wZ[LNE]))
endif
set LqE=DRv(LlE,LLE,HVE(HVE(LgE,LGE,LME),b1,uZ[LNE]),b1)
set LQE=d9
set LlE=LqE
set LLE=LQE
set LsE=I_e(LlE,LLE,DRv(HVE(HVE(LjE,LJE,LpE),b1,rZ[LNE]),b1,HVE(HVE(LjE,LJE,(wZ[LNE]-1)*1./2),b1,rZ[LNE]),b1),d9)
set LSE=O1
set LlE=LsE
set LLE=LSE
set h9=LlE
set F9=LLE
return h9
endfunction
function LtE takes integer LTE,integer LuE,integer LUE,real LwE,real LWE,real LyE,real LYE,string LzE returns real
local real LZE
local real L_E
local real L0E
local real L1E
set ZM[EM]=LzE
set EM=EM+1
if Jg[LTE]==0 then
if LTE==0 then
call Cdv("Nullpointer exception when calling FormationSettings.getPos","when calling error in Formations, line 26")
else
call Cdv("Called FormationSettings.getPos on invalid object.","when calling error in Formations, line 26")
endif
endif
set L0E=LAE(LTE,LuE,LUE,LwE,LWE,LyE,LYE)
set L1E=F9
set LZE=L0E
set L_E=L1E
set EM=EM-1
set k9=LZE
set j9=L_E
return k9
endfunction
function L2E takes integer L3E,string L4E returns nothing
set ZM[EM]=L4E
set EM=EM+1
call x5n(lZ[L3E],Wq,LtE(bZ[L3E],yZ[L3E],pZ[L3E],SZ[eZ[L3E]],cZ[eZ[L3E]],qZ[L3E],aZ[L3E],"when calling getPos in Formations, line 124"),j9)
set EM=EM-1
endfunction
function L5E takes string Xus returns nothing
endfunction
function L6E takes integer L7E,integer L8E returns nothing
if L7E!=L8E then
call L5E("Expected <"+SMv(L8E)+">, Actual <"+SMv(L7E)+">")
endif
endfunction
function L9E takes integer kRs returns nothing
set pp=pp/2
call L6E(pp,$FA)
endfunction
function mvE takes integer meE,string mxE returns nothing
local integer moE
local integer mrE
local integer miE
local boolean maE
local integer mnE
local integer mVE
local integer mEE
set ZM[EM]=mxE
set EM=EM+1
set moE=jdv(YJ[meE],"when calling iterator in ScmdCoreBuiltins, line 336")
loop
exitwhen not Jgv(moE,"when calling hasNext in ScmdCoreBuiltins, line 336")
set mrE=jTv(moE,"when calling next in ScmdCoreBuiltins, line 336")
call xda(8,GJ[meE],mrE,"when calling resolve in ScmdCoreBuiltins, line 337",0,null,0,null)
set miE=RJv
set mEE=ox[m0v(miE,"when calling get in ScmdCoreBuiltins, line 338")]
set maE=mEE>=$EF1 and mEE<=$EF2
call mfv(20,miE,"when calling dispatch_GenericSharedPointer_destroyGenericSharedPointer in ScmdCoreBuiltins, line 339")
if maE then
exitwhen true
endif
endloop
call Jqv(moE,"when calling close in ScmdCoreBuiltins, line 336")
set mnE=jdv(YJ[meE],"when calling iterator in ScmdCoreBuiltins, line 342")
loop
exitwhen not Jgv(mnE,"when calling hasNext in ScmdCoreBuiltins, line 342")
set mVE=jTv(mnE,"when calling next in ScmdCoreBuiltins, line 342")
call mfv(20,mVE,"when calling dispatch_GenericSharedPointer_destroyGenericSharedPointer in ScmdCoreBuiltins, line 343")
endloop
call Jqv(mnE,"when calling close in ScmdCoreBuiltins, line 342")
call JEv(YJ[meE],"when calling dispatch_HashList_destroyHashList in ScmdCoreBuiltins, line 344")
call mfv(4,GJ[meE],"when calling dispatch_Context_destroyContext in ScmdCoreBuiltins, line 345")
set EM=EM-1
endfunction
function mXE takes integer pwt returns nothing
local trigger mOE=CreateTrigger()
local group mRE
local group mIE
call YHo(mOE,Ee,Filter(RBv))
call qQa(EVENT_PLAYER_UNIT_ISSUED_ORDER,Rcv)
call OTE(Fq,We)
call ForGroup(Fq,RCv)
set mRE=Fq
call J5e(mRE)
set mIE=mRE
call kcv(mIE)
set mOE=null
set mRE=null
set mIE=null
endfunction
function mAE takes integer mNE returns nothing
local group mbE=rL[mNE]
local unit mBE
loop
exitwhen not F9e(mbE)
set mBE=F6e(mbE)
call IBe(mBE,aae(mBE)-sL[mNE])
endloop
set mBE=null
set mbE=null
endfunction
function mcE takes integer mCE,string mdE returns nothing
set ZM[EM]=mdE
set EM=EM+1
if vG[mCE]==0 then
if mCE==0 then
call Cdv("Nullpointer exception when calling CallbackSingle.call","when calling error in ClosureTimers, line 109")
else
call Cdv("Called CallbackSingle.call on invalid object.","when calling error in ClosureTimers, line 109")
endif
endif
if vG[mCE]<=$473 then
if vG[mCE]<=$46E then
if vG[mCE]<=$46C then
if vG[mCE]<=$46B then
if vG[mCE]<=$46A then
call lsE(mCE)
else
call JuE(mCE)
endif
else
call L9E(mCE)
endif
elseif vG[mCE]<=$46D then
call J6E(mCE,"when calling call_doAfter_DummyCaster_DummyCaster in ClosureTimers, line 109")
else
call lLE(mCE,"when calling call_doAfter_PlayerDefinedUnitTypes in ClosureTimers, line 109")
endif
elseif vG[mCE]<=$471 then
if vG[mCE]<=$470 then
if vG[mCE]<=$46F then
call mvE(mCE,"when calling call_doAfter_setArgumentsTypes_setVariadicArgumentTypes_registerProtectedBuiltin_ScmdCoreBuiltins in ClosureTimers, line 109")
else
call k6E(mCE)
endif
else
call mXE(mCE)
endif
elseif vG[mCE]<=$472 then
call l1E(mCE,"when calling call_nullTimer_Preloader in ClosureTimers, line 109")
else
call JqE(mCE,"when calling call_nullTimer_SLangChatSystem in ClosureTimers, line 109")
endif
elseif vG[mCE]<=$478 then
if vG[mCE]<=$476 then
if vG[mCE]<=$475 then
if vG[mCE]<=$474 then
call lvE(mCE,"when calling call_nullTimer_SimpleFormationData_Formations in ClosureTimers, line 109")
else
call L2E(mCE,"when calling call_nullTimer_SimpleFormationData_Formations in ClosureTimers, line 109")
endif
else
call JSE(mCE,"when calling call_nullTimer_SotFRP_LegacyLoad in ClosureTimers, line 109")
endif
elseif vG[mCE]<=$477 then
call JUE(mCE,"when calling call_nullTimer_SotFRP_Locale in ClosureTimers, line 109")
else
call mAE(mCE)
endif
elseif vG[mCE]<=$47A then
if vG[mCE]<=$479 then
call jAE(mCE,"when calling call_nullTimer_load_setArgumentsTypes_registerProtectedBuiltin_SotfrpGuiRegions in ClosureTimers, line 109")
else
call k0E(mCE,"when calling call_nullTimer_load_setArgumentsTypes_registerProtectedBuiltin_SotfrpGuiRegions in ClosureTimers, line 109")
endif
elseif vG[mCE]<=$47B then
call k3E(mCE,"when calling call_nullTimer_paste_load_setArgumentsTypes_registerProtectedBuiltin_SotfrpGuiRegions in ClosureTimers, line 109")
else
call loE(mCE,"when calling call_nullTimer_paste_load_setArgumentsTypes_registerProtectedBuiltin_SotfrpGuiRegions in ClosureTimers, line 109")
endif
set EM=EM-1
endfunction
function mDE takes integer mfE,string mFE returns nothing
set ZM[EM]=mFE
set EM=EM+1
if vG[mfE]==0 then
call Cdv("Double free: object of type CallbackSingle","when calling error in ClosureTimers, line 107")
else
set kG[jG]=mfE
set jG=jG+1
set vG[mfE]=0
endif
set EM=EM-1
endfunction
function mgE takes integer mGE,string mhE returns nothing
set ZM[EM]=mhE
set EM=EM+1
call atn(WW[mGE],"when calling release in ClosureTimers, line 124")
set EM=EM-1
endfunction
function mHE takes integer mjE,string mJE returns nothing
set ZM[EM]=mJE
set EM=EM+1
call mgE(mjE,"when calling CallbackSingle_onDestroy in ClosureTimers, line 123")
call mDE(mjE,"when calling dealloc_CallbackSingle in ClosureTimers, line 123")
set EM=EM-1
endfunction
function mkE takes integer mKE,string mlE returns nothing
set ZM[EM]=mlE
set EM=EM+1
if vG[mKE]==0 then
if mKE==0 then
call Cdv("Nullpointer exception when calling CallbackSingle.CallbackSingle","when calling error in ClosureTimers, line 107")
else
call Cdv("Called CallbackSingle.CallbackSingle on invalid object.","when calling error in ClosureTimers, line 107")
endif
endif
call mHE(mKE,"when calling destroyCallbackSingle in ClosureTimers, line 107")
set EM=EM-1
endfunction
function mLE takes string mmE returns nothing
local timer mME
local integer mpE
set ZM[EM]=mmE
set EM=EM+1
set mME=GetExpiredTimer()
set mpE=aqn(mME,"when calling getData in ClosureTimers, line 119")
call mcE(mpE,"when calling call in ClosureTimers, line 120")
call mkE(mpE,"when calling dispatch_CallbackSingle_destroyCallbackSingle in ClosureTimers, line 121")
set EM=EM-1
set mME=null
endfunction
function mPE takes string mqE returns nothing
set ZM[EM]=mqE
set EM=EM+1
call mLE("when calling staticCallback in ClosureTimers, line 114")
set EM=EM-1
endfunction
function mQE takes nothing returns nothing
set EM=0
call mPE("ClosureTimers, line 114")
endfunction
function msE takes nothing returns nothing
if GetEventDamage()==.0 then
return
endif
set wl=GetEventDamage()
call ForGroup(LoadGroupHandle(i,BO,GetHandleId(GetEventDamageSource())),Kz)
endfunction
function mSE takes nothing returns nothing
set G=GetUnitLoc(GetEnumUnit())
call CreateDestructableLoc('DTrf',G,270.,1.,0)
call RemoveLocation(G)
endfunction
function mtE takes string mTE returns integer
local integer muE
set ZM[EM]=mTE
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set muE=Yj
set Gj[muE]=$B0F
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdSystemsSettingsBuiltins.","when calling error in ScmdSystemsSettingsBuiltins, line 12")
set muE=0
endif
else
set Tj=Tj-1
set muE=Rj[Tj]
set Gj[muE]=$B0F
endif
set EM=EM-1
return muE
endfunction
function mUE takes string mwE returns integer
local integer mWE
set ZM[EM]=mwE
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set mWE=Yj
set Gj[mWE]=$B10
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdSystemsSettingsBuiltins.","when calling error in ScmdSystemsSettingsBuiltins, line 16")
set mWE=0
endif
else
set Tj=Tj-1
set mWE=Rj[Tj]
set Gj[mWE]=$B10
endif
set EM=EM-1
return mWE
endfunction
function myE takes string mYE returns integer
local integer mzE
set ZM[EM]=mYE
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set mzE=Yj
set Gj[mzE]=$B0E
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdSystemsSettingsBuiltins.","when calling error in ScmdSystemsSettingsBuiltins, line 8")
set mzE=0
endif
else
set Tj=Tj-1
set mzE=Rj[Tj]
set Gj[mzE]=$B0E
endif
set EM=EM-1
return mzE
endfunction
function mZE takes string m_E returns boolean
local integer m0E
local integer m1E
local integer m2E
local integer m3E
local integer m4E
local integer m5E
set ZM[EM]=m_E
set EM=EM+1
set m0E=myE("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdSystemsSettingsBuiltins in ScmdSystemsSettingsBuiltins, line 8")
set m1E=OPo(m0E,"when calling new_BuiltinData in ScmdSystemsSettingsBuiltins, line 8")
call Rxo(m1E,f3a(),"when calling setArgumentsTypes in ScmdSystemsSettingsBuiltins, line 11")
call Foa(ILo(m1E,"when calling new_BuiltinFunction in ScmdSystemsSettingsBuiltins, line 8"),"setformationwidth","when calling registerProtectedBuiltin in ScmdSystemsSettingsBuiltins, line 8")
set m2E=mtE("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdSystemsSettingsBuiltins in ScmdSystemsSettingsBuiltins, line 12")
set m3E=OPo(m2E,"when calling new_BuiltinData in ScmdSystemsSettingsBuiltins, line 12")
call Rxo(m3E,gQV(),"when calling setArgumentsTypes in ScmdSystemsSettingsBuiltins, line 15")
call Foa(ILo(m3E,"when calling new_BuiltinFunction in ScmdSystemsSettingsBuiltins, line 12"),"setformationvspacing","when calling registerProtectedBuiltin in ScmdSystemsSettingsBuiltins, line 12")
set m4E=mUE("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdSystemsSettingsBuiltins in ScmdSystemsSettingsBuiltins, line 16")
set m5E=OPo(m4E,"when calling new_BuiltinData in ScmdSystemsSettingsBuiltins, line 16")
call Rxo(m5E,gQV(),"when calling setArgumentsTypes in ScmdSystemsSettingsBuiltins, line 19")
call Foa(ILo(m5E,"when calling new_BuiltinFunction in ScmdSystemsSettingsBuiltins, line 16"),"setformationhspacing","when calling registerProtectedBuiltin in ScmdSystemsSettingsBuiltins, line 16")
set EM=EM-1
return true
endfunction
function m6E takes nothing returns boolean
set EM=0
return mZE("ScmdSystemsSettingsBuiltins, line 1")
endfunction
function m7E takes nothing returns boolean
return GetBooleanAnd(IsUnitAliveBJ(GetFilterUnit()),IsUnitEnemy(GetFilterUnit(),GetOwningPlayer(Nu)))
endfunction
function m8E takes nothing returns boolean
return(GetSpellAbilityId()=='A07W')
endfunction
function m9E takes nothing returns boolean
return(GetSpellAbilityId()=='A0DT')
endfunction
function MvE takes nothing returns boolean
return(GetUnitTypeId(GetDyingUnit())=='o023')
endfunction
function MeE takes nothing returns boolean
return not(IsPlayerEnemy(GetOwningPlayer(GetFilterUnit()),GetOwningPlayer(GetSpellAbilityUnit()))==false)
endfunction
function MxE takes nothing returns nothing
call DestroyEffect(AddSpecialEffectTarget("Abilities\\Spells\\Items\\AIhe\\AIheTarget.mdl",GetEnumUnit(),"origin"))
call SetUnitState(GetEnumUnit(),UNIT_STATE_LIFE,GetUnitState(GetEnumUnit(),UNIT_STATE_LIFE)+425.)
endfunction
function MoE takes nothing returns boolean
return(GetDestructableMaxLife(GetEnumDestructable())==2501.)
endfunction
function MrE takes nothing returns nothing
if MoE()then
call ModifyGateBJ(bj_GATEOPERATION_CLOSE,GetEnumDestructable())
endif
endfunction
function MiE takes nothing returns boolean
local integer MaE=0
local integer MnE=GetDestructableTypeId(GetSpellTargetDestructable())
loop
if MnE==Nr[MaE]then
set MaE=0
set MnE=0
return true
endif
set MaE=MaE+1
exitwhen MaE==Mr
endloop
set MaE=0
set MnE=0
return false
endfunction
function MVE takes nothing returns nothing
if MiE()then
if kw[GetPlayerId(GetTriggerPlayer())]!=null then
set Fw[ts]=kw[GetPlayerId(GetTriggerPlayer())]
set hw[ts]=GetSpellTargetDestructable()
call TriggerRegisterDeathEvent(nS,Fw[ts])
set ts=ts+1
endif
call RemoveUnit(ss[GetPlayerId(GetTriggerPlayer())])
set ss[GetPlayerId(GetTriggerPlayer())]=CreateUnitAtLoc(GetTriggerPlayer(),'h0Q7',GetUnitLoc(GetSpellAbilityUnit()),270.)
else
call zZV(GetOwningPlayer(GetSpellAbilityUnit()),"",true,false)
endif
endfunction
function MEE takes nothing returns nothing
local unit MXE=GetOrderedUnit()
call SetUnitPositionLoc(MXE,GetOrderPointLoc())
call TriggerSleepAction(.01)
call IssueImmediateOrderById(MXE,$D0004)
set MXE=null
set MXE=null
endfunction
function MOE takes nothing returns boolean
return(F[GetConvertedPlayerId(GetTriggerPlayer())])and(SubStringBJ(GetEventPlayerChatString(),1,3)=="max")
endfunction
function MRE takes nothing returns boolean
return(MOE())
endfunction
function MIE takes nothing returns boolean
return(GetUnitTypeId(GetEnumUnit())!='h000')and(GetUnitTypeId(GetEnumUnit())!='h0KW')and(IsUnitSelected(GetEnumUnit(),GetTriggerPlayer()))
endfunction
function MAE takes nothing returns nothing
if MIE()then
call UnitRemoveTypeBJ(UNIT_TYPE_PEON,GetEnumUnit())
endif
endfunction
function MNE takes nothing returns boolean
local integer MbE=sy
local integer MBE=uy
call LoadInteger(i,Kl[MbE],MBE)
return true
endfunction
function McE takes integer MCE,string MdE returns nothing
set ZM[EM]=MdE
set EM=EM+1
if Lv[MCE]==0 then
call Cdv("Double free: object of type UnitIndex","when calling error in UnitIndexer, line 172")
else
set Hv[Jv]=MCE
set Jv=Jv+1
set Lv[MCE]=0
endif
set EM=EM-1
endfunction
function MDE takes integer MfE returns nothing
call jlV(GB[MfE])
call isV(gT)
call jMV()
call jpV(GB[MfE],0)
endfunction
function MFE takes integer MgE,string MGE returns nothing
set ZM[EM]=MGE
set EM=EM+1
call MDE(MgE)
call McE(MgE,"when calling dealloc_UnitIndex in UnitIndexer, line 188")
set EM=EM-1
endfunction
function MhE takes integer MHE,string MjE returns nothing
set ZM[EM]=MjE
set EM=EM+1
if Lv[MHE]==0 then
if MHE==0 then
call Cdv("Nullpointer exception when calling UnitIndex.UnitIndex","when calling error in UnitIndexer, line 172")
else
call Cdv("Called UnitIndex.UnitIndex on invalid object.","when calling error in UnitIndexer, line 172")
endif
endif
call MFE(MHE,"when calling destroyUnitIndex in UnitIndexer, line 172")
set EM=EM-1
endfunction
function MJE takes unit MkE,string MKE returns boolean
set ZM[EM]=MKE
set EM=EM+1
if UGx(MkE)==0 then
set EM=EM-1
return false
else
call MhE(jYV(MkE,"when calling toUnitIndex in UnitIndexer, line 169"),"when calling dispatch_UnitIndex_destroyUnitIndex in UnitIndexer, line 169")
set EM=EM-1
return true
endif
endfunction
function MlE takes string MLE returns nothing
set ZM[EM]=MLE
set EM=EM+1
if jKV(vTV())then
call MJE(vTV(),"when calling deindex in UnitIndexer, line 197")
endif
set EM=EM-1
endfunction
function MmE takes nothing returns nothing
set EM=0
call MlE("UnitIndexer, line 197")
endfunction
function MME takes string MpE returns integer
local integer MPE
set ZM[EM]=MpE
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set MPE=Yj
set Gj[MPE]=$AC5
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_SLangSpecialEffectFunctions.","when calling error in SLangSpecialEffectFunctions, line 51")
set MPE=0
endif
else
set Tj=Tj-1
set MPE=Rj[Tj]
set Gj[MPE]=$AC5
endif
set EM=EM-1
return MPE
endfunction
function MqE takes string MQE returns integer
local integer MsE
set ZM[EM]=MQE
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set MsE=Yj
set Gj[MsE]=$AC3
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_SLangSpecialEffectFunctions.","when calling error in SLangSpecialEffectFunctions, line 43")
set MsE=0
endif
else
set Tj=Tj-1
set MsE=Rj[Tj]
set Gj[MsE]=$AC3
endif
set EM=EM-1
return MsE
endfunction
function MSE takes string MtE returns integer
local integer MTE
set ZM[EM]=MtE
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set MTE=Yj
set Gj[MTE]=$AC1
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_SLangSpecialEffectFunctions.","when calling error in SLangSpecialEffectFunctions, line 35")
set MTE=0
endif
else
set Tj=Tj-1
set MTE=Rj[Tj]
set Gj[MTE]=$AC1
endif
set EM=EM-1
return MTE
endfunction
function MuE takes string MUE returns integer
local integer MwE
set ZM[EM]=MUE
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set MwE=Yj
set Gj[MwE]=$AC2
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_SLangSpecialEffectFunctions.","when calling error in SLangSpecialEffectFunctions, line 39")
set MwE=0
endif
else
set Tj=Tj-1
set MwE=Rj[Tj]
set Gj[MwE]=$AC2
endif
set EM=EM-1
return MwE
endfunction
function MWE takes string MyE returns integer
local integer MYE
set ZM[EM]=MyE
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set MYE=Yj
set Gj[MYE]=$AC4
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_SLangSpecialEffectFunctions.","when calling error in SLangSpecialEffectFunctions, line 47")
set MYE=0
endif
else
set Tj=Tj-1
set MYE=Rj[Tj]
set Gj[MYE]=$AC4
endif
set EM=EM-1
return MYE
endfunction
function MzE takes string MZE returns integer
local integer M_E
set ZM[EM]=MZE
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set M_E=Yj
set Gj[M_E]=$AC6
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_SLangSpecialEffectFunctions.","when calling error in SLangSpecialEffectFunctions, line 55")
set M_E=0
endif
else
set Tj=Tj-1
set M_E=Rj[Tj]
set Gj[M_E]=$AC6
endif
set EM=EM-1
return M_E
endfunction
function M0E takes nothing returns integer
return Sd
endfunction
function M1E takes string M2E returns integer
local integer M3E
set ZM[EM]=M2E
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set M3E=Yj
set Gj[M3E]=$ABD
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_SLangSpecialEffectFunctions.","when calling error in SLangSpecialEffectFunctions, line 18")
set M3E=0
endif
else
set Tj=Tj-1
set M3E=Rj[Tj]
set Gj[M3E]=$ABD
endif
set EM=EM-1
return M3E
endfunction
function M4E takes string M5E returns integer
local integer M6E
set ZM[EM]=M5E
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set M6E=Yj
set Gj[M6E]=$A37
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_SLangSpecialEffectFunctions.","when calling error in SLangSpecialEffectFunctions, line 11")
set M6E=0
endif
else
set Tj=Tj-1
set M6E=Rj[Tj]
set Gj[M6E]=$A37
endif
set EM=EM-1
return M6E
endfunction
function M7E takes string M8E returns integer
local integer M9E
set ZM[EM]=M8E
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set M9E=Yj
set Gj[M9E]=$ABC
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_SLangSpecialEffectFunctions.","when calling error in SLangSpecialEffectFunctions, line 14")
set M9E=0
endif
else
set Tj=Tj-1
set M9E=Rj[Tj]
set Gj[M9E]=$ABC
endif
set EM=EM-1
return M9E
endfunction
function pvE takes string peE returns integer
local integer pxE
set ZM[EM]=peE
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set pxE=Yj
set Gj[pxE]=$ABE
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_SLangSpecialEffectFunctions.","when calling error in SLangSpecialEffectFunctions, line 22")
set pxE=0
endif
else
set Tj=Tj-1
set pxE=Rj[Tj]
set Gj[pxE]=$ABE
endif
set EM=EM-1
return pxE
endfunction
function poE takes string prE returns integer
local integer piE
set ZM[EM]=prE
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set piE=Yj
set Gj[piE]=$ABF
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_SLangSpecialEffectFunctions.","when calling error in SLangSpecialEffectFunctions, line 26")
set piE=0
endif
else
set Tj=Tj-1
set piE=Rj[Tj]
set Gj[piE]=$ABF
endif
set EM=EM-1
return piE
endfunction
function paE takes string pnE returns integer
local integer pVE
set ZM[EM]=pnE
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set pVE=Yj
set Gj[pVE]=$ABB
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_SLangSpecialEffectFunctions.","when calling error in SLangSpecialEffectFunctions, line 6")
set pVE=0
endif
else
set Tj=Tj-1
set pVE=Rj[Tj]
set Gj[pVE]=$ABB
endif
set EM=EM-1
return pVE
endfunction
function pEE takes string pXE returns integer
local integer pOE
set ZM[EM]=pXE
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set pOE=Yj
set Gj[pOE]=$AC0
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_SLangSpecialEffectFunctions.","when calling error in SLangSpecialEffectFunctions, line 31")
set pOE=0
endif
else
set Tj=Tj-1
set pOE=Rj[Tj]
set Gj[pOE]=$AC0
endif
set EM=EM-1
return pOE
endfunction
function pRE takes string pIE returns integer
local integer pAE
set ZM[EM]=pIE
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set pAE=Yj
set Gj[pAE]=$B2A
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_SLangSpecialEffectFunctions.","when calling error in SLangSpecialEffectFunctions, line 9")
set pAE=0
endif
else
set Tj=Tj-1
set pAE=Rj[Tj]
set Gj[pAE]=$B2A
endif
set EM=EM-1
return pAE
endfunction
function pNE takes string pbE returns boolean
local integer pBE
local integer pcE
local integer pCE
local integer pdE
local integer pDE
local integer pfE
local integer pFE
local integer pgE
local integer pGE
local integer phE
local integer pHE
local integer pjE
local integer pJE
local integer pkE
local integer pKE
local integer plE
local integer pLE
local integer pmE
local integer pME
local integer ppE
local integer pPE
local integer pqE
local integer pQE
local integer psE
local integer pSE
local integer ptE
local integer pTE
local integer puE
local integer pUE
local integer pwE
local integer pWE
set ZM[EM]=pbE
set EM=EM+1
set pBE=paE("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_SLangSpecialEffectFunctions in SLangSpecialEffectFunctions, line 6")
set pcE=OPo(pBE,"when calling new_BuiltinData in SLangSpecialEffectFunctions, line 6")
call etV(pcE,OFo(),gQV(),gQV(),"when calling setArgumentsTypes in SLangSpecialEffectFunctions, line 8")
call Foa(ILo(pcE,"when calling new_BuiltinFunction in SLangSpecialEffectFunctions, line 6"),"addspecialeffect","when calling registerProtectedBuiltin in SLangSpecialEffectFunctions, line 6")
set pCE=pRE("when calling alloc_IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_SLangSpecialEffectFunctions in SLangSpecialEffectFunctions, line 9")
set pdE=OPo(pCE,"when calling new_BuiltinData in SLangSpecialEffectFunctions, line 9")
call FRa(pdE,OFo(),OFo(),"when calling setArgumentsTypes in SLangSpecialEffectFunctions, line 11")
set pDE=pdE
call LWV(pDE,"when calling setRequiringEnumUnit in SLangSpecialEffectFunctions, line 11")
set pgE=ILo(pDE,"when calling new_BuiltinFunction in SLangSpecialEffectFunctions, line 9")
set pWE=pgE
set pfE=M4E("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_SLangSpecialEffectFunctions in SLangSpecialEffectFunctions, line 11")
set pFE=OPo(pfE,"when calling new_BuiltinData in SLangSpecialEffectFunctions, line 11")
call etV(pFE,eJV(),OFo(),OFo(),"when calling setArgumentsTypes in SLangSpecialEffectFunctions, line 13")
call IFo(pWE,pFE,"when calling addOverload in SLangSpecialEffectFunctions, line 11")
call Foa(pgE,"addspecialeffecttarget","when calling registerProtectedBuiltin in SLangSpecialEffectFunctions, line 9")
set pGE=M7E("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_SLangSpecialEffectFunctions in SLangSpecialEffectFunctions, line 14")
set phE=OPo(pGE,"when calling new_BuiltinData in SLangSpecialEffectFunctions, line 14")
call mKV(phE,M0E(),f3a(),f3a(),f3a(),f3a(),"when calling setArgumentsTypes in SLangSpecialEffectFunctions, line 17")
call Foa(ILo(phE,"when calling new_BuiltinFunction in SLangSpecialEffectFunctions, line 14"),"setspecialeffectvertexcolor","when calling registerProtectedBuiltin in SLangSpecialEffectFunctions, line 14")
set pHE=M1E("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_SLangSpecialEffectFunctions in SLangSpecialEffectFunctions, line 18")
set pjE=OPo(pHE,"when calling new_BuiltinData in SLangSpecialEffectFunctions, line 18")
call FRa(pjE,M0E(),gQV(),"when calling setArgumentsTypes in SLangSpecialEffectFunctions, line 21")
call Foa(ILo(pjE,"when calling new_BuiltinFunction in SLangSpecialEffectFunctions, line 18"),"setspecialeffectx","when calling registerProtectedBuiltin in SLangSpecialEffectFunctions, line 18")
set pJE=pvE("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_SLangSpecialEffectFunctions in SLangSpecialEffectFunctions, line 22")
set pkE=OPo(pJE,"when calling new_BuiltinData in SLangSpecialEffectFunctions, line 22")
call FRa(pkE,M0E(),gQV(),"when calling setArgumentsTypes in SLangSpecialEffectFunctions, line 25")
call Foa(ILo(pkE,"when calling new_BuiltinFunction in SLangSpecialEffectFunctions, line 22"),"setspecialeffecty","when calling registerProtectedBuiltin in SLangSpecialEffectFunctions, line 22")
set pKE=poE("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_SLangSpecialEffectFunctions in SLangSpecialEffectFunctions, line 26")
set plE=OPo(pKE,"when calling new_BuiltinData in SLangSpecialEffectFunctions, line 26")
call FRa(plE,M0E(),gQV(),"when calling setArgumentsTypes in SLangSpecialEffectFunctions, line 30")
call Foa(ILo(plE,"when calling new_BuiltinFunction in SLangSpecialEffectFunctions, line 26"),"setspecialeffectz","when calling registerProtectedBuiltin in SLangSpecialEffectFunctions, line 26")
set pLE=pEE("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_SLangSpecialEffectFunctions in SLangSpecialEffectFunctions, line 31")
set pmE=OPo(pLE,"when calling new_BuiltinData in SLangSpecialEffectFunctions, line 31")
call FRa(pmE,M0E(),gQV(),"when calling setArgumentsTypes in SLangSpecialEffectFunctions, line 34")
call Foa(ILo(pmE,"when calling new_BuiltinFunction in SLangSpecialEffectFunctions, line 31"),"setspecialeffectscale","when calling registerProtectedBuiltin in SLangSpecialEffectFunctions, line 31")
set pME=MSE("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_SLangSpecialEffectFunctions in SLangSpecialEffectFunctions, line 35")
set ppE=OPo(pME,"when calling new_BuiltinData in SLangSpecialEffectFunctions, line 35")
call FRa(ppE,M0E(),gQV(),"when calling setArgumentsTypes in SLangSpecialEffectFunctions, line 38")
call Foa(ILo(ppE,"when calling new_BuiltinFunction in SLangSpecialEffectFunctions, line 35"),"setspecialeffectheight","when calling registerProtectedBuiltin in SLangSpecialEffectFunctions, line 35")
set pPE=MuE("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_SLangSpecialEffectFunctions in SLangSpecialEffectFunctions, line 39")
set pqE=OPo(pPE,"when calling new_BuiltinData in SLangSpecialEffectFunctions, line 39")
call FRa(pqE,M0E(),gQV(),"when calling setArgumentsTypes in SLangSpecialEffectFunctions, line 42")
call Foa(ILo(pqE,"when calling new_BuiltinFunction in SLangSpecialEffectFunctions, line 39"),"setspecialeffecttimescale","when calling registerProtectedBuiltin in SLangSpecialEffectFunctions, line 39")
set pQE=MqE("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_SLangSpecialEffectFunctions in SLangSpecialEffectFunctions, line 43")
set psE=OPo(pQE,"when calling new_BuiltinData in SLangSpecialEffectFunctions, line 43")
call FRa(psE,M0E(),gQV(),"when calling setArgumentsTypes in SLangSpecialEffectFunctions, line 46")
call Foa(ILo(psE,"when calling new_BuiltinFunction in SLangSpecialEffectFunctions, line 43"),"setspecialeffecttime","when calling registerProtectedBuiltin in SLangSpecialEffectFunctions, line 43")
set pSE=MWE("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_SLangSpecialEffectFunctions in SLangSpecialEffectFunctions, line 47")
set ptE=OPo(pSE,"when calling new_BuiltinData in SLangSpecialEffectFunctions, line 47")
call FRa(ptE,M0E(),gQV(),"when calling setArgumentsTypes in SLangSpecialEffectFunctions, line 50")
call Foa(ILo(ptE,"when calling new_BuiltinFunction in SLangSpecialEffectFunctions, line 47"),"setspecialeffectyaw","when calling registerProtectedBuiltin in SLangSpecialEffectFunctions, line 47")
set pTE=MME("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_SLangSpecialEffectFunctions in SLangSpecialEffectFunctions, line 51")
set puE=OPo(pTE,"when calling new_BuiltinData in SLangSpecialEffectFunctions, line 51")
call FRa(puE,M0E(),gQV(),"when calling setArgumentsTypes in SLangSpecialEffectFunctions, line 54")
call Foa(ILo(puE,"when calling new_BuiltinFunction in SLangSpecialEffectFunctions, line 51"),"setspecialeffectpitch","when calling registerProtectedBuiltin in SLangSpecialEffectFunctions, line 51")
set pUE=MzE("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_SLangSpecialEffectFunctions in SLangSpecialEffectFunctions, line 55")
set pwE=OPo(pUE,"when calling new_BuiltinData in SLangSpecialEffectFunctions, line 55")
call FRa(pwE,M0E(),gQV(),"when calling setArgumentsTypes in SLangSpecialEffectFunctions, line 58")
call Foa(ILo(pwE,"when calling new_BuiltinFunction in SLangSpecialEffectFunctions, line 55"),"setspecialeffectroll","when calling registerProtectedBuiltin in SLangSpecialEffectFunctions, line 55")
set EM=EM-1
return true
endfunction
function pyE takes nothing returns boolean
set EM=0
return pNE("SLangSpecialEffectFunctions, line 1")
endfunction
function pYE takes integer pzE,string pZE returns nothing
set Ld[Kd]=pzE
set Xd[Kd]=pZE
set Kd=Kd+1
endfunction
function p_E takes nothing returns boolean
set Kd=0
call pYE('AHav',"avatar")
call pYE('ANav',"avatar2")
call pYE('AHbn',"banish")
call pYE('AHbh',"bash")
call pYE('AHbz',"blizzard")
call pYE('AHab',"brillianceaura")
call pYE('AHad',"devotionaura")
call pYE('AHds',"divineshield")
call pYE('AHfs',"flamestrike")
call pYE('AHhb',"holylight")
call pYE('AHmt',"massteleport")
call pYE('AHpx',"phoenix")
call pYE('AHre',"resurrection")
call pYE('AHdr',"siphonmana")
call pYE('AHtb',"stormbolt")
call pYE('AHwe',"summonwaterelemental")
call pYE('AHtc',"thunderclap")
call pYE('AOvd',"bigbadvoodoo")
call pYE('AOww',"bladestorm")
call pYE('AOcl',"chainlightning")
call pYE('AOcr',"criticalstrike")
call pYE('AOeq',"earthquake")
call pYE('AOae',"enduranceaura")
call pYE('AOr2',"enduranceaura2")
call pYE('AOfs',"farsight")
call pYE('AOsf',"feralspirit")
call pYE('AOhw',"healingwave")
call pYE('ANhw',"healingwave2")
call pYE('AOhx',"hex")
call pYE('ANhx',"hex2")
call pYE('AOre',"reincarnation")
call pYE('AOr3',"reincarnation2")
call pYE('AOsw',"serpentward")
call pYE('Arsw',"serpentward2")
call pYE('AOs3',"shockwave")
call pYE('AOs4',"shockwave2")
call pYE('AOls',"voodoospirits")
call pYE('AOws',"warstomp")
call pYE('AOw2',"warstomp2")
call pYE('AOwk',"windwalk")
call pYE('AUan',"animatedead")
call pYE('AUcb',"carrionbeetles")
call pYE('AUcs',"carrionswarm")
call pYE('AUdr',"darkritual")
call pYE('AUdd',"deathanddecay")
call pYE('AUdp',"deathpact")
call pYE('AUfa',"frostarmor")
call pYE('AUfu',"frostarmor2")
call pYE('AUfn',"frostnova")
call pYE('AUim',"impale")
call pYE('AUin',"inferno")
call pYE('AUls',"locustswarm")
call pYE('AUsl',"sleep")
call pYE('AUts',"spikedcarapace")
call pYE('AUau',"unholyaura")
call pYE('AUav',"vampiricaura")
call pYE('AEbl',"blink")
call pYE('AEer',"entanglingroots")
call pYE('AEev',"evasion")
call pYE('AEfk',"fanofknives")
call pYE('AEfn',"forceofnature")
call pYE('AEim',"immolation")
call pYE('AEmb',"manaburn")
call pYE('AEst',"scout")
call pYE('AHfa',"searingarrows")
call pYE('AEsh',"shadowstrike")
call pYE('AEsf',"starfall")
call pYE('AEah',"thornsaura")
call pYE('AEtq',"tranquility")
call pYE('AEar',"trueshotaura")
call pYE('AEsv',"vengeance")
call pYE('ANab',"acidbomb")
call pYE('Aamk',"attributebonus")
call pYE('ANbr',"battleroar")
call pYE('ANba',"blackarrow")
call pYE('A08I',"plaguearrow")
call pYE('ANbf',"breathoffire")
call pYE('ANcf',"breathoffire2")
call pYE('ANch',"charm")
call pYE('ANca',"cleavingattack")
call pYE('ANcs',"clusterrockets")
call pYE('ANc1',"clusterrockets2")
call pYE('ANc2',"clusterrockets3")
call pYE('ANc3',"clusterrockets4")
call pYE('AHca',"coldarrows")
call pYE('ANdc',"darkconversion")
call pYE('SNdc',"darkconversion2")
call pYE('ANdp',"darkportal")
call pYE('SNdd',"deathanddecay2")
call pYE('ANde',"demolish")
call pYE('ANd1',"demolish2")
call pYE('ANd2',"demolish3")
call pYE('ANd3',"demolish4")
call pYE('ANdo',"doom")
call pYE('ANdb',"drunkenbrawler")
call pYE('Acdb',"drunkenbrawler2")
call pYE('ANdh',"drunkenhaze")
call pYE('Acdh',"drunkenhaze2")
call pYE('SNeq',"earthquake2")
call pYE('ACs7',"feralspirit2")
call pYE('ANfd',"fingerofdeath")
call pYE('ANfb',"firebolt")
call pYE('ANfl',"forkedlightning")
call pYE('ANfa',"frostarrows")
call pYE('ANhs',"healingspray")
call pYE('ANht',"howlofterror")
call pYE('ANic',"incinerate")
call pYE('ANia',"incinerate2")
call pYE('ANdr',"lifedrain")
call pYE('ANms',"manashield")
call pYE('ANmo',"monsoon")
call pYE('ANsy',"pocketfactory")
call pYE('ANs1',"pocketfactory2")
call pYE('ANs2',"pocketfactory3")
call pYE('ANs3',"pocketfactory4")
call pYE('AEpa',"poisonarrows")
call pYE('ANrc',"rainofchaos")
call pYE('ANr3',"rainofchaos2")
call pYE('ANrf',"rainoffire")
call pYE('ANr2',"reincarnation3")
call pYE('ANrn',"reincarnation4")
call pYE('ANsi',"silence")
call pYE('ANso',"soulburn")
call pYE('ANsl',"soulpreservation")
call pYE('ACs8',"spiritbeast")
call pYE('ANst',"stampede")
call pYE('Arsp',"stampede2")
call pYE('AEsb',"starfall2")
call pYE('ABsb',"stormbolt2")
call pYE('ANsg',"summonbear")
call pYE('ANsw',"summonhawk")
call pYE('ANlm',"summonlavaspawn")
call pYE('Arsg',"summonmisha")
call pYE('Aslp',"summonprawns")
call pYE('ANsq',"summonquilbeast")
call pYE('Arsq',"summonquilbeast2")
call pYE('ANto',"tornado")
call pYE('ANtm',"transmute")
call pYE('ANvc',"volcano")
call pYE('ANwm',"wateryminion")
call pYE('ANwk',"windwalk2")
call pYE('AOmi',"mirrorimage")
call pYE('AUdc',"deathcoil")
call pYE('A07U',"flameburst")
call pYE('A06Q',"shadowfury")
call pYE('A07V',"slowingaura")
call pYE('A07S',"graspofdarkness")
call pYE('A07Y',"breathoffrost")
call pYE('A07Z',"chainoffrost")
call pYE('A081',"sandbreath")
call pYE('A082',"lightningballs")
call pYE('A083',"forceofnature2")
call pYE('A06H',"blizzard2")
call pYE('A085',"rainoffire2")
call pYE('A088',"monsoon2")
call pYE('A07T',"darksummoning")
call pYE('ANef',"stormearthandfire")
call pYE('Acef',"stormearthandfire2")
call pYE('AHld',"lightofdawn")
call pYE('A07G',"powershot")
call pYE('A0LZ',"waveoflight")
call pYE('A08C',"summoningritual")
call pYE('A08D',"mindflay")
call pYE('A08E',"poisonspray")
call pYE('A08F',"felprotection")
call pYE('A08J',"searingtotem")
call pYE('A08N',"summonghouls")
call pYE('A06V',"storm")
call pYE('A08R',"powerwave")
call pYE('A08W',"massentanglingroots")
call pYE('A08Y',"masspolymorph")
call pYE('A090',"masshex")
call pYE('A092',"masscyclone")
call pYE('A094',"holylight2")
call pYE('A095',"deathcoil2")
call pYE('A096',"massbloodlust")
call pYE('A0E8',"blessing")
call pYE('A09C',"lifebloom")
call pYE('A09D',"lifebloom2")
call pYE('A09E',"polymorph")
call pYE('A09F',"chainheal")
call pYE('A0KX',"deathanddecay3")
call pYE('A09P',"chainofdeath")
call pYE('A09Q',"flashofdeath")
call pYE('A06F',"lavaburst")
call pYE('A09R',"energybeam")
call pYE('A09S',"suddenrush")
call pYE('A09T',"secondwind")
call pYE('A09U',"summonrockgolems")
call pYE('A0A0',"summonrevenants")
call pYE('A0A3',"summonseaelemental")
call pYE('A06M',"invisibility")
call pYE('A0DQ',"deadlyplague")
call pYE('A03L',"voodoocharm")
call pYE('A04K',"holyrain")
call pYE('A09A',"antimagicshell")
call pYE('A09B',"antimagicshell2")
call pYE('A0AR',"wither")
call pYE('A09H',"baneofdoom")
call pYE('A0CB',"poweroverwhelming")
call pYE('A0CL',"sunderingblow")
call pYE('A0CP',"felenergy")
call pYE('A0CQ',"felenergy2")
call pYE('A0CR',"heroicthrow")
call pYE('A04A',"heroicthrow2")
call pYE('A03K',"aimedshot")
call pYE('A07B',"mobilization")
call pYE('A03O',"remorselesswinter")
call pYE('A07C',"death'sembrace")
call pYE('A09V',"energystrike")
call pYE('A062',"chaosbolt")
call pYE('A0GK',"stimulatingdrink")
call pYE('A0D3',"avengingwrath")
call pYE('A0D9',"fire")
call pYE('A0DA',"thunderball")
call pYE('A0DE',"totemofthunderstorm")
call pYE('A03G',"multishot")
call pYE('A0KS',"magicmultishot")
call pYE('A0KT',"rocketmultishot")
call pYE('A0DN',"fierymultishot")
call pYE('A03Y',"fierypotion")
call pYE('A08A',"forestspirits")
call pYE('A05O',"holywake")
call pYE('A05P',"deathwake")
call pYE('A0D0',"envenomedweapons")
call pYE('A0DC',"flare")
call pYE('A0DF',"mobilization2")
call pYE('A0DG',"layonhands")
call pYE('A0DM',"suddendoom")
call pYE('A0L2',"glow")
call pYE('A0DT',"soulleech")
call pYE('A0E3',"electrostaticstrike")
call pYE('A0E6',"earthbindtotem")
call pYE('A0EA',"manatidetotem")
call pYE('A0EF',"whirlwind")
call pYE('A0EG',"deathpact2")
call pYE('A061',"illusion")
call pYE('A0EH',"elementalblast")
call pYE('A07H',"bloodyfangs")
call pYE('A06Y',"blazesaw")
call pYE('A0EJ',"heroicleap")
call pYE('A0EM',"armyofthedeadzombie")
call pYE('A0EO',"rainofstars")
call pYE('A0EP',"rainofstars2")
call pYE('A04F',"firestorm")
call pYE('A0ES',"leapoffaith")
call pYE('A07E',"mirroroffate")
call pYE('A0EU',"sweepingstrikes")
call pYE('A0EZ',"echooftheelements")
call pYE('A0CS',"shadowdance")
call pYE('A0F4',"deadlysickles")
call pYE('A0F6',"dodge")
call pYE('A06E',"stormofsouls")
call pYE('A0FH',"ironcapture")
call pYE('A064',"poweraura")
call pYE('A06G',"auraofterror")
call pYE('A0EI',"howlingblast")
call pYE('A0FJ',"forceofnature3")
call pYE('A0FL',"greatforceofnature")
call pYE('A0FN',"greatforceofnature2")
call pYE('A0FP',"armyofthedeadskeletons")
call pYE('A0FQ',"explosivewave")
call pYE('A0FR',"frostbolt")
call pYE('A0FS',"hurlboulder")
call pYE('A0FT',"fear")
call pYE('A0FY',"waspswarm")
call pYE('A0G1',"attention")
call pYE('A0G2',"attention2")
call pYE('A0G3',"attention3")
call pYE('ACes',"charactershield")
call pYE('A06Z',"specialmanashield")
call pYE('A070',"rebirth")
call pYE('A0FX',"strike")
call pYE('A071',"instantdamage")
call pYE('A003',"massdamage")
call pYE('A005',"massannihilation")
call pYE('A072',"stun")
call pYE('A073',"specialcriticalstrike")
call pYE('A002',"insuperableobstacle")
call pYE('A001',"massstun")
call pYE('A0A9',"specialblink")
call pYE('A074',"iconofsin")
call pYE('A075',"handofdestruction")
call pYE('A077',"rainofhellfire")
call pYE('A0AA',"infinityterror")
call pYE('A078',"wordoflies")
call pYE('A07A',"tormentofpain")
call pYE('A079',"gripofdecay")
call pYE('A0GJ',"shadowstep")
call pYE('A0I5',"shieldwall")
call pYE('A0GG',"firefury")
call pYE('A0HO',"ravager")
call pYE('A0HQ',"recklessness")
call pYE('A0HW',"deathstrike")
call pYE('A0HX',"cloakofshadows")
call pYE('A0I1',"deepwounds")
call pYE('A060',"jump")
call pYE('A0HP',"resistantskin")
call pYE('A0I2',"resistantskin")
call pYE('A0I4',"windfury")
call pYE('A08Q',"danceofdeath")
call pYE('A0IP',"danceofpain")
call pYE('A0IT',"charge")
call pYE('A06P',"auraofdestruction")
call pYE('A0J1',"divineshieldalter")
call pYE('AOss',"seismicslam")
call pYE('A0JP',"warbanner")
call pYE('A0G9',"temporalrift")
call pYE('A0HY',"iceblock")
call pYE('A0JW',"feigndeath")
call pYE('A0KM',"protectionfield")
call pYE('A054',"meteor")
call pYE('A0KU',"shroudofconcealment")
call pYE('A0KY',"felprotectionalter")
call pYE('A0L4',"hunter'smark")
call pYE('A0L6',"lightningwhip")
call pYE('A0L8',"scannersweep")
call pYE('A0FI',"fieryprison")
call pYE('A0A5',"napalm")
call pYE('AOdc',"dragon'scall")
call pYE('AOcs',"colossussmash")
call pYE('AOex',"execute")
call pYE('AOer',"enragedregeneration")
call pYE('AOra',"rampage")
call pYE('AObm',"bombardment")
call pYE('AOnp',"noblephantasm")
call pYE('AOds',"divinestorm")
call pYE('AOda',"disarm")
call pYE('AObw',"burningwave")
call pYE('AOew',"explosivewave2")
call pYE('AOgt',"glaivethrow")
call pYE('AOha',"hatred")
call pYE('AOsm',"surgeofmalice")
call pYE('AObe',"battleenravishment")
call pYE('AEbe',"battleenravishment")
call pYE('A0D3',"enrage")
call pYE('A0IC',"magefirebolt")
call pYE('A0ID',"mageflamestrike")
call pYE('A0GF',"felfirebolt")
call pYE('A040',"felrainoffire")
call pYE('A0GL',"felrainoffire2")
call pYE('A0GQ',"felflamestrike")
call pYE('A0GR',"felbreathoffire")
call pYE('A0GS',"felincinerate")
call pYE('A0GT',"felincinerate2")
call pYE('A0GW',"felsoulburn")
call pYE('A0GY',"fellavaburst")
call pYE('A0H3',"felfierypotion")
call pYE('A0MJ',"auraofblight")
call pYE('A0ML',"tormentingplague")
call pYE('A0MQ',"immolationaura")
call pYE('A0MF',"iceboundfortitude")
call pYE('A0MA',"shatteringthrow")
call pYE('A0MH',"victoryrush")
call pYE('A0MB',"desperateplea")
call pYE('A0MM',"powerwordshield")
call pYE('A0LO',"lightningbarrier")
call pYE('A0LP',"lightningbarrieralter")
call pYE('A0LU',"magicbarrier")
call pYE('A0LV',"magicbarrieralter")
call pYE('A0LW',"flamebarrier")
call pYE('A0LX',"flamebarrieralter")
call pYE('A0M6',"frostbarrier")
call pYE('A0M7',"frostbarrieralter")
call pYE('A0LL',"crushingwave")
call pYE('A0LN',"reversepower")
call pYE(my,"cleave")
call pYE(RR,"stickygrenadenew")
call pYE('A0HL',"ignorepain")
call pYE(ST,"touchofkarma")
call pYE(Hp,"emergencyevade")
call pYE(dq,"obliterate")
call pYE(ma,"rollthebones")
return true
endfunction
function p0E takes nothing returns nothing
local unit p1E=GetEventDamageSource()
if GetUnitAbilityLevel(p1E,dq)>0 and GetRandomInt(0,$3E8)<='}' then
call nPn(GetOwningPlayer(p1E),Rq,GetUnitAbilityLevel(p1E,dq),"attackonce",p1E,GetUnitX(p1E),GetUnitY(p1E))
endif
set p1E=null
endfunction
function p2E takes nothing returns nothing
call ForGroupBJ(Lu,p0)
endfunction
function p3E takes nothing returns boolean
return GetSpellAbilityId()=='AOcs'
endfunction
function p4E takes nothing returns boolean
return(GetSpellAbilityId()=='A0KQ')
endfunction
function p5E takes nothing returns boolean
return GetSpellAbilityId()=='A092'
endfunction
function p6E takes nothing returns nothing
local timer p7E=GetExpiredTimer()
local unit p8E=LoadUnitHandle(nr,GetHandleId(p7E),StringHash("u"))
call FlushChildHashtable(nr,GetHandleId(p7E))
call DestroyTimer(p7E)
set p7E=null
call SaveTimerHandle(nr,GetHandleId(p8E),StringHash("dsT"),null)
call GroupRemoveUnit(Tt[2],p8E)
call GroupRemoveUnit(Tt[1],p8E)
call GroupRemoveUnit(Tt[0],p8E)
set p8E=null
set p7E=null
set p8E=null
endfunction
function p9E takes nothing returns boolean
return IsUnitSelected(GetFilterUnit(),GetTriggerPlayer())
endfunction
function PvE takes nothing returns nothing
call HLv(Va,C0v(GetFilterUnit()))
endfunction
function PeE takes nothing returns boolean
return(GetSpellAbilityId()=='TMm1')or(GetSpellAbilityId()=='TMm2')or(GetSpellAbilityId()=='TMm3')or(GetSpellAbilityId()=='TMm4')or(GetSpellAbilityId()=='TMm5')or(GetSpellAbilityId()=='TMm6')or(GetSpellAbilityId()=='TMm7')
endfunction
function PxE takes nothing returns boolean
return(PeE())
endfunction
function PoE takes nothing returns boolean
return(GetEventPlayerChatString()=="equip "+Ms[GetForLoopIndexA()])
endfunction
function PrE takes nothing returns boolean
return(GetEventPlayerChatString()=="unequip "+Ms[GetForLoopIndexA()])
endfunction
function PiE takes nothing returns nothing
set g[GetConvertedPlayerId(GetTriggerPlayer())]=GetUnitsOfPlayerAll(GetTriggerPlayer())
set bj_forLoopAIndex=0
set bj_forLoopAIndexEnd=wt
loop
exitwhen bj_forLoopAIndex>bj_forLoopAIndexEnd
if PoE()then
call ForGroupBJ(g[GetConvertedPlayerId(GetTriggerPlayer())],euv)
endif
if PrE()then
call ForGroupBJ(g[GetConvertedPlayerId(GetTriggerPlayer())],eUv)
endif
set bj_forLoopAIndex=bj_forLoopAIndex+1
endloop
call DestroyGroup(g[GetPlayerId(GetTriggerPlayer())+1])
endfunction
function PaE takes nothing returns boolean
return(gs[1]==0)
endfunction
function PnE takes nothing returns nothing
if PaE()then
call EnableTrigger(CS)
endif
set gs[1]=gs[1]+1
set gs[2]=gs[2]+1
set xs[1]=GetUnitLoc(As)
set Rs[gs[2]]=DistanceBetweenPoints(xs[1],Ps)
set Fs[gs[2]]=.0
set js[gs[2]]=Is
set ms[gs[2]]=As
set ds[gs[2]]=AngleBetweenPoints(xs[1],Ps)
set Ts[gs[2]]=Us
set fs[gs[2]]=Qs
set vs[gs[2]]=Es
set Gs[gs[2]]=Zs*Rs[gs[2]]
set Hs[gs[2]]=Ds
set Ks[gs[2]]=Js
call SetUnitPathing(As,false)
call SetUnitTimeScalePercent(As,Ws*100.)
call SetUnitAnimation(As,Qs)
call GroupAddUnitSimple(As,Ys)
call UnitAddAbilityBJ('Arav',xr)
call UnitRemoveAbilityBJ('Arav',xr)
call RemoveLocation(xs[1])
call RemoveLocation(Ps)
endfunction
function PVE takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),1,7)=="expgain")
endfunction
function PEE takes nothing returns nothing
if GetUnitTypeId(GetEnumUnit())!='h000' and IsUnitSelected(GetEnumUnit(),GetTriggerPlayer()) then
call UnitAddAbility(GetEnumUnit(),'A0IR')
call UnitMakeAbilityPermanent(GetEnumUnit(),true,'A0IR')
if IsUnitInGroup(GetEnumUnit(),as)==false then
call GroupAddUnit(as,GetEnumUnit())
call TriggerRegisterUnitStateEvent(Wc,GetEnumUnit(),UNIT_STATE_MANA,LESS_THAN_OR_EQUAL,.0)
endif
endif
endfunction
function PXE takes nothing returns boolean
return(GetEventPlayerChatString()=="@worker")
endfunction
function POE takes nothing returns boolean
return(GetEventPlayerChatString()=="~worker")
endfunction
function PRE takes nothing returns nothing
set g[GetConvertedPlayerId(GetTriggerPlayer())]=GetUnitsOfPlayerMatching(GetTriggerPlayer(),Condition(rXv))
if POE()then
call ForGroupBJ(g[GetConvertedPlayerId(GetTriggerPlayer())],rOv)
elseif PXE()then
call ForGroupBJ(g[GetConvertedPlayerId(GetTriggerPlayer())],rRv)
endif
call DestroyGroup(g[GetPlayerId(GetTriggerPlayer())+1])
endfunction
function PIE takes nothing returns nothing
set Ut=CreateLeaderboard()
call LeaderboardSetLabel(Ut,"________ ________...")
call PlayerSetLeaderboard(GetLocalPlayer(),Ut)
call LeaderboardDisplay(Ut,false)
endfunction
function PAE takes unit PNE returns nothing
call SetWidgetLife(PNE,GetWidgetLife(PNE)+50.)
call DestroyEffect(AddSpecialEffectTarget("Abilities\\Spells\\Items\\AIma\\AImaTarget.mdl",PNE,"origin"))
endfunction
function PbE takes nothing returns boolean
call PAE(ry)
return true
endfunction
function PBE takes string PcE returns nothing
set ZM[EM]=PcE
set EM=EM+1
call oCn("when calling generalEventCallback in ClosureEvents, line 295")
set EM=EM-1
endfunction
function PCE takes nothing returns nothing
set EM=0
call PBE("ClosureEvents, line 295")
endfunction
function PdE takes string PDE returns integer
local integer PfE
set ZM[EM]=PDE
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set PfE=Yj
set Gj[PfE]=$AF9
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdItemBuiltins.","when calling error in ScmdItemBuiltins, line 25")
set PfE=0
endif
else
set Tj=Tj-1
set PfE=Rj[Tj]
set Gj[PfE]=$AF9
endif
set EM=EM-1
return PfE
endfunction
function PFE takes string PgE returns integer
local integer PGE
set ZM[EM]=PgE
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set PGE=Yj
set Gj[PGE]=$AF8
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdItemBuiltins.","when calling error in ScmdItemBuiltins, line 17")
set PGE=0
endif
else
set Tj=Tj-1
set PGE=Rj[Tj]
set Gj[PGE]=$AF8
endif
set EM=EM-1
return PGE
endfunction
function PhE takes string PHE returns integer
local integer PjE
set ZM[EM]=PHE
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set PjE=Yj
set Gj[PjE]=$A40
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdItemBuiltins.","when calling error in ScmdItemBuiltins, line 10")
set PjE=0
endif
else
set Tj=Tj-1
set PjE=Rj[Tj]
set Gj[PjE]=$A40
endif
set EM=EM-1
return PjE
endfunction
function PJE takes string PkE returns integer
local integer PKE
set ZM[EM]=PkE
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set PKE=Yj
set Gj[PKE]=$AF7
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdItemBuiltins.","when calling error in ScmdItemBuiltins, line 13")
set PKE=0
endif
else
set Tj=Tj-1
set PKE=Rj[Tj]
set Gj[PKE]=$AF7
endif
set EM=EM-1
return PKE
endfunction
function PlE takes string PLE returns integer
local integer PmE
set ZM[EM]=PLE
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set PmE=Yj
set Gj[PmE]=$B21
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_setArgumentsTypes_registerProtectedBuiltin_ScmdItemBuiltins.","when calling error in ScmdItemBuiltins, line 21")
set PmE=0
endif
else
set Tj=Tj-1
set PmE=Rj[Tj]
set Gj[PmE]=$B21
endif
set EM=EM-1
return PmE
endfunction
function PME takes string PpE returns integer
local integer PPE
set ZM[EM]=PpE
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set PPE=Yj
set Gj[PPE]=$AFA
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdItemBuiltins.","when calling error in ScmdItemBuiltins, line 29")
set PPE=0
endif
else
set Tj=Tj-1
set PPE=Rj[Tj]
set Gj[PPE]=$AFA
endif
set EM=EM-1
return PPE
endfunction
function PqE takes string PQE returns integer
local integer PsE
set ZM[EM]=PQE
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set PsE=Yj
set Gj[PsE]=$AFD
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdItemBuiltins.","when calling error in ScmdItemBuiltins, line 41")
set PsE=0
endif
else
set Tj=Tj-1
set PsE=Rj[Tj]
set Gj[PsE]=$AFD
endif
set EM=EM-1
return PsE
endfunction
function PSE takes string PtE returns integer
local integer PTE
set ZM[EM]=PtE
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set PTE=Yj
set Gj[PTE]=$AFE
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdItemBuiltins.","when calling error in ScmdItemBuiltins, line 45")
set PTE=0
endif
else
set Tj=Tj-1
set PTE=Rj[Tj]
set Gj[PTE]=$AFE
endif
set EM=EM-1
return PTE
endfunction
function PuE takes string PUE returns integer
local integer PwE
set ZM[EM]=PUE
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set PwE=Yj
set Gj[PwE]=$B2B
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdItemBuiltins.","when calling error in ScmdItemBuiltins, line 8")
set PwE=0
endif
else
set Tj=Tj-1
set PwE=Rj[Tj]
set Gj[PwE]=$B2B
endif
set EM=EM-1
return PwE
endfunction
function PWE takes string PyE returns integer
local integer PYE
set ZM[EM]=PyE
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set PYE=Yj
set Gj[PYE]=$AFC
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdItemBuiltins.","when calling error in ScmdItemBuiltins, line 37")
set PYE=0
endif
else
set Tj=Tj-1
set PYE=Rj[Tj]
set Gj[PYE]=$AFC
endif
set EM=EM-1
return PYE
endfunction
function PzE takes nothing returns integer
return Mn
endfunction
function PZE takes string P_E returns integer
local integer P0E
set ZM[EM]=P_E
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set P0E=Yj
set Gj[P0E]=$AFB
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdItemBuiltins.","when calling error in ScmdItemBuiltins, line 33")
set P0E=0
endif
else
set Tj=Tj-1
set P0E=Rj[Tj]
set Gj[P0E]=$AFB
endif
set EM=EM-1
return P0E
endfunction
function P1E takes string P2E returns boolean
local integer P3E
local integer P4E
local integer P5E
local integer P6E
local integer P7E
local integer P8E
local integer P9E
local integer qvE
local integer qeE
local integer qxE
local integer qoE
local integer qrE
local integer qiE
local integer qaE
local integer qnE
local integer qVE
local integer qEE
local integer qXE
local integer qOE
local integer qRE
local integer qIE
local integer qAE
local integer qNE
local integer qbE
local integer qBE
local integer qcE
set ZM[EM]=P2E
set EM=EM+1
set P3E=PuE("when calling alloc_IBuiltin_setArgumentsTypes_setRequiringEnumUnit_addOverload_registerProtectedBuiltin_ScmdItemBuiltins in ScmdItemBuiltins, line 8")
set P4E=OPo(P3E,"when calling new_BuiltinData in ScmdItemBuiltins, line 8")
call Rxo(P4E,f3a(),"when calling setArgumentsTypes in ScmdItemBuiltins, line 10")
set P5E=P4E
call LWV(P5E,"when calling setRequiringEnumUnit in ScmdItemBuiltins, line 10")
set P8E=ILo(P5E,"when calling new_BuiltinFunction in ScmdItemBuiltins, line 8")
set qcE=P8E
set P6E=PhE("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdItemBuiltins in ScmdItemBuiltins, line 10")
set P7E=OPo(P6E,"when calling new_BuiltinData in ScmdItemBuiltins, line 10")
call FRa(P7E,e4V(),f3a(),"when calling setArgumentsTypes in ScmdItemBuiltins, line 12")
call IFo(qcE,P7E,"when calling addOverload in ScmdItemBuiltins, line 10")
call Foa(P8E,"iteminslot","when calling registerProtectedBuiltin in ScmdItemBuiltins, line 8")
set P9E=PJE("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdItemBuiltins in ScmdItemBuiltins, line 13")
set qvE=OPo(P9E,"when calling new_BuiltinData in ScmdItemBuiltins, line 13")
call FRa(qvE,PzE(),d_V(),"when calling setArgumentsTypes in ScmdItemBuiltins, line 16")
call Foa(ILo(qvE,"when calling new_BuiltinFunction in ScmdItemBuiltins, line 13"),"itemsetdropondeath","when calling registerProtectedBuiltin in ScmdItemBuiltins, line 13")
set qeE=PFE("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdItemBuiltins in ScmdItemBuiltins, line 17")
set qxE=OPo(qeE,"when calling new_BuiltinData in ScmdItemBuiltins, line 17")
call FRa(qxE,PzE(),d_V(),"when calling setArgumentsTypes in ScmdItemBuiltins, line 20")
call Foa(ILo(qxE,"when calling new_BuiltinFunction in ScmdItemBuiltins, line 17"),"itemsetdroppable","when calling registerProtectedBuiltin in ScmdItemBuiltins, line 17")
set qoE=PlE("when calling alloc_IBuiltin_setArgumentsTypes_setArgumentsTypes_registerProtectedBuiltin_ScmdItemBuiltins in ScmdItemBuiltins, line 21")
set qrE=OPo(qoE,"when calling new_BuiltinData in ScmdItemBuiltins, line 21")
call FRa(qrE,PzE(),OFo(),"when calling setArgumentsTypes in ScmdItemBuiltins, line 24")
set qiE=qrE
call FRa(qiE,PzE(),OFo(),"when calling setArgumentsTypes in ScmdItemBuiltins, line 24")
call Foa(ILo(qiE,"when calling new_BuiltinFunction in ScmdItemBuiltins, line 21"),"itemsetname","when calling registerProtectedBuiltin in ScmdItemBuiltins, line 21")
set qaE=PdE("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdItemBuiltins in ScmdItemBuiltins, line 25")
set qnE=OPo(qaE,"when calling new_BuiltinData in ScmdItemBuiltins, line 25")
call FRa(qnE,PzE(),OFo(),"when calling setArgumentsTypes in ScmdItemBuiltins, line 28")
call Foa(ILo(qnE,"when calling new_BuiltinFunction in ScmdItemBuiltins, line 25"),"itemsetdescription","when calling registerProtectedBuiltin in ScmdItemBuiltins, line 25")
set qVE=PME("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdItemBuiltins in ScmdItemBuiltins, line 29")
set qEE=OPo(qVE,"when calling new_BuiltinData in ScmdItemBuiltins, line 29")
call FRa(qEE,PzE(),OFo(),"when calling setArgumentsTypes in ScmdItemBuiltins, line 32")
call Foa(ILo(qEE,"when calling new_BuiltinFunction in ScmdItemBuiltins, line 29"),"itemsettooltip","when calling registerProtectedBuiltin in ScmdItemBuiltins, line 29")
set qXE=PZE("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdItemBuiltins in ScmdItemBuiltins, line 33")
set qOE=OPo(qXE,"when calling new_BuiltinData in ScmdItemBuiltins, line 33")
call FRa(qOE,PzE(),OFo(),"when calling setArgumentsTypes in ScmdItemBuiltins, line 36")
call Foa(ILo(qOE,"when calling new_BuiltinFunction in ScmdItemBuiltins, line 33"),"itemsetextendedtooltip","when calling registerProtectedBuiltin in ScmdItemBuiltins, line 33")
set qRE=PWE("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdItemBuiltins in ScmdItemBuiltins, line 37")
set qIE=OPo(qRE,"when calling new_BuiltinData in ScmdItemBuiltins, line 37")
call FRa(qIE,PzE(),OFo(),"when calling setArgumentsTypes in ScmdItemBuiltins, line 40")
call Foa(ILo(qIE,"when calling new_BuiltinFunction in ScmdItemBuiltins, line 37"),"itemseticonpath","when calling registerProtectedBuiltin in ScmdItemBuiltins, line 37")
set qAE=PqE("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdItemBuiltins in ScmdItemBuiltins, line 41")
set qNE=OPo(qAE,"when calling new_BuiltinData in ScmdItemBuiltins, line 41")
call FRa(qNE,PzE(),f3a(),"when calling setArgumentsTypes in ScmdItemBuiltins, line 44")
call Foa(ILo(qNE,"when calling new_BuiltinFunction in ScmdItemBuiltins, line 41"),"itemsetcharges","when calling registerProtectedBuiltin in ScmdItemBuiltins, line 41")
set qbE=PSE("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdItemBuiltins in ScmdItemBuiltins, line 45")
set qBE=OPo(qbE,"when calling new_BuiltinData in ScmdItemBuiltins, line 45")
call FRa(qBE,PzE(),gQV(),"when calling setArgumentsTypes in ScmdItemBuiltins, line 48")
call Foa(ILo(qBE,"when calling new_BuiltinFunction in ScmdItemBuiltins, line 45"),"itemsetlife","when calling registerProtectedBuiltin in ScmdItemBuiltins, line 45")
set EM=EM-1
return true
endfunction
function qCE takes nothing returns boolean
set EM=0
return P1E("ScmdItemBuiltins, line 1")
endfunction
function qdE takes nothing returns nothing
call CameraSetEQNoiseForPlayer(GetEnumPlayer(),4.)
endfunction
function qDE takes nothing returns boolean
return(Du==LoadIntegerBJ(0,GetHandleIdBJ(GetEnumUnit()),Au))
endfunction
function qfE takes nothing returns nothing
if qDE()then
call FlushChildHashtableBJ(GetHandleIdBJ(GetEnumUnit()),Au)
call GroupRemoveUnitSimple(GetEnumUnit(),Ku)
call RemoveUnit(GetEnumUnit())
endif
endfunction
function qFE takes nothing returns nothing
local unit qgE=GetSpellTargetUnit()
local unit qGE=GetSpellAbilityUnit()
local real qhE=GetUnitState(GetSpellAbilityUnit(),UNIT_STATE_LIFE)
local real qHE=GetUnitState(GetSpellAbilityUnit(),UNIT_STATE_MANA)
local integer qjE=0
local effect qJE
if IsUnitInGroup(qGE,rs) then
call GroupRemoveUnit(rs,qGE)
call pAa(1.)
endif
call GroupAddUnit(rs,qGE)
call UnitAddAbility(qGE,'A0GI')
call UnitMakeAbilityPermanent(qGE,true,'A0GI')
call AddSpecialEffectLoc("Abilities\\Spells\\Undead\\DeathPact\\DeathPactTarget.mdl",GetUnitLoc(qgE))
call AddSpecialEffectLoc("Abilities\\Spells\\Undead\\DeathPact\\DeathPactCaster.mdl",GetUnitLoc(qgE))
call AddSpecialEffectLoc("Objects\\Spawnmodels\\Undead\\UndeadDissipate\\UndeadDissipate.mdl",GetUnitLoc(qgE))
call AddSpecialEffectLoc("Abilities\\Spells\\Undead\\DeathPact\\DeathPactTarget.mdl",GetUnitLoc(qGE))
call AddSpecialEffectLoc("Abilities\\Spells\\Undead\\DeathPact\\DeathPactCaster.mdl",GetUnitLoc(qGE))
set qJE=AddSpecialEffectTarget("Abilities\\Spells\\Undead\\DarkSummoning\\DarkSummonMissile.mdl",qGE,"chest")
call SetUnitExploded(qgE,true)
call KillUnit(qgE)
if GetUnitAbilityLevel(GetSpellAbilityUnit(),'A0DT')==3 then
call UnitAddAbility(qGE,'A0E1')
call UnitMakeAbilityPermanent(qGE,true,'A0E1')
call SetUnitState(qGE,UNIT_STATE_LIFE,qhE+375.)
call UnitAddAbility(qGE,'A0E2')
call UnitMakeAbilityPermanent(qGE,true,'A0E2')
call SetUnitState(qGE,UNIT_STATE_MANA,qHE+375.)
call UnitAddAbility(qGE,'A0DW')
call UnitMakeAbilityPermanent(qGE,true,'A0DW')
elseif GetUnitAbilityLevel(GetSpellAbilityUnit(),'A0DT')==2 then
call UnitAddAbility(qGE,'A0DZ')
call UnitMakeAbilityPermanent(qGE,true,'A0DZ')
call SetUnitState(qGE,UNIT_STATE_LIFE,qhE+250.)
call UnitAddAbility(qGE,'A0E0')
call UnitMakeAbilityPermanent(qGE,true,'A0E0')
call SetUnitState(qGE,UNIT_STATE_MANA,qHE+250.)
call UnitAddAbility(qGE,'A0DV')
call UnitMakeAbilityPermanent(qGE,true,'A0DV')
elseif GetUnitAbilityLevel(GetSpellAbilityUnit(),'A0DT')==1 then
call UnitAddAbility(qGE,'A0DX')
call UnitMakeAbilityPermanent(qGE,true,'A0DX')
call SetUnitState(qGE,UNIT_STATE_LIFE,qhE+125.)
call UnitAddAbility(qGE,'A0DY')
call UnitMakeAbilityPermanent(qGE,true,'A0DY')
call SetUnitState(qGE,UNIT_STATE_MANA,qHE+125.)
call UnitAddAbility(qGE,'A0DU')
call UnitMakeAbilityPermanent(qGE,true,'A0DU')
endif
loop
exitwhen IsUnitInGroup(qGE,rs)==false
call pAa(1.)
set qjE=qjE+1
if qjE==$F or GetUnitState(qGE,UNIT_STATE_LIFE)<=.0 then
call GroupRemoveUnit(rs,qGE)
endif
endloop
call DestroyEffect(qJE)
call UnitRemoveAbility(qGE,'A0GI')
call UnitRemoveAbility(qGE,'B03F')
call UnitRemoveAbility(qGE,'A0E1')
call UnitRemoveAbility(qGE,'A0E2')
call UnitRemoveAbility(qGE,'A0DW')
call UnitRemoveAbility(qGE,'A0DZ')
call UnitRemoveAbility(qGE,'A0E0')
call UnitRemoveAbility(qGE,'A0DV')
call UnitRemoveAbility(qGE,'A0DX')
call UnitRemoveAbility(qGE,'A0DY')
call UnitRemoveAbility(qGE,'A0DU')
set qgE=null
set qGE=null
set qhE=.0
set qHE=.0
set qJE=null
set qjE=0
set qgE=null
set qGE=null
set qJE=null
endfunction
function qkE takes nothing returns nothing
local integer qKE=1
local unit qlE=GetSpellAbilityUnit()
local unit qLE=GetSpellTargetUnit()
loop
exitwhen qKE>$3B9ACA00
if ut[qKE]==null then
set ut[qKE]=qlE
set rt[qKE]=qLE
call UnitRemoveAbility(ut[qKE],'A0JG')
call UnitAddAbility(ut[qKE],'A0JH')
call UnitMakeAbilityPermanent(ut[qKE],true,'A0JH')
set qKE=0
set qlE=null
set qLE=null
set qlE=null
set qLE=null
return
endif
set qKE=qKE+1
endloop
set qKE=0
set qlE=null
set qLE=null
set qlE=null
set qLE=null
endfunction
function qmE takes nothing returns nothing
local group qME=GetUnitsInRangeOfLocMatching(600.,GetSpellTargetLoc(),Condition(azv))
local unit qpE=GetSpellAbilityUnit()
local unit qPE=null
local integer qqE=GetUnitAbilityLevel(qpE,'A0IP')
local integer qQE=0
local integer qsE=0
if qqE==1 then
set qsE=85
elseif qqE==2 then
set qsE='}'
elseif qqE==3 then
set qsE=$B4
endif
call GroupAddUnit(qs,qpE)
call SetUnitPathing(qpE,false)
call UnitAddAbility(qpE,'A0IM')
call UnitMakeAbilityPermanent(qpE,true,'A0IM')
loop
exitwhen IsUnitInGroup(qpE,qs)==false
set qPE=FirstOfGroup(qME)
call GroupRemoveUnit(qME,qPE)
if BlzIsUnitInvulnerable(qPE)==false and GetUnitState(qPE,UNIT_STATE_LIFE)>.0 and IsUnitLoaded(qPE)==false then
call DestroyEffect(AddSpecialEffectTarget("Abilities\\Spells\\Other\\TalkToMe\\TalkToMe.mdl",qPE,"overhead"))
call pAa(1.)
call DestroyEffect(AddSpecialEffectLoc("Abilities\\Spells\\NightElf\\Blink\\BlinkCaster.mdl",GetUnitLoc(qpE)))
call SetUnitPositionLoc(qpE,GetUnitLoc(qPE))
call SetUnitFacing(qpE,AngleBetweenPoints(GetUnitLoc(qpE),GetUnitLoc(qPE)))
call DestroyEffect(AddSpecialEffectLoc("Abilities\\Spells\\NightElf\\Blink\\BlinkTarget.mdl",GetUnitLoc(qpE)))
call DestroyEffect(AddSpecialEffectTarget("Objects\\Spawnmodels\\Critters\\Albatross\\CritterBloodAlbatross.mdl",qPE,"chest"))
call SetUnitAnimation(qpE,"attack")
call UnitDamageTarget(qpE,qPE,qsE,true,true,ATTACK_TYPE_NORMAL,DAMAGE_TYPE_MAGIC,WEAPON_TYPE_WHOKNOWS)
set qQE=qQE+1
endif
if qQE==2+2*qqE or FirstOfGroup(qME)==null or GetUnitState(qpE,UNIT_STATE_LIFE)<=.0 or IsUnitLoaded(qpE) or GetUnitAbilityLevel(qpE,'BEer')>0 or GetUnitAbilityLevel(qpE,'Bweb')>0 or GetUnitAbilityLevel(qpE,'Bwea')>0 or GetUnitAbilityLevel(qpE,'Bens')>0 or GetUnitAbilityLevel(qpE,'Beng')>0 or GetUnitAbilityLevel(qpE,'Bena')>0 or GetUnitAbilityLevel(qpE,'Bdvv')>0 or GetUnitAbilityLevel(qpE,'Bmlt')>0 or GetUnitAbilityLevel(qpE,'BSTN')>0 or GetUnitAbilityLevel(qpE,'BPSE')>0 or GetUnitAbilityLevel(qpE,'BUsl')>0 or GetUnitAbilityLevel(qpE,'BUst')>0 or GetUnitAbilityLevel(qpE,'BUsp')>0 or GetUnitAbilityLevel(qpE,'Bcyc')>0 or GetUnitAbilityLevel(qpE,'Bcy2')>0 then
call pAa(.5)
call UnitRemoveAbility(qpE,'A0IM')
call SetUnitPathing(qpE,true)
call GroupRemoveUnit(qs,qpE)
call SetUnitAnimation(qpE,"stand")
endif
endloop
call DestroyGroup(qME)
set qME=null
set qpE=null
set qPE=null
set qqE=0
set qQE=0
set qsE=0
set qME=null
set qpE=null
set qPE=null
endfunction
function qSE takes nothing returns nothing
local timer qtE=GetExpiredTimer()
local location qTE=LoadLocationHandle(nr,GetHandleId(qtE),StringHash("l1"))
local location quE=LoadLocationHandle(nr,GetHandleId(qtE),StringHash("l2"))
local integer qUE=LoadInteger(nr,GetHandleId(qtE),StringHash("i"))
local real qwE=GetLocationX(qTE)+qUE*$FA*Cos(Atan2(GetLocationY(quE)-GetLocationY(qTE),GetLocationX(quE)-GetLocationX(qTE)))
local real qWE=GetLocationY(qTE)+qUE*$FA*Sin(Atan2(GetLocationY(quE)-GetLocationY(qTE),GetLocationX(quE)-GetLocationX(qTE)))
local unit qyE=CreateUnit(Player(PLAYER_NEUTRAL_PASSIVE),'h0JO',qwE,qWE,.0)
call UnitAddAbility(qyE,'AObf')
call IssuePointOrderById(qyE,$D0208,qwE,qWE)
call oLn(qyE,2.5)
set qyE=null
set qUE=qUE+1
if qUE==6 then
call FlushChildHashtable(nr,GetHandleId(qtE))
call DestroyTimer(qtE)
call RemoveLocation(qTE)
call RemoveLocation(quE)
else
call SaveInteger(nr,GetHandleId(qtE),StringHash("i"),qUE)
endif
set qtE=null
set qTE=null
set quE=null
set qUE=0
set qtE=null
set qTE=null
set quE=null
set qyE=null
endfunction
function qYE takes nothing returns boolean
return(GetEventPlayerChatString()=="remove timer")
endfunction
function qzE takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),1,6)=="timer ")and(S2R(SubStringBJ(GetEventPlayerChatString(),7,9))>=.0)
endfunction
function qZE takes nothing returns boolean
return(GetEventPlayerChatString()=="unpause timer")
endfunction
function q_E takes nothing returns boolean
return(GetEventPlayerChatString()=="pause timer")
endfunction
function q0E takes nothing returns nothing
if qYE()then
call DestroyTimerDialogBJ(jw)
call PauseTimerBJ(true,xw)
endif
if q_E()then
call PauseTimerBJ(true,xw)
endif
if qZE()then
call PauseTimerBJ(false,xw)
endif
if qzE()then
call DestroyTimerDialogBJ(jw)
call PauseTimerBJ(true,xw)
call StartTimerBJ(xw,false,S2R(SubStringBJ(GetEventPlayerChatString(),7,9))*60.)
set jw=CreateTimerDialogBJ(GetLastCreatedTimerBJ(),SubStringBJ(GetEventPlayerChatString(),$B,StringLength(GetEventPlayerChatString())))
endif
if true then
endif
endfunction
function q1E takes nothing returns boolean
return(GetUnitTypeId(GetEnumUnit())!='h000')and(IsUnitSelected(GetEnumUnit(),GetTriggerPlayer()))
endfunction
function q2E takes nothing returns nothing
if q1E()then
call GroupRemoveUnitSimple(GetEnumUnit(),yt)
call UnitRemoveAbilityBJ('A0K7',GetEnumUnit())
call UnitRemoveAbilityBJ('A0K9',GetEnumUnit())
call UnitRemoveAbilityBJ('A0K6',GetEnumUnit())
endif
endfunction
function q3E takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),1,1)=="@")
endfunction
function q4E takes nothing returns nothing
call KillDestructable(GetEnumDestructable())
endfunction
function q5E takes nothing returns boolean
set la=bj_MAX_PLAYER_SLOTS
set ba=$DF
set aa="\")
\tcall SetPlayerName(Player("
set na="), \""
set da="\")
//"
set fa="\" )
endfunction
function AAA takes nothing returns nothing 
//"
set Ra=0
set ea=0
set qa=0
return true
endfunction
function q6E takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),1,4)=="item")
endfunction
function q7E takes unit q8E returns nothing
local real q9E=LoadReal(i,HO,GetHandleId(q8E))+GetUnitAbilityLevel(q8E,'A0HL')*'d'*(2.-GetWidgetLife(q8E)/BlzGetUnitMaxHP(q8E))
local real QvE=400*GetUnitAbilityLevel(q8E,'A0HL')
if q9E>QvE then
set q9E=QvE
endif
call SaveReal(i,HO,GetHandleId(q8E),q9E*1.)
endfunction
function QeE takes nothing returns boolean
call q7E(ry)
return true
endfunction
function QxE takes integer QoE,string QrE returns nothing
set ZM[EM]=QrE
set EM=EM+1
if kg[QoE]==0 then
call Cdv("Double free: object of type PositionedDestructableDataPasteCallback","when calling error in DestructableData, line 210")
else
set gg[hg]=QoE
set hg=hg+1
set kg[QoE]=0
endif
set EM=EM-1
endfunction
function QiE takes integer QaE,string QnE returns nothing
set ZM[EM]=QnE
set EM=EM+1
call QxE(QaE,"when calling dealloc_PositionedDestructableDataPasteCallback in DestructableData, line 210")
set EM=EM-1
endfunction
function QVE takes integer QEE,string QXE returns nothing
set ZM[EM]=QXE
set EM=EM+1
if kg[QEE]==0 then
if QEE==0 then
call Cdv("Nullpointer exception when calling PositionedDestructableDataPasteCallback.PositionedDestructableDataPasteCallback","when calling error in DestructableData, line 210")
else
call Cdv("Called PositionedDestructableDataPasteCallback.PositionedDestructableDataPasteCallback on invalid object.","when calling error in DestructableData, line 210")
endif
endif
call QiE(QEE,"when calling destroyPositionedDestructableDataPasteCallback in DestructableData, line 210")
set EM=EM-1
endfunction
function QOE takes string QRE returns integer
local integer QIE
set ZM[EM]=QRE
set EM=EM+1
if uj==0 then
if rj<$8000 then
set rj=rj+1
set QIE=rj
set sj[QIE]=4117
else
call Cdv("Out of memory: Could not create PositionedUnitDataPasteCallback_paste_paste_paste_RegionData_RegionData.","when calling error in RegionData, line 117")
set QIE=0
endif
else
set uj=uj-1
set QIE=wj[uj]
set sj[QIE]=4117
endif
set EM=EM-1
return QIE
endfunction
function QAE takes string QNE returns integer
local integer QbE
set ZM[EM]=QNE
set EM=EM+1
if pg==0 then
if eg<$8000 then
set eg=eg+1
set QbE=eg
set qg[QbE]=$462
else
call Cdv("Out of memory: Could not create CallbackCounted_doPeriodicallyCounted_PositionedUnitData_UnitData.","when calling error in UnitData, line 1433")
set QbE=0
endif
else
set pg=pg-1
set QbE=yg[pg]
set qg[QbE]=$462
endif
set EM=EM-1
return QbE
endfunction
function QBE takes integer QcE,player QCE,real QdE,real QDE,integer QfE,string QFE returns nothing
local integer QgE
local integer QGE
local integer QhE
local real QHE
local real QjE
set ZM[EM]=QFE
set EM=EM+1
set QgE=bxx(0,"when calling new_Box⟪integer⟫ in UnitData, line 1432")
set QhE=kPe(P3x(dgv(XC[QcE],"when calling size in UnitData, line 1433")*1./25),1)
set QGE=QAE("when calling alloc_CallbackCounted_doPeriodicallyCounted_PositionedUnitData_UnitData in UnitData, line 1433")
call qWx(QGE)
set cV[QGE]=QgE
set oV[QGE]=QcE
set OV[QGE]=QCE
set QHE=QdE
set QjE=QDE
set lV[QGE]=QHE
set bV[QGE]=QjE
set yV[QGE]=QfE
call QXx(.25,QhE,QGE,"when calling doPeriodicallyCounted in UnitData, line 1433")
set EM=EM-1
endfunction
function QJE takes integer QkE,player QKE,real QlE,real QLE,integer QmE,string QME returns nothing
set ZM[EM]=QME
set EM=EM+1
if Gg[QkE]==0 then
if QkE==0 then
call Cdv("Nullpointer exception when calling PositionedUnitData.paste","when calling error in UnitData, line 1431")
else
call Cdv("Called PositionedUnitData.paste on invalid object.","when calling error in UnitData, line 1431")
endif
endif
call QBE(QkE,QKE,QlE,QLE,QmE,"when calling paste in UnitData, line 1431")
set EM=EM-1
endfunction
function QpE takes integer QPE,string QqE returns nothing
local integer QQE
local integer QsE
local player QSE
local real QtE
local real QTE
local real QuE
local real QUE
set ZM[EM]=QqE
set EM=EM+1
set QsE=CH[NH[QPE]]
set QSE=xD[NH[QPE]]
set QuE=AH[NH[QPE]]
set QUE=DH[NH[QPE]]
set QtE=QuE
set QTE=QUE
set QQE=QOE("when calling alloc_PositionedUnitDataPasteCallback_paste_paste_paste_RegionData_RegionData in RegionData, line 117")
set wJ[QQE]=MH[QPE]
call QJE(QsE,QSE,QtE,QTE,QQE,"when calling paste in RegionData, line 117")
set EM=EM-1
set QSE=null
endfunction
function QwE takes integer QWE,string QyE returns nothing
set ZM[EM]=QyE
set EM=EM+1
if kg[QWE]==0 then
if QWE==0 then
call Cdv("Nullpointer exception when calling PositionedDestructableDataPasteCallback.onPasted","when calling error in DestructableData, line 211")
else
call Cdv("Called PositionedDestructableDataPasteCallback.onPasted on invalid object.","when calling error in DestructableData, line 211")
endif
endif
call QpE(QWE,"when calling onPasted_paste_paste_RegionData_RegionData in DestructableData, line 211")
set EM=EM-1
endfunction
function QYE takes integer QzE,integer QZE returns boolean
return n9e(QzE,QZE)
endfunction
function Q_E takes destructable Q0E,real Q1E returns nothing
call SetDestructableAnimationSpeed(Q0E,Q1E)
endfunction
function Q2E takes integer Q3E,player Q4E,real Q5E,real Q6E,string Q7E returns destructable
local destructable Q8E
local destructable Q9E
set ZM[EM]=Q7E
set EM=EM+1
set Q9E=O0a(Q4E,Dfn(fE[Q3E],YE[Q3E],"when calling getRawcode in DestructableData, line 129"),oDE(I_e(Q5E,Q6E,IYe(GE[Q3E],gE[Q3E]),d1),O1,hE[Q3E]),s3,t3,FE[Q3E],kE[Q3E],jE[Q3E])
call Rea(Q9E,bUn(RE[Q3E],0))
set Q8E=Q9E
if QYE(TE[Q3E],0)then
call A5a(Q8E,xE[Q3E])
endif
if QYE(TE[Q3E],1)then
call Q_E(Q8E,vE[Q3E])
endif
if QYE(TE[Q3E],2)then
call Noa(Q8E,DQv(mE[Q3E]))
endif
if QYE(TE[Q3E],3)then
call A8a(Q8E,DQv(QE[Q3E]))
endif
set EM=EM-1
set R6v=Q8E
set Q8E=null
set Q9E=null
return R6v
endfunction
function svE takes integer seE,player sxE,real soE,real srE,string siE returns destructable
local destructable saE
set ZM[EM]=siE
set EM=EM+1
if mg[seE]==0 then
if seE==0 then
call Cdv("Nullpointer exception when calling SingleDestructableData.create","when calling error in DestructableData, line 128")
else
call Cdv("Called SingleDestructableData.create on invalid object.","when calling error in DestructableData, line 128")
endif
endif
set saE=Q2E(seE,sxE,soE,srE,"when calling create in DestructableData, line 128")
set EM=EM-1
set IRv=saE
set saE=null
return IRv
endfunction
function snE takes integer sVE returns boolean
return mW[sVE]==1
endfunction
function sEE takes integer sXE,string sOE returns boolean
local boolean sRE
set ZM[EM]=sOE
set EM=EM+1
if qg[sXE]==0 then
if sXE==0 then
call Cdv("Nullpointer exception when calling CallbackCounted.isLast","when calling error in ClosureTimers, line 156")
else
call Cdv("Called CallbackCounted.isLast on invalid object.","when calling error in ClosureTimers, line 156")
endif
endif
set sRE=snE(sXE)
set EM=EM-1
return sRE
endfunction
function sIE takes integer sAE,integer sNE,string sbE returns nothing
local integer sBE
local integer scE
set ZM[EM]=sbE
set EM=EM+1
set sBE=vM[pE[sAE]]*25
set scE=bUe(dgv(rE[eE[sAE]],"when calling size in DestructableData, line 277"),(vM[pE[sAE]]+1)*25)-1
loop
exitwhen sBE>scE
call svE(jqv(rE[eE[sAE]],sBE,"when calling get in DestructableData, line 278"),qE[sAE],aE[sAE],nE[sAE],"when calling create in DestructableData, line 278")
set sBE=sBE+1
endloop
set vM[pE[sAE]]=vM[pE[sAE]]+1
if sEE(sNE,"when calling isLast in DestructableData, line 280")then
call Bcx(pE[sAE],"when calling dispatch_Box⟪integer⟫_destroyBox⟪integer⟫ in DestructableData, line 281")
if dE[sAE]!=0 then
call QwE(dE[sAE],"when calling onPasted in DestructableData, line 283")
call QVE(dE[sAE],"when calling dispatch_PositionedDestructableDataPasteCallback_destroyPositionedDestructableDataPasteCallback in DestructableData, line 284")
endif
endif
set EM=EM-1
endfunction
function sCE takes integer AOo returns nothing
endfunction
function sdE takes integer sDE,string sfE returns nothing
set ZM[EM]=sfE
set EM=EM+1
if Sm[sDE]==0 then
call Cdv("Double free: object of type UnitDataPasteCallback","when calling error in UnitTypeData, line 1341")
else
set im=im+1
set Sm[sDE]=0
endif
set EM=EM-1
endfunction
function sFE takes integer sgE,string sGE returns nothing
set ZM[EM]=sGE
set EM=EM+1
call sdE(sgE,"when calling dealloc_UnitDataPasteCallback in UnitTypeData, line 1341")
set EM=EM-1
endfunction
function shE takes integer sHE,string sjE returns nothing
set ZM[EM]=sjE
set EM=EM+1
if Sm[sHE]==0 then
if sHE==0 then
call Cdv("Nullpointer exception when calling UnitDataPasteCallback.UnitDataPasteCallback","when calling error in UnitTypeData, line 1341")
else
call Cdv("Called UnitDataPasteCallback.UnitDataPasteCallback on invalid object.","when calling error in UnitTypeData, line 1341")
endif
endif
call sFE(sHE,"when calling destroyUnitDataPasteCallback in UnitTypeData, line 1341")
set EM=EM-1
endfunction
function sJE takes integer skE,integer sKE,string slE returns integer
local integer sLE
set ZM[EM]=slE
set EM=EM+1
set sLE=jqv(yM[skE],sKE,"when calling get in UnitTypeData, line 1281")
set EM=EM-1
return sLE
endfunction
function smE takes integer sME,integer spE,string sPE returns integer
local integer sqE
set ZM[EM]=sPE
set EM=EM+1
if bm[sME]==0 then
if sME==0 then
call Cdv("Nullpointer exception when calling UnitTypeTable.getUnitType","when calling error in UnitTypeData, line 1280")
else
call Cdv("Called UnitTypeTable.getUnitType on invalid object.","when calling error in UnitTypeData, line 1280")
endif
endif
set sqE=sJE(sME,spE,"when calling getUnitType in UnitTypeData, line 1280")
set EM=EM-1
return sqE
endfunction
function sQE takes unit ssE,integer sSE,real stE,real sTE,real suE,real sUE,real swE returns nothing
if ZOe(sSE,0)then
call AMe(ssE,stE)
endif
if ZOe(sSE,2)then
call ASe(ssE,sTE)
endif
if ZOe(sSE,3)then
call AWe(ssE,suE)
endif
if ZOe(sSE,6)then
call Aqe(ssE,sUE)
endif
if ZOe(sSE,7)then
call Age(ssE,uiv(swE))
endif
endfunction
function sWE takes unit syE,unittype sYE,boolean szE returns nothing
if szE then
call UnitAddType(syE,sYE)
else
call UnitRemoveType(syE,sYE)
endif
endfunction
function sZE takes integer s_E,integer s0E returns boolean
return n9e(s_E,s0E)
endfunction
function s1E takes unit s2E,integer s3E returns nothing
call sWE(s2E,UNIT_TYPE_TOWNHALL,sZE(s3E,0))
endfunction
function s4E takes integer s5E,unit s6E returns nothing
call wnv(s6E,ZB[s5E])
call Uuv(s6E,ZB[s5E],UB[s5E])
if vhx(EB[s5E],4)then
call OPe(s6E,ZB[s5E],UB[s5E],IB[s5E])
endif
if vhx(EB[s5E],5)then
call Ole(s6E,ZB[s5E],UB[s5E],PB[s5E])
endif
endfunction
function s7E takes integer s8E,unit s9E,string SvE returns nothing
set ZM[EM]=SvE
set EM=EM+1
if wm[s8E]==0 then
if s8E==0 then
call Cdv("Nullpointer exception when calling SingleAbilityData.apply","when calling error in UnitTypeData, line 855")
else
call Cdv("Called SingleAbilityData.apply on invalid object.","when calling error in UnitTypeData, line 855")
endif
endif
call s4E(s8E,s9E)
set EM=EM-1
endfunction
function SeE takes unit SxE,integer SoE,integer SrE,real SiE,integer SaE,integer SnE,integer SVE returns nothing
if Z8e(SoE,0)then
call N6e(SxE,SrE,SVE)
endif
if Z8e(SoE,2)then
call tEv(SxE,SiE,SVE)
endif
if Z8e(SoE,4)then
call tev(SxE,SaE,SVE)
endif
if Z8e(SoE,6)then
call N2e(SxE,SnE,SVE)
endif
endfunction
function SEE takes unit SXE,integer SOE,integer SRE,integer SIE,real SAE,integer SNE,integer SbE,integer SBE,integer ScE,real SCE,integer SdE,integer SDE,integer SfE,integer SFE,integer SgE returns nothing
if Z5e(SOE,0)then
call SeE(SXE,SRE,SIE,SAE,SNE,SbE,1)
endif
if Z5e(SOE,1)then
call SeE(SXE,SBE,ScE,SCE,SdE,SDE,2)
endif
if Z5e(SOE,2)then
call bpe(SXE,SfE)
endif
if Z5e(SOE,4)then
call bVe(SXE,SFE)
endif
call O0e(SXE,b7e(SXE))
if Z5e(SOE,6)then
call uBv(SXE,SgE)
endif
call Rqe(SXE,bOe(SXE))
endfunction
function SGE takes integer ShE,integer SHE returns boolean
return n9e(ShE,SHE)
endfunction
function SjE takes unit SJE,integer SkE returns nothing
call sWE(SJE,UNIT_TYPE_GIANT,SGE(SkE,0))
call sWE(SJE,UNIT_TYPE_SUMMONED,SGE(SkE,1))
call sWE(SJE,UNIT_TYPE_UNDEAD,SGE(SkE,2))
call sWE(SJE,UNIT_TYPE_MECHANICAL,SGE(SkE,3))
call sWE(SJE,UNIT_TYPE_PEON,SGE(SkE,4))
call sWE(SJE,UNIT_TYPE_SAPPER,SGE(SkE,5))
call sWE(SJE,UNIT_TYPE_ANCIENT,SGE(SkE,6))
endfunction
function SKE takes unit SlE,integer SLE,real SmE,integer SME,integer SpE,integer SPE,integer SqE,integer SQE,real SsE returns nothing
if vPx(SLE,0)then
call Nde(SlE,SmE)
endif
if vPx(SLE,3)then
call tuv(SlE,tWv(SME))
endif
if vPx(SLE,4)then
call Nre(SlE,SpE,SPE,SqE,SQE)
endif
if vPx(SLE,5)then
call NIe(SlE,SsE)
endif
endfunction
function SSE takes unit StE,integer STE,integer MCr,integer SuE,integer SUE,integer SwE,integer SWE returns nothing
call RGe(StE,Zle(STE,0))
call ZNv(StE,SuE,false)
if Zle(STE,1)then
call O8e(StE,SUE)
endif
if Zle(STE,3)then
call O8e(StE,SwE)
endif
if Zle(STE,5)then
call O8e(StE,SWE)
endif
endfunction
function SyE takes unit SYE,integer SzE,integer SZE,integer S_E,integer S0E,integer S1E,integer S2E,integer S3E,integer S4E returns nothing
if Zhe(SzE,0)then
call SSE(SYE,SZE,S_E,S0E,S1E,S2E,S3E)
endif
if Zhe(SzE,1)then
call bze(SYE,S4E)
endif
if Zhe(SzE,2)then
call bFe(SYE,1,false)
elseif Zhe(SzE,3)then
call bFe(SYE,1,true)
endif
call bFe(SYE,2,Zhe(SzE,4))
endfunction
function S5E takes integer S6E,player S7E,real S8E,real S9E,real tvE,string teE returns unit
local unit txE
local unit toE
local integer trE
local integer tiE
local integer taE
local integer tnE
set ZM[EM]=teE
set EM=EM+1
set toE=CreateUnit(S7E,RN[S6E],S8E,S9E,tvE)
call RSe(toE,Z2e(dN[S6E],0))
set txE=toE
if Z2e(dN[S6E],2)then
call Nee(txE,RAe(nN[S6E],TN[S6E],"when calling getString in UnitTypeData, line 1136"))
endif
call SKE(txE,YN[S6E],GN[S6E],gN[S6E],hN[S6E],FN[S6E],kN[S6E],jN[S6E],xN[S6E])
call sQE(txE,vN[S6E],mN[S6E],QN[S6E],WN[S6E],EN[S6E],ZN[S6E])
call SyE(txE,UN[S6E],IN[S6E],PN[S6E],AN[S6E],DN[S6E],HN[S6E],JN[S6E],KN[S6E])
call SEE(txE,LN[S6E],XN[S6E],CN[S6E],VN[S6E],BN[S6E],NN[S6E],MN[S6E],wM[S6E],uM[S6E],rM[S6E],sM[S6E],tM[S6E],iM[S6E],SM[S6E])
if Zhe(UN[S6E],5)then
set trE=Xle(cM[S6E],"when calling iterator in UnitTypeData, line 1145")
loop
exitwhen not Xie(trE)
set tiE=E3e(trE)
call TMv(txE,tiE)
endloop
call Xpe(trE,"when calling close in UnitTypeData, line 1145")
endif
if Zhe(UN[S6E],6)then
set taE=Xle(oM[S6E],"when calling iterator in UnitTypeData, line 1148")
loop
exitwhen not Xie(taE)
set tnE=E3e(taE)
call s7E(tnE,txE,"when calling apply in UnitTypeData, line 1149")
endloop
call Xpe(taE,"when calling close in UnitTypeData, line 1148")
endif
if Z2e(dN[S6E],1)then
call O3e(txE)
endif
call NQe(txE,not ZFe(fN[S6E],0))
call Rze(txE,S8E,S9E)
if ZFe(fN[S6E],1)then
call SjE(txE,OM[S6E])
endif
if ZFe(fN[S6E],2)then
call s1E(txE,lM[S6E])
endif
if ZFe(fN[S6E],3)then
call WaygateActivate(txE,true)
endif
set EM=EM-1
set IXv=txE
set txE=null
set toE=null
return IXv
endfunction
function tVE takes integer tEE,player tXE,real tOE,real tRE,real tIE,string tAE returns unit
local unit tNE
set ZM[EM]=tAE
set EM=EM+1
if lm[tEE]==0 then
if tEE==0 then
call Cdv("Nullpointer exception when calling UnitTypeData.create","when calling error in UnitTypeData, line 1131")
else
call Cdv("Called UnitTypeData.create on invalid object.","when calling error in UnitTypeData, line 1131")
endif
endif
set tNE=S5E(tEE,tXE,tOE,tRE,tIE,"when calling create in UnitTypeData, line 1131")
set EM=EM-1
set IYv=tNE
set tNE=null
return IYv
endfunction
function tbE takes integer tBE,player tcE,real tCE,real tdE,string tDE returns unit
local unit tfE
local unit tFE
local unit tgE
set ZM[EM]=tDE
set EM=EM+1
set tfE=tVE(smE(DB[tBE],HB[tBE],"when calling getUnitType in UnitTypeData, line 1329"),tcE,I_e(tCE,tdE,IYe(JB[tBE],KB[tBE]),d1),O1,LB[tBE],"when calling create in UnitTypeData, line 1329")
call O0e(tfE,DQv(XB[tBE]))
set tFE=tfE
call Rqe(tFE,DQv(CB[tBE]))
set tgE=tFE
set EM=EM-1
set IEv=tgE
set tfE=null
set tFE=null
set tgE=null
return IEv
endfunction
function tGE takes integer thE,player tHE,real tjE,real tJE,string tkE returns unit
local unit tKE
set ZM[EM]=tkE
set EM=EM+1
if tm[thE]==0 then
if thE==0 then
call Cdv("Nullpointer exception when calling SingleUnitData.create","when calling error in UnitTypeData, line 1328")
else
call Cdv("Called SingleUnitData.create on invalid object.","when calling error in UnitTypeData, line 1328")
endif
endif
set tKE=tbE(thE,tHE,tjE,tJE,"when calling create in UnitTypeData, line 1328")
set EM=EM-1
set Iyv=tKE
set tKE=null
return Iyv
endfunction
function tlE takes integer tLE,integer tmE,string tME returns nothing
local integer tpE
local integer tPE
set ZM[EM]=tME
set EM=EM+1
set tpE=vM[bN[tLE]]*25
set tPE=bUe(dgv(MB[yN[tLE]],"when calling size in UnitTypeData, line 1417"),(vM[bN[tLE]]+1)*25)-1
loop
exitwhen tpE>tPE
call tGE(jqv(MB[yN[tLE]],tpE,"when calling get in UnitTypeData, line 1418"),pN[tLE],eN[tLE],qN[tLE],"when calling create in UnitTypeData, line 1418")
set tpE=tpE+1
endloop
set vM[bN[tLE]]=vM[bN[tLE]]+1
if sEE(tmE,"when calling isLast in UnitTypeData, line 1420")then
call Bcx(bN[tLE],"when calling dispatch_Box⟪integer⟫_destroyBox⟪integer⟫ in UnitTypeData, line 1421")
call sCE(aN[tLE])
call shE(aN[tLE],"when calling dispatch_UnitDataPasteCallback_destroyUnitDataPasteCallback in UnitTypeData, line 1423")
endif
set EM=EM-1
endfunction
function tqE takes string tQE returns integer
local integer tsE
set ZM[EM]=tQE
set EM=EM+1
if jG==0 then
if xG<$8000 then
set xG=xG+1
set tsE=xG
set vG[tsE]=$47B
else
call Cdv("Out of memory: Could not create CallbackSingle_nullTimer_paste_load_setArgumentsTypes_registerProtectedBuiltin_SotfrpGuiRegions.","when calling error in SotfrpGuiRegions, line 169")
set tsE=0
endif
else
set jG=jG-1
set tsE=kG[jG]
set vG[tsE]=$47B
endif
set EM=EM-1
return tsE
endfunction
function tSE takes integer ttE,string tTE returns nothing
local integer tuE
set ZM[EM]=tTE
set EM=EM+1
call GDe("Загрузка завершена!",30.,sa[uX[ttE]])
set tuE=tqE("when calling alloc_CallbackSingle_nullTimer_paste_load_setArgumentsTypes_registerProtectedBuiltin_SotfrpGuiRegions in SotfrpGuiRegions, line 169")
call EUx(tuE)
set sX[tuE]=rX[ttE]
call Lsx(tuE,"when calling nullTimer in SotfrpGuiRegions, line 169")
set EM=EM-1
endfunction
function tUE takes integer twE,string tWE returns nothing
set ZM[EM]=tWE
set EM=EM+1
if Ck[twE]==0 then
if twE==0 then
call Cdv("Nullpointer exception when calling RegionDataPasteCallback.onPasted","when calling error in RegionData, line 25")
else
call Cdv("Called RegionDataPasteCallback.onPasted on invalid object.","when calling error in RegionData, line 25")
endif
endif
call tSE(twE,"when calling onPasted_paste_load_setArgumentsTypes_registerProtectedBuiltin_SotfrpGuiRegions in RegionData, line 25")
set EM=EM-1
endfunction
function tyE takes integer tYE,string tzE returns nothing
set ZM[EM]=tzE
set EM=EM+1
if Ck[tYE]==0 then
call Cdv("Double free: object of type RegionDataPasteCallback","when calling error in RegionData, line 24")
else
set Kk[Lk]=tYE
set Lk=Lk+1
set Ck[tYE]=0
endif
set EM=EM-1
endfunction
function tZE takes integer t_E,string t0E returns nothing
set ZM[EM]=t0E
set EM=EM+1
call tyE(t_E,"when calling dealloc_RegionDataPasteCallback in RegionData, line 24")
set EM=EM-1
endfunction
function t1E takes integer t2E,string t3E returns nothing
set ZM[EM]=t3E
set EM=EM+1
if Ck[t2E]==0 then
if t2E==0 then
call Cdv("Nullpointer exception when calling RegionDataPasteCallback.RegionDataPasteCallback","when calling error in RegionData, line 24")
else
call Cdv("Called RegionDataPasteCallback.RegionDataPasteCallback on invalid object.","when calling error in RegionData, line 24")
endif
endif
call tZE(t2E,"when calling destroyRegionDataPasteCallback in RegionData, line 24")
set EM=EM-1
endfunction
function t4E takes integer t5E,string t6E returns nothing
set ZM[EM]=t6E
set EM=EM+1
if wJ[t5E]!=0 then
call tUE(wJ[t5E],"when calling onPasted in RegionData, line 119")
call t1E(wJ[t5E],"when calling dispatch_RegionDataPasteCallback_destroyRegionDataPasteCallback in RegionData, line 120")
endif
set EM=EM-1
endfunction
function t7E takes integer t8E,string t9E returns nothing
set ZM[EM]=t9E
set EM=EM+1
if sj[t8E]==0 then
if t8E==0 then
call Cdv("Nullpointer exception when calling PositionedUnitDataPasteCallback.onPasted","when calling error in UnitData, line 1364")
else
call Cdv("Called PositionedUnitDataPasteCallback.onPasted on invalid object.","when calling error in UnitData, line 1364")
endif
endif
call t4E(t8E,"when calling onPasted_paste_paste_paste_RegionData_RegionData in UnitData, line 1364")
set EM=EM-1
endfunction
function TvE takes integer TeE,player TxE,real ToE,real TrE,string TiE returns unit
local unit TaE
set ZM[EM]=TiE
set EM=EM+1
set TaE=BFe(TeE,TxE,I_e(ToE,TrE,IYe(dV[TeE],fV[TeE]),d1),O1,RV[TeE],"when calling create in UnitData, line 1349")
set EM=EM-1
set Inv=TaE
set TaE=null
return Inv
endfunction
function TnE takes integer TVE,player TEE,real TXE,real TOE,string TRE returns unit
local unit TIE
set ZM[EM]=TRE
set EM=EM+1
if Dv[TVE]==0 then
if TVE==0 then
call Cdv("Nullpointer exception when calling SinglePositionedUnitData.create","when calling error in UnitData, line 1348")
else
call Cdv("Called SinglePositionedUnitData.create on invalid object.","when calling error in UnitData, line 1348")
endif
endif
set TIE=TvE(TVE,TEE,TXE,TOE,"when calling create in UnitData, line 1348")
set EM=EM-1
set Iwv=TIE
set TIE=null
return Iwv
endfunction
function TAE takes integer TNE,string TbE returns nothing
set ZM[EM]=TbE
set EM=EM+1
if sj[TNE]==0 then
call Cdv("Double free: object of type PositionedUnitDataPasteCallback","when calling error in UnitData, line 1363")
else
set wj[uj]=TNE
set uj=uj+1
set sj[TNE]=0
endif
set EM=EM-1
endfunction
function TBE takes integer TcE,string TCE returns nothing
set ZM[EM]=TCE
set EM=EM+1
call TAE(TcE,"when calling dealloc_PositionedUnitDataPasteCallback in UnitData, line 1363")
set EM=EM-1
endfunction
function TdE takes integer TDE,string TfE returns nothing
set ZM[EM]=TfE
set EM=EM+1
if sj[TDE]==0 then
if TDE==0 then
call Cdv("Nullpointer exception when calling PositionedUnitDataPasteCallback.PositionedUnitDataPasteCallback","when calling error in UnitData, line 1363")
else
call Cdv("Called PositionedUnitDataPasteCallback.PositionedUnitDataPasteCallback on invalid object.","when calling error in UnitData, line 1363")
endif
endif
call TBE(TDE,"when calling destroyPositionedUnitDataPasteCallback in UnitData, line 1363")
set EM=EM-1
endfunction
function TFE takes integer TgE,integer TGE,string ThE returns nothing
local integer THE
local integer TjE
set ZM[EM]=ThE
set EM=EM+1
set THE=vM[cV[TgE]]*25
set TjE=bUe(dgv(XC[oV[TgE]],"when calling size in UnitData, line 1434"),(vM[cV[TgE]]+1)*25)-1
loop
exitwhen THE>TjE
call TnE(jqv(XC[oV[TgE]],THE,"when calling get in UnitData, line 1435"),OV[TgE],lV[TgE],bV[TgE],"when calling create in UnitData, line 1435")
set THE=THE+1
endloop
set vM[cV[TgE]]=vM[cV[TgE]]+1
if sEE(TGE,"when calling isLast in UnitData, line 1437")then
call Bcx(cV[TgE],"when calling dispatch_Box⟪integer⟫_destroyBox⟪integer⟫ in UnitData, line 1438")
if yV[TgE]!=0 then
call t7E(yV[TgE],"when calling onPasted in UnitData, line 1440")
call TdE(yV[TgE],"when calling dispatch_PositionedUnitDataPasteCallback_destroyPositionedUnitDataPasteCallback in UnitData, line 1441")
endif
endif
set EM=EM-1
endfunction
function TJE takes integer TkE,integer TKE,string TlE returns nothing
set ZM[EM]=TlE
set EM=EM+1
if qg[TkE]==0 then
if TkE==0 then
call Cdv("Nullpointer exception when calling CallbackCounted.call","when calling error in ClosureTimers, line 148")
else
call Cdv("Called CallbackCounted.call on invalid object.","when calling error in ClosureTimers, line 148")
endif
endif
if qg[TkE]<=$462 then
if qg[TkE]<=$461 then
call sIE(TkE,TKE,"when calling call_doPeriodicallyCounted_PositionedDestructableData_DestructableData in ClosureTimers, line 148")
else
call TFE(TkE,TKE,"when calling call_doPeriodicallyCounted_PositionedUnitData_UnitData in ClosureTimers, line 148")
endif
else
call tlE(TkE,TKE,"when calling call_doPeriodicallyCounted_UnitData_UnitTypeData in ClosureTimers, line 148")
endif
set EM=EM-1
endfunction
function TLE takes integer TmE,string TME returns nothing
set ZM[EM]=TME
set EM=EM+1
if qg[TmE]==0 then
call Cdv("Double free: object of type CallbackCounted","when calling error in ClosureTimers, line 144")
else
set yg[pg]=TmE
set pg=pg+1
set qg[TmE]=0
endif
set EM=EM-1
endfunction
function TpE takes integer TPE,string TqE returns nothing
set ZM[EM]=TqE
set EM=EM+1
call atn(QW[TPE],"when calling release in ClosureTimers, line 176")
set EM=EM-1
endfunction
function TQE takes integer TsE,string TSE returns nothing
set ZM[EM]=TSE
set EM=EM+1
call TpE(TsE,"when calling CallbackCounted_onDestroy in ClosureTimers, line 175")
call TLE(TsE,"when calling dealloc_CallbackCounted in ClosureTimers, line 175")
set EM=EM-1
endfunction
function TtE takes integer TTE,string TuE returns nothing
set ZM[EM]=TuE
set EM=EM+1
if qg[TTE]==0 then
if TTE==0 then
call Cdv("Nullpointer exception when calling CallbackCounted.CallbackCounted","when calling error in ClosureTimers, line 144")
else
call Cdv("Called CallbackCounted.CallbackCounted on invalid object.","when calling error in ClosureTimers, line 144")
endif
endif
call TQE(TTE,"when calling destroyCallbackCounted in ClosureTimers, line 144")
set EM=EM-1
endfunction
function TUE takes integer TwE,string TWE returns nothing
set ZM[EM]=TWE
set EM=EM+1
if mW[TwE]>0 then
call TJE(TwE,TwE,"when calling call in ClosureTimers, line 170")
set mW[TwE]=mW[TwE]-1
else
call TtE(TwE,"when calling dispatch_CallbackCounted_destroyCallbackCounted in ClosureTimers, line 173")
endif
set EM=EM-1
endfunction
function TyE takes integer TYE,string TzE returns nothing
set ZM[EM]=TzE
set EM=EM+1
if qg[TYE]==0 then
if TYE==0 then
call Cdv("Nullpointer exception when calling CallbackCounted.callAndCount","when calling error in ClosureTimers, line 168")
else
call Cdv("Called CallbackCounted.callAndCount on invalid object.","when calling error in ClosureTimers, line 168")
endif
endif
call TUE(TYE,"when calling callAndCount in ClosureTimers, line 168")
set EM=EM-1
endfunction
function TZE takes string T_E returns nothing
set ZM[EM]=T_E
set EM=EM+1
call TyE(aqn(GetExpiredTimer(),"when calling getData in ClosureTimers, line 166"),"when calling callAndCount in ClosureTimers, line 166")
set EM=EM-1
endfunction
function T0E takes nothing returns nothing
set EM=0
call TZE("ClosureTimers, line 154")
endfunction
function T1E takes unit T2E returns nothing
if q5a(T2E)then
call sne(Ly,T2E,EVENT_UNIT_DAMAGED)
endif
endfunction
function T3E takes nothing returns nothing
call T1E(X1V())
endfunction
function T4E takes nothing returns nothing
set g[GetConvertedPlayerId(GetTriggerPlayer())]=GetUnitsOfPlayerAndTypeId(GetTriggerPlayer(),'h000')
call ForGroupBJ(g[GetConvertedPlayerId(GetTriggerPlayer())],vNv)
call DestroyGroup(g[GetPlayerId(GetTriggerPlayer())+1])
endfunction
function T5E takes string T6E returns integer
local integer T7E
set ZM[EM]=T6E
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set T7E=Yj
set Gj[T7E]=$B04
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdRectBuiltins.","when calling error in ScmdRectBuiltins, line 22")
set T7E=0
endif
else
set Tj=Tj-1
set T7E=Rj[Tj]
set Gj[T7E]=$B04
endif
set EM=EM-1
return T7E
endfunction
function T8E takes integer T9E,rect uvE returns nothing
call TBo(T9E)
set eK[T9E]=uvE
endfunction
function ueE takes rect uxE,string uoE returns integer
local integer urE
set ZM[EM]=uoE
set EM=EM+1
set urE=Tjo("when calling alloc_Rect in ScmdDataTypes, line 690")
call T8E(urE,uxE)
set EM=EM-1
return urE
endfunction
function uiE takes string uaE returns integer
local integer unE
set ZM[EM]=uaE
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set unE=Yj
set Gj[unE]=$B02
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdRectBuiltins.","when calling error in ScmdRectBuiltins, line 16")
set unE=0
endif
else
set Tj=Tj-1
set unE=Rj[Tj]
set Gj[unE]=$B02
endif
set EM=EM-1
return unE
endfunction
function uVE takes string uEE returns integer
local integer uXE
set ZM[EM]=uEE
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set uXE=Yj
set Gj[uXE]=$B00
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdRectBuiltins.","when calling error in ScmdRectBuiltins, line 10")
set uXE=0
endif
else
set Tj=Tj-1
set uXE=Rj[Tj]
set Gj[uXE]=$B00
endif
set EM=EM-1
return uXE
endfunction
function uOE takes string uRE returns integer
local integer uIE
set ZM[EM]=uRE
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set uIE=Yj
set Gj[uIE]=$B01
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdRectBuiltins.","when calling error in ScmdRectBuiltins, line 13")
set uIE=0
endif
else
set Tj=Tj-1
set uIE=Rj[Tj]
set Gj[uIE]=$B01
endif
set EM=EM-1
return uIE
endfunction
function uAE takes string uNE returns integer
local integer ubE
set ZM[EM]=uNE
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set ubE=Yj
set Gj[ubE]=$B03
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdRectBuiltins.","when calling error in ScmdRectBuiltins, line 19")
set ubE=0
endif
else
set Tj=Tj-1
set ubE=Rj[Tj]
set Gj[ubE]=$B03
endif
set EM=EM-1
return ubE
endfunction
function uBE takes string ucE returns integer
local integer uCE
set ZM[EM]=ucE
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set uCE=Yj
set Gj[uCE]=$B05
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdRectBuiltins.","when calling error in ScmdRectBuiltins, line 25")
set uCE=0
endif
else
set Tj=Tj-1
set uCE=Rj[Tj]
set Gj[uCE]=$B05
endif
set EM=EM-1
return uCE
endfunction
function udE takes string uDE returns integer
local integer ufE
set ZM[EM]=uDE
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set ufE=Yj
set Gj[ufE]=$A2E
else
call Cdv("Out of memory: Could not create IBuiltin_registerProtectedBuiltin_ScmdRectBuiltins.","when calling error in ScmdRectBuiltins, line 35")
set ufE=0
endif
else
set Tj=Tj-1
set ufE=Rj[Tj]
set Gj[ufE]=$A2E
endif
set EM=EM-1
return ufE
endfunction
function uFE takes string ugE returns integer
local integer uGE
set ZM[EM]=ugE
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set uGE=Yj
set Gj[uGE]=$B07
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdRectBuiltins.","when calling error in ScmdRectBuiltins, line 31")
set uGE=0
endif
else
set Tj=Tj-1
set uGE=Rj[Tj]
set Gj[uGE]=$B07
endif
set EM=EM-1
return uGE
endfunction
function uhE takes string uHE returns integer
local integer ujE
set ZM[EM]=uHE
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set ujE=Yj
set Gj[ujE]=$B06
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdRectBuiltins.","when calling error in ScmdRectBuiltins, line 28")
set ujE=0
endif
else
set Tj=Tj-1
set ujE=Rj[Tj]
set Gj[ujE]=$B06
endif
set EM=EM-1
return ujE
endfunction
function uJE takes string ukE returns boolean
local integer uKE
local integer ulE
local integer uLE
local integer umE
local integer uME
local integer upE
local integer uPE
local integer uqE
local integer uQE
local integer usE
local integer uSE
local integer utE
local integer uTE
local integer uuE
local integer uUE
local integer uwE
local integer uWE
set ZM[EM]=ukE
set EM=EM+1
set vd=p0v(ueE(We,"when calling new_Rect in ScmdRectBuiltins, line 7"),"when calling new_SharedPointer in ScmdRectBuiltins, line 7")
set uKE=uVE("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdRectBuiltins in ScmdRectBuiltins, line 10")
set ulE=OPo(uKE,"when calling new_BuiltinData in ScmdRectBuiltins, line 10")
call glV(ulE,gQV(),gQV(),gQV(),gQV(),"when calling setArgumentsTypes in ScmdRectBuiltins, line 12")
call Foa(ILo(ulE,"when calling new_BuiltinFunction in ScmdRectBuiltins, line 10"),"rect","when calling registerProtectedBuiltin in ScmdRectBuiltins, line 10")
set uLE=uOE("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdRectBuiltins in ScmdRectBuiltins, line 13")
set umE=OPo(uLE,"when calling new_BuiltinData in ScmdRectBuiltins, line 13")
call Rxo(umE,e5V(),"when calling setArgumentsTypes in ScmdRectBuiltins, line 15")
call Foa(ILo(umE,"when calling new_BuiltinFunction in ScmdRectBuiltins, line 13"),"getrectmaxx","when calling registerProtectedBuiltin in ScmdRectBuiltins, line 13")
set uME=uiE("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdRectBuiltins in ScmdRectBuiltins, line 16")
set upE=OPo(uME,"when calling new_BuiltinData in ScmdRectBuiltins, line 16")
call Rxo(upE,e5V(),"when calling setArgumentsTypes in ScmdRectBuiltins, line 18")
call Foa(ILo(upE,"when calling new_BuiltinFunction in ScmdRectBuiltins, line 16"),"getrectmaxy","when calling registerProtectedBuiltin in ScmdRectBuiltins, line 16")
set uPE=uAE("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdRectBuiltins in ScmdRectBuiltins, line 19")
set uqE=OPo(uPE,"when calling new_BuiltinData in ScmdRectBuiltins, line 19")
call Rxo(uqE,e5V(),"when calling setArgumentsTypes in ScmdRectBuiltins, line 21")
call Foa(ILo(uqE,"when calling new_BuiltinFunction in ScmdRectBuiltins, line 19"),"getrectminx","when calling registerProtectedBuiltin in ScmdRectBuiltins, line 19")
set uQE=T5E("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdRectBuiltins in ScmdRectBuiltins, line 22")
set usE=OPo(uQE,"when calling new_BuiltinData in ScmdRectBuiltins, line 22")
call Rxo(usE,e5V(),"when calling setArgumentsTypes in ScmdRectBuiltins, line 24")
call Foa(ILo(usE,"when calling new_BuiltinFunction in ScmdRectBuiltins, line 22"),"getrectminy","when calling registerProtectedBuiltin in ScmdRectBuiltins, line 22")
set uSE=uBE("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdRectBuiltins in ScmdRectBuiltins, line 25")
set utE=OPo(uSE,"when calling new_BuiltinData in ScmdRectBuiltins, line 25")
call Rxo(utE,e5V(),"when calling setArgumentsTypes in ScmdRectBuiltins, line 27")
call Foa(ILo(utE,"when calling new_BuiltinFunction in ScmdRectBuiltins, line 25"),"getrectcenterx","when calling registerProtectedBuiltin in ScmdRectBuiltins, line 25")
set uTE=uhE("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdRectBuiltins in ScmdRectBuiltins, line 28")
set uuE=OPo(uTE,"when calling new_BuiltinData in ScmdRectBuiltins, line 28")
call Rxo(uuE,e5V(),"when calling setArgumentsTypes in ScmdRectBuiltins, line 30")
call Foa(ILo(uuE,"when calling new_BuiltinFunction in ScmdRectBuiltins, line 28"),"getrectcentery","when calling registerProtectedBuiltin in ScmdRectBuiltins, line 28")
set uUE=uFE("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdRectBuiltins in ScmdRectBuiltins, line 31")
set uwE=OPo(uUE,"when calling new_BuiltinData in ScmdRectBuiltins, line 31")
call etV(uwE,e5V(),gQV(),gQV(),"when calling setArgumentsTypes in ScmdRectBuiltins, line 34")
call Foa(ILo(uwE,"when calling new_BuiltinFunction in ScmdRectBuiltins, line 31"),"moverectto","when calling registerProtectedBuiltin in ScmdRectBuiltins, line 31")
set uWE=udE("when calling alloc_IBuiltin_registerProtectedBuiltin_ScmdRectBuiltins in ScmdRectBuiltins, line 35")
call Foa(ILo(OPo(uWE,"when calling new_BuiltinData in ScmdRectBuiltins, line 35"),"when calling new_BuiltinFunction in ScmdRectBuiltins, line 35"),"getentiremaprect","when calling registerProtectedBuiltin in ScmdRectBuiltins, line 35")
set EM=EM-1
return true
endfunction
function uyE takes nothing returns boolean
set EM=0
return uJE("ScmdRectBuiltins, line 1")
endfunction
function uYE takes nothing returns boolean
set KT[0]=0
set KT[1]='AM01'
set KT[2]='AM02'
set KT[3]='AM03'
set KT[4]='AM04'
set KT[5]='AM05'
set KT[6]=iy
set LT=GetCameraBoundMaxX()+GetCameraMargin(CAMERA_MARGIN_RIGHT)
set XT=GetCameraBoundMinX()-GetCameraMargin(CAMERA_MARGIN_LEFT)
set CT=GetCameraBoundMaxY()+GetCameraMargin(CAMERA_MARGIN_TOP)
set VT=GetCameraBoundMinY()-GetCameraMargin(CAMERA_MARGIN_BOTTOM)
set BT=InitHashtable()
return true
endfunction
function uzE takes nothing returns boolean
return(CountUnitsInGroup(Lu)==0)and(CountUnitsInGroup(Hu)==0)and(CountUnitsInGroup(Ku)==0)
endfunction
function uZE takes nothing returns nothing
set Du=Du+1
call ForGroupBJ(Hu,q0)
call ForGroupBJ(Ku,Q0)
if uzE()then
set Du=0
call DisableTrigger(GetTriggeringTrigger())
endif
endfunction
function u_E takes nothing returns nothing
call GroupRemoveUnit(lt,GetSpellAbilityUnit())
endfunction
function u0E takes nothing returns boolean
return IsPlayerEnemy(GetOwningPlayer(GetFilterUnit()),GetOwningPlayer(GetSpellAbilityUnit()))==false
endfunction
function u1E takes nothing returns nothing
local unit u2E=GetSpellAbilityUnit()
local location u3E=GetSpellTargetLoc()
local boolean u4E=BlzIsUnitInvulnerable(u2E)
local effect u5E=AddSpecialEffectTarget("Objects\\Spawnmodels\\Undead\\ImpaleTargetDust\\ImpaleTargetDust.mdl",u2E,"chest")
call PauseUnit(u2E,true)
call SetUnitInvulnerable(u2E,true)
call pAa(1.)
call DestroyEffect(u5E)
call SetUnitPositionLoc(u2E,u3E)
set u3E=null
set u5E=AddSpecialEffectTarget("Objects\\Spawnmodels\\Undead\\ImpaleTargetDust\\ImpaleTargetDust.mdl",u2E,"chest")
call pAa(1.)
call DestroyEffect(u5E)
call SetUnitInvulnerable(u2E,u4E)
call PauseUnit(u2E,false)
call SetUnitAnimation(u2E,"stand")
set u2E=null
set u5E=null
set u2E=null
set u3E=null
set u5E=null
endfunction
function u6E takes nothing returns nothing
if GetSpellAbilityId()!=ul or GetUnitAbilityLevel(GetSpellTargetUnit(),Sl)==0 then
return
endif
call IssueImmediateOrderById(GetSpellAbilityUnit(),$D0004)
endfunction
function u7E takes nothing returns nothing
if GetDestructableTypeId(GetSpellTargetDestructable())=='DTlv' then
set kw[GetPlayerId(GetTriggerPlayer())]=GetSpellTargetDestructable()
call RemoveUnit(ss[GetPlayerId(GetTriggerPlayer())])
set ss[GetPlayerId(GetTriggerPlayer())]=CreateUnitAtLoc(GetTriggerPlayer(),'h0Q6',GetUnitLoc(GetSpellAbilityUnit()),270.)
else
call zZV(GetOwningPlayer(GetSpellAbilityUnit()),"",true,false)
endif
endfunction
function u8E takes nothing returns boolean
return(GetSpellAbilityId()=='A0G4')
endfunction
function u9E takes nothing returns nothing
local group UvE=CreateGroup()
call GroupEnumUnitsOfPlayer(UvE,GetTriggerPlayer(),Condition(e8v))
call ForGroup(UvE,e9v)
call DestroyGroup(UvE)
set UvE=null
set UvE=null
endfunction
function UeE takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),1,3)=="add")
endfunction
function UxE takes nothing returns boolean
return(GetUnitTypeId(GetEnumUnit())!='h000')and(IsUnitSelected(GetEnumUnit(),GetTriggerPlayer()))and(GetUnitTypeId(GetEnumUnit())!='h0KW')
endfunction
function UoE takes nothing returns nothing
if UxE()then
call UnitAddTypeBJ(UNIT_TYPE_STRUCTURE,GetEnumUnit())
call UnitRemoveAbilityBJ('Amov',GetEnumUnit())
endif
endfunction
function UrE takes nothing returns nothing
local string UiE=GetEventPlayerChatString()
local player UaE=GetTriggerPlayer()
set x=x+1
set v[30]=v[29]
set v[29]=v[28]
set v[28]=v[27]
set v[27]=v[26]
set v[26]=v[25]
set v[25]=v[24]
set v[24]=v[23]
set v[23]=v[22]
set v[22]=v[21]
set v[21]=v[20]
set v[20]=v[19]
set v[19]=v[18]
set v[18]=v[17]
set v[17]=v[16]
set v[16]=v[$F]
set v[$F]=v[$E]
set v[$E]=v[$D]
set v[$D]=v[$C]
set v[$C]=v[$B]
set v[$B]=v[$A]
set v[$A]=v[9]
set v[9]=v[8]
set v[8]=v[7]
set v[7]=v[6]
set v[6]=v[5]
set v[5]=v[4]
set v[4]=v[3]
set v[3]=v[2]
set v[2]=v[1]
if UiE!="516b1b971d90fd815f889fd50ac4e3a2a8d0dc5b28736ce07441aef387cdb54968a8666ee1dd2dc47e308adc87e4e8be60ca0d2359b31efa0f671370f1cf4av" then
set v[1]="|CFF808040["+I2S(x)+"] CMDLOG:|R "+k[GetPlayerId(UaE)]+UiE
else
set v[1]="|CFF808040["+I2S(x)+"] CMDLOG:|R "+k[GetPlayerId(UaE)]+GetPlayerName(UaE)+"|R |CFF808040начал загрузку области.|R"
endif
set UaE=null
set UaE=null
endfunction
function UnE takes destructable UVE returns integer
return C0v(UVE)
endfunction
function UEE takes string UXE returns nothing
local unit UOE
local unit URE
local unit UIE
set ZM[EM]=UXE
set EM=EM+1
set UOE=vTV()
if umv(UOE)==Wf then
set URE=UOE
call tSv(URE,oa)
set UIE=URE
call w0v(UIE,$FF,$FF,$FF,25)
if ta!=HVo(UOE)then
call NXe(UOE,.0)
endif
call fqv(Ef,Hzo(UOE),UnE(CreateDestructableZ('OTis',QJv(UOE),uev(UOE),Mko(uov(UOE),c3)+150.,270.,1.,1)),"when calling put in SotfrpGuiDestructables, line 104")
endif
set EM=EM-1
set UOE=null
set URE=null
set UIE=null
endfunction
function UAE takes nothing returns nothing
set EM=0
call UEE("SotfrpGuiDestructables, line 98")
endfunction
function UNE takes nothing returns boolean
return true
endfunction
function UbE takes integer UBE,integer UcE returns nothing
set kM[UBE]=UcE
endfunction
function UCE takes integer UdE,integer UDE,string UfE returns nothing
set ZM[EM]=UfE
set EM=EM+1
if Im[UdE]==0 then
if UdE==0 then
call Cdv("Nullpointer exception when calling Buff⟪integer⟫.onApplication","when calling error in Buffs, line 27")
else
call Cdv("Called Buff⟪integer⟫.onApplication on invalid object.","when calling error in Buffs, line 27")
endif
endif
call UbE(UdE,UDE)
set EM=EM-1
endfunction
function UFE takes string UgE returns integer
local integer UGE
set ZM[EM]=UgE
set EM=EM+1
if ij==0 then
if Sj<$8000 then
set Sj=Sj+1
set UGE=Sj
set cj[UGE]=$7AB
else
call Cdv("Out of memory: Could not create EventHandler_onApplication_RollTheBones.","when calling error in RollTheBones, line 28")
set UGE=0
endif
else
set ij=ij-1
set UGE=tj[ij]
set cj[UGE]=$7AB
endif
set EM=EM-1
return UGE
endfunction
function UhE takes integer UHE,integer UjE returns nothing
set jM[UHE]=UjE
endfunction
function UJE takes integer UkE,integer UKE,string UlE returns nothing
set ZM[EM]=UlE
set EM=EM+1
if Im[UkE]==0 then
if UkE==0 then
call Cdv("Nullpointer exception when calling Buff⟪integer⟫.onRemoval","when calling error in Buffs, line 33")
else
call Cdv("Called Buff⟪integer⟫.onRemoval on invalid object.","when calling error in Buffs, line 33")
endif
endif
call UhE(UkE,UKE)
set EM=EM-1
endfunction
function ULE takes integer UmE,integer UME,string UpE returns integer
local integer UPE
set ZM[EM]=UpE
set EM=EM+1
set UPE=haa(null,UmE,UME,"when calling addSpellInternal in ClosureEvents, line 141")
set EM=EM-1
return UPE
endfunction
function UqE takes integer lnS,integer bnS returns nothing
endfunction
function UQE takes integer UsE,integer USE,string UtE returns nothing
set ZM[EM]=UtE
set EM=EM+1
if Im[UsE]==0 then
if UsE==0 then
call Cdv("Nullpointer exception when calling Buff⟪integer⟫.onExpiration","when calling error in Buffs, line 30")
else
call Cdv("Called Buff⟪integer⟫.onExpiration on invalid object.","when calling error in Buffs, line 30")
endif
endif
call UqE(UsE,USE)
set EM=EM-1
endfunction
function UTE takes string UuE returns integer
local integer UUE
set ZM[EM]=UuE
set EM=EM+1
if ij==0 then
if Sj<$8000 then
set Sj=Sj+1
set UUE=Sj
set cj[UUE]=$7AF
else
call Cdv("Out of memory: Could not create EventHandler_onRemoval_RollTheBones.","when calling error in RollTheBones, line 37")
set UUE=0
endif
else
set ij=ij-1
set UUE=tj[ij]
set cj[UUE]=$7AF
endif
set EM=EM-1
return UUE
endfunction
function UwE takes string UWE returns integer
local integer UyE
set ZM[EM]=UWE
set EM=EM+1
if ij==0 then
if Sj<$8000 then
set Sj=Sj+1
set UyE=Sj
set cj[UyE]=$7AC
else
call Cdv("Out of memory: Could not create EventHandler_onApplication_RollTheBones.","when calling error in RollTheBones, line 44")
set UyE=0
endif
else
set ij=ij-1
set UyE=tj[ij]
set cj[UyE]=$7AC
endif
set EM=EM-1
return UyE
endfunction
function UYE takes string UzE returns integer
local integer UZE
set ZM[EM]=UzE
set EM=EM+1
if BG==0 then
if NG<$8000 then
set NG=NG+1
set UZE=NG
set MG[UZE]=$F33
else
call Cdv("Out of memory: Could not create OnCastListener_onCast_RollTheBones.","when calling error in RollTheBones, line 47")
set UZE=0
endif
else
set BG=BG-1
set UZE=VG[BG]
set MG[UZE]=$F33
endif
set EM=EM-1
return UZE
endfunction
function U_E takes string U0E returns integer
local integer U1E
set ZM[EM]=U0E
set EM=EM+1
if ij==0 then
if Sj<$8000 then
set Sj=Sj+1
set U1E=Sj
set cj[U1E]=$7AE
else
call Cdv("Out of memory: Could not create EventHandler_onExpiration_onRemoval_RollTheBones.","when calling error in RollTheBones, line 35")
set U1E=0
endif
else
set ij=ij-1
set U1E=tj[ij]
set cj[U1E]=$7AE
endif
set EM=EM-1
return U1E
endfunction
function U2E takes string U3E returns integer
local integer U4E
set ZM[EM]=U3E
set EM=EM+1
if ij==0 then
if Sj<$8000 then
set Sj=Sj+1
set U4E=Sj
set cj[U4E]=$7AD
else
call Cdv("Out of memory: Could not create EventHandler_onApplication_onExpiration_onRemoval_RollTheBones.","when calling error in RollTheBones, line 32")
set U4E=0
endif
else
set ij=ij-1
set U4E=tj[ij]
set cj[U4E]=$7AD
endif
set EM=EM-1
return U4E
endfunction
function U5E takes string U6E returns boolean
local integer U7E
local integer U8E
local integer U9E
local integer wvE
local integer weE
local integer wxE
local integer woE
local integer wrE
local integer wiE
local integer waE
local integer wnE
local integer wVE
local integer wEE
local integer wXE
local integer wOE
local integer wRE
local integer wIE
local integer wAE
local integer wNE
local integer wbE
local integer wBE
local integer wcE
local integer wCE
set ZM[EM]=U6E
set EM=EM+1
set ma='Artb'
set Qa=$F
set wAE='AM08'
set wNE='BM03'
set Wa=wAE
set Ea=wNE
set U8E=M4a("when calling new_Buff⟪integer⟫ in RollTheBones, line 28")
set wVE=U8E
set U7E=UFE("when calling alloc_EventHandler_onApplication_RollTheBones in RollTheBones, line 28")
call UCE(wVE,U7E,"when calling onApplication in RollTheBones, line 28")
set wbE='AM0a'
set wBE='BM04'
set Za=wbE
set Ua=wBE
set wvE=M4a("when calling new_Buff⟪integer⟫ in RollTheBones, line 32")
set wEE=wvE
set U9E=U2E("when calling alloc_EventHandler_onApplication_onExpiration_onRemoval_RollTheBones in RollTheBones, line 32")
call UCE(wEE,U9E,"when calling onApplication in RollTheBones, line 32")
set wxE=wvE
set wXE=wxE
set weE=U_E("when calling alloc_EventHandler_onExpiration_onRemoval_RollTheBones in RollTheBones, line 35")
call UQE(wXE,weE,"when calling onExpiration in RollTheBones, line 35")
set wrE=wxE
set wOE=wrE
set woE=UTE("when calling alloc_EventHandler_onRemoval_RollTheBones in RollTheBones, line 37")
call UJE(wOE,woE,"when calling onRemoval in RollTheBones, line 37")
set Ia=wrE
set wcE='AM0c'
set wCE='BM05'
set Pa=wcE
set Aa=wCE
set waE=M4a("when calling new_Buff⟪integer⟫ in RollTheBones, line 44")
set wRE=waE
set wiE=UwE("when calling alloc_EventHandler_onApplication_RollTheBones in RollTheBones, line 44")
call UCE(wRE,wiE,"when calling onApplication in RollTheBones, line 44")
set Da=waE
set wIE=ma
set wnE=UYE("when calling alloc_OnCastListener_onCast_RollTheBones in RollTheBones, line 47")
call Gla(wnE)
call ULE(wIE,wnE,"when calling onCast in RollTheBones, line 47")
set EM=EM-1
return true
endfunction
function wdE takes nothing returns boolean
set EM=0
return U5E("RollTheBones, line 1")
endfunction
function wDE takes nothing returns nothing
local trigger wfE=CreateTrigger()
call Avv(wfE,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(wfE,Filter(OWv))
call TriggerRegisterEnterRegion(Tq,Ee,Filter(Oyv))
call TriggerAddCondition(Yq,Filter(OYv))
set wfE=null
endfunction
function wFE takes nothing returns boolean
set dq='A0KE'
set fq='B05A'
set Rq='A0KF'
set Tq=CreateTrigger()
set Yq=CreateTrigger()
set Gq="Abilities\\Spells\\Custom\\Obliterate\\Obliterate"
set gq="Abilities\\Spells\\Custom\\Obliterate\\ObliterateTarget.wav"
call wDE()
return true
endfunction
function wgE takes nothing returns boolean
return(Mu==1)
endfunction
function wGE takes nothing returns boolean
return(Mu==2)
endfunction
function whE takes nothing returns nothing
if wgE()then
call UnitDamageTargetBJ(Nu,GetEnumUnit(),xu,ATTACK_TYPE_NORMAL,DAMAGE_TYPE_COLD)
call AddSpecialEffectTargetUnitBJ("chest",GetEnumUnit(),"Abilities\\Weapons\\LichMissile\\LichMissile.mdl")
elseif wGE()then
call UnitDamageTargetBJ(Nu,GetEnumUnit(),vu,ATTACK_TYPE_NORMAL,DAMAGE_TYPE_FIRE)
call AddSpecialEffectTargetUnitBJ("chest",GetEnumUnit(),"Abilities\\Weapons\\RedDragonBreath\\RedDragonMissile.mdl")
else
call UnitDamageTargetBJ(Nu,GetEnumUnit(),mu,ATTACK_TYPE_NORMAL,DAMAGE_TYPE_LIGHTNING)
call AddSpecialEffectTargetUnitBJ("chest",GetEnumUnit(),"Abilities\\Weapons\\FarseerMissile\\FarseerMissile.mdl")
endif
call DestroyEffectBJ(GetLastCreatedEffectBJ())
endfunction
function wHE takes nothing returns nothing
local location wjE=GetSpellTargetLoc()
local effect wJE=AddSpecialEffectLoc("Abilities\\Spells\\Other\\TalkToMe\\TalkToMe.mdl",wjE)
local effect wkE=AddSpecialEffectLoc("Abilities\\Spells\\Human\\FlameStrike\\FlameStrikeTarget.mdl",wjE)
local unit wKE=GetSpellAbilityUnit()
local unit wlE=CreateUnitAtLoc(Player(PLAYER_NEUTRAL_PASSIVE),'h0JO',GetUnitLoc(wKE),GetUnitFacing(wKE))
call UnitAddAbility(wlE,'A0A6')
call pAa(.5)
call IssuePointOrderByIdLoc(wlE,$D0208,wjE)
call pAa(.5)
call DestroyEffect(wJE)
set wJE=null
call DestroyEffect(wkE)
set wkE=null
call DestroyEffect(AddSpecialEffectLoc("Objects\\Spawnmodels\\Other\\NeutralBuildingExplosion\\NeutralBuildingExplosion.mdl",wjE))
call DestroyEffect(AddSpecialEffectLoc("war3mapImported\\NewMassiveEX.mdx",wjE))
call UnitDamagePoint(wKE,.0,200.,GetLocationX(wjE),GetLocationY(wjE),475.,true,true,ATTACK_TYPE_NORMAL,DAMAGE_TYPE_MAGIC,WEAPON_TYPE_WHOKNOWS)
set wKE=null
call pAa(10.)
call RemoveLocation(wjE)
set wjE=null
call RemoveUnit(wlE)
set wlE=null
set wjE=null
set wJE=null
set wkE=null
set wKE=null
set wlE=null
endfunction
function wLE takes nothing returns nothing
local unit wmE=GetSpellAbilityUnit()
local location wME=GetSpellTargetLoc()
local integer wpE=GetUnitAbilityLevel(wmE,'A04K')
local unit wPE=CreateUnitAtLoc(GetOwningPlayer(wmE),'h0JO',GetUnitLoc(wmE),270.)
local group wqE=CreateGroup()
call UnitAddAbility(wPE,'A099')
call SetUnitAbilityLevel(wPE,'A099',wpE)
call IssuePointOrderByIdLoc(wPE,$D0079,wME)
call pAa(1.)
call GroupEnumUnitsInRangeOfLoc(wqE,wME,200.,Condition(npv))
set gt=wpE
set ht=wmE
call ForGroup(wqE,nPv)
set ht=null
set gt=0
call DestroyGroup(wqE)
set wqE=CreateGroup()
call GroupEnumUnitsInRangeOfLoc(wqE,wME,200.,Condition(nqv))
set gt=wpE
call ForGroup(wqE,nQv)
set gt=0
call DestroyGroup(wqE)
set wqE=CreateGroup()
call IssuePointOrderByIdLoc(wPE,$D0079,wME)
call pAa(1.)
call GroupEnumUnitsInRangeOfLoc(wqE,wME,200.,Condition(npv))
set gt=wpE
set ht=wmE
call ForGroup(wqE,nPv)
set ht=null
set gt=0
call DestroyGroup(wqE)
set wqE=CreateGroup()
call GroupEnumUnitsInRangeOfLoc(wqE,wME,200.,Condition(nqv))
set gt=wpE
call ForGroup(wqE,nQv)
set gt=0
call DestroyGroup(wqE)
set wqE=CreateGroup()
call IssuePointOrderByIdLoc(wPE,$D0079,wME)
call pAa(1.)
call GroupEnumUnitsInRangeOfLoc(wqE,wME,200.,Condition(npv))
set gt=wpE
set ht=wmE
call ForGroup(wqE,nPv)
set ht=null
set gt=0
call DestroyGroup(wqE)
set wqE=CreateGroup()
call GroupEnumUnitsInRangeOfLoc(wqE,wME,200.,Condition(nqv))
set gt=wpE
call ForGroup(wqE,nQv)
set gt=0
call DestroyGroup(wqE)
set wqE=null
call RemoveLocation(wME)
set wME=null
set wmE=null
set wpE=0
call pAa(1.)
call RemoveUnit(wPE)
set wPE=null
set wmE=null
set wME=null
set wPE=null
set wqE=null
endfunction
function wQE takes nothing returns nothing
local unit wsE=GetEnumUnit()
local unit wSE=CreateUnitAtLoc(Player($F),'h0JO',GetUnitLoc(wsE),270.)
call UnitAddAbility(wSE,'A0A4')
call IssueTargetOrderById(wSE,$D0011,wsE)
call oLn(wSE,3.)
set wsE=null
set wSE=null
set wsE=null
set wSE=null
endfunction
function wtE takes nothing returns nothing
local unit wTE=GetSpellAbilityUnit()
local unit wuE=GetSpellTargetUnit()
call UnitDamageTarget(wTE,wuE,'}'*GetUnitAbilityLevel(wTE,'AOha')-25,true,true,ATTACK_TYPE_NORMAL,DAMAGE_TYPE_MAGIC,WEAPON_TYPE_WHOKNOWS)
call cRv(AddSpecialEffect("Abilities\\Spells\\Orc\\LiquidFire\\Liquidfire.mdl",GetUnitX(wuE),GetUnitY(wuE)),1.)
set wuE=null
set wTE=null
set wTE=null
set wuE=null
endfunction
function wUE takes nothing returns boolean
return IsUnitSelected(GetFilterUnit(),GetTriggerPlayer())
endfunction
function wwE takes nothing returns nothing
local string wWE=GetEventPlayerChatString()
local player wyE=GetTriggerPlayer()
local group wYE
call GetPlayerId(wyE)
call StringLength(wWE)
if wWE=="@attack" then
set wYE=CreateGroup()
call GroupEnumUnitsOfPlayer(wYE,wyE,Condition(eQv))
call ForGroup(wYE,esv)
call DestroyGroup(wYE)
set wYE=null
set wyE=null
set wyE=null
set wYE=null
return
endif
if wWE=="@aiswitcher" then
set wYE=CreateGroup()
call GroupEnumUnitsOfPlayer(wYE,wyE,Condition(eQv))
call ForGroup(wYE,eSv)
call DestroyGroup(wYE)
set wYE=null
set wyE=null
set wyE=null
set wYE=null
return
endif
set wYE=null
set wyE=null
set wyE=null
set wYE=null
endfunction
function wzE takes hashtable wZE,integer w_E,integer w0E returns destructable
return LoadDestructableHandle(wZE,w_E,w0E)
endfunction
function w1E takes integer w2E,integer w3E returns destructable
return wzE(XR,w2E,w3E)
endfunction
function w4E takes integer w5E,integer w6E,string w7E returns destructable
local destructable w8E
set ZM[EM]=w7E
set EM=EM+1
if ph[w5E]==0 then
if w5E==0 then
call Cdv("Nullpointer exception when calling Table.loadDestructable","when calling error in Table, line 81")
else
call Cdv("Called Table.loadDestructable on invalid object.","when calling error in Table, line 81")
endif
endif
set w8E=w1E(w5E,w6E)
set EM=EM-1
set ISv=w8E
set w8E=null
return ISv
endfunction
function w9E takes integer WvE,string WeE returns destructable
local destructable WxE
set ZM[EM]=WeE
set EM=EM+1
call zix(RT,0,ConvertFogState(WvE),"when calling saveFogState in TypeCasting, line 60")
set WxE=w4E(RT,0,"when calling loadDestructable in TypeCasting, line 61")
set EM=EM-1
set R0v=WxE
set WxE=null
return R0v
endfunction
function WoE takes string WrE returns nothing
local unit WiE
set ZM[EM]=WrE
set EM=EM+1
set WiE=vTV()
if umv(WiE)==Wf then
call bNe(w9E(f3v(Ef,Hzo(WiE),"when calling get in SotfrpGuiDestructables, line 108"),"when calling destructableFromIndex in SotfrpGuiDestructables, line 108"))
endif
set EM=EM-1
set WiE=null
endfunction
function WaE takes nothing returns nothing
set EM=0
call WoE("SotfrpGuiDestructables, line 105")
endfunction
function WnE takes nothing returns boolean
return(Mu==1)
endfunction
function WVE takes nothing returns boolean
return(Mu==2)
endfunction
function WEE takes nothing returns nothing
if WnE()then
call UnitDamageTargetBJ(Nu,GetEnumUnit(),xu,ATTACK_TYPE_NORMAL,DAMAGE_TYPE_COLD)
call AddSpecialEffectTargetUnitBJ("chest",GetEnumUnit(),"Abilities\\Weapons\\LichMissile\\LichMissile.mdl")
elseif WVE()then
call UnitDamageTargetBJ(Nu,GetEnumUnit(),vu,ATTACK_TYPE_NORMAL,DAMAGE_TYPE_FIRE)
call AddSpecialEffectTargetUnitBJ("chest",GetEnumUnit(),"Abilities\\Weapons\\RedDragonBreath\\RedDragonMissile.mdl")
else
call UnitDamageTargetBJ(Nu,GetEnumUnit(),mu,ATTACK_TYPE_NORMAL,DAMAGE_TYPE_LIGHTNING)
call AddSpecialEffectTargetUnitBJ("chest",GetEnumUnit(),"Abilities\\Weapons\\FarseerMissile\\FarseerMissile.mdl")
endif
call DestroyEffectBJ(GetLastCreatedEffectBJ())
endfunction
function WXE takes string WOE returns integer
local integer WRE
set ZM[EM]=WOE
set EM=EM+1
if hj==0 then
if Fj<$8000 then
set Fj=Fj+1
set WRE=Fj
set kj[WRE]=$4B0
else
call Cdv("Out of memory: Could not create Channel.","when calling error in SLangChatSystem, line 135")
set WRE=0
endif
else
set hj=hj-1
set WRE=gj[hj]
set kj[WRE]=$4B0
endif
set EM=EM-1
return WRE
endfunction
function WIE takes integer WAE returns nothing
set SJ[WAE]=0
endfunction
function WNE takes integer WbE,string WBE returns nothing
set ZM[EM]=WBE
set EM=EM+1
call WIE(WbE)
set tJ[WbE]=yTv("when calling new_LinkedList in SLangChatSystem, line 96")
set iJ[WbE]=BQa("when calling new_HashSet in SLangChatSystem, line 97")
set EM=EM-1
endfunction
function WcE takes string WCE returns integer
local integer WdE
set ZM[EM]=WCE
set EM=EM+1
if xj==0 then
if vj<$8000 then
set vj=vj+1
set WdE=vj
set mj[WdE]=$D46
else
call Cdv("Out of memory: Could not create Log.","when calling error in SLangChatSystem, line 88")
set WdE=0
endif
else
set xj=xj-1
set WdE=jj[xj]
set mj[WdE]=$D46
endif
set EM=EM-1
return WdE
endfunction
function WDE takes string WfE returns integer
local integer WFE
set ZM[EM]=WfE
set EM=EM+1
set WFE=WcE("when calling alloc_Log in SLangChatSystem, line 95")
call WNE(WFE,"when calling construct_Log in SLangChatSystem, line 95")
set EM=EM-1
return WFE
endfunction
function WgE takes integer Ket returns nothing
endfunction
function WGE takes integer WhE,integer WHE,string WjE returns nothing
set ZM[EM]=WjE
set EM=EM+1
call WgE(WhE)
set rJ[WhE]=WHE
set sJ[WhE]=WDE("when calling new_Log in SLangChatSystem, line 142")
set EM=EM-1
endfunction
function WJE takes integer WkE,string WKE returns integer
local integer WlE
set ZM[EM]=WKE
set EM=EM+1
set WlE=WXE("when calling alloc_Channel in SLangChatSystem, line 140")
call WGE(WlE,WkE,"when calling construct_Channel in SLangChatSystem, line 140")
set EM=EM-1
return WlE
endfunction
function WLE takes string WmE returns integer
local integer WME
set ZM[EM]=WmE
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set WME=Yj
set Gj[WME]=$B6E
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_setRequiringEnumUnit_registerBuiltin_SLangChatSystem.","when calling error in SLangChatSystem, line 206")
set WME=0
endif
else
set Tj=Tj-1
set WME=Rj[Tj]
set Gj[WME]=$B6E
endif
set EM=EM-1
return WME
endfunction
function WpE takes string WPE returns integer
local integer WqE
set ZM[EM]=WPE
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set WqE=Yj
set Gj[WqE]=$AAE
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_SLangChatSystem.","when calling error in SLangChatSystem, line 190")
set WqE=0
endif
else
set Tj=Tj-1
set WqE=Rj[Tj]
set Gj[WqE]=$AAE
endif
set EM=EM-1
return WqE
endfunction
function WQE takes integer WsE returns nothing
set Qn[Wn]=WsE
set Wn=Wn+1
endfunction
function WSE takes string WtE returns integer
local integer WTE
set ZM[EM]=WtE
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set WTE=Yj
set Gj[WTE]=$AAD
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_SLangChatSystem.","when calling error in SLangChatSystem, line 179")
set WTE=0
endif
else
set Tj=Tj-1
set WTE=Rj[Tj]
set Gj[WTE]=$AAD
endif
set EM=EM-1
return WTE
endfunction
function WuE takes string WUE returns integer
local integer WwE
set ZM[EM]=WUE
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set WwE=Yj
set Gj[WwE]=$AA8
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerBuiltin_SLangChatSystem.","when calling error in SLangChatSystem, line 202")
set WwE=0
endif
else
set Tj=Tj-1
set WwE=Rj[Tj]
set Gj[WwE]=$AA8
endif
set EM=EM-1
return WwE
endfunction
function WWE takes string WyE returns integer
local integer WYE
set ZM[EM]=WyE
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set WYE=Yj
set Gj[WYE]=$B6F
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_setRequiringEnumUnit_registerBuiltin_SLangChatSystem.","when calling error in SLangChatSystem, line 213")
set WYE=0
endif
else
set Tj=Tj-1
set WYE=Rj[Tj]
set Gj[WYE]=$B6F
endif
set EM=EM-1
return WYE
endfunction
function WzE takes string WZE returns integer
local integer W_E
set ZM[EM]=WZE
set EM=EM+1
if jG==0 then
if xG<$8000 then
set xG=xG+1
set W_E=xG
set vG[W_E]=$473
else
call Cdv("Out of memory: Could not create CallbackSingle_nullTimer_SLangChatSystem.","when calling error in SLangChatSystem, line 168")
set W_E=0
endif
else
set jG=jG-1
set W_E=kG[jG]
set vG[W_E]=$473
endif
set EM=EM-1
return W_E
endfunction
function W0E takes string W1E returns integer
local integer W2E
set ZM[EM]=W1E
set EM=EM+1
if Oj==0 then
if lj<$8000 then
set lj=lj+1
set W2E=lj
set bj[W2E]=$BA8
else
call Cdv("Out of memory: Could not create IMessageFormatter_SLangChatSystem.","when calling error in SLangChatSystem, line 158")
set W2E=0
endif
else
set Oj=Oj-1
set W2E=oj[Oj]
set bj[W2E]=$BA8
endif
set EM=EM-1
return W2E
endfunction
function W3E takes string W4E returns integer
local integer W5E
set ZM[EM]=W4E
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set W5E=Yj
set Gj[W5E]=$AAA
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerBuiltin_SLangChatSystem.","when calling error in SLangChatSystem, line 227")
set W5E=0
endif
else
set Tj=Tj-1
set W5E=Rj[Tj]
set Gj[W5E]=$AAA
endif
set EM=EM-1
return W5E
endfunction
function W6E takes string W7E returns integer
local integer W8E
set ZM[EM]=W7E
set EM=EM+1
if Oj==0 then
if lj<$8000 then
set lj=lj+1
set W8E=lj
set bj[W8E]=$BA9
else
call Cdv("Out of memory: Could not create IMessageFormatter_SLangChatSystem.","when calling error in SLangChatSystem, line 159")
set W8E=0
endif
else
set Oj=Oj-1
set W8E=oj[Oj]
set bj[W8E]=$BA9
endif
set EM=EM-1
return W8E
endfunction
function W9E takes integer yvE returns nothing
set md[Qd]=yvE
set Qd=Qd+1
endfunction
function yeE takes integer yxE,integer yoE returns nothing
set rJ[yxE]=yoE
endfunction
function yrE takes integer yiE,integer yaE,string ynE returns nothing
set ZM[EM]=ynE
set EM=EM+1
if kj[yiE]==0 then
if yiE==0 then
call Cdv("Nullpointer exception when calling Channel.setFormatter","when calling error in SLangChatSystem, line 144")
else
call Cdv("Called Channel.setFormatter on invalid object.","when calling error in SLangChatSystem, line 144")
endif
endif
call yeE(yiE,yaE)
set EM=EM-1
endfunction
function yVE takes string yEE returns integer
local integer yXE
set ZM[EM]=yEE
set EM=EM+1
if Oj==0 then
if lj<$8000 then
set lj=lj+1
set yXE=lj
set bj[yXE]=$BAA
else
call Cdv("Out of memory: Could not create IMessageFormatter_setFormatter_SLangChatSystem.","when calling error in SLangChatSystem, line 173")
set yXE=0
endif
else
set Oj=Oj-1
set yXE=oj[Oj]
set bj[yXE]=$BAA
endif
set EM=EM-1
return yXE
endfunction
function yOE takes string yRE returns integer
local integer yIE
set ZM[EM]=yRE
set EM=EM+1
if pj==0 then
if ej<$8000 then
set ej=ej+1
set yIE=ej
set qj[yIE]=$BB8
else
call Cdv("Out of memory: Could not create ISystemMessagesReceiver_registerSystemMessagesReceiver_SLangChatSystem.","when calling error in SLangChatSystem, line 175")
set yIE=0
endif
else
set pj=pj-1
set yIE=yj[pj]
set qj[yIE]=$BB8
endif
set EM=EM-1
return yIE
endfunction
function yAE takes string yNE returns integer
local integer ybE
set ZM[EM]=yNE
set EM=EM+1
if nj==0 then
if dj<$8000 then
set dj=dj+1
set ybE=dj
set fj[ybE]=$BA5
else
call Cdv("Out of memory: Could not create IExceptionHandler_registerExceptionHandler_SLangChatSystem.","when calling error in SLangChatSystem, line 177")
set ybE=0
endif
else
set nj=nj-1
set ybE=aj[nj]
set fj[ybE]=$BA5
endif
set EM=EM-1
return ybE
endfunction
function yBE takes string ycE returns integer
local integer yCE
set ZM[EM]=ycE
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set yCE=Yj
set Gj[yCE]=$AA9
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerBuiltin_SLangChatSystem.","when calling error in SLangChatSystem, line 220")
set yCE=0
endif
else
set Tj=Tj-1
set yCE=Rj[Tj]
set Gj[yCE]=$AA9
endif
set EM=EM-1
return yCE
endfunction
function ydE takes string yDE returns boolean
return BlzLoadTOCFile(yDE)
endfunction
function yfE takes string yFE returns boolean
local integer ygE
local integer yGE
local integer yhE
local integer yHE
local integer yjE
local integer yJE
local integer ykE
local integer yKE
local integer ylE
local integer yLE
local integer ymE
local integer yME
local integer ypE
local integer yPE
local integer yqE
local integer yQE
local integer ysE
local integer ySE
local integer ytE
local integer yTE
local integer yuE
local integer yUE
local integer ywE
local integer yWE
local integer yyE
local integer yYE
set ZM[EM]=yFE
set EM=EM+1
set La=24
set Xa=512
set ygE=W0E("when calling alloc_IMessageFormatter_SLangChatSystem in SLangChatSystem, line 158")
set Ha=WJE(ygE,"when calling new_Channel in SLangChatSystem, line 158")
set yGE=W6E("when calling alloc_IMessageFormatter_SLangChatSystem in SLangChatSystem, line 159")
set Ja=WJE(yGE,"when calling new_Channel in SLangChatSystem, line 159")
call ydE("ui\\framedef\\templates.toc")
set yhE=WzE("when calling alloc_CallbackSingle_nullTimer_SLangChatSystem in SLangChatSystem, line 168")
call EUx(yhE)
call Lsx(yhE,"when calling nullTimer in SLangChatSystem, line 168")
set yHE=0
set yjE=bj_MAX_PLAYERS-1
loop
exitwhen yHE>yjE
set ykE=WJE(0,"when calling new_Channel in SLangChatSystem, line 173")
set yYE=ykE
set yJE=yVE("when calling alloc_IMessageFormatter_setFormatter_SLangChatSystem in SLangChatSystem, line 173")
call yrE(yYE,yJE,"when calling setFormatter in SLangChatSystem, line 173")
set Ka[yHE]=ykE
set yHE=yHE+1
endloop
set yKE=yOE("when calling alloc_ISystemMessagesReceiver_registerSystemMessagesReceiver_SLangChatSystem in SLangChatSystem, line 175")
call W9E(yKE)
set ylE=yAE("when calling alloc_IExceptionHandler_registerExceptionHandler_SLangChatSystem in SLangChatSystem, line 177")
call WQE(ylE)
set yLE=WSE("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_SLangChatSystem in SLangChatSystem, line 179")
set ymE=OPo(yLE,"when calling new_BuiltinData in SLangChatSystem, line 179")
call FRa(ymE,OFo(),OFo(),"when calling setArgumentsTypes in SLangChatSystem, line 189")
call Foa(ILo(ymE,"when calling new_BuiltinFunction in SLangChatSystem, line 179"),"sendmsg","when calling registerProtectedBuiltin in SLangChatSystem, line 179")
set yME=WpE("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_SLangChatSystem in SLangChatSystem, line 190")
set ypE=OPo(yME,"when calling new_BuiltinData in SLangChatSystem, line 190")
call FRa(ypE,OFo(),OFo(),"when calling setArgumentsTypes in SLangChatSystem, line 200")
call Foa(ILo(ypE,"when calling new_BuiltinFunction in SLangChatSystem, line 190"),"dumplog","when calling registerProtectedBuiltin in SLangChatSystem, line 190")
set yPE=WuE("when calling alloc_IBuiltin_setArgumentsTypes_registerBuiltin_SLangChatSystem in SLangChatSystem, line 202")
set yqE=OPo(yPE,"when calling new_BuiltinData in SLangChatSystem, line 202")
call Rxo(yqE,OFo(),"when calling setArgumentsTypes in SLangChatSystem, line 205")
call nUE(ILo(yqE,"when calling new_BuiltinFunction in SLangChatSystem, line 202"),"!","when calling registerBuiltin in SLangChatSystem, line 202")
set yQE=WLE("when calling alloc_IBuiltin_setArgumentsTypes_setRequiringEnumUnit_registerBuiltin_SLangChatSystem in SLangChatSystem, line 206")
set ysE=OPo(yQE,"when calling new_BuiltinData in SLangChatSystem, line 206")
call Rxo(ysE,OFo(),"when calling setArgumentsTypes in SLangChatSystem, line 212")
set ySE=ysE
call LWV(ySE,"when calling setRequiringEnumUnit in SLangChatSystem, line 212")
call nUE(ILo(ySE,"when calling new_BuiltinFunction in SLangChatSystem, line 206"),"%","when calling registerBuiltin in SLangChatSystem, line 206")
set ytE=WWE("when calling alloc_IBuiltin_setArgumentsTypes_setRequiringEnumUnit_registerBuiltin_SLangChatSystem in SLangChatSystem, line 213")
set yTE=OPo(ytE,"when calling new_BuiltinData in SLangChatSystem, line 213")
call Rxo(yTE,OFo(),"when calling setArgumentsTypes in SLangChatSystem, line 219")
set yuE=yTE
call LWV(yuE,"when calling setRequiringEnumUnit in SLangChatSystem, line 219")
call nUE(ILo(yuE,"when calling new_BuiltinFunction in SLangChatSystem, line 213"),"%*","when calling registerBuiltin in SLangChatSystem, line 213")
set yUE=yBE("when calling alloc_IBuiltin_setArgumentsTypes_registerBuiltin_SLangChatSystem in SLangChatSystem, line 220")
set ywE=OPo(yUE,"when calling new_BuiltinData in SLangChatSystem, line 220")
call FRa(ywE,OFo(),OFo(),"when calling setArgumentsTypes in SLangChatSystem, line 226")
call nUE(ILo(ywE,"when calling new_BuiltinFunction in SLangChatSystem, line 220"),"setICname","when calling registerBuiltin in SLangChatSystem, line 220")
set yWE=W3E("when calling alloc_IBuiltin_setArgumentsTypes_registerBuiltin_SLangChatSystem in SLangChatSystem, line 227")
set yyE=OPo(yWE,"when calling new_BuiltinData in SLangChatSystem, line 227")
call Rxo(yyE,OFo(),"when calling setArgumentsTypes in SLangChatSystem, line 230")
call nUE(ILo(yyE,"when calling new_BuiltinFunction in SLangChatSystem, line 227"),".","when calling registerBuiltin in SLangChatSystem, line 227")
set EM=EM-1
return true
endfunction
function yzE takes nothing returns boolean
set EM=0
return yfE("SLangChatSystem, line 1")
endfunction
function yZE takes nothing returns nothing
call CameraClearNoiseForPlayer(GetEnumPlayer())
endfunction
function y_E takes nothing returns nothing
local unit y0E=GetSpellAbilityUnit()
local timer y1E=CreateTimer()
call SaveLocationHandle(nr,GetHandleId(y1E),StringHash("l"),GetSpellTargetLoc())
call SaveUnitHandle(nr,GetHandleId(y1E),StringHash("u"),y0E)
call SaveEffectHandle(nr,GetHandleId(y1E),StringHash("e"),AddSpecialEffectTarget("Abilities\\Spells\\Other\\Bombardment\\BombardmentCaster.mdx",y0E,"overhead"))
call SaveInteger(nr,GetHandleId(y1E),StringHash("i"),0)
call SaveTimerHandle(nr,GetHandleId(y0E),StringHash("bmT"),y1E)
set y0E=null
call TimerStart(y1E,.25,true,VZv)
set y1E=null
set y0E=null
set y1E=null
endfunction
function y2E takes nothing returns boolean
return GetSpellAbilityId()=='A0JP'
endfunction
function y3E takes nothing returns nothing
local unit y4E=CreateUnitAtLoc(GetOwningPlayer(GetSpellAbilityUnit()),'h0JO',GetUnitLoc(GetEnumUnit()),270.)
call UnitAddAbility(y4E,'A097')
call IssueTargetOrderById(y4E,$D0085,GetEnumUnit())
call oLn(y4E,3.)
set y4E=null
set y4E=null
endfunction
function y5E takes nothing returns nothing
local unit y6E=GetSpellAbilityUnit()
local unit y7E
local effect y8E
local effect y9E
if(GetUnitAbilityLevel(GetEnumUnit(),'A07E')==3 and GetRandomInt(1,'d')<=30)or(GetUnitAbilityLevel(GetEnumUnit(),'A07E')==2 and GetRandomInt(1,'d')<=20)or(GetUnitAbilityLevel(GetEnumUnit(),'A07E')==1 and GetRandomInt(1,'d')<=$A)then
set y7E=CreateUnitAtLoc(GetOwningPlayer(GetEnumUnit()),'h0JO',GetUnitLoc(GetEnumUnit()),270.)
set y8E=AddSpecialEffectTarget("Abilities\\Spells\\Items\\SpellShieldAmulet\\SpellShieldCaster.mdl",GetEnumUnit(),"origin")
set y9E=AddSpecialEffectTarget("Abilities\\Spells\\Other\\Silence\\SilenceTarget.mdl",y6E,"overhead")
call UnitAddAbility(y7E,'A0EY')
call SetUnitAbilityLevel(y7E,'A0EY',GetUnitAbilityLevel(y6E,'Ansi'))
call IssuePointOrderByIdLoc(y7E,$D0270,GetUnitLoc(y6E))
call TriggerSleepAction(3.)
call RemoveUnit(y7E)
call DestroyEffect(y8E)
call DestroyEffect(y9E)
endif
set y6E=null
set y7E=null
set y8E=null
set y9E=null
set y6E=null
set y7E=null
set y8E=null
set y9E=null
endfunction
function YvE takes nothing returns boolean
return GetSpellAbilityId()=='Acmg' or GetSpellAbilityId()=='Apos' or GetSpellAbilityId()=='Aps2' or GetSpellAbilityId()=='ACps' or GetSpellAbilityId()=='ACch' or GetSpellAbilityId()=='ANch' or GetSpellAbilityId()=='ANdo' or GetSpellAbilityId()=='ANtm' or GetSpellAbilityId()=='A0DM' or GetSpellAbilityId()=='A03K' or GetSpellAbilityId()=='A03L'
endfunction
function YeE takes nothing returns boolean
return GetSpellAbilityId()=='A0H5'
endfunction
function YxE takes nothing returns boolean
return(GetUnitTypeId(GetTriggerUnit())=='h0F3')
endfunction
function YoE takes nothing returns nothing
if YxE()then
call CreateDestructableLoc('B00F',GetUnitLoc(GetTriggerUnit()),.0,6.,0)
call RemoveUnit(GetTriggerUnit())
endif
endfunction
function YrE takes nothing returns boolean
return(Bw[1]==0)
endfunction
function YiE takes nothing returns boolean
return(ru[Bw[3]]<wu[Bw[3]])
endfunction
function YaE takes nothing returns boolean
return(IsUnitInGroup(iu[Bw[3]],au))
endfunction
function YnE takes nothing returns boolean
return(GetRandomInt(1,5)==1)
endfunction
function YVE takes nothing returns boolean
return(bu[Bw[3]])
endfunction
function YEE takes nothing returns nothing
set Bw[3]=1
loop
exitwhen Bw[3]>Bw[2]
if YaE()then
if YiE()then
call QueueUnitAnimationBJ(iu[Bw[3]],Ou[Bw[3]])
set Nw[1]=GetUnitLoc(iu[Bw[3]])
set Nw[2]=PolarProjectionBJ(Nw[1],su[Bw[3]],Su[Bw[3]])
if YVE()then
call EnumDestructablesInCircleBJ(150.,Nw[2],owv)
endif
call SetUnitPositionLoc(iu[Bw[3]],Nw[2])
set ru[Bw[3]]=ru[Bw[3]]+su[Bw[3]]
if YnE()then
call AddSpecialEffectTargetUnitBJ("chest",iu[Bw[3]],cu[Bw[3]])
call DestroyEffectBJ(GetLastCreatedEffectBJ())
endif
set nu[Bw[3]]=nu[Bw[3]]+180./(wu[Bw[3]]/su[Bw[3]])
set du[Bw[3]]=SinBJ(nu[Bw[3]])*pu[Bw[3]]
call SetUnitFlyHeightBJ(iu[Bw[3]],du[Bw[3]],1000000000.)
call RemoveLocation(Nw[1])
call RemoveLocation(Nw[2])
else
call SetUnitPathing(iu[Bw[3]],true)
call GroupRemoveUnitSimple(iu[Bw[3]],au)
call SetUnitTimeScalePercent(iu[Bw[3]],100.)
call ResetUnitAnimation(iu[Bw[3]])
set nu[Bw[3]]=.0
set Bw[1]=Bw[1]-1
if YrE()then
set Bw[2]=0
call DisableTrigger(GetTriggeringTrigger())
endif
endif
endif
set Bw[3]=Bw[3]+1
endloop
endfunction
function YXE takes nothing returns nothing
local unit YOE=GetTriggerUnit()
local real YRE=GetUnitAbilityLevel(YOE,'A0IS')
if GetUnitAbilityLevel(YOE,'A0IS')==1 then
set YRE=1.
elseif GetUnitAbilityLevel(YOE,'A0IS')==2 then
set YRE=1.5
elseif GetUnitAbilityLevel(YOE,'A0IS')==3 then
set YRE=2.
endif
if GetUnitState(YOE,UNIT_STATE_MANA)-GetEventDamage()/YRE>=.0 then
call SetUnitState(YOE,UNIT_STATE_LIFE,GetUnitState(YOE,UNIT_STATE_LIFE)+GetEventDamage())
call SetUnitState(YOE,UNIT_STATE_MANA,GetUnitState(YOE,UNIT_STATE_MANA)-GetEventDamage()/YRE)
else
call SetUnitState(YOE,UNIT_STATE_LIFE,GetUnitState(YOE,UNIT_STATE_LIFE)+GetUnitState(YOE,UNIT_STATE_MANA)*YRE)
call SetUnitState(YOE,UNIT_STATE_MANA,GetUnitState(YOE,UNIT_STATE_MANA)-GetEventDamage()/YRE)
endif
set YOE=null
set YRE=.0
set YOE=null
endfunction
function YIE takes nothing returns boolean
return(GetUnitTypeId(GetEnumUnit())!='h000')and(IsUnitSelected(GetEnumUnit(),GetTriggerPlayer()))
endfunction
function YAE takes nothing returns boolean
return(YIE())
endfunction
function YNE takes nothing returns boolean
return(GetUnitAbilityLevelSwapped('A0G4',GetEnumUnit())==0)and(GetUnitAbilityLevelSwapped('A0G7',GetEnumUnit())==0)and(GetUnitAbilityLevelSwapped('A0G5',GetEnumUnit())==0)
endfunction
function YbE takes nothing returns boolean
return(YNE())
endfunction
function YBE takes nothing returns nothing
if YAE()then
call SetUnitAbilityLevelSwapped('A0G4',GetEnumUnit(),GetUnitAbilityLevelSwapped('A0G4',GetEnumUnit())+1)
call SetUnitAbilityLevelSwapped('A0G7',GetEnumUnit(),GetUnitAbilityLevelSwapped('A0G7',GetEnumUnit())+1)
call SetUnitAbilityLevelSwapped('A0G5',GetEnumUnit(),GetUnitAbilityLevelSwapped('A0G5',GetEnumUnit())+1)
if YbE()then
call UnitAddAbilityBJ('A0G4',GetEnumUnit())
call UnitMakeAbilityPermanent(GetEnumUnit(),true,'A0G4')
endif
endif
endfunction
function YcE takes nothing returns boolean
return(GetEventPlayerChatString()=="~building")
endfunction
function YCE takes nothing returns nothing
set g[GetConvertedPlayerId(GetTriggerPlayer())]=GetUnitsOfPlayerMatching(GetTriggerPlayer(),Condition(rnv))
if YcE()then
call ForGroupBJ(g[GetConvertedPlayerId(GetTriggerPlayer())],rVv)
endif
call DestroyGroup(g[GetPlayerId(GetTriggerPlayer())+1])
endfunction
function YdE takes nothing returns nothing
call CreateQuestBJ(bj_QUESTTYPE_REQ_DISCOVERED,"TRIGSTR_9182","TRIGSTR_9183","ReplaceableTextures\\CommandButtons\\BTNMassTeleport.blp")
call CreateQuestBJ(bj_QUESTTYPE_REQ_DISCOVERED,"TRIGSTR_066","TRIGSTR_067","ReplaceableTextures\\CommandButtons\\BTNEngineeringUpgrade.blp")
call CreateQuestBJ(bj_QUESTTYPE_REQ_DISCOVERED,"TRIGSTR_8661","TRIGSTR_8662","ReplaceableTextures\\CommandButtons\\BTNBrilliance.blp")
call CreateQuestBJ(bj_QUESTTYPE_REQ_DISCOVERED,"TRIGSTR_1139","TRIGSTR_1252","ReplaceableTextures\\CommandButtons\\BTNBrilliance.blp")
call CreateQuestBJ(bj_QUESTTYPE_REQ_DISCOVERED,"TRIGSTR_342","TRIGSTR_1288","ReplaceableTextures\\CommandButtons\\BTNFelFireBolt.blp")
call CreateQuestBJ(bj_QUESTTYPE_REQ_DISCOVERED,"TRIGSTR_2196","TRIGSTR_2896","ReplaceableTextures\\CommandButtons\\BTNMageFireBolt.blp")
call CreateQuestBJ(bj_QUESTTYPE_REQ_DISCOVERED,"TRIGSTR_068","TRIGSTR_069","ReplaceableTextures\\CommandButtons\\BTNBerserkForTrolls.blp")
call CreateQuestBJ(bj_QUESTTYPE_REQ_DISCOVERED,"TRIGSTR_070","TRIGSTR_071","ReplaceableTextures\\CommandButtons\\BTNBerserkForTrolls.blp")
call CreateQuestBJ(bj_QUESTTYPE_REQ_DISCOVERED,"TRIGSTR_11204","TRIGSTR_11205","ReplaceableTextures\\CommandButtons\\BTNArmorGolem.blp")
call CreateQuestBJ(bj_QUESTTYPE_REQ_DISCOVERED,"TRIGSTR_154","TRIGSTR_155","ReplaceableTextures\\CommandButtons\\BTNTameHippogriff.blp")
call CreateQuestBJ(bj_QUESTTYPE_REQ_DISCOVERED,"TRIGSTR_100","TRIGSTR_101","ReplaceableTextures\\CommandButtons\\BTNHoldPosition.blp")
call CreateQuestBJ(bj_QUESTTYPE_REQ_DISCOVERED,"TRIGSTR_102","TRIGSTR_103","ReplaceableTextures\\CommandButtons\\BTNHoldPosition.blp")
call CreateQuestBJ(bj_QUESTTYPE_REQ_DISCOVERED,"TRIGSTR_104","TRIGSTR_105","ReplaceableTextures\\CommandButtons\\BTNHoldPosition.blp")
call CreateQuestBJ(bj_QUESTTYPE_REQ_DISCOVERED,"TRIGSTR_106","TRIGSTR_107","ReplaceableTextures\\CommandButtons\\BTNHoldPosition.blp")
call CreateQuestBJ(bj_QUESTTYPE_REQ_DISCOVERED,"TRIGSTR_108","TRIGSTR_109","ReplaceableTextures\\CommandButtons\\BTNHoldPosition.blp")
call CreateQuestBJ(bj_QUESTTYPE_REQ_DISCOVERED,"TRIGSTR_110","TRIGSTR_111","ReplaceableTextures\\CommandButtons\\BTNHoldPosition.blp")
call CreateQuestBJ(bj_QUESTTYPE_REQ_DISCOVERED,"TRIGSTR_112","TRIGSTR_113","ReplaceableTextures\\CommandButtons\\BTNHoldPosition.blp")
call CreateQuestBJ(bj_QUESTTYPE_REQ_DISCOVERED,"TRIGSTR_114","TRIGSTR_115","ReplaceableTextures\\CommandButtons\\BTNHoldPosition.blp")
call CreateQuestBJ(bj_QUESTTYPE_REQ_DISCOVERED,"TRIGSTR_116","TRIGSTR_117","ReplaceableTextures\\CommandButtons\\BTNHoldPosition.blp")
call CreateQuestBJ(bj_QUESTTYPE_REQ_DISCOVERED,"TRIGSTR_118","TRIGSTR_119","ReplaceableTextures\\CommandButtons\\BTNWellSpring.blp")
call CreateQuestBJ(bj_QUESTTYPE_REQ_DISCOVERED,"TRIGSTR_120","TRIGSTR_121","ReplaceableTextures\\CommandButtons\\BTNWellSpring.blp")
call CreateQuestBJ(bj_QUESTTYPE_REQ_DISCOVERED,"TRIGSTR_122","TRIGSTR_123","ReplaceableTextures\\CommandButtons\\BTNWellSpring.blp")
call CreateQuestBJ(bj_QUESTTYPE_REQ_DISCOVERED,"TRIGSTR_124","TRIGSTR_125","ReplaceableTextures\\CommandButtons\\BTNWellSpring.blp")
call CreateQuestBJ(bj_QUESTTYPE_REQ_DISCOVERED,"TRIGSTR_126","TRIGSTR_127","ReplaceableTextures\\CommandButtons\\BTNWellSpring.blp")
call CreateQuestBJ(bj_QUESTTYPE_REQ_DISCOVERED,"TRIGSTR_128","TRIGSTR_129","ReplaceableTextures\\CommandButtons\\BTNWellSpring.blp")
call CreateQuestBJ(bj_QUESTTYPE_REQ_DISCOVERED,"TRIGSTR_130","TRIGSTR_131","ReplaceableTextures\\CommandButtons\\BTNWellSpring.blp")
call CreateQuestBJ(bj_QUESTTYPE_REQ_DISCOVERED,"TRIGSTR_132","TRIGSTR_133","ReplaceableTextures\\CommandButtons\\BTNWellSpring.blp")
call CreateQuestBJ(bj_QUESTTYPE_REQ_DISCOVERED,"TRIGSTR_134","TRIGSTR_135","ReplaceableTextures\\CommandButtons\\BTNWellSpring.blp")
call CreateQuestBJ(bj_QUESTTYPE_REQ_DISCOVERED,"TRIGSTR_136","TRIGSTR_137","ReplaceableTextures\\CommandButtons\\BTNWellSpring.blp")
call CreateQuestBJ(bj_QUESTTYPE_REQ_DISCOVERED,"TRIGSTR_144","TRIGSTR_145","ReplaceableTextures\\CommandButtons\\BTNHumanBuild.blp")
call CreateQuestItemBJ(GetLastCreatedQuestBJ(),"TRIGSTR_1408")
call CreateQuestBJ(bj_QUESTTYPE_REQ_DISCOVERED,"TRIGSTR_1958","TRIGSTR_1968","ReplaceableTextures\\CommandButtons\\BTNHumanBuild.blp")
call CreateQuestItemBJ(GetLastCreatedQuestBJ(),"TRIGSTR_2461")
call CreateQuestBJ(bj_QUESTTYPE_REQ_DISCOVERED,"TRIGSTR_2473","TRIGSTR_2547","ReplaceableTextures\\CommandButtons\\BTNHumanBuild.blp")
call CreateQuestItemBJ(GetLastCreatedQuestBJ(),"TRIGSTR_2564")
call CreateQuestBJ(bj_QUESTTYPE_REQ_DISCOVERED,"TRIGSTR_2583","TRIGSTR_2611","ReplaceableTextures\\CommandButtons\\BTNHumanBuild.blp")
call CreateQuestItemBJ(GetLastCreatedQuestBJ(),"TRIGSTR_2618")
call CreateQuestBJ(bj_QUESTTYPE_REQ_DISCOVERED,"TRIGSTR_2635","TRIGSTR_2650","ReplaceableTextures\\CommandButtons\\BTNHumanBuild.blp")
call CreateQuestItemBJ(GetLastCreatedQuestBJ(),"TRIGSTR_2655")
call CreateQuestBJ(bj_QUESTTYPE_REQ_DISCOVERED,"TRIGSTR_2886","TRIGSTR_2940","ReplaceableTextures\\CommandButtons\\BTNHumanBuild.blp")
call CreateQuestItemBJ(GetLastCreatedQuestBJ(),"TRIGSTR_2943")
call CreateQuestBJ(bj_QUESTTYPE_REQ_DISCOVERED,"TRIGSTR_2945","TRIGSTR_2949","ReplaceableTextures\\CommandButtons\\BTNHumanBuild.blp")
call CreateQuestItemBJ(GetLastCreatedQuestBJ(),"TRIGSTR_2964")
call CreateQuestBJ(bj_QUESTTYPE_REQ_DISCOVERED,"TRIGSTR_2973","TRIGSTR_2982","ReplaceableTextures\\CommandButtons\\BTNHumanBuild.blp")
call CreateQuestItemBJ(GetLastCreatedQuestBJ(),"TRIGSTR_3049")
call CreateQuestBJ(bj_QUESTTYPE_REQ_DISCOVERED,"TRIGSTR_3151","TRIGSTR_3169","ReplaceableTextures\\CommandButtons\\BTNHumanBuild.blp")
call CreateQuestItemBJ(GetLastCreatedQuestBJ(),"TRIGSTR_3173")
call CreateQuestBJ(bj_QUESTTYPE_REQ_DISCOVERED,"TRIGSTR_3177","TRIGSTR_3204","ReplaceableTextures\\CommandButtons\\BTNHumanBuild.blp")
call CreateQuestItemBJ(GetLastCreatedQuestBJ(),"TRIGSTR_3208")
call CreateQuestBJ(bj_QUESTTYPE_REQ_DISCOVERED,"TRIGSTR_3212","TRIGSTR_3228","ReplaceableTextures\\CommandButtons\\BTNHumanBuild.blp")
call CreateQuestItemBJ(GetLastCreatedQuestBJ(),"TRIGSTR_3236")
call CreateQuestBJ(bj_QUESTTYPE_REQ_DISCOVERED,"TRIGSTR_3249","TRIGSTR_3250","ReplaceableTextures\\CommandButtons\\BTNHumanBuild.blp")
call CreateQuestItemBJ(GetLastCreatedQuestBJ(),"TRIGSTR_3252")
call CreateQuestBJ(bj_QUESTTYPE_REQ_DISCOVERED,"TRIGSTR_3258","TRIGSTR_3288","ReplaceableTextures\\CommandButtons\\BTNHumanBuild.blp")
call CreateQuestItemBJ(GetLastCreatedQuestBJ(),"TRIGSTR_3297")
call CreateQuestBJ(bj_QUESTTYPE_REQ_DISCOVERED,"TRIGSTR_3305","TRIGSTR_3313","ReplaceableTextures\\CommandButtons\\BTNHumanBuild.blp")
call CreateQuestItemBJ(GetLastCreatedQuestBJ(),"TRIGSTR_3421")
call CreateQuestBJ(bj_QUESTTYPE_REQ_DISCOVERED,"TRIGSTR_3438","TRIGSTR_3462","ReplaceableTextures\\CommandButtons\\BTNHumanBuild.blp")
call CreateQuestItemBJ(GetLastCreatedQuestBJ(),"TRIGSTR_3464")
call CreateQuestBJ(bj_QUESTTYPE_REQ_DISCOVERED,"TRIGSTR_3467","TRIGSTR_3470","ReplaceableTextures\\CommandButtons\\BTNHumanBuild.blp")
call CreateQuestItemBJ(GetLastCreatedQuestBJ(),"TRIGSTR_3473")
call CreateQuestBJ(bj_QUESTTYPE_REQ_DISCOVERED,"TRIGSTR_3476","TRIGSTR_3479","ReplaceableTextures\\CommandButtons\\BTNHumanBuild.blp")
call CreateQuestItemBJ(GetLastCreatedQuestBJ(),"TRIGSTR_3482")
call CreateQuestBJ(bj_QUESTTYPE_REQ_DISCOVERED,"TRIGSTR_3485","TRIGSTR_3488","ReplaceableTextures\\CommandButtons\\BTNHumanBuild.blp")
call CreateQuestItemBJ(GetLastCreatedQuestBJ(),"TRIGSTR_3491")
call CreateQuestBJ(bj_QUESTTYPE_REQ_DISCOVERED,"TRIGSTR_3494","TRIGSTR_3497","ReplaceableTextures\\CommandButtons\\BTNHumanBuild.blp")
call CreateQuestItemBJ(GetLastCreatedQuestBJ(),"TRIGSTR_3503")
call CreateQuestBJ(bj_QUESTTYPE_REQ_DISCOVERED,"TRIGSTR_3504","TRIGSTR_3506","ReplaceableTextures\\CommandButtons\\BTNHumanBuild.blp")
call CreateQuestItemBJ(GetLastCreatedQuestBJ(),"TRIGSTR_3509")
call CreateQuestBJ(bj_QUESTTYPE_REQ_DISCOVERED,"TRIGSTR_3513","TRIGSTR_3516","ReplaceableTextures\\CommandButtons\\BTNHumanBuild.blp")
call CreateQuestItemBJ(GetLastCreatedQuestBJ(),"TRIGSTR_3525")
call CreateQuestBJ(bj_QUESTTYPE_REQ_DISCOVERED,"TRIGSTR_156","TRIGSTR_157","ReplaceableTextures\\CommandButtons\\BTNHumanMissileUpOne.blp")
call CreateQuestBJ(bj_QUESTTYPE_REQ_DISCOVERED,"TRIGSTR_158","TRIGSTR_159","ReplaceableTextures\\CommandButtons\\BTNHumanMissileUpOne.blp")
call CreateQuestBJ(bj_QUESTTYPE_REQ_DISCOVERED,"TRIGSTR_160","TRIGSTR_161","ReplaceableTextures\\CommandButtons\\BTNHumanMissileUpOne.blp")
call CreateQuestBJ(bj_QUESTTYPE_REQ_DISCOVERED,"TRIGSTR_162","TRIGSTR_163","ReplaceableTextures\\CommandButtons\\BTNHumanMissileUpOne.blp")
call CreateQuestBJ(bj_QUESTTYPE_REQ_DISCOVERED,"TRIGSTR_164","TRIGSTR_165","ReplaceableTextures\\CommandButtons\\BTNHumanMissileUpOne.blp")
call CreateQuestBJ(bj_QUESTTYPE_REQ_DISCOVERED,"TRIGSTR_166","TRIGSTR_167","ReplaceableTextures\\CommandButtons\\BTNHumanMissileUpOne.blp")
call CreateQuestBJ(bj_QUESTTYPE_REQ_DISCOVERED,"TRIGSTR_168","TRIGSTR_169","ReplaceableTextures\\CommandButtons\\BTNHumanMissileUpOne.blp")
call CreateQuestBJ(bj_QUESTTYPE_REQ_DISCOVERED,"TRIGSTR_170","TRIGSTR_171","ReplaceableTextures\\CommandButtons\\BTNHumanMissileUpOne.blp")
call CreateQuestBJ(bj_QUESTTYPE_REQ_DISCOVERED,"TRIGSTR_172","TRIGSTR_173","ReplaceableTextures\\CommandButtons\\BTNHumanMissileUpOne.blp")
call CreateQuestBJ(bj_QUESTTYPE_REQ_DISCOVERED,"TRIGSTR_174","TRIGSTR_175","ReplaceableTextures\\CommandButtons\\BTNHumanMissileUpOne.blp")
call CreateQuestBJ(bj_QUESTTYPE_REQ_DISCOVERED,"TRIGSTR_2189","TRIGSTR_2190","ReplaceableTextures\\CommandButtons\\BTNHumanMissileUpOne.blp")
call CreateQuestBJ(bj_QUESTTYPE_REQ_DISCOVERED,"TRIGSTR_176","TRIGSTR_177","ReplaceableTextures\\CommandButtons\\BTNMonsoon.blp")
call CreateQuestBJ(bj_QUESTTYPE_REQ_DISCOVERED,"TRIGSTR_178","TRIGSTR_179","ReplaceableTextures\\CommandButtons\\BTNMonsoon.blp")
call CreateQuestBJ(bj_QUESTTYPE_REQ_DISCOVERED,"TRIGSTR_180","TRIGSTR_181","ReplaceableTextures\\CommandButtons\\BTNMonsoon.blp")
call CreateQuestBJ(bj_QUESTTYPE_REQ_DISCOVERED,"TRIGSTR_182","TRIGSTR_183","ReplaceableTextures\\CommandButtons\\BTNTranquility.blp")
call CreateQuestBJ(bj_QUESTTYPE_REQ_DISCOVERED,"TRIGSTR_184","TRIGSTR_185","ReplaceableTextures\\CommandButtons\\BTNTranquility.blp")
call CreateQuestBJ(bj_QUESTTYPE_OPT_DISCOVERED,"TRIGSTR_358","TRIGSTR_520","ReplaceableTextures\\CommandButtons\\BTNPillage.blp")
call DestroyTrigger(GetTriggeringTrigger())
endfunction
function YDE takes nothing returns boolean
local integer YfE=sy
local integer YFE=uy
call LoadStr(i,Vl[YfE],YFE)
return true
endfunction
function YgE takes string YGE returns nothing
local integer YhE
set ZM[EM]=YGE
set EM=EM+1
set YhE=zTa(vTV())
if YhE!=0 and(not zra(YhE,"when calling areAllPlayersSynced in SyncSimple, line 180"))then
call Cbv("SimpleSynchronizer: dummy unit was removed before all players synced, make sure your map doesn't remove neutral dummy units")
endif
set EM=EM-1
endfunction
function YHE takes nothing returns nothing
set EM=0
call YgE("SyncSimple, line 177")
endfunction
function YjE takes nothing returns nothing
local unit YJE
local real YkE
local real YKE
local real YlE
if GetUnitAbilityLevel(GetTriggerUnit(),'B056')==0 or GetEventDamage()==.0 then
set YJE=null
return
endif
set YJE=GetTriggerUnit()
set YkE=GetEventDamage()
set YKE=LoadReal(i,HO,GetHandleId(YJE))
if YkE/2.<YKE then
set YlE=YkE/2.
else
set YlE=YKE
endif
call BlzSetEventDamage(YkE-YlE)
call SaveReal(i,HO,GetHandleId(YJE),(YKE-YlE)*1.)
if YKE==YlE then
call UnitRemoveAbility(YJE,'B056')
endif
set YJE=null
set YJE=null
endfunction
function YLE takes nothing returns nothing
call CameraClearNoiseForPlayer(GetEnumPlayer())
endfunction
function YmE takes nothing returns boolean
return(er<=100.)
endfunction
function YME takes nothing returns boolean
return(CountUnitsInGroup(lr[rr])==0)
endfunction
function YpE takes nothing returns boolean
return(GetUnitFlyHeight(GetEnumUnit())<5.)
endfunction
function YPE takes nothing returns boolean
return(Mu==1)
endfunction
function YqE takes nothing returns boolean
return(Mu==2)
endfunction
function YQE takes nothing returns nothing
set Ju[2]=GetUnitLoc(Nu)
set er=LoadRealBJ(1,GetHandleIdBJ(GetEnumUnit()),Au)
set qr=LoadRealBJ(2,GetHandleIdBJ(GetEnumUnit()),Au)
set ar=LoadRealBJ(3,GetHandleIdBJ(GetEnumUnit()),Au)
if YmE()then
set Ju[3]=PolarProjectionBJ(Ju[2],er+2.,qr+10.)
call SaveRealBJ(er+2.,1,GetHandleIdBJ(GetEnumUnit()),Au)
else
set Ju[3]=PolarProjectionBJ(Ju[2],er,qr+5.)
endif
call SaveRealBJ(qr+10.,2,GetHandleIdBJ(GetEnumUnit()),Au)
call SaveRealBJ(ar+3.,3,GetHandleIdBJ(GetEnumUnit()),Au)
call SetUnitPositionLocFacingBJ(GetEnumUnit(),Ju[3],qr+90.)
call SetUnitFlyHeightBJ(GetEnumUnit(),GetUnitFlyHeight(GetEnumUnit())-3.,.0)
call SetUnitScalePercent(GetEnumUnit(),ar,ar,ar)
if YpE()then
call KillUnit(GetEnumUnit())
call GroupRemoveUnitSimple(GetEnumUnit(),lr[rr])
call GroupAddUnitSimple(GetEnumUnit(),Ku)
call SaveIntegerBJ(Du+1,0,GetHandleIdBJ(GetEnumUnit()),Au)
if YPE()then
call AddSpecialEffectLocBJ(Ju[3],"Abilities\\Weapons\\LichMissile\\LichMissile.mdl")
elseif YqE()then
call AddSpecialEffectLocBJ(Ju[3],"Abilities\\Weapons\\RedDragonBreath\\RedDragonMissile.mdl")
else
call AddSpecialEffectLocBJ(Ju[3],"Abilities\\Weapons\\FarseerMissile\\FarseerMissile.mdl")
endif
call DestroyEffectBJ(GetLastCreatedEffectBJ())
if YME()then
call SaveIntegerBJ(0,$A,Bu,Au)
call SaveIntegerBJ(3,7,Bu,Au)
endif
endif
call RemoveLocation(Ju[2])
call RemoveLocation(Ju[3])
endfunction
function YsE takes nothing returns nothing
set vq[0]="absorb"
set vq[1]="acidbomb"
set vq[2]="acolyteharvest"
set vq[3]="whirlwind"
set vq[4]="ambush"
set vq[5]="ancestralspirit"
set vq[6]="ancestralspirittarget"
set vq[7]="animatedead"
set vq[8]="antimagicshell"
set vq[9]="webon"
set vq[$A]="weboff"
set vq[$B]="web"
set vq[$C]="attributemodskill"
set vq[$D]="auraunholy"
set vq[$E]="auravampiric"
set vq[$F]="autodispel"
set vq[16]="autodispeloff"
set vq[17]="autodispelon"
set vq[18]="autoentangle"
set vq[19]="autoentangleinstant"
set vq[20]="wateryminion"
set vq[21]="waterelemental"
set vq[22]="avatar"
set vq[23]="avengerform"
set vq[24]="awaken"
set vq[25]="banish"
set vq[26]="barkskin"
set vq[27]="barkskinoff"
set vq[28]="barkskinon"
set vq[29]="battleroar"
set vq[30]="battlestations"
set vq[31]="bearform"
set vq[32]="berserk"
set vq[33]="blackarrow"
set vq[34]="blackarrowoff"
set vq[35]="blackarrowon"
set vq[36]="blight"
set vq[37]="blink"
set vq[38]="blizzard"
set vq[39]="bloodlust"
set vq[40]="bloodlustoff"
set vq[41]="bloodluston"
set vq[42]="board"
set vq[43]="breathoffire"
set vq[44]="breathoffrost"
set vq[45]="ward"
set vq[46]="burrow"
set vq[47]="cannibalize"
set vq[48]="carrionscarabs"
set vq[49]="carrionscarabsinstant"
set vq[50]="carrionscarabsoff"
set vq[51]="carrionscarabson"
set vq[52]="carrionswarm"
set vq[53]="chainlightning"
set vq[54]="channel"
set vq[55]="charm"
set vq[56]="chemicalrage"
set vq[57]="cloudoffog"
set vq[58]="clusterrockets"
set vq[59]="coldarrows"
set vq[60]="coldarrowstarg"
set vq[61]="controlmagic"
set vq[62]="corporealform"
set vq[63]="corrosivebreath"
set vq[64]="coupleinstant"
set vq[65]="coupletarget"
set vq[66]="creepanimatedead"
set vq[67]="creepdevour"
set vq[68]="creepheal"
set vq[69]="creephealoff"
set vq[70]="creephealon"
set vq[71]="creepthunderbolt"
set vq[72]="creepthunderclap"
set vq[73]="cripple"
set vq[74]="curse"
set vq[75]="curseoff"
set vq[76]="curseon"
set vq[77]="cyclone"
set vq[78]="darkconversion"
set vq[79]="darkportal"
set vq[80]="darkritual"
set vq[81]="darksummoning"
set vq[82]="deathanddecay"
set vq[83]="deathcoil"
set vq[84]="deathpact"
set vq[85]="windwalk"
set vq[86]="defend"
set vq[87]="detectaoe"
set vq[88]="detonate"
set vq[89]="devour"
set vq[90]="devourmagic"
set vq[91]="disassociate"
set vq[92]="disenchant"
set vq[93]="dismount"
set vq[94]="dispel"
set vq[95]="divineshield"
set vq[96]="doom"
set vq[97]="drain"
set vq[98]="dreadlordinferno"
set vq[99]="dropitem"
set vq['d']="drunkenhaze"
set vq['e']="earthquake"
set vq['f']="eattree"
set vq['g']="elementalfury"
set vq['h']="wispharvest"
set vq['i']="ensnareoff"
set vq['j']="ensnareon"
set vq['k']="entangle"
set vq['l']="entangleinstant"
set vq['m']="entanglingroots"
set vq['n']="etherealform"
set vq['o']="evileye"
set vq['p']="faeriefire"
set vq['q']="faeriefireoff"
set vq['r']="faeriefireon"
set vq['s']="fanofknives"
set vq['t']="farsight"
set vq['u']="fingerofdeath"
set vq['v']="firebolt"
set vq['w']="flamestrike"
set vq['x']="flamingarrows"
set vq['y']="flamingarrowstarg"
set vq['z']="flamingattack"
set vq['{']="flamingattacktarg"
set vq['|']="flare"
set vq['}']="forceboard"
set vq[$7E]="forceofnature"
set vq[$7F]="forkedlightning"
set vq[$80]="freezingbreath"
set vq[$81]="frenzy"
set vq[$82]="frenzyoff"
set vq[$83]="frenzyon"
set vq[$84]="frostarmor"
set vq[$85]="frostarmoroff"
set vq[$86]="frostarmoron"
set vq[$87]="frostnova"
set vq[$88]="getitem"
set vq[$89]="gold2lumber"
set vq[$8A]="grabtree"
set vq[$8B]="harvest"
set vq[$8C]="heal"
set vq[$8D]="healingspray"
set vq[$8E]="healingward"
set vq[$8F]="healingwave"
set vq[$90]="healoff"
set vq[$91]="healon"
set vq[$92]="hex"
set vq[$93]="voodoo"
set vq[$94]="holybolt"
set vq[$95]="howlofterror"
set vq[$96]="humanbuild"
set vq[$97]="immolation"
set vq[$98]="impale"
set vq[$99]="incineratearrow"
set vq[$9A]="incineratearrowoff"
set vq[$9B]="incineratearrowon"
set vq[$9C]="inferno"
set vq[$9D]="innerfire"
set vq[$9E]="innerfireoff"
set vq[$9F]="innerfireon"
set vq[$A0]="instant"
set vq[$A1]="invisibility"
set vq[$A2]="lavamonster"
set vq[$A3]="lightningshield"
set vq[$A4]="load"
set vq[$A5]="loadarcher"
set vq[$A6]="loadcorpse"
set vq[$A7]="loadcorpseinstant"
set vq[$A8]="locustswarm"
set vq[$A9]="lumber2gold"
set vq[$AA]="magicdefense"
set vq[$AB]="magicleash"
set vq[$AC]="magicundefense"
set vq[$AD]="manaburn"
set vq[$AE]="manaflareoff"
set vq[$AF]="manaflareon"
set vq[$B0]="manashieldoff"
set vq[$B1]="manashieldon"
set vq[$B2]="massteleport"
set vq[$B3]="mechanicalcritter"
set vq[$B4]="metamorphosis"
set vq[$B5]="militia"
set vq[$B6]="militiaconvert"
set vq[$B7]="militiaoff"
set vq[$B8]="militiaunconvert"
set vq[$B9]="mindrot"
set vq[$BA]="mirrorimage"
set vq[$BB]="monsoon"
set vq[$BC]="mount"
set vq[$BD]="mounthippogryph"
set vq[$BE]="vengeanceoff"
set vq[$BF]="nagabuild"
set vq[$C0]="neutraldetectaoe"
set vq[$C1]="neutralinteract"
set vq[$C2]="neutralspell"
set vq[$C3]="nightelfbuild"
set vq[$C4]="orcbuild"
set vq[$C5]="parasite"
set vq[$C6]="parasiteoff"
set vq[$C7]="parasiteon"
set vq[$C8]="patrol"
set vq[$C9]="phaseshift"
set vq[$CA]="phaseshiftinstant"
set vq[$CB]="phaseshiftoff"
set vq[$CC]="phaseshifton"
set vq[$CD]="phoenixfire"
set vq[$CE]="phoenixmorph"
set vq[$CF]="poisonarrows"
set vq[$D0]="poisonarrowstarg"
set vq[$D1]="polymorph"
set vq[$D2]="possession"
set vq[$D3]="preservation"
set vq[$D4]="purge"
set vq[$D5]="rainofchaos"
set vq[$D6]="rainoffire"
set vq[$D7]="raisedead"
set vq[$D8]="raisedeadoff"
set vq[$D9]="raisedeadon"
set vq[$DA]="ravenform"
set vq[$DB]="recharge"
set vq[$DC]="rechargeoff"
set vq[$DD]="rechargeon"
set vq[$DE]="rejuvination"
set vq[$DF]="renew"
set vq[$E0]="renewoff"
set vq[$E1]="renewon"
set vq[$E2]="repair"
set vq[$E3]="repairoff"
set vq[$E4]="repairon"
set vq[$E5]="replenish"
set vq[$E6]="replenishlife"
set vq[$E7]="replenishlifeoff"
set vq[$E8]="replenishlifeon"
set vq[$E9]="replenishmana"
set vq[$EA]="replenishmanaoff"
set vq[$EB]="replenishmanaon"
set vq[$EC]="replenishoff"
set vq[$ED]="replenishon"
set vq[$EE]="request_hero"
set vq[$EF]="requestsacrifice"
set vq[$F0]="restoration"
set vq[$F1]="restorationoff"
set vq[$F2]="restorationon"
set vq[$F3]="resumebuild"
set vq[$F4]="resumeharvesting"
set vq[$F5]="resurrection"
set vq[$F6]="returnresources"
set vq[$F7]="revenge"
set vq[$F8]="revive"
set vq[$F9]="roar"
set vq[$FA]="robogoblin"
set vq[$FB]="root"
set vq[$FC]="sacrifice"
set vq[$FD]="sanctuary"
set vq[$FE]="scout"
set vq[$FF]="selfdestruct"
set vq[256]="selfdestructoff"
set vq[257]="selfdestructon"
set vq[258]="sentinel"
set vq[259]="setrally"
set vq[260]="shadowsight"
set vq[261]="shadowstrike"
set vq[262]="shockwave"
set vq[263]="silence"
set vq[264]="sleep"
set vq[265]="slow"
set vq[266]="slowoff"
set vq[267]="slowon"
set vq[268]="vengeanceon"
set vq[269]="soulburn"
set vq[270]="soulpreservation"
set vq[271]="spellshield"
set vq[272]="spellshieldaoe"
set vq[273]="spellsteal"
set vq[274]="spellstealoff"
set vq[275]="spellstealon"
set vq[276]="spies"
set vq[277]="spiritlink"
set vq[278]="spiritofvengeance"
set vq[279]="spirittroll"
set vq[280]="spiritwolf"
set vq[281]="stampede"
set vq[282]="standdown"
set vq[283]="starfall"
set vq[284]="stasistrap"
set vq[285]="steal"
set vq[286]="stomp"
set vq[287]="stoneform"
set vq[288]="volcano"
set vq[289]="submerge"
set vq[290]="summonfactory"
set vq[291]="summongrizzly"
set vq[292]="summonphoenix"
set vq[293]="summonquillbeast"
set vq[294]="summonwareagle"
set vq[295]="tankdroppilot"
set vq[296]="tankloadpilot"
set vq[297]="tankpilot"
set vq[298]="taunt"
set vq[299]="thunderbolt"
set vq[300]="thunderclap"
set vq[301]="tornado"
set vq[302]="townbelloff"
set vq[303]="townbellon"
set vq[304]="tranquility"
set vq[305]="transmute"
set vq[306]="unavatar"
set vq[307]="unavengerform"
set vq[308]="unbearform"
set vq[309]="unburrow"
set vq[310]="uncoldarrows"
set vq[311]="uncorporealform"
set vq[312]="undeadbuild"
set vq[313]="undefend"
set vq[314]="undivineshield"
set vq[315]="unetherealform"
set vq[316]="unflamingarrows"
set vq[317]="unflamingattack"
set vq[318]="unholyfrenzy"
set vq[319]="unimmolation"
set vq[320]="unload"
set vq[321]="unloadall"
set vq[322]="unloadallcorpses"
set vq[323]="unloadallinstant"
set vq[324]="unpoisonarrows"
set vq[325]="unravenform"
set vq[326]="unrobogoblin"
set vq[327]="unroot"
set vq[328]="unstableconcoction"
set vq[329]="unstoneform"
set vq[330]="unsubmerge"
set vq[331]="unsummon"
set vq[332]="unwindwalk"
set vq[333]="vengeance"
set vq[334]="vengeanceinstant"
endfunction
function YSE takes integer YtE,boolean YTE,string YuE returns string
set ZM[EM]=YuE
set EM=EM+1
if vq[0]==null then
call YsE()
endif
set hD[YtE]=hD[YtE]+1
if hD[YtE]>334 then
if YTE then
set hD[YtE]=0
else
call Cdv("Cannot get more than 344 Orders from an OrderStringFactory","when calling error in OrderStringFactory, line 17")
endif
endif
set EM=EM-1
return vq[hD[YtE]]
endfunction
function YUE takes integer YwE,boolean YWE,string YyE returns string
local string YYE
set ZM[EM]=YyE
set EM=EM+1
if fk[YwE]==0 then
if YwE==0 then
call Cdv("Nullpointer exception when calling OrderStringFactory.getOrderString","when calling error in OrderStringFactory, line 9")
else
call Cdv("Called OrderStringFactory.getOrderString on invalid object.","when calling error in OrderStringFactory, line 9")
endif
endif
set YYE=YSE(YwE,YWE,"when calling getOrderString in OrderStringFactory, line 9")
set EM=EM-1
return YYE
endfunction
function YzE takes string YZE returns integer
local integer Y_E
set ZM[EM]=YZE
set EM=EM+1
if lY==0 then
if bY<$8000 then
set bY=bY+1
set Y_E=bY
set yY[Y_E]=4820
else
call Cdv("Out of memory: Could not create StringLevelClosure_AbilityDefinition_AbilityObjEditing.","when calling error in AbilityObjEditing, line 320")
set Y_E=0
endif
else
set lY=lY-1
set Y_E=OY[lY]
set yY[Y_E]=4820
endif
set EM=EM-1
return Y_E
endfunction
function Y0E takes integer Y1E,integer Y2E,string Y3E returns nothing
local integer Y4E
local integer Y5E
set ZM[EM]=Y3E
set EM=EM+1
call lva(rQ[Y1E],"alev",0,0,Y2E)
set sQ[Y1E]=Y2E
set Y5E=YzE("when calling alloc_StringLevelClosure_AbilityDefinition_AbilityObjEditing in AbilityObjEditing, line 320")
set eQ[Y5E]=Y2E
set Y4E=Y5E
call hya(Y1E,"Levels",Y4E,"when calling addTooltipProperty in AbilityObjEditing, line 321")
set EM=EM-1
endfunction
function Y6E takes integer Y7E,integer Y8E,string Y9E returns nothing
set ZM[EM]=Y9E
set EM=EM+1
if tY[Y7E]==0 then
if Y7E==0 then
call Cdv("Nullpointer exception when calling AbilityDefinition.setLevels","when calling error in AbilityObjEditing, line 317")
else
call Cdv("Called AbilityDefinition.setLevels on invalid object.","when calling error in AbilityObjEditing, line 317")
endif
endif
call Y0E(Y7E,Y8E,"when calling setLevels in AbilityObjEditing, line 317")
set EM=EM-1
endfunction
function zvE takes integer zeE,string zxE returns nothing
call h0a(rQ[zeE],"aeat",0,0,zxE)
endfunction
function zoE takes integer zrE,string ziE,string zaE returns nothing
set ZM[EM]=zaE
set EM=EM+1
if tY[zrE]==0 then
if zrE==0 then
call Cdv("Nullpointer exception when calling AbilityDefinition.setArtEffect","when calling error in AbilityObjEditing, line 171")
else
call Cdv("Called AbilityDefinition.setArtEffect on invalid object.","when calling error in AbilityObjEditing, line 171")
endif
endif
call zvE(zrE,ziE)
set EM=EM-1
endfunction
function znE takes integer zVE,string zEE returns nothing
call h0a(rQ[zVE],"acat",0,0,zEE)
endfunction
function zXE takes integer zOE,string zRE,string zIE returns nothing
set ZM[EM]=zIE
set EM=EM+1
if tY[zOE]==0 then
if zOE==0 then
call Cdv("Nullpointer exception when calling AbilityDefinition.setArtCaster","when calling error in AbilityObjEditing, line 162")
else
call Cdv("Called AbilityDefinition.setArtCaster on invalid object.","when calling error in AbilityObjEditing, line 162")
endif
endif
call znE(zOE,zRE)
set EM=EM-1
endfunction
function zAE takes integer zNE,string zbE returns nothing
call h0a(rQ[zNE],"asat",0,0,zbE)
endfunction
function zBE takes integer zcE,string zCE,string zdE returns nothing
set ZM[EM]=zdE
set EM=EM+1
if tY[zcE]==0 then
if zcE==0 then
call Cdv("Nullpointer exception when calling AbilityDefinition.setArtSpecial","when calling error in AbilityObjEditing, line 168")
else
call Cdv("Called AbilityDefinition.setArtSpecial on invalid object.","when calling error in AbilityObjEditing, line 168")
endif
endif
call zAE(zcE,zCE)
set EM=EM-1
endfunction
function zDE takes integer zfE,integer zFE,string zgE returns nothing
set ZM[EM]=zgE
set EM=EM+1
call CHE(rQ[zfE],"Ncl4",sQ[zfE],4,zFE,"when calling setLevelsDataUnreal in AbilityObjEditing, line 9841")
call CDE(zfE,"ArtDuration",zFE,"when calling addTooltipProperty in AbilityObjEditing, line 9842")
set EM=EM-1
endfunction
function zGE takes integer zhE,integer zHE,string zjE returns nothing
set ZM[EM]=zjE
set EM=EM+1
if tY[zhE]==0 then
if zhE==0 then
call Cdv("Nullpointer exception when calling AbilityDefinitionIllidanChannel.presetArtDuration","when calling error in AbilityObjEditing, line 9840")
else
call Cdv("Called AbilityDefinitionIllidanChannel.presetArtDuration on invalid object.","when calling error in AbilityObjEditing, line 9840")
endif
endif
call zDE(zhE,zHE,"when calling presetArtDuration in AbilityObjEditing, line 9840")
set EM=EM-1
endfunction
function zJE takes integer zkE,string zKE returns nothing
call h0a(rQ[zkE],"atat",0,0,zKE)
endfunction
function zlE takes integer zLE,string zmE,string zME returns nothing
set ZM[EM]=zME
set EM=EM+1
if tY[zLE]==0 then
if zLE==0 then
call Cdv("Nullpointer exception when calling AbilityDefinition.setArtTarget","when calling error in AbilityObjEditing, line 165")
else
call Cdv("Called AbilityDefinition.setArtTarget on invalid object.","when calling error in AbilityObjEditing, line 165")
endif
endif
call zJE(zLE,zmE)
set EM=EM-1
endfunction
function zpE takes string zPE returns integer
local integer zqE
set ZM[EM]=zPE
set EM=EM+1
if DG==0 then
if HG<$8000 then
set HG=HG+1
set zqE=HG
set JG[zqE]=4169
else
call Cdv("Out of memory: Could not create RealLevelClosure_presetArtDuration_ChannelAbilityPreset_ChannelAbilityPreset.","when calling error in ChannelAbilityPreset, line 79")
set zqE=0
endif
else
set DG=DG-1
set zqE=AG[DG]
set JG[zqE]=4169
endif
set EM=EM-1
return zqE
endfunction
function zQE takes string zsE returns integer
local integer zSE
set ZM[EM]=zsE
set EM=EM+1
if UG==0 then
if IG<$8000 then
set IG=IG+1
set zSE=IG
set PG[zSE]=$415
else
call Cdv("Out of memory: Could not create BooleanLevelClosure_presetDisableOtherAbilities_ChannelAbilityPreset_ChannelAbilityPreset.","when calling error in ChannelAbilityPreset, line 77")
set zSE=0
endif
else
set UG=UG-1
set zSE=ZG[UG]
set PG[zSE]=$415
endif
set EM=EM-1
return zSE
endfunction
function ztE takes string zTE returns integer
local integer zuE
set ZM[EM]=zTE
set EM=EM+1
if DG==0 then
if HG<$8000 then
set HG=HG+1
set zuE=HG
set JG[zuE]=4202
else
call Cdv("Out of memory: Could not create RealLevelClosure_presetFollowThroughTime_ChannelAbilityPreset_ChannelAbilityPreset.","when calling error in ChannelAbilityPreset, line 78")
set zuE=0
endif
else
set DG=DG-1
set zuE=AG[DG]
set JG[zuE]=4202
endif
set EM=EM-1
return zuE
endfunction
function zUE takes string zwE returns integer
local integer zWE
set ZM[EM]=zwE
set EM=EM+1
if SY==0 then
if cY<$8000 then
set cY=cY+1
set zWE=cY
set oY[zWE]=$C53
else
call Cdv("Out of memory: Could not create IntLevelClosure_presetOptions_ChannelAbilityPreset_ChannelAbilityPreset.","when calling error in ChannelAbilityPreset, line 99")
set zWE=0
endif
else
set SY=SY-1
set zWE=iY[SY]
set oY[zWE]=$C53
endif
set EM=EM-1
return zWE
endfunction
function zyE takes integer zYE,integer zzE,string zZE returns nothing
set ZM[EM]=zZE
set EM=EM+1
call lea(rQ[zYE],"Ncl3",sQ[zYE],3,zzE,"when calling setLevelsDataInt in AbilityObjEditing, line 9876")
call K5a(zYE,"Options",zzE,"when calling addTooltipProperty in AbilityObjEditing, line 9877")
set EM=EM-1
endfunction
function z_E takes integer z0E,integer z1E,string z2E returns nothing
set ZM[EM]=z2E
set EM=EM+1
if tY[z0E]==0 then
if z0E==0 then
call Cdv("Nullpointer exception when calling AbilityDefinitionIllidanChannel.presetOptions","when calling error in AbilityObjEditing, line 9875")
else
call Cdv("Called AbilityDefinitionIllidanChannel.presetOptions on invalid object.","when calling error in AbilityObjEditing, line 9875")
endif
endif
call zyE(z0E,z1E,"when calling presetOptions in AbilityObjEditing, line 9875")
set EM=EM-1
endfunction
function z3E takes integer z4E,integer z5E,boolean z6E,string z7E returns nothing
local integer z8E
local integer z9E
local integer ZvE
local integer ZeE
local integer ZxE
set ZM[EM]=z7E
set EM=EM+1
set z8E=z5E
if n9e(qW[z4E],z8E)then
if not z6E then
set ZeE=Dav(qW[z4E],z8E)
set qW[z4E]=ZeE
endif
elseif z6E then
set ZxE=dpv(qW[z4E],z8E)
set qW[z4E]=ZxE
endif
set ZvE=z4E
set z9E=zUE("when calling alloc_IntLevelClosure_presetOptions_ChannelAbilityPreset_ChannelAbilityPreset in ChannelAbilityPreset, line 99")
set TW[z9E]=z4E
call z_E(ZvE,z9E,"when calling presetOptions in ChannelAbilityPreset, line 99")
set EM=EM-1
endfunction
function ZoE takes integer ZrE,integer ZiE,boolean ZaE,string ZnE returns nothing
set ZM[EM]=ZnE
set EM=EM+1
if tY[ZrE]==0 then
if ZrE==0 then
call Cdv("Nullpointer exception when calling ChannelAbilityPreset.presetOption","when calling error in ChannelAbilityPreset, line 91")
else
call Cdv("Called ChannelAbilityPreset.presetOption on invalid object.","when calling error in ChannelAbilityPreset, line 91")
endif
endif
call z3E(ZrE,ZiE,ZaE,"when calling presetOption in ChannelAbilityPreset, line 91")
set EM=EM-1
endfunction
function ZVE takes integer ZEE,integer ZXE,string ZOE returns nothing
set ZM[EM]=ZOE
set EM=EM+1
call CHE(rQ[ZEE],"Ncl1",sQ[ZEE],1,ZXE,"when calling setLevelsDataUnreal in AbilityObjEditing, line 9862")
call CDE(ZEE,"FollowThroughTime",ZXE,"when calling addTooltipProperty in AbilityObjEditing, line 9863")
set EM=EM-1
endfunction
function ZRE takes integer ZIE,integer ZAE,string ZNE returns nothing
set ZM[EM]=ZNE
set EM=EM+1
if tY[ZIE]==0 then
if ZIE==0 then
call Cdv("Nullpointer exception when calling AbilityDefinitionIllidanChannel.presetFollowThroughTime","when calling error in AbilityObjEditing, line 9861")
else
call Cdv("Called AbilityDefinitionIllidanChannel.presetFollowThroughTime on invalid object.","when calling error in AbilityObjEditing, line 9861")
endif
endif
call ZVE(ZIE,ZAE,"when calling presetFollowThroughTime in AbilityObjEditing, line 9861")
set EM=EM-1
endfunction
function ZbE takes string ZBE returns integer
local integer ZcE
set ZM[EM]=ZBE
set EM=EM+1
if lY==0 then
if bY<$8000 then
set bY=bY+1
set ZcE=bY
set yY[ZcE]=4823
else
call Cdv("Out of memory: Could not create StringLevelClosure_addTooltipProperty_AbilityDefinition_AbilityObjEditing.","when calling error in AbilityObjEditing, line 80")
set ZcE=0
endif
else
set lY=lY-1
set ZcE=OY[lY]
set yY[ZcE]=4823
endif
set EM=EM-1
return ZcE
endfunction
function ZCE takes integer ZdE,string ZDE,integer ZfE,string ZFE returns nothing
local integer ZgE
local integer ZGE
local string ZhE
set ZM[EM]=ZFE
set EM=EM+1
set ZGE=ZdE
set ZhE=ZDE
set ZgE=ZbE("when calling alloc_StringLevelClosure_addTooltipProperty_AbilityDefinition_AbilityObjEditing in AbilityObjEditing, line 80")
set bQ[ZgE]=ZfE
call hya(ZGE,ZhE,ZgE,"when calling addTooltipProperty in AbilityObjEditing, line 80")
set EM=EM-1
endfunction
function ZHE takes integer ZjE,string ZJE,integer ZkE,string ZKE returns nothing
set ZM[EM]=ZKE
set EM=EM+1
if tY[ZjE]==0 then
if ZjE==0 then
call Cdv("Nullpointer exception when calling AbilityDefinition.addTooltipProperty","when calling error in AbilityObjEditing, line 79")
else
call Cdv("Called AbilityDefinition.addTooltipProperty on invalid object.","when calling error in AbilityObjEditing, line 79")
endif
endif
call ZCE(ZjE,ZJE,ZkE,"when calling addTooltipProperty in AbilityObjEditing, line 79")
set EM=EM-1
endfunction
function ZlE takes integer ZLE,string ZmE,integer ZME,integer ZpE,boolean ZPE returns nothing
if ZPE then
call lva(ZLE,ZmE,ZME,ZpE,1)
else
call lva(ZLE,ZmE,ZME,ZpE,0)
endif
endfunction
function ZqE takes integer ZQE,string ZsE,integer ZSE,integer ZtE,integer ZTE,string ZuE returns nothing
local integer ZUE
local integer ZwE
set ZM[EM]=ZuE
set EM=EM+1
set ZUE=1
set ZwE=ZSE
loop
exitwhen ZUE>ZwE
call ZlE(ZQE,ZsE,ZUE,ZtE,kGa(ZTE,ZUE,"when calling run in ObjEditingNatives, line 106"))
set ZUE=ZUE+1
endloop
set EM=EM-1
endfunction
function ZWE takes integer ZyE,integer ZYE,string ZzE returns nothing
set ZM[EM]=ZzE
set EM=EM+1
call ZqE(rQ[ZyE],"Ncl5",sQ[ZyE],5,ZYE,"when calling setLevelsDataBoolean in AbilityObjEditing, line 9855")
call ZHE(ZyE,"DisableOtherAbilities",ZYE,"when calling addTooltipProperty in AbilityObjEditing, line 9856")
set EM=EM-1
endfunction
function ZZE takes integer Z_E,integer Z0E,string Z1E returns nothing
set ZM[EM]=Z1E
set EM=EM+1
if tY[Z_E]==0 then
if Z_E==0 then
call Cdv("Nullpointer exception when calling AbilityDefinitionIllidanChannel.presetDisableOtherAbilities","when calling error in AbilityObjEditing, line 9854")
else
call Cdv("Called AbilityDefinitionIllidanChannel.presetDisableOtherAbilities on invalid object.","when calling error in AbilityObjEditing, line 9854")
endif
endif
call ZWE(Z_E,Z0E,"when calling presetDisableOtherAbilities in AbilityObjEditing, line 9854")
set EM=EM-1
endfunction
function Z2E takes integer Z3E,boolean Z4E,boolean Z5E,string Z6E returns nothing
local integer Z7E
local integer Z8E
local integer Z9E
local integer vvX
local integer veX
local integer vxX
set ZM[EM]=Z6E
set EM=EM+1
set vvX=Z3E
set Z7E=zQE("when calling alloc_BooleanLevelClosure_presetDisableOtherAbilities_ChannelAbilityPreset_ChannelAbilityPreset in ChannelAbilityPreset, line 77")
call ZZE(vvX,Z7E,"when calling presetDisableOtherAbilities in ChannelAbilityPreset, line 77")
set veX=Z3E
set Z8E=ztE("when calling alloc_RealLevelClosure_presetFollowThroughTime_ChannelAbilityPreset_ChannelAbilityPreset in ChannelAbilityPreset, line 78")
call ZRE(veX,Z8E,"when calling presetFollowThroughTime in ChannelAbilityPreset, line 78")
set vxX=Z3E
set Z9E=zpE("when calling alloc_RealLevelClosure_presetArtDuration_ChannelAbilityPreset_ChannelAbilityPreset in ChannelAbilityPreset, line 79")
call zGE(vxX,Z9E,"when calling presetArtDuration in ChannelAbilityPreset, line 79")
if Z5E then
call ZoE(Z3E,0,true,"when calling presetOption in ChannelAbilityPreset, line 81")
endif
if Z4E then
call zXE(Z3E,"","when calling setArtCaster in ChannelAbilityPreset, line 83")
call zoE(Z3E,"","when calling setArtEffect in ChannelAbilityPreset, line 84")
call zBE(Z3E,"","when calling setArtSpecial in ChannelAbilityPreset, line 85")
call zlE(Z3E,"","when calling setArtTarget in ChannelAbilityPreset, line 86")
endif
set EM=EM-1
endfunction
function voX takes integer vrX,boolean viX,boolean vaX,string vnX returns nothing
set ZM[EM]=vnX
set EM=EM+1
if tY[vrX]==0 then
if vrX==0 then
call Cdv("Nullpointer exception when calling ChannelAbilityPreset.removeChannelProperties","when calling error in ChannelAbilityPreset, line 76")
else
call Cdv("Called ChannelAbilityPreset.removeChannelProperties on invalid object.","when calling error in ChannelAbilityPreset, line 76")
endif
endif
call Z2E(vrX,viX,vaX,"when calling removeChannelProperties in ChannelAbilityPreset, line 76")
set EM=EM-1
endfunction
function vVX takes integer vEX,boolean vXX,string vOX returns nothing
set ZM[EM]=vOX
set EM=EM+1
call voX(vEX,vXX,true,"when calling removeChannelProperties in ChannelAbilityPreset, line 74")
set EM=EM-1
endfunction
function vRX takes integer vIX,boolean vAX,string vNX returns nothing
set ZM[EM]=vNX
set EM=EM+1
if tY[vIX]==0 then
if vIX==0 then
call Cdv("Nullpointer exception when calling ChannelAbilityPreset.removeChannelProperties","when calling error in ChannelAbilityPreset, line 73")
else
call Cdv("Called ChannelAbilityPreset.removeChannelProperties on invalid object.","when calling error in ChannelAbilityPreset, line 73")
endif
endif
call vVX(vIX,vAX,"when calling removeChannelProperties in ChannelAbilityPreset, line 73")
set EM=EM-1
endfunction
function vbX takes integer vBX,integer vcX,string vCX returns nothing
set ZM[EM]=vCX
set EM=EM+1
call kya(rQ[vBX],"Ncl6",sQ[vBX],6,vcX,"when calling setLevelsDataString in AbilityObjEditing, line 9848")
call hya(vBX,"BaseOrderID",vcX,"when calling addTooltipProperty in AbilityObjEditing, line 9849")
set EM=EM-1
endfunction
function vdX takes integer vDX,integer vfX,string vFX returns nothing
set ZM[EM]=vFX
set EM=EM+1
if tY[vDX]==0 then
if vDX==0 then
call Cdv("Nullpointer exception when calling AbilityDefinitionIllidanChannel.presetBaseOrderID","when calling error in AbilityObjEditing, line 9847")
else
call Cdv("Called AbilityDefinitionIllidanChannel.presetBaseOrderID on invalid object.","when calling error in AbilityObjEditing, line 9847")
endif
endif
call vbX(vDX,vfX,"when calling presetBaseOrderID in AbilityObjEditing, line 9847")
set EM=EM-1
endfunction
function vgX takes integer xec,integer vec returns nothing
endfunction
function vGX takes integer vhX,boolean vHX returns nothing
set iQ[vhX]=false
if tQ[vhX]!=0 and vHX then
call vgX(tQ[vhX],vhX)
endif
endfunction
function vjX takes integer vJX,boolean vkX,string vKX returns nothing
set ZM[EM]=vKX
set EM=EM+1
if tY[vJX]==0 then
if vJX==0 then
call Cdv("Nullpointer exception when calling AbilityDefinition.tooltipStopListen","when calling error in AbilityObjEditing, line 91")
else
call Cdv("Called AbilityDefinition.tooltipStopListen on invalid object.","when calling error in AbilityObjEditing, line 91")
endif
endif
call vGX(vJX,vkX)
set EM=EM-1
endfunction
function vlX takes string vLX returns integer
local integer vmX
set ZM[EM]=vLX
set EM=EM+1
if lY==0 then
if bY<$8000 then
set bY=bY+1
set vmX=bY
set yY[vmX]=4825
else
call Cdv("Out of memory: Could not create StringLevelClosure_presetBaseOrderID_ChannelAbilityPreset_ChannelAbilityPreset.","when calling error in ChannelAbilityPreset, line 64")
set vmX=0
endif
else
set lY=lY-1
set vmX=OY[lY]
set yY[vmX]=4825
endif
set EM=EM-1
return vmX
endfunction
function vMX takes integer vpX returns nothing
set iQ[vpX]=true
endfunction
function vPX takes integer vqX,string vQX returns nothing
set ZM[EM]=vQX
set EM=EM+1
if tY[vqX]==0 then
if vqX==0 then
call Cdv("Nullpointer exception when calling AbilityDefinition.tooltipStartListen","when calling error in AbilityObjEditing, line 85")
else
call Cdv("Called AbilityDefinition.tooltipStartListen on invalid object.","when calling error in AbilityObjEditing, line 85")
endif
endif
call vMX(vqX)
set EM=EM-1
endfunction
function vsX takes integer vSX,integer vtX,boolean vTX,string vuX returns nothing
local integer vUX
local integer vwX
set ZM[EM]=vuX
set EM=EM+1
set sQ[vSX]=vtX
call vPX(vSX,"when calling tooltipStartListen in ChannelAbilityPreset, line 60")
call Y6E(vSX,vtX,"when calling setLevels in ChannelAbilityPreset, line 61")
call vjX(vSX,false,"when calling tooltipStopListen in ChannelAbilityPreset, line 62")
set aW[vSX]=YUE(vy,true,"when calling getOrderString in ChannelAbilityPreset, line 63")
set vwX=vSX
set vUX=vlX("when calling alloc_StringLevelClosure_presetBaseOrderID_ChannelAbilityPreset_ChannelAbilityPreset in ChannelAbilityPreset, line 64")
set nW[vUX]=vSX
call vdX(vwX,vUX,"when calling presetBaseOrderID in ChannelAbilityPreset, line 64")
if vTX then
call vRX(vSX,true,"when calling removeChannelProperties in ChannelAbilityPreset, line 66")
endif
set EM=EM-1
endfunction
function vWX takes integer vyX,integer vYX,boolean vzX,string vZX returns nothing
set ZM[EM]=vZX
set EM=EM+1
if tY[vyX]==0 then
if vyX==0 then
call Cdv("Nullpointer exception when calling ChannelAbilityPreset.setup","when calling error in ChannelAbilityPreset, line 58")
else
call Cdv("Called ChannelAbilityPreset.setup on invalid object.","when calling error in ChannelAbilityPreset, line 58")
endif
endif
call vsX(vyX,vYX,vzX,"when calling setup in ChannelAbilityPreset, line 58")
set EM=EM-1
endfunction
function v_X takes integer v0X returns nothing
local integer v1X=0
set qW[v0X]=v1X
endfunction
function v2X takes integer Sis returns nothing
endfunction
function v3X takes integer v4X,integer v5X returns nothing
call KLa(v4X,v5X,ty)
call v2X(v4X)
endfunction
function v6X takes integer v7X,integer v8X,integer v9X,boolean evX,string eeX returns nothing
set ZM[EM]=eeX
set EM=EM+1
call v3X(v7X,v8X)
call v_X(v7X)
call vWX(v7X,v9X,evX,"when calling setup in ChannelAbilityPreset, line 56")
set EM=EM-1
endfunction
function exX takes string eoX returns integer
local integer erX
set ZM[EM]=eoX
set EM=EM+1
if rY==0 then
if sY<$8000 then
set sY=sY+1
set erX=sY
set tY[erX]=319
else
call Cdv("Out of memory: Could not create ChannelAbilityPreset.","when calling error in ChannelAbilityPreset, line 42")
set erX=0
endif
else
set rY=rY-1
set erX=uY[rY]
set tY[erX]=319
endif
set EM=EM-1
return erX
endfunction
function eiX takes integer eaX,integer enX,boolean eVX,string eEX returns integer
local integer eXX
set ZM[EM]=eEX
set EM=EM+1
set eXX=exX("when calling alloc_ChannelAbilityPreset in ChannelAbilityPreset, line 54")
call v6X(eXX,eaX,enX,eVX,"when calling construct_ChannelAbilityPreset2 in ChannelAbilityPreset, line 54")
set EM=EM-1
return eXX
endfunction
function eOX takes string eRX returns integer
local integer eIX
set ZM[EM]=eRX
set EM=EM+1
if lY==0 then
if bY<$8000 then
set bY=bY+1
set eIX=bY
set yY[eIX]=4841
else
call Cdv("Out of memory: Could not create StringLevelClosure_presetBaseOrderID_presetTargetTypes_presetOption_presetCastRange_SotfrpGuiPresets.","when calling error in SotfrpGuiPresets, line 25")
set eIX=0
endif
else
set lY=lY-1
set eIX=OY[lY]
set yY[eIX]=4841
endif
set EM=EM-1
return eIX
endfunction
function eAX takes string eNX returns integer
local integer ebX
set ZM[EM]=eNX
set EM=EM+1
if DG==0 then
if HG<$8000 then
set HG=HG+1
set ebX=HG
set JG[ebX]=4175
else
call Cdv("Out of memory: Could not create RealLevelClosure_presetCastRange_SotfrpGuiPresets.","when calling error in SotfrpGuiPresets, line 28")
set ebX=0
endif
else
set DG=DG-1
set ebX=AG[DG]
set JG[ebX]=4175
endif
set EM=EM-1
return ebX
endfunction
function eBX takes string ecX returns integer
local integer eCX
set ZM[EM]=ecX
set EM=EM+1
if SY==0 then
if cY<$8000 then
set cY=cY+1
set eCX=cY
set oY[eCX]=$C57
else
call Cdv("Out of memory: Could not create IntLevelClosure_presetTargetType_ChannelAbilityPreset_ChannelAbilityPreset.","when calling error in ChannelAbilityPreset, line 89")
set eCX=0
endif
else
set SY=SY-1
set eCX=iY[SY]
set oY[eCX]=$C57
endif
set EM=EM-1
return eCX
endfunction
function edX takes integer eDX,integer efX,string eFX returns nothing
set ZM[EM]=eFX
set EM=EM+1
call lea(rQ[eDX],"Ncl2",sQ[eDX],2,efX,"when calling setLevelsDataInt in AbilityObjEditing, line 9869")
call K5a(eDX,"TargetType",efX,"when calling addTooltipProperty in AbilityObjEditing, line 9870")
set EM=EM-1
endfunction
function egX takes integer eGX,integer ehX,string eHX returns nothing
set ZM[EM]=eHX
set EM=EM+1
if tY[eGX]==0 then
if eGX==0 then
call Cdv("Nullpointer exception when calling AbilityDefinitionIllidanChannel.presetTargetType","when calling error in AbilityObjEditing, line 9868")
else
call Cdv("Called AbilityDefinitionIllidanChannel.presetTargetType on invalid object.","when calling error in AbilityObjEditing, line 9868")
endif
endif
call edX(eGX,ehX,"when calling presetTargetType in AbilityObjEditing, line 9868")
set EM=EM-1
endfunction
function ejX takes integer eJX,integer ekX,string eKX returns nothing
local integer elX
local integer eLX
set ZM[EM]=eKX
set EM=EM+1
set eLX=eJX
set elX=eBX("when calling alloc_IntLevelClosure_presetTargetType_ChannelAbilityPreset_ChannelAbilityPreset in ChannelAbilityPreset, line 89")
set RW[elX]=ekX
call egX(eLX,elX,"when calling presetTargetType in ChannelAbilityPreset, line 89")
set EM=EM-1
endfunction
function emX takes integer eMX,integer epX,string ePX returns nothing
set ZM[EM]=ePX
set EM=EM+1
if tY[eMX]==0 then
if eMX==0 then
call Cdv("Nullpointer exception when calling ChannelAbilityPreset.presetTargetTypes","when calling error in ChannelAbilityPreset, line 88")
else
call Cdv("Called ChannelAbilityPreset.presetTargetTypes on invalid object.","when calling error in ChannelAbilityPreset, line 88")
endif
endif
call ejX(eMX,epX,"when calling presetTargetTypes in ChannelAbilityPreset, line 88")
set EM=EM-1
endfunction
function eqX takes string eQX returns integer
local integer esX
local integer eSX
local integer etX
local integer eTX
local integer euX
local integer eUX
local integer ewX
local integer eWX
local integer eyX
set ZM[EM]=eQX
set EM=EM+1
set eSX=eiX(l0a(qq,"when calling next in SotfrpGuiPresets, line 24"),1,true,"when calling new_ChannelAbilityPreset in SotfrpGuiPresets, line 24")
set eWX=eSX
set esX=eOX("when calling alloc_StringLevelClosure_presetBaseOrderID_presetTargetTypes_presetOption_presetCastRange_SotfrpGuiPresets in SotfrpGuiPresets, line 25")
call vdX(eWX,esX,"when calling presetBaseOrderID in SotfrpGuiPresets, line 25")
set etX=eSX
call emX(etX,2,"when calling presetTargetTypes in SotfrpGuiPresets, line 26")
set eTX=etX
call ZoE(eTX,0,false,"when calling presetOption in SotfrpGuiPresets, line 27")
set eUX=eTX
set eyX=eUX
set euX=eAX("when calling alloc_RealLevelClosure_presetCastRange_SotfrpGuiPresets in SotfrpGuiPresets, line 28")
call CsE(eyX,euX,"when calling presetCastRange in SotfrpGuiPresets, line 28")
set ewX=eUX
set EM=EM-1
return ewX
endfunction
function eYX takes string ezX returns boolean
local integer eZX
set ZM[EM]=ezX
set EM=EM+1
if me then
set eZX=eqX("when calling generateSmartAbility in SotfrpGuiPresets, line 30")
else
set eZX=0
endif
set Cf=eZX
set Vf='AM0j'
set Mf[0]="Q"
set Mf[1]="W"
set Mf[2]="E"
set Mf[3]="R"
set Mf[4]="A"
set Mf[5]="S"
set Mf[6]="D"
set Mf[7]="F"
set Mf[8]="Z"
set Mf[9]="X"
set Mf[$A]="C"
set Mf[$B]="V"
set Nf=YT
set Bf[0]="Q"
set Bf[1]="W"
set Bf[2]="E"
set Bf[3]="R"
set Bf[4]="A"
set Bf[5]="S"
set Bf[6]="D"
set Bf[7]="F"
set Bf[8]="Z"
set Bf[9]="X"
set Bf[$A]="C"
set Bf[$B]="V"
set EM=EM-1
return true
endfunction
function e_X takes nothing returns boolean
set EM=0
return eYX("SotfrpGuiPresets, line 1")
endfunction
function e0X takes nothing returns nothing
local timer e1X=GetExpiredTimer()
local location e2X=LoadLocationHandle(nr,GetHandleId(e1X),StringHash("l"))
local unit e3X=LoadUnitHandle(nr,GetHandleId(e1X),StringHash("u"))
local effect e4X=LoadEffectHandle(nr,GetHandleId(e1X),StringHash("e"))
local real e5X=GetLocationX(e2X)
local real e6X=GetLocationY(e2X)
local real e7X=.0
local real e8X=.0
local integer e9X=LoadInteger(nr,GetHandleId(e1X),StringHash("i"))
local integer xvX=0
if 60-e9X>=3 then
set xvX=GetRandomInt(1,3)
elseif 60-e9X==2 then
set xvX=GetRandomInt(1,2)
else
set xvX=1
endif
loop
set e7X=GetRandomReal(-350.,350.)
set e8X=GetRandomReal(-350.,350.)
call DestroyEffect(AddSpecialEffect("Abilities\\Spells\\Other\\Bombardment\\Bombardment.mdx",e5X+e7X,e6X+e8X))
call UnitDamagePoint(e3X,.0,50.,e5X+e7X,e6X+e8X,525.,true,true,ATTACK_TYPE_SIEGE,DAMAGE_TYPE_DEMOLITION,WEAPON_TYPE_WHOKNOWS)
set e9X=e9X+1
set xvX=xvX-1
exitwhen xvX==0
endloop
set e5X=.0
set e6X=.0
set e7X=.0
set e8X=.0
if e9X==60 then
call RemoveLocation(e2X)
call SaveTimerHandle(nr,GetHandleId(e3X),StringHash("bmT"),null)
call FlushChildHashtable(nr,GetHandleId(e1X))
call DestroyTimer(e1X)
call DestroyEffect(e4X)
call IssueImmediateOrderById(e3X,$D0004)
else
call SaveInteger(nr,GetHandleId(e1X),StringHash("i"),e9X)
endif
set e1X=null
set e2X=null
set e3X=null
set e4X=null
set e9X=0
set e1X=null
set e2X=null
set e3X=null
set e4X=null
endfunction
function xeX takes nothing returns boolean
if GetSpellAbilityId()=='A0JW' then
return true
else
return false
endif
endfunction
function xxX takes nothing returns boolean
return(GetSpellAbilityId()=='A096')
endfunction
function xoX takes nothing returns boolean
return(IsUnitInGroup(GetTriggerUnit(),Rr))
endfunction
function xrX takes nothing returns boolean
return(IsUnitInGroup(GetTriggerUnit(),fr))
endfunction
function xiX takes nothing returns boolean
return(IsUnitInGroup(GetTriggerUnit(),dr))
endfunction
function xaX takes nothing returns nothing
if xiX()then
call GroupRemoveUnitSimple(GetTriggerUnit(),dr)
call GroupAddUnitSimple(GetTriggerUnit(),Rr)
call UnitRemoveAbilityBJ('A08T',GetTriggerUnit())
call UnitAddAbilityBJ('A08U',GetTriggerUnit())
call SetUnitAbilityLevelSwapped('A08U',GetTriggerUnit(),GetUnitAbilityLevelSwapped('A08V',GetTriggerUnit()))
call UnitMakeAbilityPermanent(GetTriggerUnit(),true,'A08U')
elseif xoX()then
call GroupRemoveUnitSimple(GetTriggerUnit(),Rr)
call GroupAddUnitSimple(GetTriggerUnit(),fr)
call UnitRemoveAbilityBJ('A08U',GetTriggerUnit())
call UnitAddAbilityBJ('A08S',GetTriggerUnit())
call SetUnitAbilityLevelSwapped('A08S',GetTriggerUnit(),GetUnitAbilityLevelSwapped('A08V',GetTriggerUnit()))
call UnitMakeAbilityPermanent(GetTriggerUnit(),true,'A08S')
elseif xrX()then
call GroupRemoveUnitSimple(GetTriggerUnit(),fr)
call GroupAddUnitSimple(GetTriggerUnit(),dr)
call UnitRemoveAbilityBJ('A08S',GetTriggerUnit())
call UnitAddAbilityBJ('A08T',GetTriggerUnit())
call SetUnitAbilityLevelSwapped('A08T',GetTriggerUnit(),GetUnitAbilityLevelSwapped('A08V',GetTriggerUnit()))
call UnitMakeAbilityPermanent(GetTriggerUnit(),true,'A08T')
endif
endfunction
function xnX takes nothing returns nothing
local unit xVX
local unit xEX
local integer xXX
local integer xOX
local group xRX
if GetSpellAbilityId()!=ul then
set xVX=null
set xEX=null
set xRX=null
return
endif
set xVX=GetSpellAbilityUnit()
set xEX=GetSpellTargetUnit()
set xOX=GetHandleId(xVX)
set xXX=GetUnitAbilityLevel(xVX,ul)
call GBv(cl,xXX,"attackonce",xEX)
call GBv(sl,xXX,"attackonce",xEX)
call GBv(il,xXX,"attackonce",xEX)
set xRX=LoadGroupHandle(i,bl,xOX)
if xRX==null then
set xRX=CreateGroup()
call SaveGroupHandle(i,bl,xOX,xRX)
endif
call opV(ol,xEX)
call GroupAddUnit(xRX,xEX)
set xOX=GetHandleId(xEX)
call SaveReal(i,Ol,xOX,xXX*$C8*1.)
call SaveReal(i,ll,xOX,xXX*$C8*1.)
call SaveUnitHandle(i,yl,xOX,xVX)
call RbV(ol,xEX,15.)
set xRX=null
set xEX=null
set xVX=null
set xVX=null
set xEX=null
set xRX=null
endfunction
function xIX takes nothing returns boolean
return GetSpellAbilityId()=='A0H4'
endfunction
function xAX takes nothing returns nothing
local unit xNX=GetSpellAbilityUnit()
local location xbX=GetSpellTargetLoc()
call WaygateSetDestination(xNX,GetLocationX(xbX),GetLocationY(xbX))
call WaygateActivate(xNX,true)
call RemoveLocation(xbX)
set xbX=null
set xNX=null
set xNX=null
set xbX=null
endfunction
function xBX takes nothing returns boolean
return(GetUnitAbilityLevel(GetTriggerUnit(),'A0IS')>0)
endfunction
function xcX takes nothing returns boolean
return true
endfunction
function xCX takes string xdX returns nothing
set ZM[EM]=xdX
set EM=EM+1
call LHa(umv(GetEnumUnit()),"when calling protectUnitType in SotfrpGuiCoreUnit, line 66")
set EM=EM-1
endfunction
function xDX takes nothing returns nothing
set EM=0
call xCX("SotfrpGuiCoreUnit, line 66")
endfunction
function xfX takes nothing returns boolean
set lq=InitGameCache("1")
set bq=InitGameCache("2")
return true
endfunction
function xFX takes string xgX returns integer
local integer xGX
set ZM[EM]=xgX
set EM=EM+1
if jG==0 then
if xG<$8000 then
set xG=xG+1
set xGX=xG
set vG[xGX]=$46E
else
call Cdv("Out of memory: Could not create CallbackSingle_doAfter_PlayerDefinedUnitTypes.","when calling error in PlayerDefinedUnitTypes, line 89")
set xGX=0
endif
else
set jG=jG-1
set xGX=kG[jG]
set vG[xGX]=$46E
endif
set EM=EM-1
return xGX
endfunction
function xhX takes string xHX returns boolean
local integer xjX
set ZM[EM]=xHX
set EM=EM+1
set Mq='x'
set Bq=0
set xjX=xFX("when calling alloc_CallbackSingle_doAfter_PlayerDefinedUnitTypes in PlayerDefinedUnitTypes, line 89")
call EUx(xjX)
call EQx(1.,xjX,"when calling doAfter in PlayerDefinedUnitTypes, line 89")
set EM=EM-1
return true
endfunction
function xJX takes nothing returns boolean
set EM=0
return xhX("PlayerDefinedUnitTypes, line 1")
endfunction
function xkX takes nothing returns boolean
set nq="Objects\\StartLocation\\StartLocation.mdx"
return true
endfunction
function xKX takes nothing returns nothing
local effect xlX=AddSpecialEffectTarget("Abilities\\Spells\\Orc\\Bladestorm\\Bladestorm.mdx",GetSpellAbilityUnit(),"origin")
call pAa(1.5)
call DestroyEffect(xlX)
set xlX=null
set xlX=null
endfunction
function xLX takes nothing returns boolean
return(GetSpellAbilityId()=='A0EK')
endfunction
function xmX takes nothing returns boolean
return(IsPlayerEnemy(GetOwningPlayer(GetSpellAbilityUnit()),GetOwningPlayer(GetFilterUnit()))and IsUnitType(GetEnumUnit(),UNIT_TYPE_STRUCTURE)==false and BlzIsUnitInvulnerable(GetFilterUnit())==false)!=null
endfunction
function xMX takes nothing returns nothing
call UnitRemoveAbilityBJ('Arbr',GetSpellAbilityUnit())
call UnitAddAbilityBJ('A0CX',GetSpellAbilityUnit())
call UnitRemoveAbilityBJ('A0CY',GetSpellAbilityUnit())
endfunction
function xpX takes nothing returns boolean
return(GetUnitAbilityLevelSwapped('A0FD',GetEnumUnit())!=0)or(GetUnitAbilityLevelSwapped('A0FC',GetEnumUnit())!=0)
endfunction
function xPX takes nothing returns boolean
return(GetUnitTypeId(GetEnumUnit())!='h000')and(IsUnitSelected(GetEnumUnit(),GetTriggerPlayer()))and(xpX())
endfunction
function xqX takes nothing returns boolean
return(xPX())
endfunction
function xQX takes nothing returns nothing
if xqX()then
call UnitRemoveAbilityBJ('A0FD',GetEnumUnit())
call UnitRemoveAbilityBJ('A0FC',GetEnumUnit())
call UnitRemoveAbilityBJ('A0FF',GetEnumUnit())
endif
endfunction
function xsX takes nothing returns boolean
return(GetDestructableMaxLife(GetEnumDestructable())<1000000000.)and(GetDestructableMaxLife(GetEnumDestructable())!=777.77)
endfunction
function xSX takes nothing returns nothing
if xsX()then
call KillDestructable(GetEnumDestructable())
endif
endfunction
function xtX takes nothing returns boolean
set me=false
return true
endfunction
function xTX takes nothing returns boolean
return GetSpellAbilityId()=='A008'
endfunction
function xuX takes nothing returns nothing
call DestroyEffect(AddSpecialEffectLoc("Abilities\\Spells\\Undead\\DeathPact\\DeathPactTarget.mdl",GetUnitLoc(GetSpellTargetUnit())))
call DestroyEffect(AddSpecialEffectLoc("Abilities\\Spells\\Undead\\DeathPact\\DeathPactCaster.mdl",GetUnitLoc(GetSpellTargetUnit())))
call DestroyEffect(AddSpecialEffectLoc("Objects\\Spawnmodels\\Undead\\UndeadDissipate\\UndeadDissipate.mdl",GetUnitLoc(GetSpellTargetUnit())))
endfunction
function xUX takes nothing returns nothing
local unit xwX=Os
call UnitDamageTarget(xwX,GetEnumUnit(),75.,true,true,ATTACK_TYPE_NORMAL,DAMAGE_TYPE_MAGIC,WEAPON_TYPE_WHOKNOWS)
call DestroyEffect(AddSpecialEffectTarget("Objects\\Spawnmodels\\Critters\\Albatross\\CritterBloodAlbatross.mdl",GetEnumUnit(),"chest"))
set xwX=null
set xwX=null
endfunction
function xWX takes nothing returns boolean
return(GetSellingUnit()==Fr[2])
endfunction
function xyX takes nothing returns boolean
return(GetSellingUnit()==RO)
endfunction
function xYX takes nothing returns boolean
return(GetSellingUnit()==Fr[4])
endfunction
function xzX takes nothing returns boolean
return(GetSellingUnit()==Fr[3])
endfunction
function xZX takes nothing returns boolean
return(GetSellingUnit()==YO)
endfunction
function x_X takes nothing returns boolean
return(GetSellingUnit()==Fr[1])
endfunction
function x0X takes nothing returns boolean
return(GetSellingUnit()==TO)
endfunction
function x1X takes nothing returns boolean
return(GetSellingUnit()==fO)
endfunction
function x2X takes nothing returns nothing
if x1X()then
call SelectUnitRemoveForPlayer(GetSellingUnit(),GetOwningPlayer(GetSoldUnit()))
call SelectUnitAddForPlayer(Fr[1],GetOwningPlayer(GetSoldUnit()))
elseif x_X()then
call SelectUnitRemoveForPlayer(GetSellingUnit(),GetOwningPlayer(GetSoldUnit()))
call SelectUnitAddForPlayer(fO,GetOwningPlayer(GetSoldUnit()))
elseif x0X()then
call SelectUnitRemoveForPlayer(GetSellingUnit(),GetOwningPlayer(GetSoldUnit()))
call SelectUnitAddForPlayer(Fr[2],GetOwningPlayer(GetSoldUnit()))
elseif xWX()then
call SelectUnitRemoveForPlayer(GetSellingUnit(),GetOwningPlayer(GetSoldUnit()))
call SelectUnitAddForPlayer(TO,GetOwningPlayer(GetSoldUnit()))
elseif xZX()then
call SelectUnitRemoveForPlayer(GetSellingUnit(),GetOwningPlayer(GetSoldUnit()))
call SelectUnitAddForPlayer(Fr[3],GetOwningPlayer(GetSoldUnit()))
elseif xzX()then
call SelectUnitRemoveForPlayer(GetSellingUnit(),GetOwningPlayer(GetSoldUnit()))
call SelectUnitAddForPlayer(YO,GetOwningPlayer(GetSoldUnit()))
elseif xyX()then
call SelectUnitRemoveForPlayer(GetSellingUnit(),GetOwningPlayer(GetSoldUnit()))
call SelectUnitAddForPlayer(Fr[4],GetOwningPlayer(GetSoldUnit()))
elseif xYX()then
call SelectUnitRemoveForPlayer(GetSellingUnit(),GetOwningPlayer(GetSoldUnit()))
call SelectUnitAddForPlayer(RO,GetOwningPlayer(GetSoldUnit()))
endif
endfunction
function x3X takes nothing returns boolean
set fe=InitHashtable()
return true
endfunction
function x4X takes nothing returns boolean
return IsUnitSelected(GetFilterUnit(),GetTriggerPlayer())
endfunction
function x5X takes nothing returns nothing
call SetBlightRadiusLocBJ(true,GetEnumPlayer(),G,92.)
endfunction
function x6X takes nothing returns boolean
return(SubStringBJ(GetEventPlayerChatString(),1,4)=="item")
endfunction
function x7X takes string x8X returns integer
local integer x9X
set ZM[EM]=x8X
set EM=EM+1
if Ig==0 then
if Pg<$8000 then
set Pg=Pg+1
set x9X=Pg
set Ag[x9X]=738
else
call Cdv("Out of memory: Could not create ArrayQueue.","when calling error in DummyRecycler, line 51")
set x9X=0
endif
else
set Ig=Ig-1
set x9X=Ug[Ig]
set Ag[x9X]=738
endif
set EM=EM-1
return x9X
endfunction
function ovX takes integer oeX returns nothing
set JE[oeX]=0
set KE[oeX]=0
set LE[oeX]=0
endfunction
function oxX takes integer ooX returns nothing
call ovX(ooX)
endfunction
function orX takes string oiX returns integer
local integer oaX
set ZM[EM]=oiX
set EM=EM+1
set oaX=x7X("when calling alloc_ArrayQueue in DummyRecycler, line 51")
call oxX(oaX)
set EM=EM-1
return oaX
endfunction
function onX takes string oVX returns boolean
local integer oEX
local integer oXX
local integer oOX
local integer oRX
set ZM[EM]=oVX
set EM=EM+1
set Ep='xdum'
set Zp=8
set Up=360*1./Zp
set Ip=6
set Pp=CreateTimer()
set Ap=0
set oEX=0
set oXX=Zp-1
loop
exitwhen oEX>oXX
set Dp[oEX]=orX("when calling new_ArrayQueue in DummyRecycler, line 142")
set oOX=0
set oRX=Ip-1
loop
exitwhen oOX>oRX
call Pea(Dp[oEX],BbV(He,Je,Ty,vde(oEX*Up)),"when calling enqueue in DummyRecycler, line 144")
set oOX=oOX+1
endloop
set oEX=oEX+1
endloop
set EM=EM-1
return true
endfunction
function oIX takes nothing returns boolean
set EM=0
return onX("DummyRecycler, line 1")
endfunction
function oAX takes force oNX,player obX returns nothing
call ForceAddPlayer(oNX,obX)
endfunction
function oBX takes nothing returns boolean
set Mp=CreateForce()
call oAX(Mp,ta)
set re=0
return true
endfunction
function ocX takes nothing returns nothing
local unit oCX=GetEventDamageSource()
if GetUnitAbilityLevel(oCX,'BHds')>0 or GetUnitAbilityLevel(oCX,'B04Q')>0 or GetUnitAbilityLevel(oCX,'B05C')>0 or GetUnitAbilityLevel(oCX,'B05D')>0 or GetUnitAbilityLevel(oCX,'B05E')>0 or GetUnitAbilityLevel(oCX,'B05F')>0 then
call BlzSetEventDamage(GetEventDamage()/2.)
endif
set oCX=GetTriggerUnit()
if GetUnitAbilityLevel(oCX,'BHds')>0 or GetUnitAbilityLevel(oCX,'B04Q')>0 or GetUnitAbilityLevel(oCX,'B05C')>0 or GetUnitAbilityLevel(oCX,'B05D')>0 or GetUnitAbilityLevel(oCX,'B05E')>0 or GetUnitAbilityLevel(oCX,'B05F')>0 then
call BlzSetEventDamage(.0)
endif
set oCX=null
set oCX=null
endfunction
function odX takes nothing returns boolean
return(RectContainsLoc(GetPlayableMapRect(),Ju[1]))
endfunction
function oDX takes nothing returns boolean
return(DistanceBetweenPoints(Ju[2],Ju[1])<Gu*1.5)or(DistanceBetweenPoints(Ju[2],Ju[1])>gu)or(RectContainsLoc(GetPlayableMapRect(),Ju[1])==false)
endfunction
function ofX takes nothing returns boolean
return(oDX())
endfunction
function oFX takes nothing returns nothing
set Ju[1]=GetSpellTargetLoc()
set Ju[2]=LoadLocationHandleBJ(0,GetHandleIdBJ(GetTriggerUnit()),Au)
if ofX()then
call IssueImmediateOrderBJ(GetTriggerUnit(),"stop")
set Xu=GetForceOfPlayer(GetOwningPlayer(GetTriggerUnit()))
if odX()then
call DisplayTextToForce(Xu,"TRIGSTR_8262")
else
call DisplayTextToForce(Xu,"TRIGSTR_8275")
endif
call DestroyForce(Xu)
endif
call RemoveLocation(Ju[1])
endfunction
function ogX takes string oGX returns integer
local integer ohX
set ZM[EM]=oGX
set EM=EM+1
if BG==0 then
if NG<$8000 then
set NG=NG+1
set ohX=NG
set MG[ohX]=$F41
else
call Cdv("Out of memory: Could not create OnPointCast_onPointCast_SotfrpGuiLocust.","when calling error in SotfrpGuiLocust, line 24")
set ohX=0
endif
else
set BG=BG-1
set ohX=VG[BG]
set MG[ohX]=$F41
endif
set EM=EM-1
return ohX
endfunction
function oHX takes string ojX returns boolean
local integer oJX
local integer okX
local unit oKX
local integer olX
local unit oLX
local integer omX
set ZM[EM]=ojX
set EM=EM+1
set Xf='AM0q'
set oJX=0
set okX=bj_MAX_PLAYERS-1
loop
exitwhen oJX>okX
set oKX=QKv(oJX)
if oKX!=null then
set oLX=oKX
set omX=Xf
set olX=ogX("when calling alloc_OnPointCast_onPointCast_SotfrpGuiLocust in SotfrpGuiLocust, line 24")
call LCa(olX)
set YL[olX]=oJX
call LDa(oLX,omX,olX,"when calling onPointCast in SotfrpGuiLocust, line 24")
endif
set oJX=oJX+1
endloop
set EM=EM-1
set oKX=null
set oLX=null
return true
endfunction
function oMX takes nothing returns boolean
set EM=0
return oHX("SotfrpGuiLocust, line 1")
endfunction
function opX takes nothing returns boolean
return GetSpellAbilityId()=='A0K6' or GetSpellAbilityId()=='A0K7'
endfunction
function oPX takes nothing returns boolean
return GetSpellAbilityId()=='AOha'
endfunction
function oqX takes nothing returns nothing
set G=GetSpellTargetLoc()
call EnumDestructablesInCircleBJ(256.,G,oGv)
endfunction
function oQX takes nothing returns nothing
local unit osX=GetSpellTargetUnit()
local real oSX
local effect otX
local effect oTX
local effect ouX
if not(IsUnitInGroup(GetSpellTargetUnit(),hr)==false)then
call AddSpecialEffectTargetUnitBJ("origin",osX,"Abilities\\Spells\\Items\\SpellShieldAmulet\\SpellShieldCaster.mdl")
set osX=null
set otX=null
set oTX=null
set ouX=null
return
endif
call GroupAddUnitSimple(osX,hr)
set otX=AddSpecialEffectTargetUnitBJ("overhead",osX,"Abilities\\Spells\\Other\\SoulBurn\\SoulBurnbuff.mdl")
set oTX=AddSpecialEffectTargetUnitBJ("left hand",osX,"Abilities\\Weapons\\PhoenixMissile\\Phoenix_Missile_mini.mdl")
set ouX=AddSpecialEffectTargetUnitBJ("right hand",osX,"Abilities\\Weapons\\PhoenixMissile\\Phoenix_Missile_mini.mdl")
set oSX=GetUnitStateSwap(UNIT_STATE_LIFE,osX)
if GetUnitAbilityLevelSwapped('A0CB',GetSpellAbilityUnit())==3 then
call UnitAddAbilityBJ('A0CG',osX)
call SetUnitLifeBJ(osX,oSX+750.)
call UnitAddAbilityBJ('A0CE',osX)
call UnitAddAbilityBJ('A0CK',osX)
call PolledWait(2.)
call DestroyEffectBJ(otX)
call PolledWait(13.)
elseif GetUnitAbilityLevelSwapped('A0CB',GetSpellAbilityUnit())==2 then
call UnitAddAbilityBJ('A0CH',osX)
call SetUnitLifeBJ(osX,oSX+500.)
call UnitAddAbilityBJ('A0CD',osX)
call UnitAddAbilityBJ('A0CJ',osX)
call PolledWait(2.)
call DestroyEffectBJ(otX)
call PolledWait(8.)
elseif GetUnitAbilityLevelSwapped('A0CB',GetSpellAbilityUnit())==1 then
call UnitAddAbilityBJ('A0CF',osX)
call SetUnitLifeBJ(osX,oSX+250.)
call UnitAddAbilityBJ('A0CC',osX)
call UnitAddAbilityBJ('A0CI',osX)
call PolledWait(2.)
call DestroyEffectBJ(otX)
call PolledWait(3.)
endif
call DestroyEffectBJ(oTX)
call DestroyEffectBJ(ouX)
call GroupRemoveUnitSimple(osX,hr)
call AddSpecialEffectTargetUnitBJ("origin",osX,"Abilities\\Spells\\Other\\Incinerate\\FireLordDeathExplode.mdl")
call AddSpecialEffectTargetUnitBJ("origin",osX,"Objects\\Spawnmodels\\Other\\NeutralBuildingExplosion\\NeutralBuildingExplosion.mdl")
call ExplodeUnitBJ(osX)
set osX=null
set oSX=.0
set otX=null
set oTX=null
set ouX=null
set osX=null
set otX=null
set oTX=null
set ouX=null
endfunction
function oUX takes nothing returns nothing
local string owX=GetEventPlayerChatString()
if SubString(owX,7,StringLength(owX))=="on" then
call SetItemDropOnDeath(UnitItemInSlot(GetEnumUnit(),S2I(SubString(owX,5,6))-1),true)
call SetItemUserData(UnitItemInSlot(GetEnumUnit(),S2I(SubString(owX,5,6))-1),1)
else
call SetItemDropOnDeath(UnitItemInSlot(GetEnumUnit(),S2I(SubString(owX,5,6))-1),false)
call SetItemUserData(UnitItemInSlot(GetEnumUnit(),S2I(SubString(owX,5,6))-1),0)
endif
set owX=null
endfunction
function oWX takes nothing returns boolean
return IsUnitSelected(GetFilterUnit(),GetTriggerPlayer())and(not(GetUnitTypeId(GetFilterUnit())=='h000'))
endfunction
function oyX takes nothing returns nothing
set g[GetConvertedPlayerId(GetTriggerPlayer())]=GetUnitsOfPlayerAll(GetTriggerPlayer())
call ForGroupBJ(g[GetConvertedPlayerId(GetTriggerPlayer())],eBv)
call DestroyGroup(g[GetPlayerId(GetTriggerPlayer())+1])
endfunction
function oYX takes nothing returns boolean
return IsUnitSelected(GetFilterUnit(),GetTriggerPlayer())
endfunction
function ozX takes integer oZX returns nothing
set sy=oZX
call TriggerEvaluate(Jb[Kb[oZX]])
endfunction
function o_X takes integer o0X returns nothing
if o0X==0 then
return
elseif bb[o0X]!=-1 then
return
endif
set sy=o0X
call TriggerEvaluate(Lb[Kb[o0X]])
set bb[o0X]=Ob
set Ob=o0X
endfunction
function o1X takes nothing returns boolean
local timer o2X=GetExpiredTimer()
local integer o3X=LoadInteger(i,y,GetHandleId(o2X))
call Gmv(o2X)
call ozX(o3X)
call o_X(o3X)
set o2X=null
return true
endfunction
function o4X takes nothing returns nothing
if GetUnitAbilityLevel(GetTriggerUnit(),Zd)>0 then
call BlzSetEventDamage(.2*GetEventDamage())
endif
endfunction
function o5X takes string o6X returns boolean
local boolean o7X
set ZM[EM]=o6X
set EM=EM+1
set o7X=not Mla(umv(GetFilterUnit()),"when calling isUnitTypeProtected in SotFRP_SaveLoad, line 79")
set EM=EM-1
return o7X
endfunction
function o8X takes nothing returns boolean
set EM=0
return o5X("SotFRP_SaveLoad, line 79")
endfunction
function o9X takes nothing returns boolean
return GetBooleanAnd(IsUnitAliveBJ(GetFilterUnit()),IsUnitEnemy(GetFilterUnit(),GetOwningPlayer(Nu)))
endfunction
function rvX takes nothing returns boolean
set cq=256
set oq=$80
set Oq=3
return true
endfunction
function reX takes string rxX returns integer
local integer roX
set ZM[EM]=rxX
set EM=EM+1
if CY==0 then
if VY<$8000 then
set VY=VY+1
set roX=VY
set BY[roX]=$85F
else
call Cdv("Out of memory: Could not create ForForceCallback_execute_StringEncoder.","when calling error in StringEncoder, line 54")
set roX=0
endif
else
set CY=CY-1
set roX=XY[CY]
set BY[roX]=$85F
endif
set EM=EM-1
return roX
endfunction
function rrX takes string riX returns integer
local integer raX
set ZM[EM]=riX
set EM=EM+1
if CY==0 then
if VY<$8000 then
set VY=VY+1
set raX=VY
set BY[raX]=$85E
else
call Cdv("Out of memory: Could not create ForForceCallback_execute_StringEncoder.","when calling error in StringEncoder, line 53")
set raX=0
endif
else
set CY=CY-1
set raX=XY[CY]
set BY[raX]=$85E
endif
set EM=EM-1
return raX
endfunction
function rnX takes string rVX returns boolean
local integer rEX
local integer rXX
set ZM[EM]=rVX
set EM=EM+1
set jR=" !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
set xR=95
set vR=Ctv("when calling new_HashMap in StringEncoder, line 13")
set rEX=rrX("when calling alloc_ForForceCallback_execute_StringEncoder in StringEncoder, line 53")
call Fte(rEX,"when calling execute in StringEncoder, line 53")
set rXX=reX("when calling alloc_ForForceCallback_execute_StringEncoder in StringEncoder, line 54")
call Fte(rXX,"when calling execute in StringEncoder, line 54")
set EM=EM-1
return true
endfunction
function rOX takes nothing returns boolean
set EM=0
return rnX("StringEncoder, line 1")
endfunction
function rRX takes nothing returns boolean
return(GetUnitAbilityLevelSwapped('A0D3',GetAttacker())>0)
endfunction
function rIX takes nothing returns boolean
return GetSpellAbilityId()=='A08Y'
endfunction
function rAX takes nothing returns boolean
return(GetSpellAbilityId()=='A0CY')
endfunction
function rNX takes nothing returns nothing
local timer rbX=GetExpiredTimer()
local location rBX=LoadLocationHandle(nr,GetHandleId(rbX),StringHash("l1"))
local location rcX=LoadLocationHandle(nr,GetHandleId(rbX),StringHash("l2"))
local integer rCX=LoadInteger(nr,GetHandleId(rbX),StringHash("i"))
local real rdX=GetLocationX(rBX)+rCX*$FA*Cos(Atan2(GetLocationY(rcX)-GetLocationY(rBX),GetLocationX(rcX)-GetLocationX(rBX)))
local real rDX=GetLocationY(rBX)+rCX*$FA*Sin(Atan2(GetLocationY(rcX)-GetLocationY(rBX),GetLocationX(rcX)-GetLocationX(rBX)))
local unit rfX=LoadUnitHandle(nr,GetHandleId(rbX),StringHash("u"))
call DestroyEffect(AddSpecialEffect("Objects\\Spawnmodels\\Human\\FragmentationShards\\FragBoomSpawn.mdl",rdX,rDX))
call DestroyEffect(AddSpecialEffect("Objects\\Spawnmodels\\Other\\NeutralBuildingExplosion\\NeutralBuildingExplosion.mdl",rdX,rDX))
call UnitDamagePoint(rfX,.0,200.,rdX,rDX,360.,true,true,ATTACK_TYPE_NORMAL,DAMAGE_TYPE_MAGIC,WEAPON_TYPE_WHOKNOWS)
set rfX=null
set rdX=.0
set rDX=.0
set rCX=rCX+1
if rCX==6 then
call FlushChildHashtable(nr,GetHandleId(rbX))
call DestroyTimer(rbX)
call RemoveLocation(rBX)
call RemoveLocation(rcX)
else
call SaveInteger(nr,GetHandleId(rbX),StringHash("i"),rCX)
endif
set rbX=null
set rBX=null
set rcX=null
set rCX=0
set rbX=null
set rBX=null
set rcX=null
set rfX=null
endfunction
function rFX takes nothing returns nothing
call GroupRemoveUnitSimple(GetSpellAbilityUnit(),ws)
endfunction
function rgX takes nothing returns nothing
local unit rGX
if GetSpellAbilityId()!='AOer' then
set rGX=null
return
endif
set rGX=GetSpellAbilityUnit()
call GBv('A0MK',GetUnitAbilityLevel(rGX,'AOer'),"attackonce",rGX)
call SaveInteger(i,al,GetHandleId(rGX),GetUnitAbilityLevel(rGX,'AOer'))
set rGX=null
set rGX=null
endfunction
function rhX takes nothing returns boolean
return(GetUnitTypeId(GetEnumUnit())!='h000')and(IsUnitSelected(GetEnumUnit(),GetTriggerPlayer()))
endfunction
function rHX takes nothing returns boolean
return(rhX())
endfunction
function rjX takes nothing returns nothing
if rHX()then
call UnitAddAbilityBJ(aw[GetForLoopIndexA()],GetEnumUnit())
call UnitMakeAbilityPermanent(GetEnumUnit(),true,aw[GetForLoopIndexA()])
endif
endfunction
function rJX takes nothing returns boolean
return(GetSpellAbilityId()=='A0DM')
endfunction
function rkX takes nothing returns boolean
set ne=InitHashtable()
set de=InitHashtable()
return true
endfunction
function rKX takes unit rlX returns nothing
if GetUnitAbilityLevel(rlX,'AaI0')>0 then
call ZTn(rlX)
elseif GetUnitAbilityLevel(rlX,'AaI1')>0 then
call Zyn(rlX)
endif
set rlX=null
endfunction
function rLX takes nothing returns nothing
local unit rmX=GetTriggerUnit()
call TriggerSleepAction(.01)
call rKX(rmX)
if IsUnitType(rmX,UNIT_TYPE_HERO)==false then
call SaveTriggerHandle(nr,GetHandleId(rmX),StringHash("aiR"),null)
call SaveUnitHandle(nr,GetHandleId(LoadTimerHandle(nr,GetHandleId(rmX),StringHash("aiR"))),StringHash("aiRu"),null)
call DestroyTimer(LoadTimerHandle(nr,GetHandleId(rmX),StringHash("aiR")))
call SaveTimerHandle(nr,GetHandleId(rmX),StringHash("aiR"),null)
endif
set rmX=null
call DestroyTrigger(GetTriggeringTrigger())
set rmX=null
endfunction
function rMX takes nothing returns nothing
set g[GetConvertedPlayerId(GetTriggerPlayer())]=GetUnitsOfPlayerAll(GetTriggerPlayer())
call ForGroupBJ(g[GetConvertedPlayerId(GetTriggerPlayer())],env)
call DestroyGroup(g[GetPlayerId(GetTriggerPlayer())+1])
endfunction
function rpX takes nothing returns nothing
set mR[0]=""
set mR[1]=""
set mR[2]=""
set mR[3]=""
set mR[4]=""
set mR[5]=""
set mR[6]=""
set mR[7]=""
set mR[8]=""
set mR[9]="\t"
set mR[$A]="
"
set mR[$B]=""
set mR[$C]=""
set mR[$D]="
"
set mR[$E]=""
set mR[$F]=""
set mR[16]=""
set mR[17]=""
set mR[18]=""
set mR[19]=""
set mR[20]=""
set mR[21]=""
set mR[22]=""
set mR[23]=""
set mR[24]=""
set mR[25]=""
set mR[26]=""
set mR[27]=""
set mR[28]=""
set mR[29]=""
set mR[30]=""
set mR[31]=""
set mR[32]=" "
set mR[33]="!"
set mR[34]="\""
set mR[35]="#"
set mR[36]="$"
set mR[37]="%"
set mR[38]="&"
set mR[39]="'"
set mR[40]="("
set mR[41]=")"
set mR[42]="*"
set mR[43]="+"
set mR[44]=","
set mR[45]="-"
set mR[46]="."
set mR[47]="/"
set mR[48]="0"
set mR[49]="1"
set mR[50]="2"
set mR[51]="3"
set mR[52]="4"
set mR[53]="5"
set mR[54]="6"
set mR[55]="7"
set mR[56]="8"
set mR[57]="9"
set mR[58]=":"
set mR[59]=";"
set mR[60]="<"
set mR[61]="="
set mR[62]=">"
set mR[63]="?"
set mR[64]="@"
set mR[65]="A"
set mR[66]="B"
set mR[67]="C"
set mR[68]="D"
set mR[69]="E"
set mR[70]="F"
set mR[71]="G"
set mR[72]="H"
set mR[73]="I"
set mR[74]="J"
set mR[75]="K"
set mR[76]="L"
set mR[77]="M"
set mR[78]="N"
set mR[79]="O"
set mR[80]="P"
set mR[81]="Q"
set mR[82]="R"
set mR[83]="S"
set mR[84]="T"
set mR[85]="U"
set mR[86]="V"
set mR[87]="W"
set mR[88]="X"
set mR[89]="Y"
set mR[90]="Z"
set mR[91]="["
set mR[92]="\\"
set mR[93]="]"
set mR[94]="^"
set mR[95]="_"
set mR[96]="`"
set mR[97]="a"
set mR[98]="b"
set mR[99]="c"
set mR['d']="d"
set mR['e']="e"
set mR['f']="f"
set mR['g']="g"
set mR['h']="h"
set mR['i']="i"
set mR['j']="j"
set mR['k']="k"
set mR['l']="l"
set mR['m']="m"
set mR['n']="n"
set mR['o']="o"
set mR['p']="p"
set mR['q']="q"
set mR['r']="r"
set mR['s']="s"
set mR['t']="t"
set mR['u']="u"
set mR['v']="v"
set mR['w']="w"
set mR['x']="x"
set mR['y']="y"
set mR['z']="z"
set mR['{']="{"
set mR['|']="|"
set mR['}']="}"
set mR[$7E]="~"
set mR[$7F]=""
endfunction
function rPX takes nothing returns nothing
local integer rqX=0
local integer rQX=WR
loop
exitwhen rqX>rQX
if XAx(mR[rqX])==mR[rqX]then
set QR[StringHash(mR[rqX])/$1F0748+$3EA]=rqX
endif
set rqX=rqX+1
endloop
endfunction
function rsX takes nothing returns nothing
endfunction
function rSX takes nothing returns nothing
call rpX()
call rPX()
call rsX()
endfunction
function rtX takes string rTX returns boolean
set ZM[EM]=rTX
set EM=EM+1
set WR=$7E+1
call rSX()
call KCv("","when calling stringToIndex in StringUtils, line 187")
set EM=EM-1
return true
endfunction
function ruX takes nothing returns boolean
set EM=0
return rtX("StringUtils, line 1")
endfunction
function rUX takes string rwX returns integer
local integer rWX
set ZM[EM]=rwX
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set rWX=Yj
set Gj[rWX]=$AA6
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_SotfrpGuiDestructables.","when calling error in SotfrpGuiDestructables, line 231")
set rWX=0
endif
else
set Tj=Tj-1
set rWX=Rj[Tj]
set Gj[rWX]=$AA6
endif
set EM=EM-1
return rWX
endfunction
function ryX takes string rYX returns integer
local integer rzX
set ZM[EM]=rYX
set EM=EM+1
if lY==0 then
if bY<$8000 then
set bY=bY+1
set rzX=bY
set yY[rzX]=4826
else
call Cdv("Out of memory: Could not create StringLevelClosure_presetBaseOrderID_SotfrpGuiDestructables.","when calling error in SotfrpGuiDestructables, line 110")
set rzX=0
endif
else
set lY=lY-1
set rzX=OY[lY]
set yY[rzX]=4826
endif
set EM=EM-1
return rzX
endfunction
function rZX takes string r_X returns integer
local integer r0X
set ZM[EM]=r_X
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set r0X=Yj
set Gj[r0X]=$AA5
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_SotfrpGuiDestructables.","when calling error in SotfrpGuiDestructables, line 226")
set r0X=0
endif
else
set Tj=Tj-1
set r0X=Rj[Tj]
set Gj[r0X]=$AA5
endif
set EM=EM-1
return r0X
endfunction
function r1X takes string r2X returns integer
local integer r3X
set ZM[EM]=r2X
set EM=EM+1
if BG==0 then
if NG<$8000 then
set NG=NG+1
set r3X=NG
set MG[r3X]=$F40
else
call Cdv("Out of memory: Could not create OnPointCast_onPointCast_SotfrpGuiDestructables.","when calling error in SotfrpGuiDestructables, line 238")
set r3X=0
endif
else
set BG=BG-1
set r3X=VG[BG]
set MG[r3X]=$F40
endif
set EM=EM-1
return r3X
endfunction
function r4X takes integer r5X,integer r6X,integer r7X,integer r8X returns string
return"|c"+gue(r8X)+gue(r5X)+gue(r6X)+gue(r7X)
endfunction
function r9X takes string ivX,integer ieX,string ixX returns nothing
set ZM[EM]=ixX
set EM=EM+1
call ZWv(mf,ivX,ieX,"when calling put in SotfrpGuiDestructables, line 21")
call ZWv(mf,d0v(ieX),ieX,"when calling put in SotfrpGuiDestructables, line 22")
call fqv(Qf,ieX,KCv(ivX,"when calling stringToIndex in SotfrpGuiDestructables, line 23"),"when calling put in SotfrpGuiDestructables, line 23")
set EM=EM-1
endfunction
function ioX takes string irX returns boolean
local integer iiX
local integer iaX
local integer inX
local integer iVX
local integer iEX
local integer iXX
local integer iOX
local integer iRX
local integer iIX
local integer iAX
local integer iNX
local unit ibX
local integer iBX
local integer icX
local integer iCX
local unit idX
local integer iDX
set ZM[EM]=irX
set EM=EM+1
set mf=g1v("when calling new_StringHashMap in SotfrpGuiDestructables, line 17")
set Qf=Ctv("when calling new_HashMap in SotfrpGuiDestructables, line 18")
call r9X("ashenvaletree",'ATtr',"when calling registerDestructable in SotfrpGuiDestructables, line 32")
call r9X("outlandmushroomtree",'OTtw',"when calling registerDestructable in SotfrpGuiDestructables, line 33")
call r9X("dalaranruinstree",'JTct',"when calling registerDestructable in SotfrpGuiDestructables, line 34")
call r9X("lordaeronsnowtree",'YTst',"when calling registerDestructable in SotfrpGuiDestructables, line 35")
call r9X("lordaeronwintertree",'YTwt',"when calling registerDestructable in SotfrpGuiDestructables, line 36")
call r9X("lordaeronsnowtree",'YTct',"when calling registerDestructable in SotfrpGuiDestructables, line 37")
call r9X("lordaeronfalltree",'YTft',"when calling registerDestructable in SotfrpGuiDestructables, line 38")
call r9X("lordaeronsummertree",'VTlt',"when calling registerDestructable in SotfrpGuiDestructables, line 39")
call r9X("ruinstree",'ZTtw',"when calling registerDestructable in SotfrpGuiDestructables, line 40")
call r9X("icecrowntree",'ITtw',"when calling registerDestructable in SotfrpGuiDestructables, line 41")
call r9X("northrendtree",'NTtw',"when calling registerDestructable in SotfrpGuiDestructables, line 42")
call r9X("mushroomtree",'DTsh',"when calling registerDestructable in SotfrpGuiDestructables, line 43")
call r9X("undergroundmushroomtree",'GTsh',"when calling registerDestructable in SotfrpGuiDestructables, line 44")
call r9X("barrenstree",'BTtw',"when calling registerDestructable in SotfrpGuiDestructables, line 45")
call r9X("dalaranruinstree",'JTtw',"when calling registerDestructable in SotfrpGuiDestructables, line 46")
call r9X("lordaeronsnowtree",'WTst',"when calling registerDestructable in SotfrpGuiDestructables, line 47")
call r9X("lordaeronwintertree",'WTtw',"when calling registerDestructable in SotfrpGuiDestructables, line 48")
call r9X("lordaeronsummertree",'LTlt',"when calling registerDestructable in SotfrpGuiDestructables, line 49")
call r9X("lordaeronfalltree",'FTtw',"when calling registerDestructable in SotfrpGuiDestructables, line 50")
call r9X("outlandmushroomtree",'KTtw',"when calling registerDestructable in SotfrpGuiDestructables, line 51")
call r9X("felwoodtree",'CTtr',"when calling registerDestructable in SotfrpGuiDestructables, line 52")
call r9X("ashenvalecanopytree",'ATtc',"when calling registerDestructable in SotfrpGuiDestructables, line 53")
call r9X("icecrowncanopytree",'ITtc',"when calling registerDestructable in SotfrpGuiDestructables, line 54")
call r9X("northrendcanopytree",'NTtc',"when calling registerDestructable in SotfrpGuiDestructables, line 55")
call r9X("barrenscanopytree",'BTtc',"when calling registerDestructable in SotfrpGuiDestructables, line 56")
call r9X("ruinscanopytree",'ZTtc',"when calling registerDestructable in SotfrpGuiDestructables, line 57")
call r9X("felwoodcanopytree",'CTtc',"when calling registerDestructable in SotfrpGuiDestructables, line 58")
call r9X("barricade",'LTba',"when calling registerDestructable in SotfrpGuiDestructables, line 59")
call r9X("tntbarrel",'LTex',"when calling registerDestructable in SotfrpGuiDestructables, line 60")
call r9X("lordaerongate",'LTg1',"when calling registerDestructable in SotfrpGuiDestructables, line 62")
call r9X("lordaerongate45",'LTg3',"when calling registerDestructable in SotfrpGuiDestructables, line 63")
call r9X("ruinsgate",'ZTg1',"when calling registerDestructable in SotfrpGuiDestructables, line 64")
call r9X("ruinsgate45",'ZTg3',"when calling registerDestructable in SotfrpGuiDestructables, line 65")
call r9X("bigelfgate",'ATg1',"when calling registerDestructable in SotfrpGuiDestructables, line 66")
call r9X("bigelfgate45",'ATg3',"when calling registerDestructable in SotfrpGuiDestructables, line 67")
call r9X("irongate",'DTg5',"when calling registerDestructable in SotfrpGuiDestructables, line 68")
call r9X("irongate45",'DTg6',"when calling registerDestructable in SotfrpGuiDestructables, line 69")
call r9X("rockchunks",'DTrc',"when calling registerDestructable in SotfrpGuiDestructables, line 71")
call r9X("lordaeronrockchunks",'LTrc',"when calling registerDestructable in SotfrpGuiDestructables, line 72")
call r9X("dungeonlever",'DTlv',"when calling registerDestructable in SotfrpGuiDestructables, line 74")
call r9X("crates",'LTcr',"when calling registerDestructable in SotfrpGuiDestructables, line 75")
call r9X("ruinsflower",'ZPfw',"when calling registerDestructable in SotfrpGuiDestructables, line 77")
call r9X("fire",'YOtf',"when calling registerDestructable in SotfrpGuiDestructables, line 78")
set Wf='x004'
set Ef=Ctv("when calling new_HashMap in SotfrpGuiDestructables, line 94")
call LHa(Wf,"when calling protectUnitType in SotfrpGuiDestructables, line 97")
call own(Rev)
call oyn(Rxv)
if me then
set iaX=Lxa("when calling new_SotfrpGuiCommandPalettePreset in SotfrpGuiDestructables, line 110")
set icX=iaX
set iiX=ryX("when calling alloc_StringLevelClosure_presetBaseOrderID_SotfrpGuiDestructables in SotfrpGuiDestructables, line 110")
call k8a(icX,iiX,"when calling presetBaseOrderID in SotfrpGuiDestructables, line 110")
endif
set Zf="Создание в указанной точке выбранной с помощью команды dood декорации."
set Uf='AM0o'
set If="|n|n"+r4X(Yp,Gp,gp,hp)+"Текущие параметры|r|nДекорация: {0} ({1})|nВысота полета: {2}|nПоворот: {3}|nРазмер: {4}|nВариация: {5}"
set inX=0
set iVX=bj_MAX_PLAYERS-1
loop
exitwhen inX>iVX
set Af[inX]=.0
set Df[inX]=true
set Jf[inX]=1.
set Kf[inX]=true
set inX=inX+1
endloop
set iEX=rZX("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_SotfrpGuiDestructables in SotfrpGuiDestructables, line 226")
set iXX=OPo(iEX,"when calling new_BuiltinData in SotfrpGuiDestructables, line 226")
call Rxo(iXX,OFo(),"when calling setArgumentsTypes in SotfrpGuiDestructables, line 231")
set iIX=ILo(iXX,"when calling new_BuiltinFunction in SotfrpGuiDestructables, line 226")
set iCX=iIX
set iOX=rUX("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_SotfrpGuiDestructables in SotfrpGuiDestructables, line 231")
set iRX=OPo(iOX,"when calling new_BuiltinData in SotfrpGuiDestructables, line 231")
call FRa(iRX,OFo(),OFo(),"when calling setArgumentsTypes in SotfrpGuiDestructables, line 233")
call IFo(iCX,iRX,"when calling addOverload in SotfrpGuiDestructables, line 231")
call Foa(iIX,"dood","when calling registerProtectedBuiltin in SotfrpGuiDestructables, line 226")
set iAX=0
set iNX=bj_MAX_PLAYERS-1
loop
exitwhen iAX>iNX
set ibX=QKv(iAX)
if ibX!=null then
set idX=ibX
set iDX=Uf
set iBX=r1X("when calling alloc_OnPointCast_onPointCast_SotfrpGuiDestructables in SotfrpGuiDestructables, line 238")
call LCa(iBX)
set TL[iBX]=iAX
call LDa(idX,iDX,iBX,"when calling onPointCast in SotfrpGuiDestructables, line 238")
endif
set iAX=iAX+1
endloop
set EM=EM-1
set ibX=null
set idX=null
return true
endfunction
function ifX takes nothing returns boolean
set EM=0
return ioX("SotfrpGuiDestructables, line 1")
endfunction
function iFX takes nothing returns boolean
return true
endfunction
function igX takes nothing returns nothing
call iUV(GetFilterUnit())
endfunction
function iGX takes nothing returns boolean
local real ihX=.0
local real iHX=.0
set NT=ihX
set MT=iHX
set wY=Location(.0,.0)
return true
endfunction
function ijX takes nothing returns boolean
return(RectContainsLoc(GetPlayableMapRect(),Ju[1]))
endfunction
function iJX takes nothing returns boolean
return(DistanceBetweenPoints(Ju[2],Ju[1])<Gu*1.5)or(DistanceBetweenPoints(Ju[2],Ju[1])>gu)or(RectContainsLoc(GetPlayableMapRect(),Ju[1])==false)
endfunction
function ikX takes nothing returns boolean
return(iJX())
endfunction
function iKX takes nothing returns nothing
set Ju[1]=GetSpellTargetLoc()
set Ju[2]=LoadLocationHandleBJ(0,GetHandleIdBJ(GetTriggerUnit()),Au)
if ikX()then
call IssueImmediateOrderBJ(GetTriggerUnit(),"stop")
set Xu=GetForceOfPlayer(GetOwningPlayer(GetTriggerUnit()))
if ijX()then
call DisplayTextToForce(Xu,"TRIGSTR_8546")
else
call DisplayTextToForce(Xu,"TRIGSTR_8545")
endif
call DestroyForce(Xu)
endif
call RemoveLocation(Ju[1])
endfunction
function ilX takes nothing returns boolean
if GetUnitAbilityLevel(GetSpellAbilityUnit(),'A0EZ')!=0 then
return true
else
return false
endif
endfunction
function iLX takes nothing returns boolean
if GetSpellAbilityId()=='A0HI' or GetSpellAbilityId()=='A0HK' then
return true
else
return false
endif
endfunction
function imX takes nothing returns integer
set Ba=Ba+1
return Ba
endfunction
function iMX takes nothing returns boolean
local trigger ipX
set Va=InitHashtable()
set ipX=CreateTrigger()
call YHo(ipX,Ee,Filter(O_v))
set Ba=-1
set Na=imX()
set Ma=imX()
set wn=imX()
set un=imX()
set rn=imX()
set sn=imX()
set tn=imX()
set Sn=imX()
set cn=imX()
set on=imX()
set On=imX()
set ln=imX()
set bn=imX()
set yn=imX()
set pn=imX()
set en=imX()
set qn=imX()
set an=imX()
set nn=imX()
set dn=imX()
set fn=imX()
set Rn=imX()
set Tn=imX()
set Yn=4
set Gn=InitHashtable()
set gn="nEaPy9rLwNfVqb0Qizj3DkGc1OhTU4XsZgMpYKBtl26JI5FmxCoAv8euWRdH7S"
set hn=GZv(gn)
set Fn="&"
set kn=":"
set jn="*"
set ipX=null
return true
endfunction
function iPX takes nothing returns boolean
return(GetDestructableMaxLife(GetEnumDestructable())==2501.)
endfunction
function iqX takes nothing returns nothing
if iPX()then
call ModifyGateBJ(bj_GATEOPERATION_OPEN,GetEnumDestructable())
endif
endfunction
function iQX takes nothing returns boolean
if GetSpellAbilityId()=='A0HW' then
return true
else
return false
endif
endfunction
function isX takes nothing returns boolean
if GetSpellAbilityId()=='A062' then
return true
else
return false
endif
endfunction
function iSX takes nothing returns boolean
return IsUnitSelected(GetFilterUnit(),GetTriggerPlayer())
endfunction
function itX takes nothing returns boolean
local integer iTX=sy
call RemoveUnit(Ab[iTX])
return true
endfunction
function iuX takes string iUX returns nothing
set ZM[EM]=iUX
set EM=EM+1
call oCn("when calling generalEventCallback in ClosureEvents, line 294")
set EM=EM-1
endfunction
function iwX takes nothing returns nothing
set EM=0
call iuX("ClosureEvents, line 294")
endfunction
function iWX takes nothing returns nothing
local unit iyX
if GetSpellAbilityId()!='A0HL' then
set iyX=null
return
endif
set iyX=GetSpellAbilityUnit()
call GBv('A0AV',GetUnitAbilityLevel(iyX,'A0HL'),"attackonce",iyX)
call RbV(DO,iyX,12.)
set iyX=null
set iyX=null
endfunction
function iYX takes nothing returns boolean
return(Du==LoadIntegerBJ(4,GetHandleIdBJ(GetEnumUnit()),Au))
endfunction
function izX takes nothing returns nothing
if iYX()then
call GroupRemoveUnitSimple(GetEnumUnit(),Hu)
call RemoveUnit(LoadUnitHandleBJ(2,GetHandleIdBJ(GetEnumUnit()),Au))
call RemoveUnit(LoadUnitHandleBJ(3,GetHandleIdBJ(GetEnumUnit()),Au))
call SetPlayerAbilityAvailableBJ(true,'A0EH',GetOwningPlayer(GetEnumUnit()))
call UnitRemoveAbilityBJ('A06X',GetEnumUnit())
set Ju[20]=LoadLocationHandleBJ(0,GetHandleIdBJ(GetEnumUnit()),Au)
call RemoveLocation(Ju[20])
call FlushChildHashtableBJ(GetHandleIdBJ(GetEnumUnit()),Au)
endif
endfunction
function iZX takes nothing returns boolean
return(GetDestructableMaxLife(GetEnumDestructable())==69.)
endfunction
function i_X takes nothing returns nothing
if iZX()then
call ChangeElevatorHeight(GetEnumDestructable(),S2I(SubStringBJ(GetEventPlayerChatString(),5,5)))
endif
endfunction
function i0X takes string i1X returns integer
local integer i2X
set ZM[EM]=i1X
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set i2X=Yj
set Gj[i2X]=$A1F
else
call Cdv("Out of memory: Could not create IBuiltin_addOverload_registerProtectedBuiltin_ScmdFogOfWarBuiltins.","when calling error in ScmdFogOfWarBuiltins, line 23")
set i2X=0
endif
else
set Tj=Tj-1
set i2X=Rj[Tj]
set Gj[i2X]=$A1F
endif
set EM=EM-1
return i2X
endfunction
function i3X takes string i4X returns integer
local integer i5X
set ZM[EM]=i4X
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set i5X=Yj
set Gj[i5X]=$AF5
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdFogOfWarBuiltins.","when calling error in ScmdFogOfWarBuiltins, line 16")
set i5X=0
endif
else
set Tj=Tj-1
set i5X=Rj[Tj]
set Gj[i5X]=$AF5
endif
set EM=EM-1
return i5X
endfunction
function i6X takes string i7X returns integer
local integer i8X
set ZM[EM]=i7X
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set i8X=Yj
set Gj[i8X]=$A2D
else
call Cdv("Out of memory: Could not create IBuiltin_registerProtectedBuiltin_ScmdFogOfWarBuiltins.","when calling error in ScmdFogOfWarBuiltins, line 20")
set i8X=0
endif
else
set Tj=Tj-1
set i8X=Rj[Tj]
set Gj[i8X]=$A2D
endif
set EM=EM-1
return i8X
endfunction
function i9X takes string avX returns integer
local integer aeX
set ZM[EM]=avX
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set aeX=Yj
set Gj[aeX]=$A3F
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdFogOfWarBuiltins.","when calling error in ScmdFogOfWarBuiltins, line 27")
set aeX=0
endif
else
set Tj=Tj-1
set aeX=Rj[Tj]
set Gj[aeX]=$A3F
endif
set EM=EM-1
return aeX
endfunction
function axX takes string aoX returns integer
local integer arX
set ZM[EM]=aoX
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set arX=Yj
set Gj[arX]=$AF6
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdFogOfWarBuiltins.","when calling error in ScmdFogOfWarBuiltins, line 41")
set arX=0
endif
else
set Tj=Tj-1
set arX=Rj[Tj]
set Gj[arX]=$AF6
endif
set EM=EM-1
return arX
endfunction
function aiX takes string aaX returns integer
local integer anX
set ZM[EM]=aaX
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set anX=Yj
set Gj[anX]=$AF4
else
call Cdv("Out of memory: Could not create IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdFogOfWarBuiltins.","when calling error in ScmdFogOfWarBuiltins, line 9")
set anX=0
endif
else
set Tj=Tj-1
set anX=Rj[Tj]
set Gj[anX]=$AF4
endif
set EM=EM-1
return anX
endfunction
function aVX takes string aEX returns integer
local integer aXX
set ZM[EM]=aEX
set EM=EM+1
if Tj==0 then
if Yj<$8000 then
set Yj=Yj+1
set aXX=Yj
set Gj[aXX]=$A2C
else
call Cdv("Out of memory: Could not create IBuiltin_registerProtectedBuiltin_ScmdFogOfWarBuiltins.","when calling error in ScmdFogOfWarBuiltins, line 13")
set aXX=0
endif
else
set Tj=Tj-1
set aXX=Rj[Tj]
set Gj[aXX]=$A2C
endif
set EM=EM-1
return aXX
endfunction
function aOX takes string aRX returns boolean
local integer aIX
local integer aAX
local integer aNX
local integer abX
local integer aBX
local integer acX
local integer aCX
local integer adX
local integer aDX
local integer afX
local integer aFX
local integer agX
local integer aGX
set ZM[EM]=aRX
set EM=EM+1
set aIX=aiX("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdFogOfWarBuiltins in ScmdFogOfWarBuiltins, line 9")
set aAX=OPo(aIX,"when calling new_BuiltinData in ScmdFogOfWarBuiltins, line 9")
call Rxo(aAX,d_V(),"when calling setArgumentsTypes in ScmdFogOfWarBuiltins, line 12")
call Foa(ILo(aAX,"when calling new_BuiltinFunction in ScmdFogOfWarBuiltins, line 9"),"fogmaskenable","when calling registerProtectedBuiltin in ScmdFogOfWarBuiltins, line 9")
set aNX=aVX("when calling alloc_IBuiltin_registerProtectedBuiltin_ScmdFogOfWarBuiltins in ScmdFogOfWarBuiltins, line 13")
call g_V(ILo(OPo(aNX,"when calling new_BuiltinData in ScmdFogOfWarBuiltins, line 13"),"when calling new_BuiltinFunction in ScmdFogOfWarBuiltins, line 13"),fNV(KCv("isfogmaskenabled","when calling stringToIndex in ScmdFogOfWarBuiltins, line 15"),KCv("fogmaskenabled?","when calling stringToIndex in ScmdFogOfWarBuiltins, line 15"),"when calling asList in ScmdFogOfWarBuiltins, line 15"),"when calling registerProtectedBuiltin in ScmdFogOfWarBuiltins, line 13")
set abX=i3X("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdFogOfWarBuiltins in ScmdFogOfWarBuiltins, line 16")
set aBX=OPo(abX,"when calling new_BuiltinData in ScmdFogOfWarBuiltins, line 16")
call Rxo(aBX,d_V(),"when calling setArgumentsTypes in ScmdFogOfWarBuiltins, line 19")
call Foa(ILo(aBX,"when calling new_BuiltinFunction in ScmdFogOfWarBuiltins, line 16"),"fogenable","when calling registerProtectedBuiltin in ScmdFogOfWarBuiltins, line 16")
set acX=i6X("when calling alloc_IBuiltin_registerProtectedBuiltin_ScmdFogOfWarBuiltins in ScmdFogOfWarBuiltins, line 20")
call g_V(ILo(OPo(acX,"when calling new_BuiltinData in ScmdFogOfWarBuiltins, line 20"),"when calling new_BuiltinFunction in ScmdFogOfWarBuiltins, line 20"),fNV(KCv("isfogenabled","when calling stringToIndex in ScmdFogOfWarBuiltins, line 22"),KCv("fogenabled?","when calling stringToIndex in ScmdFogOfWarBuiltins, line 22"),"when calling asList in ScmdFogOfWarBuiltins, line 22"),"when calling registerProtectedBuiltin in ScmdFogOfWarBuiltins, line 20")
set aCX=i0X("when calling alloc_IBuiltin_addOverload_registerProtectedBuiltin_ScmdFogOfWarBuiltins in ScmdFogOfWarBuiltins, line 23")
set afX=ILo(OPo(aCX,"when calling new_BuiltinData in ScmdFogOfWarBuiltins, line 23"),"when calling new_BuiltinFunction in ScmdFogOfWarBuiltins, line 23")
set aGX=afX
set adX=i9X("when calling alloc_IBuiltin_setArgumentsTypes_addOverload_registerProtectedBuiltin_ScmdFogOfWarBuiltins in ScmdFogOfWarBuiltins, line 27")
set aDX=OPo(adX,"when calling new_BuiltinData in ScmdFogOfWarBuiltins, line 27")
call Rxo(aDX,OFo(),"when calling setArgumentsTypes in ScmdFogOfWarBuiltins, line 39")
call IFo(aGX,aDX,"when calling addOverload in ScmdFogOfWarBuiltins, line 27")
call Foa(afX,"seeall","when calling registerProtectedBuiltin in ScmdFogOfWarBuiltins, line 23")
set aFX=axX("when calling alloc_IBuiltin_setArgumentsTypes_registerProtectedBuiltin_ScmdFogOfWarBuiltins in ScmdFogOfWarBuiltins, line 41")
set agX=OPo(aFX,"when calling new_BuiltinData in ScmdFogOfWarBuiltins, line 41")
call Rxo(agX,OFo(),"when calling setArgumentsTypes in ScmdFogOfWarBuiltins, line 44")
call Foa(ILo(agX,"when calling new_BuiltinFunction in ScmdFogOfWarBuiltins, line 41"),"fromrawcode","when calling registerProtectedBuiltin in ScmdFogOfWarBuiltins, line 41")
set EM=EM-1
return true
endfunction
function ahX takes nothing returns boolean
set EM=0
return aOX("ScmdFogOfWarBuiltins, line 1")
endfunction
function aHX takes nothing returns nothing
local unit ajX=vTV()
local real aJX=Rpa(ajX)
call Nbe(ajX,1.,.0)
call Nbe(ajX,.0,.0)
call Nbe(ajX,aJX,.0)
set ajX=null
endfunction
function aLX takes nothing returns integer
local integer amX
if Cl[0]==0 then
set Xl=Xl+1
set amX=Xl
else
set amX=Cl[0]
set Cl[0]=Cl[Cl[0]]
endif
return amX
endfunction
function aMX takes nothing returns integer
local integer apX=aLX()
set Kl[apX]=B0v()
set Ll[apX]=0
return apX
endfunction
function main takes nothing returns nothing
local trigger aPX
local trigger aqX
local trigger aQX
local trigger asX
local trigger aSX
local trigger atX
local trigger aTX
local trigger auX
local trigger aUX
local trigger awX
local trigger aWX
local trigger ayX
local trigger aYX
local trigger azX
local integer aZX
local integer a_X
local player alX
set w=CreateGroup()
set u=CreateForce()
set t=JASS_MAX_ARRAY_SIZE-1
set i=InitHashtable()
set S=$A
set c=InitHashtable()
set o=0
set O=1
set b=0
set f=" !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
call StringLength(f)
set R=CreateTrigger()
set T='A0KG'
set Y='h0JO'
set G=null
set h=null
set x=0
set V=0
set N=0
set ww=false
set uw=null
set rw=null
set dw=0
set fw=0
set Yw=0
set gw=false
set jw=null
set xw=null
set Vw=false
set Mw=null
set uu=null
set tu=.0
set yu=false
set eu=.0
set qu=.0
set au=null
set fu=false
set Yu=false
set Gu=.0
set gu=.0
set hu=.0
set Fu=.0
set ku=0
set ju=0
set xu=.0
set vu=.0
set mu=.0
set Qu=.0
set Wu=.0
set Eu=.0
set Zu=.0
set Uu=.0
set Iu=.0
set Pu=.0
set Au=null
set Du=0
set Hu=null
set Ku=null
set Lu=null
set Xu=null
set Cu=0
set Vu=0
set Bu=0
set Nu=null
set Mu=0
set wr=0
set ur=0
set rr=0
set sr=0
set tr=.0
set ir=.0
set Sr=false
set br=0
set yr=.0
set pr=null
set er=.0
set qr=.0
set ar=.0
set nr=null
set dr=null
set fr=null
set Rr=null
set Tr=null
set Yr=null
set hr=null
set xr=null
set mr=null
set Er=.0
set Jr=false
set Lr=.0
set Xr=.0
set Cr=null
set Mr=0
set ws=null
set us=null
set rs=null
set ts=0
set cs=null
set os=null
set Os=null
set ys=null
set ps=null
set es=null
set qs=null
set as=null
set ns=null
set Ys=null
set Ws=.0
set Es=false
set Zs=.0
set Is=.0
set Ps=null
set As=null
set Ds=0
set Js=null
set Ls=null
set Xs=null
set Cs=0
set Bs=null
set wt=0
set st=null
set tt=null
set St=null
set ct=null
set ot=null
set Ot=null
set lt=null
set bt=null
set yt=null
set pt=null
set Yt=null
set gt=0
set ht=null
set Ft=null
set kt=null
set jt=null
set xt=null
set mt=0
set Ut=null
set It=null
set Pt=null
set At=null
set Dt=null
set Ht=null
set Jt=null
set Kt=null
set Lt=null
set Xt=null
set Ct=null
set Vt=null
set Bt=null
set Nt=null
set Mt=null
set wi=null
set ui=null
set ri=null
set si=null
set ti=null
set ii=null
set Si=null
set ci=null
set oi=null
set Oi=null
set li=null
set bi=null
set yi=null
set pi=null
set ei=null
set qi=null
set ai=null
set ni=null
set di=null
set fi=null
set Ri=null
set Ti=null
set Yi=null
set Gi=null
set gi=null
set hi=null
set Fi=null
set ki=null
set ji=null
set xi=null
set vi=null
set mi=null
set Qi=null
set Wi=null
set Ei=null
set Zi=null
set Ui=null
set Ii=null
set Pi=null
set Ai=null
set Di=null
set Hi=null
set Ji=null
set Ki=null
set Li=null
set Xi=null
set Ci=null
set Vi=null
set Bi=null
set Ni=null
set Mi=null
set wS=null
set uS=null
set rS=null
set sS=null
set tS=null
set iS=null
set SS=null
set cS=null
set oS=null
set OS=null
set lS=null
set bS=null
set yS=null
set pS=null
set eS=null
set qS=null
set aS=null
set nS=null
set dS=null
set fS=null
set RS=null
set TS=null
set YS=null
set GS=null
set gS=null
set hS=null
set FS=null
set kS=null
set jS=null
set xS=null
set vS=null
set mS=null
set QS=null
set WS=null
set ES=null
set ZS=null
set US=null
set IS=null
set PS=null
set AS=null
set DS=null
set HS=null
set JS=null
set KS=null
set LS=null
set XS=null
set CS=null
set VS=null
set BS=null
set NS=null
set MS=null
set wc=null
set uc=null
set rc=null
set sc=null
set tc=null
set ic=null
set Sc=null
set cc=null
set oc=null
set Oc=null
set lc=null
set bc=null
set yc=null
set pc=null
set ec=null
set qc=null
set ac=null
set nc=null
set dc=null
set fc=null
set Rc=null
set Tc=null
set Yc=null
set Gc=null
set gc=null
set hc=null
set Fc=null
set kc=null
set jc=null
set xc=null
set vc=null
set mc=null
set Qc=null
set Wc=null
set Ec=null
set Zc=null
set Uc=null
set Ic=null
set Pc=null
set Ac=null
set Dc=null
set Hc=null
set Jc=null
set Kc=null
set Lc=null
set Xc=null
set Cc=null
set Vc=null
set Bc=null
set Nc=null
set Mc=null
set wo=null
set uo=null
set ro=null
set so=null
set io=null
set So=null
set co=null
set oo=null
set Oo=null
set lo=null
set bo=null
set yo=null
set po=null
set eo=null
set qo=null
set ao=null
set no=null
set do=null
set fo=null
set Ro=null
set To=null
set Yo=null
set Go=null
set go=null
set ho=null
set Fo=null
set ko=null
set jo=null
set xo=null
set vo=null
set mo=null
set Qo=null
set Wo=null
set Eo=null
set Zo=null
set Uo=null
set Io=null
set Po=null
set Ao=null
set Do=null
set Ho=null
set Jo=null
set Ko=null
set Lo=null
set Xo=null
set Co=null
set Vo=null
set Bo=null
set No=null
set Mo=null
set wO=null
set uO=null
set rO=null
set sO=null
set tO=null
set iO=null
set SO=null
set cO=null
set oO=null
set OO=null
set lO=null
set bO=null
set yO=null
set pO=null
set eO=null
set qO=null
set aO=null
set nO=null
set dO=null
set fO=null
set RO=null
set TO=null
set YO=null
set GO='A0J1'
set gO='A0LQ'
set hO='A0KY'
set FO='A0LR'
set kO='A0LP'
set jO='A0LS'
set xO='A0LV'
set vO='A0LT'
set mO='A0LX'
set QO='A0LY'
set WO='A0M7'
set EO='A0M5'
set ZO='A0LN'
set UO='B05B'
set IO='A0LM'
set JO='A0MB'
set KO='A0MC'
set LO='A0MD'
set ul='A0MM'
set rl='B05O'
set sl='A0MO'
set tl='B05P'
set il='A0MN'
set Sl='B05Q'
set cl='A0MP'
set ql=CreateGroup()
set dl=CreateGroup()
set Yl='R001'
set Gl='R002'
set gl='R003'
set vl=bj_MAX_PLAYER_SLOTS
set Il=0
call CreateGroup()
set Xl=0
set Ml=0
set cb=0
set Ob=0
set lb=0
set yb=$80*16
set gb=0
set Fb=0
set kb=0
set Ib=0
set rY=0
set sY=0
set SY=0
set cY=0
set lY=0
set bY=0
set eY=0
set qY=0
set dY=0
set fY=0
set YY=0
set GY=0
set FY=0
set kY=0
set vY=0
set mY=0
set EY=0
set ZY=0
set PY=0
set AY=0
set JY=0
set KY=0
set CY=0
set VY=0
set MY=0
set wG=0
set sG=0
set tG=0
set cG=0
set oG=0
set yG=0
set pG=0
set aG=0
set nG=0
set RG=0
set TG=0
set gG=0
set hG=0
set jG=0
set xG=0
set QG=0
set WG=0
set UG=0
set IG=0
set DG=0
set HG=0
set LG=0
set XG=0
set BG=0
set NG=0
set ug=0
set rg=0
set ig=0
set Sg=0
set Og=0
set lg=0
set pg=0
set eg=0
set ng=0
set dg=0
set Tg=0
set Yg=0
set hg=0
set Fg=0
set xg=0
set vg=0
set Wg=0
set Eg=0
set Ig=0
set Pg=0
set Dg=0
set Kg=0
set Cg=0
set Vg=0
set Mg=0
set wh=0
set sh=0
set th=0
set ch=0
set oh=0
set bh=0
set yh=0
set eh=0
set nh=0
set dh=0
set Th=0
set Yh=0
set gh=0
set hh=0
set jh=0
set xh=0
set Qh=0
set Wh=0
set Uh=0
set Ih=0
set Dh=0
set Hh=0
set Lh=0
set Xh=0
set Bh=0
set Nh=0
set uF=0
set rF=0
set iF=0
set SF=0
set oF=0
set OF=0
set bF=0
set eF=0
set qF=0
set dF=0
set fF=0
set YF=0
set GF=0
set FF=0
set kF=0
set vF=0
set mF=0
set EF=0
set ZF=0
set IF=0
set JF=0
set KF=0
set CF=0
set VF=0
set MF=0
set wk=0
set sk=0
set tk=0
set Sk=0
set Ok=0
set lk=0
set pk=0
set ek=0
set nk=0
set dk=0
set Tk=0
set Yk=0
set gk=0
set kk=0
set jk=0
set Qk=0
set Wk=0
set Uk=0
set Ik=0
set Dk=0
set Hk=0
set Lk=0
set Xk=0
set Bk=0
set Nk=0
set uj=0
set rj=0
set ij=0
set Sj=0
set Oj=0
set lj=0
set pj=0
set ej=0
set nj=0
set dj=0
set Tj=0
set Yj=0
set hj=0
set Fj=0
set xj=0
set vj=0
set Wj=0
set Ej=0
set Ij=0
set Pj=0
set Hj=0
set Jj=0
set Xj=0
set Cj=0
set Nj=0
set Mj=0
set rx=0
set sx=0
set Sx=0
set cx=0
set lx=0
set bx=0
set ex=0
set qx=0
set dx=0
set fx=0
set Yx=0
set Gx=0
set Fx=0
set kx=0
set vx=0
set mx=0
set Ex=0
set Zx=0
set Px=0
set Ax=0
set Jx=0
set Kx=0
set Cx=0
set Vx=0
set Mx=0
set wv=0
set sv=0
set tv=0
set cv=0
set ov=0
set bv=0
set yv=0
set qv=0
set av=0
set fv=0
set Rv=0
set Yv=0
set Gv=0
set Fv=0
set kv=0
set vv=0
set mv=0
set Ev=0
set Zv=0
set Pv=0
set Av=0
set Jv=0
set Kv=0
set Cv=0
set Vv=0
set Nv=0
set Mv=0
set rm=0
set sm=0
set im=0
set om=0
set Om=0
set pm=0
set em=0
set am=0
set nm=0
set Rm=0
set Tm=0
set gm=0
set hm=0
set jm=0
set xm=0
set mm=0
set Qm=0
set Zm=0
set Um=0
set Am=0
set Dm=0
set Jm=0
set Km=0
set Cm=0
set Vm=0
set Mm=0
set wQ=0
set Rz=function Msa
set Iz=function XrV
set Az=function C6v
set Nz=function CZa
set bz=function RGV
set Bz=function P_a
set cz=function NaV
set Cz=function hiE
set dz=function aVV
set Dz=function f_E
set fz=function iLV
set Fz=function ocX
set gz=function XnV
set Gz=function Dla
set hz=function C9v
set Hz=function GWv
set jz=function Ysn
set Jz=function iWX
set kz=function YjE
set Kz=function dLV
set lz=function GHa
set Lz=function RUV
set mz=function msE
set Mz=function osV
set pz=function xnX
set Pz=function u6E
set qz=function r8n
set Qz=function HLV
set sz=function DJV
set Sz=function CpV
set tz=function EVV
set Tz=function k1V
set uz=function VDE
set Uz=function rgX
set wz=function gIE
set Wz=function RdV
set yz=function E0V
set Yz=function dba
set zz=function n3n
set Zz=function cgv
set zZ=function b7a
set v0=function n1V
set e0=function eGV
set x0=function izX
set o0=function iJE
set r0=function dpV
set i0=function KgV
set a0=function agV
set n0=function N3V
set V0=function VpE
set E0=function GJa
set X0=function oFX
set O0=function iMV
set R0=function b2V
set I0=function iHE
set A0=function KFV
set N0=function azE
set b0=function afV
set B0=function EFV
set c0=function VmE
set C0=function gmE
set d0=function FbE
set D0=function XEV
set f0=function qXa
set F0=function DLa
set g0=function fTE
set G0=function pya
set h0=function NVV
set H0=function C1a
set j0=function O7V
set J0=function GYv
set k0=function o9X
set K0=function WEE
set l0=function YLE
set L0=function f1a
set m0=function Yyn
set M0=function NnV
set p0=function kjV
set P0=function p2E
set q0=function HHV
set Q0=function qfE
set s0=function uZE
set S0=function m8E
set t0=function VRE
set T0=function EwV
set u0=function pRa
set U0=function XqE
set w0=function iKX
set W0=function HZE
set y0=function FMa
set Y0=function qdE
set z0=function m7E
set Z0=function zUV
set z1=function VXE
set z2=function aLV
set z3=function pXa
set z4=function mDa
set z5=function g_E
set z6=function ClV
set z7=function X5V
set z8=function glv
set vvv=function YQE
set vev=function D8a
set vxv=function zpn
set vov=function NJV
set vrv=function dra
set viv=function RrV
set vav=function Zqn
set vnv=function whE
set vVv=function yZE
set vEv=function AiV
set vXv=function YAn
set vOv=function zMn
set vRv=function VNV
set vIv=function j3V
set vAv=function i_X
set vNv=function iKE
set vbv=function hdE
set vBv=function T4E
set vcv=function N6V
set vCv=function mSE
set vdv=function aZE
set vDv=function Mua
set vfv=function XlE
set vFv=function gME
set vgv=function FBE
set vGv=function ipV
set vhv=function R_V
set vHv=function HTE
set vjv=function f2a
set vJv=function qRa
set vkv=function XOV
set vKv=function Mga
set vlv=function VDn
set vLv=function AKV
set vmv=function dEV
set vMv=function dGa
set vpv=function pta
set vPv=function ren
set vqv=function Vfn
set vQv=function x5X
set vsv=function HpE
set vSv=function igV
set vtv=function RjV
set vTv=function aPE
set vuv=function GtE
set vUv=function PxE
set vwv=function EnV
set vWv=function mHa
set vyv=function F2a
set vYv=function fWE
set vzv=function inV
set vZv=function fna
set v_v=function EZV
set v0v=function obV
set v1v=function dAa
set v2v=function o0n
set v3v=function YDn
set v4v=function b6a
set v5v=function gsv
set v6v=function zYn
set v7v=function UrE
set v8v=function YdE
set v9v=function haE
set evv=function jJV
set eev=function DPV
set exv=function PIE
set eov=function jaE
set erv=function aSE
set eiv=function NzV
set eav=function Mka
set env=function FaE
set eVv=function XjE
set eEv=function rMX
set eXv=function fga
set eOv=function HqE
set eRv=function bYV
set eIv=function dJa
set eAv=function pTa
set eNv=function BIa
set ebv=function OPV
set eBv=function z8n
set ecv=function oyX
set eCv=function UeE
set edv=function OfE
set eDv=function MRE
set efv=function jrE
set eFv=function oWX
set egv=function aAV
set eGv=function ENV
set ehv=function NwV
set eHv=function MHa
set ejv=function amE
set eJv=function XgE
set ekv=function rLX
set eKv=function HLE
set elv=function gHE
set eLv=function buV
set emv=function oFV
set eMv=function cpv
set epv=function psa
set ePv=function P3a
set eqv=function AlV
set eQv=function guv
set esv=function vvV
set eSv=function z6n
set etv=function OMV
set eTv=function wwE
set euv=function HqV
set eUv=function DLV
set ewv=function PiE
set eWv=function k7V
set eyv=function NTV
set eYv=function q3E
set ezv=function VGE
set eZv=function rjX
set e_v=function F4a
set e0v=function HHE
set e1v=function fEa
set e2v=function RfV
set e3v=function E5V
set e4v=function dBa
set e5v=function n7n
set e6v=function cjv
set e7v=function AgV
set e8v=function Z4n
set e9v=function oUX
set xvv=function gSv
set xev=function u9E
set xxv=function eXV
set xov=function DmV
set xrv=function ZrV
set xiv=function CyV
set xav=function PVE
set xnv=function KiV
set xVv=function EAV
set xEv=function x2X
set xXv=function iDV
set xOv=function fCa
set xRv=function bTV
set xIv=function PZa
set xAv=function cKv
set xNv=function dfa
set xbv=function Vxn
set xBv=function AkV
set xcv=function erV
set xCv=function q0E
set xdv=function H5E
set xDv=function NpV
set xfv=function VdE
set xFv=function XVE
set xgv=function gOE
set xGv=function OCE
set xhv=function MrE
set xHv=function iqX
set xjv=function CMV
set xJv=function anV
set xkv=function V9V
set xKv=function k0V
set xlv=function zzV
set xLv=function GVE
set xmv=function XEE
set xMv=function xSX
set xpv=function faa
set xPv=function oNV
set xqv=function o_n
set xQv=function gRE
set xsv=function HnE
set xSv=function bQV
set xtv=function cDv
set xTv=function n2n
set xuv=function AFV
set xUv=function OKV
set xwv=function zyn
set xWv=function xIX
set xyv=function u7E
set xYv=function YeE
set xzv=function MVE
set xZv=function GTE
set x_v=function z3V
set x0v=function CqV
set x1v=function k3V
set x2v=function aXV
set x3v=function EOV
set x4v=function mja
set x5v=function XAE
set x6v=function gcE
set x7v=function iVV
set x8v=function fVa
set x9v=function E3V
set ovv=function ocV
set oev=function cHv
set oxv=function pHa
set oov=function n6n
set orv=function Yfn
set oiv=function b8a
set oav=function OlV
set onv=function Z3n
set oVv=function xAX
set oEv=function YoE
set oXv=function aZV
set oOv=function MEE
set oRv=function GuE
set oIv=function z7V
set oAv=function CQV
set oNv=function mua
set obv=function XbE
set oBv=function f1E
set ocv=function xTX
set oCv=function fXa
set odv=function E6V
set oDv=function o3n
set ofv=function AhV
set oFv=function YFn
set ogv=function b9a
set oGv=function z_n
set ohv=function gTv
set oHv=function oqX
set ojv=function jDV
set oJv=function GZE
set okv=function CsV
set oKv=function ZeV
set olv=function aOV
set oLv=function k8V
set omv=function VhE
set oMv=function NuV
set opv=function f4E
set oPv=function F5a
set oqv=function HJE
set oQv=function E7V
set osv=function fAa
set oSv=function RFV
set otv=function pLa
set oTv=function Vvn
set ouv=function Ygn
set oUv=function OmV
set owv=function z0n
set oWv=function YEE
set oyv=function a_V
set oYv=function jgV
set ozv=function G2E
set oZv=function PnE
set o_v=function q4E
set o0v=function CtV
set o1v=function k9V
set o2v=function alE
set o3v=function ERV
set o4v=function NUV
set o5v=function VjE
set o6v=function F7a
set o7v=function f7E
set o8v=function HlE
set o9v=function RgV
set rvv=function btV
set rev=function Pza
set rxv=function dda
set rov=function o9n
set rrv=function Yhn
set riv=function Bea
set rav=function Z7n
set rnv=function oYX
set rVv=function UoE
set rEv=function YCE
set rXv=function a1V
set rOv=function DpV
set rRv=function MAE
set rIv=function PRE
set rAv=function dXV
set rNv=function q6E
set rbv=function KVV
set rBv=function EbV
set rcv=function abV
set rCv=function MJa
set rdv=function F9a
set rDv=function XHE
set rfv=function FoE
set rFv=function HPE
set rgv=function x6X
set rGv=function RkV
set rhv=function byV
set rHv=function P6a
set rjv=function cqv
set rJv=function rrn
set rkv=function Ykn
set rKv=function BVa
set rlv=function gwv
set rLv=function xaX
set rmv=function wUE
set rMv=function enV
set rpv=function X0E
set rPv=function DjV
set rqv=function p9E
set rQv=function aKE
set rsv=function q2E
set rSv=function V8V
set rtv=function mha
set rTv=function FZa
set ruv=function xQX
set rUv=function RNV
set rwv=function bqV
set rWv=function dRa
set ryv=function AbV
set rYv=function gQv
set rzv=function zUn
set rZv=function YBE
set r_v=function jjV
set r0v=function hrE
set r1v=function iSX
set r2v=function PEE
set r3v=function ZiV
set r4v=function CYV
set r5v=function KaV
set r6v=function aME
set r7v=function aNV
set r8v=function NWV
set r9v=function VJE
set ivv=function XhE
set iev=function F8a
set ixv=function FvE
set iov=function x4X
set irv=function HME
set iiv=function iFV
set iav=function fda
set inv=function E9V
set iVv=function P4a
set iEv=function ogV
set iXv=function dFa
set iOv=function rvn
set iRv=function Bra
set iIv=function gUv
set iAv=function u1E
set iNv=function YvE
set ibv=function XZE
set iBv=function MxE
set icv=function HlV
set iCv=function ktV
set idv=function aiV
set iDv=function FTa
set ifv=function fwE
set iFv=function rFX
set igv=function ioV
set iGv=function RRV
set ihv=function pGa
set iHv=function cdv
set ijv=function EzV
set iJv=function n1n
set ikv=function ARV
set iKv=function oQX
set ilv=function u8E
set iLv=function G4E
set imv=function isX
set iMv=function CuV
set ipv=function KxV
set iPv=function XdE
set iqv=function f8E
set iQv=function xUX
set isv=function ghE
set iSv=function iCV
set itv=function fBa
set iTv=function oCV
set iuv=function dDa
set iUv=function pQa
set iwv=function Yjn
set iWv=function AHV
set iyv=function Boa
set iYv=function Z8n
set izv=function z5n
set iZv=function xBX
set i_v=function YXE
set i0v=function a0V
set i1v=function jGV
set i2v=function eEV
set i3v=function G3E
set i4v=function iQX
set i5v=function ZxV
set i6v=function CTV
set i7v=function KvV
set i8v=function aIV
set i9v=function gCE
set avv=function rJX
set aev=function xuX
set axv=function iIV
set aov=function fNa
set arv=function E8V
set aiv=function pma
set aav=function Ven
set anv=function YHn
set aVv=function Bxa
set aEv=function z1n
set aXv=function xeX
set aOv=function u_E
set aRv=function y2E
set aIv=function ayV
set aAv=function MvE
set aNv=function vYV
set abv=function DFV
set aBv=function qkE
set acv=function H0E
set aCv=function VzV
set adv=function mga
set aDv=function E6E
set afv=function giE
set aFv=function fUE
set agv=function xLX
set aGv=function PPa
set ahv=function daa
set aHv=function pCa
set ajv=function cOv
set aJv=function oJn
set akv=function YBn
set aKv=function aWV
set alv=function m9E
set aLv=function qFE
set amv=function H_E
set aMv=function VwV
set apv=function mFa
set aPv=function geE
set aqv=function rRX
set aQv=function bLV
set asv=function Pma
set aSv=function oxV
set atv=function dia
set aTv=function pIa
set auv=function nYn
set aUv=function zPn
set awv=function u0E
set aWv=function y3E
set ayv=function xxX
set aYv=function XsE
set azv=function MeE
set aZv=function HjV
set a_v=function qmE
set a0v=function H1E
set a1v=function kQV
set a2v=function afE
set a3v=function V1V
set a4v=function E8E
set a5v=function gaE
set a6v=function h6E
set a7v=function RaV
set a8v=function ooV
set a9v=function dna
set nvv=function okn
set nev=function Ycn
set nxv=function b_a
set nov=function gmv
set nrv=function wHE
set niv=function XQE
set nav=function DBV
set nnv=function p4E
set nVv=function kmV
set nEv=function iZV
set nXv=function NkV
set nOv=function VcE
set nRv=function Fpa
set nIv=function fuE
set nAv=function xKX
set nNv=function r5V
set nbv=function RiV
set nBv=function bmV
set ncv=function PMa
set nCv=function cXv
set ndv=function pBa
set nDv=function Ybn
set nfv=function bza
set nFv=function zun
set ngv=function y5E
set nGv=function g2E
set nhv=function ilX
set nHv=function i1V
set njv=function NlV
set nJv=function XxE
set nkv=function gnE
set nKv=function r6V
set nlv=function D9a
set nLv=function Pua
set nmv=function pda
set nMv=function oln
set npv=function AaV
set nPv=function OHV
set nqv=function b1a
set nQv=function gMv
set nsv=function YCn
set nSv=function wLE
set ntv=function azV
set nTv=function vzV
set nuv=function XSE
set nUv=function DgV
set nwv=function zwV
set nWv=function H2E
set nyv=function p5E
set nYv=function aFE
set nzv=function NLV
set nZv=function XiE
set n_v=function V2V
set n0v=function gVE
set n1v=function xmX
set n2v=function RnV
set n3v=function rIX
set n4v=function bMV
set n5v=function PWa
set n6v=function oPn
set n7v=function AnV
set n8v=function OjV
set n9v=function Ydn
set Vvv=function ZQn
set Vev=function wQE
set Vxv=function opX
set Vov=function g8E
set Vrv=function iLX
set Viv=function zWV
set Vav=function CLV
set Vnv=function ksV
set VVv=function i7V
set VEv=function V4V
set VXv=function mGa
set VOv=function VCE
set VRv=function Fqa
set VIv=function gXE
set VAv=function rAX
set VNv=function xMX
set Vbv=function ieV
set VBv=function RXV
set Vcv=function bPV
set VCv=function EWV
set Vdv=function oVV
set VDv=function cbv
set Vfv=function pFa
set VFv=function AVV
set Vgv=function OkV
set VGv=function Z0n
set Vhv=function oPX
set VHv=function wtE
set Vjv=function XtE
set VJv=function HJV
set Vkv=function GiE
set VKv=function p6E
set Vlv=function v0V
set VLv=function i8V
set Vmv=function FQa
set VMv=function NMV
set Vpv=function HxE
set VPv=function oEV
set Vqv=function otn
set VQv=function ROV
set Vsv=function b2a
set VSv=function gpv
set Vtv=function XTE
set VTv=function qSE
set Vuv=function HKV
set VUv=function aGE
set Vwv=function rNX
set VWv=function V5V
set Vyv=function fva
set VYv=function EyV
set Vzv=function cBv
set VZv=function e0X
set V_v=function pga
set V0v=function y_E
set V1v=function amV
set V2v=function DRV
set V3v=function p3E
set V4v=function kJV
set V5v=function VBE
set V6v=function EBV
set V7v=function NZV
set V8v=function Z2n
set V9v=function gWv
set Evv=function MKa
set Eev=function pua
set Exv=function E1V
set Eov=function iGX
set Erv=function ojn
set Eiv=function oBV
set Eav=function VqE
set Env=function veV
set EVv=function ASV
set EEv=function dlV
set EXv=function xtX
set EOv=function zLn
set ERv=function cfv
set EIv=function F_a
set EAv=function bsV
set ENv=function ifV
set Ebv=function Gha
set EBv=function C5v
set Ecv=function EfV
set ECv=function IzV
set Edv=function Fka
set EDv=function gKE
set Efv=function f9E
set EFv=function FNE
set Egv=function kEV
set EGv=function ruX
set Ehv=function oBX
set EHv=function BAa
set Ejv=function rin
set EJv=function OTV
set Ekv=function gvE
set EKv=function dNa
set Elv=function D7a
set ELv=function OpV
set Emv=function xkX
set EMv=function XIE
set Epv=function F3a
set EPv=function UNE
set Eqv=function mca
set EQv=function VFn
set Esv=function iFX
set ESv=function pha
set Etv=function r4V
set ETv=function izV
set Euv=function HGE
set EUv=function oIX
set Ewv=function rkX
set EWv=function HSE
set Eyv=function XoV
set EYv=function ilV
set Ezv=function RuV
set EZv=function fPa
set E_v=function Ynn
set E0v=function Yrn
set E1v=function b_V
set E2v=function XxV
set E3v=function qEa
set E4v=function ozn
set E5v=function oMV
set E6v=function Cyv
set E7v=function X6V
set E8v=function PLa
set E9v=function E_V
set Xvv=function DKa
set Xev=function ovV
set Xxv=function x3X
set Xov=function uYE
set Xrv=function XXV
set Xiv=function pWa
set Xav=function CKV
set Xnv=function rvX
set XVv=function rAn
set XEv=function Vyn
set XXv=function YQn
set XOv=function Gzv
set XRv=function AuV
set XIv=function GaE
set XAv=function eVV
set XNv=function Cza
set Xbv=function NmV
set XBv=function O6V
set Xcv=function Giv
set XCv=function vrV
set Xdv=function Zkn
set XDv=function Pya
set Xfv=function IZV
set XFv=function rOX
set Xgv=function zzn
set XGv=function xfX
set Xhv=function wFE
set XHv=function N4V
set Xjv=function zmn
set XJv=function q5E
set Xkv=function MTa
set XKv=function xJX
set Xlv=function iGV
set XLv=function wdE
set Xmv=function yzE
set XMv=function VfE
set Xpv=function YKn
set XPv=function e_X
set Xqv=function AsV
set XQv=function iMX
set Xsv=function fPE
set XSv=function VSV
set Xtv=function J7V
set XTv=function pyE
set Xuv=function x9V
set XUv=function h5E
set Xwv=function HGV
set XWv=function ahX
set Xyv=function qCE
set XYv=function adE
set Xzv=function V3V
set XZv=function uyE
set X_v=function DOV
set X0v=function m6E
set X1v=function zuV
set X2v=function VEE
set X3v=function alV
set X4v=function EUV
set X5v=function eCV
set X6v=function bHV
set X7v=function pEa
set X8v=function p_E
set X9v=function E5E
set Ovv=function XPE
set Oev=function mBa
set Oxv=function gZE
set Oov=function F9E
set Orv=function ifX
set Oiv=function oMX
set Oav=function gBE
set Onv=function HwE
set OVv=function iQV
set OEv=function dIa
set OXv=function IwV
set OOv=function FJa
set ORv=function aDE
set OIv=function mfa
set OAv=function ZPn
set ONv=function OGV
set Obv=function gLv
set OBv=function o1X
set Ocv=function xcX
set OCv=function YDE
set Odv=function OFE
set ODv=function MNE
set Ofv=function hOE
set OFv=function itX
set Ogv=function PbE
set OGv=function ZVV
set Ohv=function QeE
set OHv=function dAV
set Ojv=function jIE
set OJv=function KIV
set Okv=function aUE
set OKv=function aBV
set Olv=function CkV
set OLv=function IYV
set Omv=function T3E
set OMv=function X4V
set Opv=function oHn
set OPv=function r3V
set Oqv=function gKv
set OQv=function D6a
set Osv=function Pla
set OSv=function nyn
set Otv=function Yvn
set OTv=function aHX
set Ouv=function KfV
set OUv=function aLE
set Owv=function zln
set OWv=function VtV
set Oyv=function oeV
set OYv=function p0E
set Ozv=function qOa
set OZv=function NjV
set O_v=function PvE
set O0v=function doa
set O1v=function RoV
set O2v=function bYa
set O3v=function vyV
set O4v=function Zmn
set O5v=function o4X
set O6v=function C4v
set O7v=function o8X
set O8v=function r7n
set O9v=function NiV
set Rvv=function xDX
set Rev=function UAE
set Rxv=function WaE
set Rov=function YHE
set Rrv=function OqE
set Riv=function nDV
set Rav=function j2V
set Rnv=function MmE
set RVv=function egV
set REv=function hcE
set RXv=function DsV
set ROv=function iwX
set RRv=function PCE
set RIv=function ihE
set RAv=function T0E
set RNv=function dKV
set Rbv=function mQE
set RBv=function igX
set Rcv=function HYE
set RCv=function iYV
set Rdv=function KDV
set RDv=function aYE
set Rfv=function aDV
set RFv=function EDV
set Rgv=function N2V
set RGv=function MQa
set Rhv=function VLE
call SetCameraBounds((-30720.)+GetCameraMargin(CAMERA_MARGIN_LEFT),(-30720.)+GetCameraMargin(CAMERA_MARGIN_BOTTOM),30720.-GetCameraMargin(CAMERA_MARGIN_RIGHT),30720.-GetCameraMargin(CAMERA_MARGIN_TOP),(-30720.)+GetCameraMargin(CAMERA_MARGIN_LEFT),30720.-GetCameraMargin(CAMERA_MARGIN_TOP),30720.-GetCameraMargin(CAMERA_MARGIN_RIGHT),(-30720.)+GetCameraMargin(CAMERA_MARGIN_BOTTOM))
call SetDayNightModels("Environment\\DNC\\DNCAshenvale\\DNCAshenvaleTerrain\\DNCAshenvaleTerrain.mdl","Environment\\DNC\\DNCAshenvale\\DNCAshenvaleUnit\\DNCAshenvaleUnit.mdl")
call NewSoundEnvironment("Default")
call SetAmbientDaySound("AshenvaleDay")
call SetAmbientNightSound("AshenvaleNight")
call SetMapMusic("Music",true,0)
set Pt=CreateSound("Sound\\Interface\\NewTournament.wav",false,false,false,$A,$A,"DefaultEAXON")
call SetSoundParamsFromLabel(Pt,"NewTournament")
call SetSoundDuration(Pt,7987)
set At=CreateSound("Sound\\Ambient\\DoodadEffects\\WaterLakeLoop1.wav",false,true,false,$A,$A,"DoodadsEAX")
call SetSoundParamsFromLabel(At,"LakeLoop")
call SetSoundDuration(At,$CE1)
call SetSoundVolume(At,$7F)
set Dt=CreateSound("Sound\\Ambient\\DoodadEffects\\WaterStreamLoop1.wav",false,true,false,$A,$A,"DoodadsEAX")
call SetSoundParamsFromLabel(Dt,"StreamLoop")
call SetSoundDuration(Dt,$7D8)
set Ht=CreateSound("Sound\\Ambient\\DoodadEffects\\WaterWavesLoop1.wav",false,true,false,$A,$A,"DoodadsEAX")
call SetSoundParamsFromLabel(Ht,"WavesLoop")
call SetSoundDuration(Ht,7445)
call SetSoundVolume(Ht,$7F)
set It=Rect(-30720.,26336.,-24672.,30720.)
call SetPlayerTechResearched(Player(0),'Rhme',3)
call SetPlayerTechResearched(Player(0),'Rhra',3)
call SetPlayerTechResearched(Player(0),'Rhhb',1)
call SetPlayerTechResearched(Player(0),'Rhar',3)
call SetPlayerTechResearched(Player(0),'Rhgb',1)
call SetPlayerTechResearched(Player(0),'Rhac',3)
call SetPlayerTechResearched(Player(0),'Rhde',1)
call SetPlayerTechResearched(Player(0),'Rhan',1)
call SetPlayerTechResearched(Player(0),'Rhpt',2)
call SetPlayerTechResearched(Player(0),'Rhst',2)
call SetPlayerTechResearched(Player(0),'Rhla',3)
call SetPlayerTechResearched(Player(0),'Rhri',1)
call SetPlayerTechResearched(Player(0),'Rhlh',2)
call SetPlayerTechResearched(Player(0),'Rhse',1)
call SetPlayerTechResearched(Player(0),'Rhfl',1)
call SetPlayerTechResearched(Player(0),'Rhss',1)
call SetPlayerTechResearched(Player(0),'Rhrt',1)
call SetPlayerTechResearched(Player(0),'Rhpm',1)
call SetPlayerTechResearched(Player(0),'Rhfc',1)
call SetPlayerTechResearched(Player(0),'Rhfs',1)
call SetPlayerTechResearched(Player(0),'Rhcd',1)
call SetPlayerTechResearched(Player(0),'Rome',3)
call SetPlayerTechResearched(Player(0),'Rora',3)
call SetPlayerTechResearched(Player(0),'Roar',3)
call SetPlayerTechResearched(Player(0),'Rwdm',1)
call SetPlayerTechResearched(Player(0),'Ropg',1)
call SetPlayerTechResearched(Player(0),'Robs',1)
call SetPlayerTechResearched(Player(0),'Rows',1)
call SetPlayerTechResearched(Player(0),'Roen',1)
call SetPlayerTechResearched(Player(0),'Rovs',1)
call SetPlayerTechResearched(Player(0),'Rowd',2)
call SetPlayerTechResearched(Player(0),'Rost',2)
call SetPlayerTechResearched(Player(0),'Rosp',3)
call SetPlayerTechResearched(Player(0),'Rotr',1)
call SetPlayerTechResearched(Player(0),'Rolf',1)
call SetPlayerTechResearched(Player(0),'Rowt',2)
call SetPlayerTechResearched(Player(0),'Rorb',1)
call SetPlayerTechResearched(Player(0),'Robk',1)
call SetPlayerTechResearched(Player(0),'Ropm',1)
call SetPlayerTechResearched(Player(0),'Robf',1)
call SetPlayerTechResearched(Player(0),'Rume',3)
call SetPlayerTechResearched(Player(0),'Rura',3)
call SetPlayerTechResearched(Player(0),'Ruar',3)
call SetPlayerTechResearched(Player(0),'Ruac',1)
call SetPlayerTechResearched(Player(0),'Ruwb',1)
call SetPlayerTechResearched(Player(0),'Rugf',1)
call SetPlayerTechResearched(Player(0),'Rusf',1)
call SetPlayerTechResearched(Player(0),'Rune',2)
call SetPlayerTechResearched(Player(0),'Ruba',2)
call SetPlayerTechResearched(Player(0),'Rufb',1)
call SetPlayerTechResearched(Player(0),'Rusl',1)
call SetPlayerTechResearched(Player(0),'Rucr',3)
call SetPlayerTechResearched(Player(0),'Rupc',1)
call SetPlayerTechResearched(Player(0),'Rusm',1)
call SetPlayerTechResearched(Player(0),'Rubu',1)
call SetPlayerTechResearched(Player(0),'Rusp',1)
call SetPlayerTechResearched(Player(0),'Ruex',1)
call SetPlayerTechResearched(Player(0),'Rupm',1)
call SetPlayerTechResearched(Player(0),'Resm',3)
call SetPlayerTechResearched(Player(0),'Resw',3)
call SetPlayerTechResearched(Player(0),'Rema',3)
call SetPlayerTechResearched(Player(0),'Rerh',3)
call SetPlayerTechResearched(Player(0),'Reuv',1)
call SetPlayerTechResearched(Player(0),'Renb',1)
call SetPlayerTechResearched(Player(0),'Resc',1)
call SetPlayerTechResearched(Player(0),'Remg',1)
call SetPlayerTechResearched(Player(0),'Reib',1)
call SetPlayerTechResearched(Player(0),'Remk',1)
call SetPlayerTechResearched(Player(0),'Redt',2)
call SetPlayerTechResearched(Player(0),'Redc',2)
call SetPlayerTechResearched(Player(0),'Resi',1)
call SetPlayerTechResearched(Player(0),'Recb',1)
call SetPlayerTechResearched(Player(0),'Reht',1)
call SetPlayerTechResearched(Player(0),'Repb',1)
call SetPlayerTechResearched(Player(0),'Rers',1)
call SetPlayerTechResearched(Player(0),'Rehs',1)
call SetPlayerTechResearched(Player(0),'Reeb',1)
call SetPlayerTechResearched(Player(0),'Reec',1)
call SetPlayerTechResearched(Player(0),'Rews',1)
call SetPlayerTechResearched(Player(0),'Repm',1)
call SetPlayerTechResearched(Player(0),'Rnen',1)
call SetPlayerTechResearched(Player(0),'Rnsw',2)
call SetPlayerTechResearched(Player(0),'Rnat',3)
call SetPlayerTechResearched(Player(0),'Rnsi',1)
call SetPlayerTechResearched(Player(0),'Rnam',3)
call SetPlayerTechResearched(Player(0),'Rnsb',1)
call SetPlayerTechResearched(Player(1),'Rhme',3)
call SetPlayerTechResearched(Player(1),'Rhra',3)
call SetPlayerTechResearched(Player(1),'Rhhb',1)
call SetPlayerTechResearched(Player(1),'Rhar',3)
call SetPlayerTechResearched(Player(1),'Rhgb',1)
call SetPlayerTechResearched(Player(1),'Rhac',3)
call SetPlayerTechResearched(Player(1),'Rhde',1)
call SetPlayerTechResearched(Player(1),'Rhan',1)
call SetPlayerTechResearched(Player(1),'Rhpt',2)
call SetPlayerTechResearched(Player(1),'Rhst',2)
call SetPlayerTechResearched(Player(1),'Rhla',3)
call SetPlayerTechResearched(Player(1),'Rhri',1)
call SetPlayerTechResearched(Player(1),'Rhlh',2)
call SetPlayerTechResearched(Player(1),'Rhse',1)
call SetPlayerTechResearched(Player(1),'Rhfl',1)
call SetPlayerTechResearched(Player(1),'Rhss',1)
call SetPlayerTechResearched(Player(1),'Rhrt',1)
call SetPlayerTechResearched(Player(1),'Rhpm',1)
call SetPlayerTechResearched(Player(1),'Rhfc',1)
call SetPlayerTechResearched(Player(1),'Rhfs',1)
call SetPlayerTechResearched(Player(1),'Rhcd',1)
call SetPlayerTechResearched(Player(1),'Rome',3)
call SetPlayerTechResearched(Player(1),'Rora',3)
call SetPlayerTechResearched(Player(1),'Roar',3)
call SetPlayerTechResearched(Player(1),'Rwdm',1)
call SetPlayerTechResearched(Player(1),'Ropg',1)
call SetPlayerTechResearched(Player(1),'Robs',1)
call SetPlayerTechResearched(Player(1),'Rows',1)
call SetPlayerTechResearched(Player(1),'Roen',1)
call SetPlayerTechResearched(Player(1),'Rovs',1)
call SetPlayerTechResearched(Player(1),'Rowd',2)
call SetPlayerTechResearched(Player(1),'Rost',2)
call SetPlayerTechResearched(Player(1),'Rosp',3)
call SetPlayerTechResearched(Player(1),'Rotr',1)
call SetPlayerTechResearched(Player(1),'Rolf',1)
call SetPlayerTechResearched(Player(1),'Rowt',2)
call SetPlayerTechResearched(Player(1),'Rorb',1)
call SetPlayerTechResearched(Player(1),'Robk',1)
call SetPlayerTechResearched(Player(1),'Ropm',1)
call SetPlayerTechResearched(Player(1),'Robf',1)
call SetPlayerTechResearched(Player(1),'Rume',3)
call SetPlayerTechResearched(Player(1),'Rura',3)
call SetPlayerTechResearched(Player(1),'Ruar',3)
call SetPlayerTechResearched(Player(1),'Ruac',1)
call SetPlayerTechResearched(Player(1),'Ruwb',1)
call SetPlayerTechResearched(Player(1),'Rugf',1)
call SetPlayerTechResearched(Player(1),'Rusf',1)
call SetPlayerTechResearched(Player(1),'Rune',2)
call SetPlayerTechResearched(Player(1),'Ruba',2)
call SetPlayerTechResearched(Player(1),'Rufb',1)
call SetPlayerTechResearched(Player(1),'Rusl',1)
call SetPlayerTechResearched(Player(1),'Rucr',3)
call SetPlayerTechResearched(Player(1),'Rupc',1)
call SetPlayerTechResearched(Player(1),'Rusm',1)
call SetPlayerTechResearched(Player(1),'Rubu',1)
call SetPlayerTechResearched(Player(1),'Rusp',1)
call SetPlayerTechResearched(Player(1),'Ruex',1)
call SetPlayerTechResearched(Player(1),'Rupm',1)
call SetPlayerTechResearched(Player(1),'Resm',3)
call SetPlayerTechResearched(Player(1),'Resw',3)
call SetPlayerTechResearched(Player(1),'Rema',3)
call SetPlayerTechResearched(Player(1),'Rerh',3)
call SetPlayerTechResearched(Player(1),'Reuv',1)
call SetPlayerTechResearched(Player(1),'Renb',1)
call SetPlayerTechResearched(Player(1),'Resc',1)
call SetPlayerTechResearched(Player(1),'Remg',1)
call SetPlayerTechResearched(Player(1),'Reib',1)
call SetPlayerTechResearched(Player(1),'Remk',1)
call SetPlayerTechResearched(Player(1),'Redt',2)
call SetPlayerTechResearched(Player(1),'Redc',2)
call SetPlayerTechResearched(Player(1),'Resi',1)
call SetPlayerTechResearched(Player(1),'Recb',1)
call SetPlayerTechResearched(Player(1),'Reht',1)
call SetPlayerTechResearched(Player(1),'Repb',1)
call SetPlayerTechResearched(Player(1),'Rers',1)
call SetPlayerTechResearched(Player(1),'Rehs',1)
call SetPlayerTechResearched(Player(1),'Reeb',1)
call SetPlayerTechResearched(Player(1),'Reec',1)
call SetPlayerTechResearched(Player(1),'Rews',1)
call SetPlayerTechResearched(Player(1),'Repm',1)
call SetPlayerTechResearched(Player(1),'Rnen',1)
call SetPlayerTechResearched(Player(1),'Rnsw',2)
call SetPlayerTechResearched(Player(1),'Rnat',3)
call SetPlayerTechResearched(Player(1),'Rnsi',1)
call SetPlayerTechResearched(Player(1),'Rnam',3)
call SetPlayerTechResearched(Player(1),'Rnsb',1)
call SetPlayerTechResearched(Player(2),'Rhme',3)
call SetPlayerTechResearched(Player(2),'Rhra',3)
call SetPlayerTechResearched(Player(2),'Rhhb',1)
call SetPlayerTechResearched(Player(2),'Rhar',3)
call SetPlayerTechResearched(Player(2),'Rhgb',1)
call SetPlayerTechResearched(Player(2),'Rhac',3)
call SetPlayerTechResearched(Player(2),'Rhde',1)
call SetPlayerTechResearched(Player(2),'Rhan',1)
call SetPlayerTechResearched(Player(2),'Rhpt',2)
call SetPlayerTechResearched(Player(2),'Rhst',2)
call SetPlayerTechResearched(Player(2),'Rhla',3)
call SetPlayerTechResearched(Player(2),'Rhri',1)
call SetPlayerTechResearched(Player(2),'Rhlh',2)
call SetPlayerTechResearched(Player(2),'Rhse',1)
call SetPlayerTechResearched(Player(2),'Rhfl',1)
call SetPlayerTechResearched(Player(2),'Rhss',1)
call SetPlayerTechResearched(Player(2),'Rhrt',1)
call SetPlayerTechResearched(Player(2),'Rhpm',1)
call SetPlayerTechResearched(Player(2),'Rhfc',1)
call SetPlayerTechResearched(Player(2),'Rhfs',1)
call SetPlayerTechResearched(Player(2),'Rhcd',1)
call SetPlayerTechResearched(Player(2),'Rome',3)
call SetPlayerTechResearched(Player(2),'Rora',3)
call SetPlayerTechResearched(Player(2),'Roar',3)
call SetPlayerTechResearched(Player(2),'Rwdm',1)
call SetPlayerTechResearched(Player(2),'Ropg',1)
call SetPlayerTechResearched(Player(2),'Robs',1)
call SetPlayerTechResearched(Player(2),'Rows',1)
call SetPlayerTechResearched(Player(2),'Roen',1)
call SetPlayerTechResearched(Player(2),'Rovs',1)
call SetPlayerTechResearched(Player(2),'Rowd',2)
call SetPlayerTechResearched(Player(2),'Rost',2)
call SetPlayerTechResearched(Player(2),'Rosp',3)
call SetPlayerTechResearched(Player(2),'Rotr',1)
call SetPlayerTechResearched(Player(2),'Rolf',1)
call SetPlayerTechResearched(Player(2),'Rowt',2)
call SetPlayerTechResearched(Player(2),'Rorb',1)
call SetPlayerTechResearched(Player(2),'Robk',1)
call SetPlayerTechResearched(Player(2),'Ropm',1)
call SetPlayerTechResearched(Player(2),'Robf',1)
call SetPlayerTechResearched(Player(2),'Rume',3)
call SetPlayerTechResearched(Player(2),'Rura',3)
call SetPlayerTechResearched(Player(2),'Ruar',3)
call SetPlayerTechResearched(Player(2),'Ruac',1)
call SetPlayerTechResearched(Player(2),'Ruwb',1)
call SetPlayerTechResearched(Player(2),'Rugf',1)
call SetPlayerTechResearched(Player(2),'Rusf',1)
call SetPlayerTechResearched(Player(2),'Rune',2)
call SetPlayerTechResearched(Player(2),'Ruba',2)
call SetPlayerTechResearched(Player(2),'Rufb',1)
call SetPlayerTechResearched(Player(2),'Rusl',1)
call SetPlayerTechResearched(Player(2),'Rucr',3)
call SetPlayerTechResearched(Player(2),'Rupc',1)
call SetPlayerTechResearched(Player(2),'Rusm',1)
call SetPlayerTechResearched(Player(2),'Rubu',1)
call SetPlayerTechResearched(Player(2),'Rusp',1)
call SetPlayerTechResearched(Player(2),'Ruex',1)
call SetPlayerTechResearched(Player(2),'Rupm',1)
call SetPlayerTechResearched(Player(2),'Resm',3)
call SetPlayerTechResearched(Player(2),'Resw',3)
call SetPlayerTechResearched(Player(2),'Rema',3)
call SetPlayerTechResearched(Player(2),'Rerh',3)
call SetPlayerTechResearched(Player(2),'Reuv',1)
call SetPlayerTechResearched(Player(2),'Renb',1)
call SetPlayerTechResearched(Player(2),'Resc',1)
call SetPlayerTechResearched(Player(2),'Remg',1)
call SetPlayerTechResearched(Player(2),'Reib',1)
call SetPlayerTechResearched(Player(2),'Remk',1)
call SetPlayerTechResearched(Player(2),'Redt',2)
call SetPlayerTechResearched(Player(2),'Redc',2)
call SetPlayerTechResearched(Player(2),'Resi',1)
call SetPlayerTechResearched(Player(2),'Recb',1)
call SetPlayerTechResearched(Player(2),'Reht',1)
call SetPlayerTechResearched(Player(2),'Repb',1)
call SetPlayerTechResearched(Player(2),'Rers',1)
call SetPlayerTechResearched(Player(2),'Rehs',1)
call SetPlayerTechResearched(Player(2),'Reeb',1)
call SetPlayerTechResearched(Player(2),'Reec',1)
call SetPlayerTechResearched(Player(2),'Rews',1)
call SetPlayerTechResearched(Player(2),'Repm',1)
call SetPlayerTechResearched(Player(2),'Rnen',1)
call SetPlayerTechResearched(Player(2),'Rnsw',2)
call SetPlayerTechResearched(Player(2),'Rnat',3)
call SetPlayerTechResearched(Player(2),'Rnsi',1)
call SetPlayerTechResearched(Player(2),'Rnam',3)
call SetPlayerTechResearched(Player(2),'Rnsb',1)
call SetPlayerTechResearched(Player(3),'Rhme',3)
call SetPlayerTechResearched(Player(3),'Rhra',3)
call SetPlayerTechResearched(Player(3),'Rhhb',1)
call SetPlayerTechResearched(Player(3),'Rhar',3)
call SetPlayerTechResearched(Player(3),'Rhgb',1)
call SetPlayerTechResearched(Player(3),'Rhac',3)
call SetPlayerTechResearched(Player(3),'Rhde',1)
call SetPlayerTechResearched(Player(3),'Rhan',1)
call SetPlayerTechResearched(Player(3),'Rhpt',2)
call SetPlayerTechResearched(Player(3),'Rhst',2)
call SetPlayerTechResearched(Player(3),'Rhla',3)
call SetPlayerTechResearched(Player(3),'Rhri',1)
call SetPlayerTechResearched(Player(3),'Rhlh',2)
call SetPlayerTechResearched(Player(3),'Rhse',1)
call SetPlayerTechResearched(Player(3),'Rhfl',1)
call SetPlayerTechResearched(Player(3),'Rhss',1)
call SetPlayerTechResearched(Player(3),'Rhrt',1)
call SetPlayerTechResearched(Player(3),'Rhpm',1)
call SetPlayerTechResearched(Player(3),'Rhfc',1)
call SetPlayerTechResearched(Player(3),'Rhfs',1)
call SetPlayerTechResearched(Player(3),'Rhcd',1)
call SetPlayerTechResearched(Player(3),'Rome',3)
call SetPlayerTechResearched(Player(3),'Rora',3)
call SetPlayerTechResearched(Player(3),'Roar',3)
call SetPlayerTechResearched(Player(3),'Rwdm',1)
call SetPlayerTechResearched(Player(3),'Ropg',1)
call SetPlayerTechResearched(Player(3),'Robs',1)
call SetPlayerTechResearched(Player(3),'Rows',1)
call SetPlayerTechResearched(Player(3),'Roen',1)
call SetPlayerTechResearched(Player(3),'Rovs',1)
call SetPlayerTechResearched(Player(3),'Rowd',2)
call SetPlayerTechResearched(Player(3),'Rost',2)
call SetPlayerTechResearched(Player(3),'Rosp',3)
call SetPlayerTechResearched(Player(3),'Rotr',1)
call SetPlayerTechResearched(Player(3),'Rolf',1)
call SetPlayerTechResearched(Player(3),'Rowt',2)
call SetPlayerTechResearched(Player(3),'Rorb',1)
call SetPlayerTechResearched(Player(3),'Robk',1)
call SetPlayerTechResearched(Player(3),'Ropm',1)
call SetPlayerTechResearched(Player(3),'Robf',1)
call SetPlayerTechResearched(Player(3),'Rume',3)
call SetPlayerTechResearched(Player(3),'Rura',3)
call SetPlayerTechResearched(Player(3),'Ruar',3)
call SetPlayerTechResearched(Player(3),'Ruac',1)
call SetPlayerTechResearched(Player(3),'Ruwb',1)
call SetPlayerTechResearched(Player(3),'Rugf',1)
call SetPlayerTechResearched(Player(3),'Rusf',1)
call SetPlayerTechResearched(Player(3),'Rune',2)
call SetPlayerTechResearched(Player(3),'Ruba',2)
call SetPlayerTechResearched(Player(3),'Rufb',1)
call SetPlayerTechResearched(Player(3),'Rusl',1)
call SetPlayerTechResearched(Player(3),'Rucr',3)
call SetPlayerTechResearched(Player(3),'Rupc',1)
call SetPlayerTechResearched(Player(3),'Rusm',1)
call SetPlayerTechResearched(Player(3),'Rubu',1)
call SetPlayerTechResearched(Player(3),'Rusp',1)
call SetPlayerTechResearched(Player(3),'Ruex',1)
call SetPlayerTechResearched(Player(3),'Rupm',1)
call SetPlayerTechResearched(Player(3),'Resm',3)
call SetPlayerTechResearched(Player(3),'Resw',3)
call SetPlayerTechResearched(Player(3),'Rema',3)
call SetPlayerTechResearched(Player(3),'Rerh',3)
call SetPlayerTechResearched(Player(3),'Reuv',1)
call SetPlayerTechResearched(Player(3),'Renb',1)
call SetPlayerTechResearched(Player(3),'Resc',1)
call SetPlayerTechResearched(Player(3),'Remg',1)
call SetPlayerTechResearched(Player(3),'Reib',1)
call SetPlayerTechResearched(Player(3),'Remk',1)
call SetPlayerTechResearched(Player(3),'Redt',2)
call SetPlayerTechResearched(Player(3),'Redc',2)
call SetPlayerTechResearched(Player(3),'Resi',1)
call SetPlayerTechResearched(Player(3),'Recb',1)
call SetPlayerTechResearched(Player(3),'Reht',1)
call SetPlayerTechResearched(Player(3),'Repb',1)
call SetPlayerTechResearched(Player(3),'Rers',1)
call SetPlayerTechResearched(Player(3),'Rehs',1)
call SetPlayerTechResearched(Player(3),'Reeb',1)
call SetPlayerTechResearched(Player(3),'Reec',1)
call SetPlayerTechResearched(Player(3),'Rews',1)
call SetPlayerTechResearched(Player(3),'Repm',1)
call SetPlayerTechResearched(Player(3),'Rnen',1)
call SetPlayerTechResearched(Player(3),'Rnsw',2)
call SetPlayerTechResearched(Player(3),'Rnat',3)
call SetPlayerTechResearched(Player(3),'Rnsi',1)
call SetPlayerTechResearched(Player(3),'Rnam',3)
call SetPlayerTechResearched(Player(3),'Rnsb',1)
call SetPlayerTechResearched(Player(4),'Rhme',3)
call SetPlayerTechResearched(Player(4),'Rhra',3)
call SetPlayerTechResearched(Player(4),'Rhhb',1)
call SetPlayerTechResearched(Player(4),'Rhar',3)
call SetPlayerTechResearched(Player(4),'Rhgb',1)
call SetPlayerTechResearched(Player(4),'Rhac',3)
call SetPlayerTechResearched(Player(4),'Rhde',1)
call SetPlayerTechResearched(Player(4),'Rhan',1)
call SetPlayerTechResearched(Player(4),'Rhpt',2)
call SetPlayerTechResearched(Player(4),'Rhst',2)
call SetPlayerTechResearched(Player(4),'Rhla',3)
call SetPlayerTechResearched(Player(4),'Rhri',1)
call SetPlayerTechResearched(Player(4),'Rhlh',2)
call SetPlayerTechResearched(Player(4),'Rhse',1)
call SetPlayerTechResearched(Player(4),'Rhfl',1)
call SetPlayerTechResearched(Player(4),'Rhss',1)
call SetPlayerTechResearched(Player(4),'Rhrt',1)
call SetPlayerTechResearched(Player(4),'Rhpm',1)
call SetPlayerTechResearched(Player(4),'Rhfc',1)
call SetPlayerTechResearched(Player(4),'Rhfs',1)
call SetPlayerTechResearched(Player(4),'Rhcd',1)
call SetPlayerTechResearched(Player(4),'Rome',3)
call SetPlayerTechResearched(Player(4),'Rora',3)
call SetPlayerTechResearched(Player(4),'Roar',3)
call SetPlayerTechResearched(Player(4),'Rwdm',1)
call SetPlayerTechResearched(Player(4),'Ropg',1)
call SetPlayerTechResearched(Player(4),'Robs',1)
call SetPlayerTechResearched(Player(4),'Rows',1)
call SetPlayerTechResearched(Player(4),'Roen',1)
call SetPlayerTechResearched(Player(4),'Rovs',1)
call SetPlayerTechResearched(Player(4),'Rowd',2)
call SetPlayerTechResearched(Player(4),'Rost',2)
call SetPlayerTechResearched(Player(4),'Rosp',3)
call SetPlayerTechResearched(Player(4),'Rotr',1)
call SetPlayerTechResearched(Player(4),'Rolf',1)
call SetPlayerTechResearched(Player(4),'Rowt',2)
call SetPlayerTechResearched(Player(4),'Rorb',1)
call SetPlayerTechResearched(Player(4),'Robk',1)
call SetPlayerTechResearched(Player(4),'Ropm',1)
call SetPlayerTechResearched(Player(4),'Robf',1)
call SetPlayerTechResearched(Player(4),'Rume',3)
call SetPlayerTechResearched(Player(4),'Rura',3)
call SetPlayerTechResearched(Player(4),'Ruar',3)
call SetPlayerTechResearched(Player(4),'Ruac',1)
call SetPlayerTechResearched(Player(4),'Ruwb',1)
call SetPlayerTechResearched(Player(4),'Rugf',1)
call SetPlayerTechResearched(Player(4),'Rusf',1)
call SetPlayerTechResearched(Player(4),'Rune',2)
call SetPlayerTechResearched(Player(4),'Ruba',2)
call SetPlayerTechResearched(Player(4),'Rufb',1)
call SetPlayerTechResearched(Player(4),'Rusl',1)
call SetPlayerTechResearched(Player(4),'Rucr',3)
call SetPlayerTechResearched(Player(4),'Rupc',1)
call SetPlayerTechResearched(Player(4),'Rusm',1)
call SetPlayerTechResearched(Player(4),'Rubu',1)
call SetPlayerTechResearched(Player(4),'Rusp',1)
call SetPlayerTechResearched(Player(4),'Ruex',1)
call SetPlayerTechResearched(Player(4),'Rupm',1)
call SetPlayerTechResearched(Player(4),'Resm',3)
call SetPlayerTechResearched(Player(4),'Resw',3)
call SetPlayerTechResearched(Player(4),'Rema',3)
call SetPlayerTechResearched(Player(4),'Rerh',3)
call SetPlayerTechResearched(Player(4),'Reuv',1)
call SetPlayerTechResearched(Player(4),'Renb',1)
call SetPlayerTechResearched(Player(4),'Resc',1)
call SetPlayerTechResearched(Player(4),'Remg',1)
call SetPlayerTechResearched(Player(4),'Reib',1)
call SetPlayerTechResearched(Player(4),'Remk',1)
call SetPlayerTechResearched(Player(4),'Redt',2)
call SetPlayerTechResearched(Player(4),'Redc',2)
call SetPlayerTechResearched(Player(4),'Resi',1)
call SetPlayerTechResearched(Player(4),'Recb',1)
call SetPlayerTechResearched(Player(4),'Reht',1)
call SetPlayerTechResearched(Player(4),'Repb',1)
call SetPlayerTechResearched(Player(4),'Rers',1)
call SetPlayerTechResearched(Player(4),'Rehs',1)
call SetPlayerTechResearched(Player(4),'Reeb',1)
call SetPlayerTechResearched(Player(4),'Reec',1)
call SetPlayerTechResearched(Player(4),'Rews',1)
call SetPlayerTechResearched(Player(4),'Repm',1)
call SetPlayerTechResearched(Player(4),'Rnen',1)
call SetPlayerTechResearched(Player(4),'Rnsw',2)
call SetPlayerTechResearched(Player(4),'Rnat',3)
call SetPlayerTechResearched(Player(4),'Rnsi',1)
call SetPlayerTechResearched(Player(4),'Rnam',3)
call SetPlayerTechResearched(Player(4),'Rnsb',1)
call SetPlayerTechResearched(Player(5),'Rhme',3)
call SetPlayerTechResearched(Player(5),'Rhra',3)
call SetPlayerTechResearched(Player(5),'Rhhb',1)
call SetPlayerTechResearched(Player(5),'Rhar',3)
call SetPlayerTechResearched(Player(5),'Rhgb',1)
call SetPlayerTechResearched(Player(5),'Rhac',3)
call SetPlayerTechResearched(Player(5),'Rhde',1)
call SetPlayerTechResearched(Player(5),'Rhan',1)
call SetPlayerTechResearched(Player(5),'Rhpt',2)
call SetPlayerTechResearched(Player(5),'Rhst',2)
call SetPlayerTechResearched(Player(5),'Rhla',3)
call SetPlayerTechResearched(Player(5),'Rhri',1)
call SetPlayerTechResearched(Player(5),'Rhlh',2)
call SetPlayerTechResearched(Player(5),'Rhse',1)
call SetPlayerTechResearched(Player(5),'Rhfl',1)
call SetPlayerTechResearched(Player(5),'Rhss',1)
call SetPlayerTechResearched(Player(5),'Rhrt',1)
call SetPlayerTechResearched(Player(5),'Rhpm',1)
call SetPlayerTechResearched(Player(5),'Rhfc',1)
call SetPlayerTechResearched(Player(5),'Rhfs',1)
call SetPlayerTechResearched(Player(5),'Rhcd',1)
call SetPlayerTechResearched(Player(5),'Rome',3)
call SetPlayerTechResearched(Player(5),'Rora',3)
call SetPlayerTechResearched(Player(5),'Roar',3)
call SetPlayerTechResearched(Player(5),'Rwdm',1)
call SetPlayerTechResearched(Player(5),'Ropg',1)
call SetPlayerTechResearched(Player(5),'Robs',1)
call SetPlayerTechResearched(Player(5),'Rows',1)
call SetPlayerTechResearched(Player(5),'Roen',1)
call SetPlayerTechResearched(Player(5),'Rovs',1)
call SetPlayerTechResearched(Player(5),'Rowd',2)
call SetPlayerTechResearched(Player(5),'Rost',2)
call SetPlayerTechResearched(Player(5),'Rosp',3)
call SetPlayerTechResearched(Player(5),'Rotr',1)
call SetPlayerTechResearched(Player(5),'Rolf',1)
call SetPlayerTechResearched(Player(5),'Rowt',2)
call SetPlayerTechResearched(Player(5),'Rorb',1)
call SetPlayerTechResearched(Player(5),'Robk',1)
call SetPlayerTechResearched(Player(5),'Ropm',1)
call SetPlayerTechResearched(Player(5),'Robf',1)
call SetPlayerTechResearched(Player(5),'Rume',3)
call SetPlayerTechResearched(Player(5),'Rura',3)
call SetPlayerTechResearched(Player(5),'Ruar',3)
call SetPlayerTechResearched(Player(5),'Ruac',1)
call SetPlayerTechResearched(Player(5),'Ruwb',1)
call SetPlayerTechResearched(Player(5),'Rugf',1)
call SetPlayerTechResearched(Player(5),'Rusf',1)
call SetPlayerTechResearched(Player(5),'Rune',2)
call SetPlayerTechResearched(Player(5),'Ruba',2)
call SetPlayerTechResearched(Player(5),'Rufb',1)
call SetPlayerTechResearched(Player(5),'Rusl',1)
call SetPlayerTechResearched(Player(5),'Rucr',3)
call SetPlayerTechResearched(Player(5),'Rupc',1)
call SetPlayerTechResearched(Player(5),'Rusm',1)
call SetPlayerTechResearched(Player(5),'Rubu',1)
call SetPlayerTechResearched(Player(5),'Rusp',1)
call SetPlayerTechResearched(Player(5),'Ruex',1)
call SetPlayerTechResearched(Player(5),'Rupm',1)
call SetPlayerTechResearched(Player(5),'Resm',3)
call SetPlayerTechResearched(Player(5),'Resw',3)
call SetPlayerTechResearched(Player(5),'Rema',3)
call SetPlayerTechResearched(Player(5),'Rerh',3)
call SetPlayerTechResearched(Player(5),'Reuv',1)
call SetPlayerTechResearched(Player(5),'Renb',1)
call SetPlayerTechResearched(Player(5),'Resc',1)
call SetPlayerTechResearched(Player(5),'Remg',1)
call SetPlayerTechResearched(Player(5),'Reib',1)
call SetPlayerTechResearched(Player(5),'Remk',1)
call SetPlayerTechResearched(Player(5),'Redt',2)
call SetPlayerTechResearched(Player(5),'Redc',2)
call SetPlayerTechResearched(Player(5),'Resi',1)
call SetPlayerTechResearched(Player(5),'Recb',1)
call SetPlayerTechResearched(Player(5),'Reht',1)
call SetPlayerTechResearched(Player(5),'Repb',1)
call SetPlayerTechResearched(Player(5),'Rers',1)
call SetPlayerTechResearched(Player(5),'Rehs',1)
call SetPlayerTechResearched(Player(5),'Reeb',1)
call SetPlayerTechResearched(Player(5),'Reec',1)
call SetPlayerTechResearched(Player(5),'Rews',1)
call SetPlayerTechResearched(Player(5),'Repm',1)
call SetPlayerTechResearched(Player(5),'Rnen',1)
call SetPlayerTechResearched(Player(5),'Rnsw',2)
call SetPlayerTechResearched(Player(5),'Rnat',3)
call SetPlayerTechResearched(Player(5),'Rnsi',1)
call SetPlayerTechResearched(Player(5),'Rnam',3)
call SetPlayerTechResearched(Player(5),'Rnsb',1)
call SetPlayerTechResearched(Player(6),'Rhme',3)
call SetPlayerTechResearched(Player(6),'Rhra',3)
call SetPlayerTechResearched(Player(6),'Rhhb',1)
call SetPlayerTechResearched(Player(6),'Rhar',3)
call SetPlayerTechResearched(Player(6),'Rhgb',1)
call SetPlayerTechResearched(Player(6),'Rhac',3)
call SetPlayerTechResearched(Player(6),'Rhde',1)
call SetPlayerTechResearched(Player(6),'Rhan',1)
call SetPlayerTechResearched(Player(6),'Rhpt',2)
call SetPlayerTechResearched(Player(6),'Rhst',2)
call SetPlayerTechResearched(Player(6),'Rhla',3)
call SetPlayerTechResearched(Player(6),'Rhri',1)
call SetPlayerTechResearched(Player(6),'Rhlh',2)
call SetPlayerTechResearched(Player(6),'Rhse',1)
call SetPlayerTechResearched(Player(6),'Rhfl',1)
call SetPlayerTechResearched(Player(6),'Rhss',1)
call SetPlayerTechResearched(Player(6),'Rhrt',1)
call SetPlayerTechResearched(Player(6),'Rhpm',1)
call SetPlayerTechResearched(Player(6),'Rhfc',1)
call SetPlayerTechResearched(Player(6),'Rhfs',1)
call SetPlayerTechResearched(Player(6),'Rhcd',1)
call SetPlayerTechResearched(Player(6),'Rome',3)
call SetPlayerTechResearched(Player(6),'Rora',3)
call SetPlayerTechResearched(Player(6),'Roar',3)
call SetPlayerTechResearched(Player(6),'Rwdm',1)
call SetPlayerTechResearched(Player(6),'Ropg',1)
call SetPlayerTechResearched(Player(6),'Robs',1)
call SetPlayerTechResearched(Player(6),'Rows',1)
call SetPlayerTechResearched(Player(6),'Roen',1)
call SetPlayerTechResearched(Player(6),'Rovs',1)
call SetPlayerTechResearched(Player(6),'Rowd',2)
call SetPlayerTechResearched(Player(6),'Rost',2)
call SetPlayerTechResearched(Player(6),'Rosp',3)
call SetPlayerTechResearched(Player(6),'Rotr',1)
call SetPlayerTechResearched(Player(6),'Rolf',1)
call SetPlayerTechResearched(Player(6),'Rowt',2)
call SetPlayerTechResearched(Player(6),'Rorb',1)
call SetPlayerTechResearched(Player(6),'Robk',1)
call SetPlayerTechResearched(Player(6),'Ropm',1)
call SetPlayerTechResearched(Player(6),'Robf',1)
call SetPlayerTechResearched(Player(6),'Rume',3)
call SetPlayerTechResearched(Player(6),'Rura',3)
call SetPlayerTechResearched(Player(6),'Ruar',3)
call SetPlayerTechResearched(Player(6),'Ruac',1)
call SetPlayerTechResearched(Player(6),'Ruwb',1)
call SetPlayerTechResearched(Player(6),'Rugf',1)
call SetPlayerTechResearched(Player(6),'Rusf',1)
call SetPlayerTechResearched(Player(6),'Rune',2)
call SetPlayerTechResearched(Player(6),'Ruba',2)
call SetPlayerTechResearched(Player(6),'Rufb',1)
call SetPlayerTechResearched(Player(6),'Rusl',1)
call SetPlayerTechResearched(Player(6),'Rucr',3)
call SetPlayerTechResearched(Player(6),'Rupc',1)
call SetPlayerTechResearched(Player(6),'Rusm',1)
call SetPlayerTechResearched(Player(6),'Rubu',1)
call SetPlayerTechResearched(Player(6),'Rusp',1)
call SetPlayerTechResearched(Player(6),'Ruex',1)
call SetPlayerTechResearched(Player(6),'Rupm',1)
call SetPlayerTechResearched(Player(6),'Resm',3)
call SetPlayerTechResearched(Player(6),'Resw',3)
call SetPlayerTechResearched(Player(6),'Rema',3)
call SetPlayerTechResearched(Player(6),'Rerh',3)
call SetPlayerTechResearched(Player(6),'Reuv',1)
call SetPlayerTechResearched(Player(6),'Renb',1)
call SetPlayerTechResearched(Player(6),'Resc',1)
call SetPlayerTechResearched(Player(6),'Remg',1)
call SetPlayerTechResearched(Player(6),'Reib',1)
call SetPlayerTechResearched(Player(6),'Remk',1)
call SetPlayerTechResearched(Player(6),'Redt',2)
call SetPlayerTechResearched(Player(6),'Redc',2)
call SetPlayerTechResearched(Player(6),'Resi',1)
call SetPlayerTechResearched(Player(6),'Recb',1)
call SetPlayerTechResearched(Player(6),'Reht',1)
call SetPlayerTechResearched(Player(6),'Repb',1)
call SetPlayerTechResearched(Player(6),'Rers',1)
call SetPlayerTechResearched(Player(6),'Rehs',1)
call SetPlayerTechResearched(Player(6),'Reeb',1)
call SetPlayerTechResearched(Player(6),'Reec',1)
call SetPlayerTechResearched(Player(6),'Rews',1)
call SetPlayerTechResearched(Player(6),'Repm',1)
call SetPlayerTechResearched(Player(6),'Rnen',1)
call SetPlayerTechResearched(Player(6),'Rnsw',2)
call SetPlayerTechResearched(Player(6),'Rnat',3)
call SetPlayerTechResearched(Player(6),'Rnsi',1)
call SetPlayerTechResearched(Player(6),'Rnam',3)
call SetPlayerTechResearched(Player(6),'Rnsb',1)
call SetPlayerTechResearched(Player(7),'Rhme',3)
call SetPlayerTechResearched(Player(7),'Rhra',3)
call SetPlayerTechResearched(Player(7),'Rhhb',1)
call SetPlayerTechResearched(Player(7),'Rhar',3)
call SetPlayerTechResearched(Player(7),'Rhgb',1)
call SetPlayerTechResearched(Player(7),'Rhac',3)
call SetPlayerTechResearched(Player(7),'Rhde',1)
call SetPlayerTechResearched(Player(7),'Rhan',1)
call SetPlayerTechResearched(Player(7),'Rhpt',2)
call SetPlayerTechResearched(Player(7),'Rhst',2)
call SetPlayerTechResearched(Player(7),'Rhla',3)
call SetPlayerTechResearched(Player(7),'Rhri',1)
call SetPlayerTechResearched(Player(7),'Rhlh',2)
call SetPlayerTechResearched(Player(7),'Rhse',1)
call SetPlayerTechResearched(Player(7),'Rhfl',1)
call SetPlayerTechResearched(Player(7),'Rhss',1)
call SetPlayerTechResearched(Player(7),'Rhrt',1)
call SetPlayerTechResearched(Player(7),'Rhpm',1)
call SetPlayerTechResearched(Player(7),'Rhfc',1)
call SetPlayerTechResearched(Player(7),'Rhfs',1)
call SetPlayerTechResearched(Player(7),'Rhcd',1)
call SetPlayerTechResearched(Player(7),'Rome',3)
call SetPlayerTechResearched(Player(7),'Rora',3)
call SetPlayerTechResearched(Player(7),'Roar',3)
call SetPlayerTechResearched(Player(7),'Rwdm',1)
call SetPlayerTechResearched(Player(7),'Ropg',1)
call SetPlayerTechResearched(Player(7),'Robs',1)
call SetPlayerTechResearched(Player(7),'Rows',1)
call SetPlayerTechResearched(Player(7),'Roen',1)
call SetPlayerTechResearched(Player(7),'Rovs',1)
call SetPlayerTechResearched(Player(7),'Rowd',2)
call SetPlayerTechResearched(Player(7),'Rost',2)
call SetPlayerTechResearched(Player(7),'Rosp',3)
call SetPlayerTechResearched(Player(7),'Rotr',1)
call SetPlayerTechResearched(Player(7),'Rolf',1)
call SetPlayerTechResearched(Player(7),'Rowt',2)
call SetPlayerTechResearched(Player(7),'Rorb',1)
call SetPlayerTechResearched(Player(7),'Robk',1)
call SetPlayerTechResearched(Player(7),'Ropm',1)
call SetPlayerTechResearched(Player(7),'Robf',1)
call SetPlayerTechResearched(Player(7),'Rume',3)
call SetPlayerTechResearched(Player(7),'Rura',3)
call SetPlayerTechResearched(Player(7),'Ruar',3)
call SetPlayerTechResearched(Player(7),'Ruac',1)
call SetPlayerTechResearched(Player(7),'Ruwb',1)
call SetPlayerTechResearched(Player(7),'Rugf',1)
call SetPlayerTechResearched(Player(7),'Rusf',1)
call SetPlayerTechResearched(Player(7),'Rune',2)
call SetPlayerTechResearched(Player(7),'Ruba',2)
call SetPlayerTechResearched(Player(7),'Rufb',1)
call SetPlayerTechResearched(Player(7),'Rusl',1)
call SetPlayerTechResearched(Player(7),'Rucr',3)
call SetPlayerTechResearched(Player(7),'Rupc',1)
call SetPlayerTechResearched(Player(7),'Rusm',1)
call SetPlayerTechResearched(Player(7),'Rubu',1)
call SetPlayerTechResearched(Player(7),'Rusp',1)
call SetPlayerTechResearched(Player(7),'Ruex',1)
call SetPlayerTechResearched(Player(7),'Rupm',1)
call SetPlayerTechResearched(Player(7),'Resm',3)
call SetPlayerTechResearched(Player(7),'Resw',3)
call SetPlayerTechResearched(Player(7),'Rema',3)
call SetPlayerTechResearched(Player(7),'Rerh',3)
call SetPlayerTechResearched(Player(7),'Reuv',1)
call SetPlayerTechResearched(Player(7),'Renb',1)
call SetPlayerTechResearched(Player(7),'Resc',1)
call SetPlayerTechResearched(Player(7),'Remg',1)
call SetPlayerTechResearched(Player(7),'Reib',1)
call SetPlayerTechResearched(Player(7),'Remk',1)
call SetPlayerTechResearched(Player(7),'Redt',2)
call SetPlayerTechResearched(Player(7),'Redc',2)
call SetPlayerTechResearched(Player(7),'Resi',1)
call SetPlayerTechResearched(Player(7),'Recb',1)
call SetPlayerTechResearched(Player(7),'Reht',1)
call SetPlayerTechResearched(Player(7),'Repb',1)
call SetPlayerTechResearched(Player(7),'Rers',1)
call SetPlayerTechResearched(Player(7),'Rehs',1)
call SetPlayerTechResearched(Player(7),'Reeb',1)
call SetPlayerTechResearched(Player(7),'Reec',1)
call SetPlayerTechResearched(Player(7),'Rews',1)
call SetPlayerTechResearched(Player(7),'Repm',1)
call SetPlayerTechResearched(Player(7),'Rnen',1)
call SetPlayerTechResearched(Player(7),'Rnsw',2)
call SetPlayerTechResearched(Player(7),'Rnat',3)
call SetPlayerTechResearched(Player(7),'Rnsi',1)
call SetPlayerTechResearched(Player(7),'Rnam',3)
call SetPlayerTechResearched(Player(7),'Rnsb',1)
call SetPlayerTechResearched(Player(8),'Rhme',3)
call SetPlayerTechResearched(Player(8),'Rhra',3)
call SetPlayerTechResearched(Player(8),'Rhhb',1)
call SetPlayerTechResearched(Player(8),'Rhar',3)
call SetPlayerTechResearched(Player(8),'Rhgb',1)
call SetPlayerTechResearched(Player(8),'Rhac',3)
call SetPlayerTechResearched(Player(8),'Rhde',1)
call SetPlayerTechResearched(Player(8),'Rhan',1)
call SetPlayerTechResearched(Player(8),'Rhpt',2)
call SetPlayerTechResearched(Player(8),'Rhst',2)
call SetPlayerTechResearched(Player(8),'Rhla',3)
call SetPlayerTechResearched(Player(8),'Rhri',1)
call SetPlayerTechResearched(Player(8),'Rhlh',2)
call SetPlayerTechResearched(Player(8),'Rhse',1)
call SetPlayerTechResearched(Player(8),'Rhfl',1)
call SetPlayerTechResearched(Player(8),'Rhss',1)
call SetPlayerTechResearched(Player(8),'Rhrt',1)
call SetPlayerTechResearched(Player(8),'Rhpm',1)
call SetPlayerTechResearched(Player(8),'Rhfc',1)
call SetPlayerTechResearched(Player(8),'Rhfs',1)
call SetPlayerTechResearched(Player(8),'Rhcd',1)
call SetPlayerTechResearched(Player(8),'Rome',3)
call SetPlayerTechResearched(Player(8),'Rora',3)
call SetPlayerTechResearched(Player(8),'Roar',3)
call SetPlayerTechResearched(Player(8),'Rwdm',1)
call SetPlayerTechResearched(Player(8),'Ropg',1)
call SetPlayerTechResearched(Player(8),'Robs',1)
call SetPlayerTechResearched(Player(8),'Rows',1)
call SetPlayerTechResearched(Player(8),'Roen',1)
call SetPlayerTechResearched(Player(8),'Rovs',1)
call SetPlayerTechResearched(Player(8),'Rowd',2)
call SetPlayerTechResearched(Player(8),'Rost',2)
call SetPlayerTechResearched(Player(8),'Rosp',3)
call SetPlayerTechResearched(Player(8),'Rotr',1)
call SetPlayerTechResearched(Player(8),'Rolf',1)
call SetPlayerTechResearched(Player(8),'Rowt',2)
call SetPlayerTechResearched(Player(8),'Rorb',1)
call SetPlayerTechResearched(Player(8),'Robk',1)
call SetPlayerTechResearched(Player(8),'Ropm',1)
call SetPlayerTechResearched(Player(8),'Robf',1)
call SetPlayerTechResearched(Player(8),'Rume',3)
call SetPlayerTechResearched(Player(8),'Rura',3)
call SetPlayerTechResearched(Player(8),'Ruar',3)
call SetPlayerTechResearched(Player(8),'Ruac',1)
call SetPlayerTechResearched(Player(8),'Ruwb',1)
call SetPlayerTechResearched(Player(8),'Rugf',1)
call SetPlayerTechResearched(Player(8),'Rusf',1)
call SetPlayerTechResearched(Player(8),'Rune',2)
call SetPlayerTechResearched(Player(8),'Ruba',2)
call SetPlayerTechResearched(Player(8),'Rufb',1)
call SetPlayerTechResearched(Player(8),'Rusl',1)
call SetPlayerTechResearched(Player(8),'Rucr',3)
call SetPlayerTechResearched(Player(8),'Rupc',1)
call SetPlayerTechResearched(Player(8),'Rusm',1)
call SetPlayerTechResearched(Player(8),'Rubu',1)
call SetPlayerTechResearched(Player(8),'Rusp',1)
call SetPlayerTechResearched(Player(8),'Ruex',1)
call SetPlayerTechResearched(Player(8),'Rupm',1)
call SetPlayerTechResearched(Player(8),'Resm',3)
call SetPlayerTechResearched(Player(8),'Resw',3)
call SetPlayerTechResearched(Player(8),'Rema',3)
call SetPlayerTechResearched(Player(8),'Rerh',3)
call SetPlayerTechResearched(Player(8),'Reuv',1)
call SetPlayerTechResearched(Player(8),'Renb',1)
call SetPlayerTechResearched(Player(8),'Resc',1)
call SetPlayerTechResearched(Player(8),'Remg',1)
call SetPlayerTechResearched(Player(8),'Reib',1)
call SetPlayerTechResearched(Player(8),'Remk',1)
call SetPlayerTechResearched(Player(8),'Redt',2)
call SetPlayerTechResearched(Player(8),'Redc',2)
call SetPlayerTechResearched(Player(8),'Resi',1)
call SetPlayerTechResearched(Player(8),'Recb',1)
call SetPlayerTechResearched(Player(8),'Reht',1)
call SetPlayerTechResearched(Player(8),'Repb',1)
call SetPlayerTechResearched(Player(8),'Rers',1)
call SetPlayerTechResearched(Player(8),'Rehs',1)
call SetPlayerTechResearched(Player(8),'Reeb',1)
call SetPlayerTechResearched(Player(8),'Reec',1)
call SetPlayerTechResearched(Player(8),'Rews',1)
call SetPlayerTechResearched(Player(8),'Repm',1)
call SetPlayerTechResearched(Player(8),'Rnen',1)
call SetPlayerTechResearched(Player(8),'Rnsw',2)
call SetPlayerTechResearched(Player(8),'Rnat',3)
call SetPlayerTechResearched(Player(8),'Rnsi',1)
call SetPlayerTechResearched(Player(8),'Rnam',3)
call SetPlayerTechResearched(Player(8),'Rnsb',1)
call SetPlayerTechResearched(Player(9),'Rhme',3)
call SetPlayerTechResearched(Player(9),'Rhra',3)
call SetPlayerTechResearched(Player(9),'Rhhb',1)
call SetPlayerTechResearched(Player(9),'Rhar',3)
call SetPlayerTechResearched(Player(9),'Rhgb',1)
call SetPlayerTechResearched(Player(9),'Rhac',3)
call SetPlayerTechResearched(Player(9),'Rhde',1)
call SetPlayerTechResearched(Player(9),'Rhan',1)
call SetPlayerTechResearched(Player(9),'Rhpt',2)
call SetPlayerTechResearched(Player(9),'Rhst',2)
call SetPlayerTechResearched(Player(9),'Rhla',3)
call SetPlayerTechResearched(Player(9),'Rhri',1)
call SetPlayerTechResearched(Player(9),'Rhlh',2)
call SetPlayerTechResearched(Player(9),'Rhse',1)
call SetPlayerTechResearched(Player(9),'Rhfl',1)
call SetPlayerTechResearched(Player(9),'Rhss',1)
call SetPlayerTechResearched(Player(9),'Rhrt',1)
call SetPlayerTechResearched(Player(9),'Rhpm',1)
call SetPlayerTechResearched(Player(9),'Rhfc',1)
call SetPlayerTechResearched(Player(9),'Rhfs',1)
call SetPlayerTechResearched(Player(9),'Rhcd',1)
call SetPlayerTechResearched(Player(9),'Rome',3)
call SetPlayerTechResearched(Player(9),'Rora',3)
call SetPlayerTechResearched(Player(9),'Roar',3)
call SetPlayerTechResearched(Player(9),'Rwdm',1)
call SetPlayerTechResearched(Player(9),'Ropg',1)
call SetPlayerTechResearched(Player(9),'Robs',1)
call SetPlayerTechResearched(Player(9),'Rows',1)
call SetPlayerTechResearched(Player(9),'Roen',1)
call SetPlayerTechResearched(Player(9),'Rovs',1)
call SetPlayerTechResearched(Player(9),'Rowd',2)
call SetPlayerTechResearched(Player(9),'Rost',2)
call SetPlayerTechResearched(Player(9),'Rosp',3)
call SetPlayerTechResearched(Player(9),'Rotr',1)
call SetPlayerTechResearched(Player(9),'Rolf',1)
call SetPlayerTechResearched(Player(9),'Rowt',2)
call SetPlayerTechResearched(Player(9),'Rorb',1)
call SetPlayerTechResearched(Player(9),'Robk',1)
call SetPlayerTechResearched(Player(9),'Ropm',1)
call SetPlayerTechResearched(Player(9),'Robf',1)
call SetPlayerTechResearched(Player(9),'Rume',3)
call SetPlayerTechResearched(Player(9),'Rura',3)
call SetPlayerTechResearched(Player(9),'Ruar',3)
call SetPlayerTechResearched(Player(9),'Ruac',1)
call SetPlayerTechResearched(Player(9),'Ruwb',1)
call SetPlayerTechResearched(Player(9),'Rugf',1)
call SetPlayerTechResearched(Player(9),'Rusf',1)
call SetPlayerTechResearched(Player(9),'Rune',2)
call SetPlayerTechResearched(Player(9),'Ruba',2)
call SetPlayerTechResearched(Player(9),'Rufb',1)
call SetPlayerTechResearched(Player(9),'Rusl',1)
call SetPlayerTechResearched(Player(9),'Rucr',3)
call SetPlayerTechResearched(Player(9),'Rupc',1)
call SetPlayerTechResearched(Player(9),'Rusm',1)
call SetPlayerTechResearched(Player(9),'Rubu',1)
call SetPlayerTechResearched(Player(9),'Rusp',1)
call SetPlayerTechResearched(Player(9),'Ruex',1)
call SetPlayerTechResearched(Player(9),'Rupm',1)
call SetPlayerTechResearched(Player(9),'Resm',3)
call SetPlayerTechResearched(Player(9),'Resw',3)
call SetPlayerTechResearched(Player(9),'Rema',3)
call SetPlayerTechResearched(Player(9),'Rerh',3)
call SetPlayerTechResearched(Player(9),'Reuv',1)
call SetPlayerTechResearched(Player(9),'Renb',1)
call SetPlayerTechResearched(Player(9),'Resc',1)
call SetPlayerTechResearched(Player(9),'Remg',1)
call SetPlayerTechResearched(Player(9),'Reib',1)
call SetPlayerTechResearched(Player(9),'Remk',1)
call SetPlayerTechResearched(Player(9),'Redt',2)
call SetPlayerTechResearched(Player(9),'Redc',2)
call SetPlayerTechResearched(Player(9),'Resi',1)
call SetPlayerTechResearched(Player(9),'Recb',1)
call SetPlayerTechResearched(Player(9),'Reht',1)
call SetPlayerTechResearched(Player(9),'Repb',1)
call SetPlayerTechResearched(Player(9),'Rers',1)
call SetPlayerTechResearched(Player(9),'Rehs',1)
call SetPlayerTechResearched(Player(9),'Reeb',1)
call SetPlayerTechResearched(Player(9),'Reec',1)
call SetPlayerTechResearched(Player(9),'Rews',1)
call SetPlayerTechResearched(Player(9),'Repm',1)
call SetPlayerTechResearched(Player(9),'Rnen',1)
call SetPlayerTechResearched(Player(9),'Rnsw',2)
call SetPlayerTechResearched(Player(9),'Rnat',3)
call SetPlayerTechResearched(Player(9),'Rnsi',1)
call SetPlayerTechResearched(Player(9),'Rnam',3)
call SetPlayerTechResearched(Player(9),'Rnsb',1)
call SetPlayerTechResearched(Player($A),'Rhme',3)
call SetPlayerTechResearched(Player($A),'Rhra',3)
call SetPlayerTechResearched(Player($A),'Rhhb',1)
call SetPlayerTechResearched(Player($A),'Rhar',3)
call SetPlayerTechResearched(Player($A),'Rhgb',1)
call SetPlayerTechResearched(Player($A),'Rhac',3)
call SetPlayerTechResearched(Player($A),'Rhde',1)
call SetPlayerTechResearched(Player($A),'Rhan',1)
call SetPlayerTechResearched(Player($A),'Rhpt',2)
call SetPlayerTechResearched(Player($A),'Rhst',2)
call SetPlayerTechResearched(Player($A),'Rhla',3)
call SetPlayerTechResearched(Player($A),'Rhri',1)
call SetPlayerTechResearched(Player($A),'Rhlh',2)
call SetPlayerTechResearched(Player($A),'Rhse',1)
call SetPlayerTechResearched(Player($A),'Rhfl',1)
call SetPlayerTechResearched(Player($A),'Rhss',1)
call SetPlayerTechResearched(Player($A),'Rhrt',1)
call SetPlayerTechResearched(Player($A),'Rhpm',1)
call SetPlayerTechResearched(Player($A),'Rhfc',1)
call SetPlayerTechResearched(Player($A),'Rhfs',1)
call SetPlayerTechResearched(Player($A),'Rhcd',1)
call SetPlayerTechResearched(Player($A),'Rome',3)
call SetPlayerTechResearched(Player($A),'Rora',3)
call SetPlayerTechResearched(Player($A),'Roar',3)
call SetPlayerTechResearched(Player($A),'Rwdm',1)
call SetPlayerTechResearched(Player($A),'Ropg',1)
call SetPlayerTechResearched(Player($A),'Robs',1)
call SetPlayerTechResearched(Player($A),'Rows',1)
call SetPlayerTechResearched(Player($A),'Roen',1)
call SetPlayerTechResearched(Player($A),'Rovs',1)
call SetPlayerTechResearched(Player($A),'Rowd',2)
call SetPlayerTechResearched(Player($A),'Rost',2)
call SetPlayerTechResearched(Player($A),'Rosp',3)
call SetPlayerTechResearched(Player($A),'Rotr',1)
call SetPlayerTechResearched(Player($A),'Rolf',1)
call SetPlayerTechResearched(Player($A),'Rowt',2)
call SetPlayerTechResearched(Player($A),'Rorb',1)
call SetPlayerTechResearched(Player($A),'Robk',1)
call SetPlayerTechResearched(Player($A),'Ropm',1)
call SetPlayerTechResearched(Player($A),'Robf',1)
call SetPlayerTechResearched(Player($A),'Rume',3)
call SetPlayerTechResearched(Player($A),'Rura',3)
call SetPlayerTechResearched(Player($A),'Ruar',3)
call SetPlayerTechResearched(Player($A),'Ruac',1)
call SetPlayerTechResearched(Player($A),'Ruwb',1)
call SetPlayerTechResearched(Player($A),'Rugf',1)
call SetPlayerTechResearched(Player($A),'Rusf',1)
call SetPlayerTechResearched(Player($A),'Rune',2)
call SetPlayerTechResearched(Player($A),'Ruba',2)
call SetPlayerTechResearched(Player($A),'Rufb',1)
call SetPlayerTechResearched(Player($A),'Rusl',1)
call SetPlayerTechResearched(Player($A),'Rucr',3)
call SetPlayerTechResearched(Player($A),'Rupc',1)
call SetPlayerTechResearched(Player($A),'Rusm',1)
call SetPlayerTechResearched(Player($A),'Rubu',1)
call SetPlayerTechResearched(Player($A),'Rusp',1)
call SetPlayerTechResearched(Player($A),'Ruex',1)
call SetPlayerTechResearched(Player($A),'Rupm',1)
call SetPlayerTechResearched(Player($A),'Resm',3)
call SetPlayerTechResearched(Player($A),'Resw',3)
call SetPlayerTechResearched(Player($A),'Rema',3)
call SetPlayerTechResearched(Player($A),'Rerh',3)
call SetPlayerTechResearched(Player($A),'Reuv',1)
call SetPlayerTechResearched(Player($A),'Renb',1)
call SetPlayerTechResearched(Player($A),'Resc',1)
call SetPlayerTechResearched(Player($A),'Remg',1)
call SetPlayerTechResearched(Player($A),'Reib',1)
call SetPlayerTechResearched(Player($A),'Remk',1)
call SetPlayerTechResearched(Player($A),'Redt',2)
call SetPlayerTechResearched(Player($A),'Redc',2)
call SetPlayerTechResearched(Player($A),'Resi',1)
call SetPlayerTechResearched(Player($A),'Recb',1)
call SetPlayerTechResearched(Player($A),'Reht',1)
call SetPlayerTechResearched(Player($A),'Repb',1)
call SetPlayerTechResearched(Player($A),'Rers',1)
call SetPlayerTechResearched(Player($A),'Rehs',1)
call SetPlayerTechResearched(Player($A),'Reeb',1)
call SetPlayerTechResearched(Player($A),'Reec',1)
call SetPlayerTechResearched(Player($A),'Rews',1)
call SetPlayerTechResearched(Player($A),'Repm',1)
call SetPlayerTechResearched(Player($A),'Rnen',1)
call SetPlayerTechResearched(Player($A),'Rnsw',2)
call SetPlayerTechResearched(Player($A),'Rnat',3)
call SetPlayerTechResearched(Player($A),'Rnsi',1)
call SetPlayerTechResearched(Player($A),'Rnam',3)
call SetPlayerTechResearched(Player($A),'Rnsb',1)
call SetPlayerTechResearched(Player($B),'Rhme',3)
call SetPlayerTechResearched(Player($B),'Rhra',3)
call SetPlayerTechResearched(Player($B),'Rhhb',1)
call SetPlayerTechResearched(Player($B),'Rhar',3)
call SetPlayerTechResearched(Player($B),'Rhgb',1)
call SetPlayerTechResearched(Player($B),'Rhac',3)
call SetPlayerTechResearched(Player($B),'Rhde',1)
call SetPlayerTechResearched(Player($B),'Rhan',1)
call SetPlayerTechResearched(Player($B),'Rhpt',2)
call SetPlayerTechResearched(Player($B),'Rhst',2)
call SetPlayerTechResearched(Player($B),'Rhla',3)
call SetPlayerTechResearched(Player($B),'Rhri',1)
call SetPlayerTechResearched(Player($B),'Rhlh',2)
call SetPlayerTechResearched(Player($B),'Rhse',1)
call SetPlayerTechResearched(Player($B),'Rhfl',1)
call SetPlayerTechResearched(Player($B),'Rhss',1)
call SetPlayerTechResearched(Player($B),'Rhrt',1)
call SetPlayerTechResearched(Player($B),'Rhpm',1)
call SetPlayerTechResearched(Player($B),'Rhfc',1)
call SetPlayerTechResearched(Player($B),'Rhfs',1)
call SetPlayerTechResearched(Player($B),'Rhcd',1)
call SetPlayerTechResearched(Player($B),'Rome',3)
call SetPlayerTechResearched(Player($B),'Rora',3)
call SetPlayerTechResearched(Player($B),'Roar',3)
call SetPlayerTechResearched(Player($B),'Rwdm',1)
call SetPlayerTechResearched(Player($B),'Ropg',1)
call SetPlayerTechResearched(Player($B),'Robs',1)
call SetPlayerTechResearched(Player($B),'Rows',1)
call SetPlayerTechResearched(Player($B),'Roen',1)
call SetPlayerTechResearched(Player($B),'Rovs',1)
call SetPlayerTechResearched(Player($B),'Rowd',2)
call SetPlayerTechResearched(Player($B),'Rost',2)
call SetPlayerTechResearched(Player($B),'Rosp',3)
call SetPlayerTechResearched(Player($B),'Rotr',1)
call SetPlayerTechResearched(Player($B),'Rolf',1)
call SetPlayerTechResearched(Player($B),'Rowt',2)
call SetPlayerTechResearched(Player($B),'Rorb',1)
call SetPlayerTechResearched(Player($B),'Robk',1)
call SetPlayerTechResearched(Player($B),'Ropm',1)
call SetPlayerTechResearched(Player($B),'Robf',1)
call SetPlayerTechResearched(Player($B),'Rume',3)
call SetPlayerTechResearched(Player($B),'Rura',3)
call SetPlayerTechResearched(Player($B),'Ruar',3)
call SetPlayerTechResearched(Player($B),'Ruac',1)
call SetPlayerTechResearched(Player($B),'Ruwb',1)
call SetPlayerTechResearched(Player($B),'Rugf',1)
call SetPlayerTechResearched(Player($B),'Rusf',1)
call SetPlayerTechResearched(Player($B),'Rune',2)
call SetPlayerTechResearched(Player($B),'Ruba',2)
call SetPlayerTechResearched(Player($B),'Rufb',1)
call SetPlayerTechResearched(Player($B),'Rusl',1)
call SetPlayerTechResearched(Player($B),'Rucr',3)
call SetPlayerTechResearched(Player($B),'Rupc',1)
call SetPlayerTechResearched(Player($B),'Rusm',1)
call SetPlayerTechResearched(Player($B),'Rubu',1)
call SetPlayerTechResearched(Player($B),'Rusp',1)
call SetPlayerTechResearched(Player($B),'Ruex',1)
call SetPlayerTechResearched(Player($B),'Rupm',1)
call SetPlayerTechResearched(Player($B),'Resm',3)
call SetPlayerTechResearched(Player($B),'Resw',3)
call SetPlayerTechResearched(Player($B),'Rema',3)
call SetPlayerTechResearched(Player($B),'Rerh',3)
call SetPlayerTechResearched(Player($B),'Reuv',1)
call SetPlayerTechResearched(Player($B),'Renb',1)
call SetPlayerTechResearched(Player($B),'Resc',1)
call SetPlayerTechResearched(Player($B),'Remg',1)
call SetPlayerTechResearched(Player($B),'Reib',1)
call SetPlayerTechResearched(Player($B),'Remk',1)
call SetPlayerTechResearched(Player($B),'Redt',2)
call SetPlayerTechResearched(Player($B),'Redc',2)
call SetPlayerTechResearched(Player($B),'Resi',1)
call SetPlayerTechResearched(Player($B),'Recb',1)
call SetPlayerTechResearched(Player($B),'Reht',1)
call SetPlayerTechResearched(Player($B),'Repb',1)
call SetPlayerTechResearched(Player($B),'Rers',1)
call SetPlayerTechResearched(Player($B),'Rehs',1)
call SetPlayerTechResearched(Player($B),'Reeb',1)
call SetPlayerTechResearched(Player($B),'Reec',1)
call SetPlayerTechResearched(Player($B),'Rews',1)
call SetPlayerTechResearched(Player($B),'Repm',1)
call SetPlayerTechResearched(Player($B),'Rnen',1)
call SetPlayerTechResearched(Player($B),'Rnsw',2)
call SetPlayerTechResearched(Player($B),'Rnat',3)
call SetPlayerTechResearched(Player($B),'Rnsi',1)
call SetPlayerTechResearched(Player($B),'Rnam',3)
call SetPlayerTechResearched(Player($B),'Rnsb',1)
set alX=Player(0)
call CreateUnit(alX,'h0VG',-28864.,27200.,270.)
call CreateUnit(alX,'h0V3',-28672.,27264.,270.)
call CreateUnit(alX,'h0N6',-30336.,30528.,270.)
call CreateUnit(alX,'h0VF',-28928.,27648.,270.)
call CreateUnit(alX,'h0UP',-29120.,26560.,270.)
call CreateUnit(alX,'h021',-30528.,28992.,270.)
call CreateUnit(alX,'h0VD',-28672.,27648.,270.)
call CreateUnit(alX,'cubh',-28608.,29376.,270.)
call CreateUnit(alX,'h0UC',-29568.,28992.,270.)
call CreateUnit(alX,'h0SR',-27968.,26752.,270.)
call CreateUnit(alX,'h0VC',-28736.,27456.,270.)
call CreateUnit(alX,'h0J1',-28416.,30336.,270.)
call CreateUnit(alX,'h0ND',-29952.,30336.,270.)
call CreateUnit(alX,'h0W8',-29952.,28224.,270.)
call CreateUnit(alX,'h0W7',-29568.,28224.,270.)
call CreateUnit(alX,'h013',-28736.,30336.,270.)
call CreateUnit(alX,'h0W5',-28224.,28608.,270.)
call CreateUnit(alX,'h0W6',-29760.,28608.,270.)
call CreateUnit(alX,'h0W4',-28800.,29184.,270.)
call CreateUnit(alX,'h0W3',-28800.,28416.,270.)
call CreateUnit(alX,'h0W0',-29760.,28416.,270.)
call CreateUnit(alX,'h0VZ',-28416.,29376.,270.)
call CreateUnit(alX,'h0N5',-30336.,30336.,270.)
call CreateUnit(alX,'h01S',-30144.,30528.,270.)
call CreateUnit(alX,'h0OS',-28096.,30336.,270.)
call CreateUnit(alX,'h025',-29952.,30528.,270.)
call CreateUnit(alX,'h01B',-29760.,30336.,270.)
call CreateUnit(alX,'h016',-29760.,30528.,270.)
call CreateUnit(alX,'h01X',-29568.,30336.,270.)
call CreateUnit(alX,'h0NC',-30144.,30144.,270.)
call CreateUnit(alX,'h012',-30528.,30336.,270.)
call CreateUnit(alX,'h027',-29376.,30336.,270.)
call CreateUnit(alX,'h04R',-28480.,26560.,270.)
call CreateUnit(alX,'h0EJ',-28608.,26560.,270.)
call CreateUnit(alX,'h00T',-27968.,27200.,270.)
call CreateUnit(alX,'h00S',-27968.,27328.,270.)
call CreateUnit(alX,'h0EV',-28096.,26560.,270.)
call CreateUnit(alX,'h09R',-28224.,26560.,270.)
call CreateUnit(alX,'h00Q',-27968.,27584.,270.)
call CreateUnit(alX,'h0IT',-27840.,28608.,270.)
call CreateUnit(alX,'h0LS',-29376.,29568.,270.)
call CreateUnit(alX,'h00P',-27968.,27712.,270.)
call CreateUnit(alX,'h0PY',-28992.,29568.,270.)
call CreateUnit(alX,'h0NB',-30144.,30336.,270.)
call CreateUnit(alX,'h00M',-28352.,27840.,270.)
call CreateUnit(alX,'h00N',-28224.,27840.,270.)
call CreateUnit(alX,'h0LD',-30528.,26688.,270.)
call CreateUnit(alX,'h0V8',-28800.,29376.,270.)
call CreateUnit(alX,'h08T',-30144.,29568.,270.)
call CreateUnit(alX,'h0CI',-30528.,27840.,270.)
call CreateUnit(alX,'h0EP',-28352.,26560.,270.)
call CreateUnit(alX,'h0EW',-27968.,26560.,270.)
call CreateUnit(alX,'h00E',-29248.,27712.,270.)
call CreateUnit(alX,'h08L',-27968.,26880.,270.)
call CreateUnit(alX,'h04Q',-27968.,27008.,270.)
call CreateUnit(alX,'h00D',-29248.,27840.,270.)
call CreateUnit(alX,'h01I',-29376.,29952.,270.)
call CreateUnit(alX,'h0PK',-28800.,29568.,270.)
call CreateUnit(alX,'h0LJ',-28992.,26560.,270.)
call CreateUnit(alX,'h0BG',-30144.,29760.,270.)
call CreateUnit(alX,'h0BE',-30336.,29760.,270.)
set fO=CreateUnit(alX,'h01K',-30528.,29952.,270.)
call CreateUnit(alX,'h0BD',-30528.,29760.,270.)
call CreateUnit(alX,'h0BF',-29952.,29760.,270.)
call CreateUnit(alX,'h003',-29760.,30144.,270.)
call CreateUnit(alX,'h01Y',-29568.,29952.,270.)
call CreateUnit(alX,'h005',-29248.,27584.,270.)
call CreateUnit(alX,'h0NE',-29952.,30144.,270.)
call CreateUnit(alX,'h0JQ',-29568.,30528.,270.)
call CreateUnit(alX,'h014',-29760.,29952.,270.)
call CreateUnit(alX,'h015',-29760.,28992.,270.)
call CreateUnit(alX,'h0VA',-28992.,29376.,270.)
call CreateUnit(alX,'h0V7',-28224.,29184.,270.)
call CreateUnit(alX,'h018',-29760.,29760.,270.)
call CreateUnit(alX,'h019',-29760.,29376.,270.)
call CreateUnit(alX,'h01A',-30336.,29568.,270.)
call CreateUnit(alX,'h01C',-30528.,29376.,270.)
call CreateUnit(alX,'h01L',-30528.,30528.,270.)
call CreateUnit(alX,'h0N0',-30528.,30144.,270.)
call CreateUnit(alX,'h0LI',-28864.,26560.,270.)
call CreateUnit(alX,'h01G',-30528.,29568.,270.)
call CreateUnit(alX,'h01H',-29952.,29376.,270.)
call CreateUnit(alX,'h01J',-29568.,30144.,270.)
call CreateUnit(alX,'h09M',-29952.,29568.,270.)
call CreateUnit(alX,'h01M',-30144.,28992.,270.)
call CreateUnit(alX,'h01O',-29760.,29568.,270.)
call CreateUnit(alX,'h01P',-29568.,29568.,270.)
call CreateUnit(alX,'h09N',-29760.,29184.,270.)
call CreateUnit(alX,'h01T',-30528.,29184.,270.)
call CreateUnit(alX,'h028',-29376.,30528.,270.)
call CreateUnit(alX,'h0J2',-30144.,29376.,270.)
call CreateUnit(alX,'h0J0',-30336.,29376.,270.)
call CreateUnit(alX,'h0BH',-30336.,28992.,270.)
call CreateUnit(alX,'h0JW',-29376.,29184.,270.)
call CreateUnit(alX,'h01Z',-29376.,28992.,270.)
call CreateUnit(alX,'h020',-29952.,28992.,270.)
call CreateUnit(alX,'h09P',-30336.,29184.,270.)
call CreateUnit(alX,'h01Q',-30144.,29184.,270.)
call CreateUnit(alX,'h022',-29952.,29184.,270.)
call CreateUnit(alX,'h024',-29568.,29376.,270.)
call CreateUnit(alX,'h09O',-29568.,29184.,270.)
call CreateUnit(alX,'h026',-29568.,29760.,270.)
call CreateUnit(alX,'h001',-30528.,27648.,270.)
call CreateUnit(alX,'h002',-30528.,27456.,270.)
call CreateUnit(alX,'h045',-30528.,27264.,270.)
call CreateUnit(alX,'h0BR',-30528.,27072.,270.)
call CreateUnit(alX,'h0GT',-30528.,26880.,270.)
call CreateUnit(alX,'h0JH',-28608.,29760.,270.)
call CreateUnit(alX,'h0FW',-28800.,29760.,270.)
call CreateUnit(alX,'h08P',-28992.,29760.,270.)
call CreateUnit(alX,'h0LO',-28224.,29760.,270.)
call CreateUnit(alX,'h0EH',-28032.,29760.,270.)
call CreateUnit(alX,'h0NK',-28608.,29568.,270.)
call CreateUnit(alX,'h0T7',-28992.,29184.,270.)
call CreateUnit(alX,'h0V5',-27840.,29568.,270.)
call CreateUnit(alX,'h0V6',-28224.,29568.,270.)
call CreateUnit(alX,'h0OV',-27840.,29760.,270.)
call CreateUnit(alX,'h0EO',-27840.,28416.,270.)
call CreateUnit(alX,'h0V2',-28800.,27648.,270.)
call CreateUnit(alX,'h0U5',-28608.,29184.,270.)
call CreateUnit(alX,'h0TK',-27840.,29376.,270.)
call CreateUnit(alX,'h0K9',-28416.,29760.,270.)
call CreateUnit(alX,'h0QR',-28416.,29568.,270.)
call CreateUnit(alX,'h0V9',-28032.,29184.,270.)
call CreateUnit(alX,'h01W',-30336.,30144.,270.)
set RO=CreateUnit(alX,'h023',-29952.,29952.,270.)
set TO=CreateUnit(alX,'h01V',-30336.,29952.,270.)
set YO=CreateUnit(alX,'h01R',-30144.,29952.,270.)
call CreateUnit(alX,'h04O',-28864.,27328.,270.)
call CreateUnit(alX,'h0EK',-28864.,27072.,270.)
call CreateUnit(alX,'h04P',-28864.,26944.,270.)
call CreateUnit(alX,'h0IR',-28864.,27456.,270.)
call CreateUnit(alX,'h09Q',-29056.,26880.,270.)
call CreateUnit(alX,'h0DL',-29056.,27008.,270.)
call CreateUnit(alX,'h04F',-29056.,27136.,270.)
call CreateUnit(alX,'h04G',-29056.,27264.,270.)
call CreateUnit(alX,'h0IS',-29056.,27648.,270.)
call CreateUnit(alX,'h006',-29248.,26688.,270.)
call CreateUnit(alX,'h007',-29248.,26816.,270.)
call CreateUnit(alX,'h008',-29248.,26944.,270.)
call CreateUnit(alX,'h009',-29248.,27072.,270.)
call CreateUnit(alX,'h017',-29376.,30144.,270.)
call CreateUnit(alX,'h0VB',-28032.,29568.,270.)
call CreateUnit(alX,'h00F',-29120.,27840.,270.)
call CreateUnit(alX,'h00G',-28992.,27840.,270.)
call CreateUnit(alX,'h0FT',-29376.,29760.,270.)
call CreateUnit(alX,'h0SQ',-28224.,29376.,270.)
call CreateUnit(alX,'h0M0',-29376.,29376.,270.)
call CreateUnit(alX,'h00A',-29248.,27200.,270.)
call CreateUnit(alX,'h00H',-28864.,27840.,270.)
call CreateUnit(alX,'h00I',-28736.,27840.,270.)
call CreateUnit(alX,'h00J',-28608.,27840.,270.)
call CreateUnit(alX,'h00K',-28480.,27840.,270.)
call CreateUnit(alX,'h00R',-27968.,27456.,270.)
call CreateUnit(alX,'h04S',-28736.,26560.,270.)
call CreateUnit(alX,'h00O',-28096.,27840.,270.)
call CreateUnit(alX,'h00L',-27968.,27840.,270.)
call CreateUnit(alX,'h00C',-29248.,27456.,270.)
call CreateUnit(alX,'h00B',-29248.,27328.,270.)
call CreateUnit(alX,'h0BP',-30144.,27456.,270.)
call CreateUnit(alX,'h06Q',-30144.,27840.,270.)
call CreateUnit(alX,'h07K',-29952.,27840.,270.)
call CreateUnit(alX,'h0KA',-29952.,27456.,270.)
call CreateUnit(alX,'h0JG',-29952.,27264.,270.)
call CreateUnit(alX,'h0TY',-29568.,27456.,270.)
call CreateUnit(alX,'h07M',-29952.,27648.,270.)
call CreateUnit(alX,'h06S',-30144.,27648.,270.)
call CreateUnit(alX,'h0A2',-29568.,27648.,270.)
call CreateUnit(alX,'h06T',-29760.,27648.,270.)
call CreateUnit(alX,'h07L',-29568.,27840.,270.)
call CreateUnit(alX,'h06R',-29760.,27840.,270.)
call CreateUnit(alX,'h0G1',-30144.,26880.,270.)
call CreateUnit(alX,'h0LN',-29952.,26880.,270.)
call CreateUnit(alX,'h094',-29760.,26880.,270.)
call CreateUnit(alX,'h0MH',-30144.,27072.,270.)
call CreateUnit(alX,'h0M1',-29952.,27072.,270.)
call CreateUnit(alX,'h0RV',-29760.,27072.,270.)
call CreateUnit(alX,'h0T9',-30144.,27264.,270.)
call CreateUnit(alX,'h0MM',-29760.,27456.,270.)
call CreateUnit(alX,'h08O',-29760.,27264.,270.)
call CreateUnit(alX,'h09A',-29568.,27264.,270.)
call CreateUnit(alX,'h0MD',-29568.,27072.,270.)
call CreateUnit(alX,'h0VJ',-28608.,28416.,270.)
call CreateUnit(alX,'h0VH',-29568.,28416.,270.)
call CreateUnit(alX,'h0VI',-29376.,28416.,270.)
call CreateUnit(alX,'h0O4',-28608.,28608.,270.)
call CreateUnit(alX,'h0UB',-29376.,28224.,270.)
call CreateUnit(alX,'h0S7',-28416.,28416.,270.)
call CreateUnit(alX,'h0OU',-29184.,28416.,270.)
call CreateUnit(alX,'h0VO',-28800.,28608.,270.)
call CreateUnit(alX,'h0VN',-29184.,28608.,270.)
call CreateUnit(alX,'h0VP',-29568.,28608.,270.)
call CreateUnit(alX,'h0VQ',-30528.,28608.,270.)
call CreateUnit(alX,'h0VR',-30336.,28608.,270.)
call CreateUnit(alX,'h0VS',-30144.,28608.,270.)
call CreateUnit(alX,'h0VT',-29952.,28608.,270.)
call CreateUnit(alX,'h0VM',-30144.,28224.,270.)
call CreateUnit(alX,'h0VK',-30144.,28416.,270.)
call CreateUnit(alX,'h0VL',-29952.,28416.,270.)
call CreateUnit(alX,'h0Q1',-30336.,28416.,270.)
call CreateUnit(alX,'h0NL',-29760.,28224.,270.)
call CreateUnit(alX,'h0OT',-30528.,28224.,270.)
call CreateUnit(alX,'h0QU',-30336.,28224.,270.)
call CreateUnit(alX,'h0PJ',-30528.,28416.,270.)
call CreateUnit(alX,'h0PV',-28416.,28608.,270.)
call CreateUnit(alX,'h0VU',-28992.,28608.,270.)
call CreateUnit(alX,'h0VV',-29376.,28608.,270.)
call CreateUnit(alX,'h0VW',-28992.,28416.,270.)
call CreateUnit(alX,'h0VX',-28032.,29376.,270.)
call CreateUnit(alX,'h0VY',-28416.,29184.,270.)
call CreateUnit(alX,'h0WA',-30528.,26496.,270.)
call CreateUnit(alX,'h0WY',-29248.,26560.,270.)
call CreateUnit(alX,'h0W9',-27840.,29184.,270.)
call CreateUnit(alX,'h0XC',-29056.,27520.,270.)
call CreateUnit(alX,'h0VE',-29056.,27392.,270.)
call CreateUnit(alX,'h0WD',-28672.,27136.,270.)
call CreateUnit(alX,'h0WC',-28544.,27648.,270.)
set alX=null
call InitBlizzard()
call ExecuteFunc("cnv")
call ExecuteFunc("cVv")
set aqX=CreateTrigger()
call Avv(aqX,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(aqX,Filter(fz))
call TriggerAddCondition(R,Filter(Fz))
set aqX=null
call TriggerAddCondition(R,Filter(gz))
set aQX=CreateTrigger()
call Avv(aQX,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(aQX,Filter(Gz))
call TriggerAddCondition(R,Filter(hz))
set PO=B0v()
set aQX=null
set asX=CreateTrigger()
call Avv(asX,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(asX,Filter(Hz))
call TriggerAddCondition(R,Filter(jz))
set AO=B2v()
set Sb[AO]=1
set asX=null
set aSX=CreateTrigger()
call Avv(aSX,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(aSX,Filter(Jz))
call TriggerAddCondition(R,Filter(kz))
set DO=B2v()
set rb[DO]=2
set sb[DO]=3
set HO=B0v()
set aSX=null
set atX=CreateTrigger()
call Avv(atX,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(atX,Filter(Lz))
call TriggerAddCondition(R,Filter(mz))
set XO=B2v()
set ib[XO]=4
set VO=B0v()
set CO=B2v()
set ib[CO]=5
set BO=B0v()
set NO=B0v()
set MO=B0v()
set atX=null
set aTX=CreateTrigger()
call Avv(aTX,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(aTX,Filter(pz))
set aTX=CreateTrigger()
call Avv(aTX,EVENT_PLAYER_UNIT_SPELL_CAST)
call TriggerAddCondition(aTX,Filter(Pz))
call TriggerAddCondition(R,Filter(qz))
set ol=B2v()
set ib[ol]=6
set ll=B0v()
set Ol=B0v()
set bl=B0v()
set yl=B0v()
set aTX=null
set auX=CreateTrigger()
call Avv(auX,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(auX,Filter(Qz))
set auX=null
set aUX=CreateTrigger()
call Avv(aUX,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(aUX,Filter(tz))
set aUX=CreateTrigger()
call Avv(aUX,EVENT_PLAYER_UNIT_DEATH)
call TriggerAddCondition(aUX,Filter(Tz))
set el=B2v()
set ib[el]=7
set aUX=null
set awX=CreateTrigger()
call Avv(awX,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(awX,Filter(Uz))
call TriggerAddCondition(R,Filter(wz))
set al=B0v()
set awX=null
set aWX=CreateTrigger()
call Avv(aWX,EVENT_PLAYER_UNIT_DEATH)
call TriggerAddCondition(aWX,Filter(Wz))
set nl=B2v()
set ib[nl]=8
set aWX=null
set ayX=CreateTrigger()
call Avv(ayX,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(ayX,Filter(zz))
call TriggerAddCondition(R,Filter(Zz))
set ayX=null
set aYX=CreateTrigger()
call Avv(aYX,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(aYX,Filter(v0))
set aYX=null
set azX=CreateTrigger()
set aZX=0
call Avv(azX,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(azX,Filter(ojv))
set azX=CreateTrigger()
call Avv(azX,EVENT_PLAYER_UNIT_ISSUED_ORDER)
call TriggerAddCondition(azX,Filter(oJv))
set azX=null
loop
exitwhen aZX==bj_MAX_PLAYER_SLOTS
set hl[aZX]=aMX()
call SetPlayerTechResearched(r[aZX],gl,0)
call jNV(aZX,false)
set aZX=aZX+1
endloop
set azX=null
set a_X=0
set a_X=0
loop
exitwhen a_X>$C
set g[a_X]=CreateGroup()
set a_X=a_X+1
endloop
set h=CreateGroup()
set a_X=0
loop
exitwhen a_X>$C
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>$C
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>$C
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>$C
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>$C
set F[a_X]=false
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>$C
set k[a_X]=""
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>$C
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>$C
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>$C
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>$C
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>$C
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>$C
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>$C
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>$C
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>$C
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>$C
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>$C
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>$C
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>$C
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>$C
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>$C
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>$C
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>$A
set a_X=a_X+1
endloop
set x=0
set a_X=0
loop
exitwhen a_X>50
set v[a_X]=""
set a_X=a_X+1
endloop
call Player(bj_PLAYER_NEUTRAL_EXTRA)
set a_X=0
loop
exitwhen a_X>8192
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>'d'
set m[a_X]=""
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>9
set Q[a_X]=""
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>$C
set X[a_X]=0
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>400
set a_X=a_X+1
endloop
set V=0
set N=0
set a_X=0
loop
exitwhen a_X>400
set M[a_X]=""
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set ww=true
set a_X=0
loop
exitwhen a_X>$C
set qw[a_X]=1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>400
set nw[a_X]=""
set a_X=a_X+1
endloop
set dw=0
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set fw=0
set a_X=0
loop
exitwhen a_X>400
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>$C
set Tw[a_X]=0
set a_X=a_X+1
endloop
set Yw=0
set a_X=0
loop
exitwhen a_X>$C
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>$C
set Gw[a_X]=.0
set a_X=a_X+1
endloop
set gw=false
set a_X=0
loop
exitwhen a_X>$C
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>$C
set a_X=a_X+1
endloop
set xw=CreateTimer()
set a_X=0
loop
exitwhen a_X>$C
set vw[a_X]=1.
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>$C
set mw[a_X]=false
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>'d'
set Qw[a_X]=""
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>$C
set Ww[a_X]=0
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set Cw=""
set Vw=false
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
call DialogCreate()
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
call CreateGroup()
set a_X=0
loop
exitwhen a_X>1
call CreateTimer()
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
call CreateGroup()
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
call CreateGroup()
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
call DialogCreate()
set a_X=a_X+1
endloop
call DialogCreate()
call DialogCreate()
call DialogCreate()
call DialogCreate()
call DialogCreate()
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
call DialogCreate()
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
call DialogCreate()
call DialogCreate()
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
call CreateGroup()
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set Bw[a_X]=0
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set wu[a_X]=.0
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set ru[a_X]=.0
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set su[a_X]=.0
set a_X=a_X+1
endloop
set tu=.0
set a_X=0
loop
exitwhen a_X>1
set Su[a_X]=.0
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set cu[a_X]=""
set a_X=a_X+1
endloop
set ou=""
set a_X=0
loop
exitwhen a_X>1
set Ou[a_X]=""
set a_X=a_X+1
endloop
set lu=""
set a_X=0
loop
exitwhen a_X>1
set bu[a_X]=false
set a_X=a_X+1
endloop
set yu=false
set a_X=0
loop
exitwhen a_X>1
set pu[a_X]=.0
set a_X=a_X+1
endloop
set eu=.0
set qu=.0
set au=CreateGroup()
set a_X=0
loop
exitwhen a_X>1
set nu[a_X]=.0
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set du[a_X]=.0
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>$C
set a_X=a_X+1
endloop
call CreateGroup()
set fu=true
call CreateGroup()
call CreateGroup()
set a_X=0
loop
exitwhen a_X>$C
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
call CreateGroup()
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>$C
set a_X=a_X+1
endloop
set Yu=false
set Gu=.0
set gu=.0
set hu=.0
set Fu=.0
set ku=0
set ju=0
set xu=.0
set vu=.0
set mu=.0
set Qu=.0
set Wu=.0
set Eu=.0
set Zu=.0
set Uu=.0
set Iu=.0
set Pu=.0
set Du=0
set Hu=CreateGroup()
set Ku=CreateGroup()
set Lu=CreateGroup()
set Xu=CreateForce()
set Cu=0
set Vu=0
set Bu=0
set Mu=0
set wr=0
set ur=0
set rr=0
set sr=0
set tr=.0
set ir=.0
set Sr=false
set a_X=0
loop
exitwhen a_X>1
set cr[a_X]=CreateGroup()
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set lr[a_X]=CreateGroup()
set a_X=a_X+1
endloop
set yr=.0
set er=.0
set qr=.0
set ar=.0
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set dr=CreateGroup()
set fr=CreateGroup()
set Rr=CreateGroup()
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
call CreateGroup()
set a_X=a_X+1
endloop
call CreateGroup()
set Yr=CreateGroup()
set hr=CreateGroup()
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
call CreateGroup()
set a_X=0
loop
exitwhen a_X>1
set kr[a_X]=0
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set vr[a_X]=.0
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set Qr[a_X]=.0
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set Wr[a_X]=.0
set a_X=a_X+1
endloop
set Er=.0
set a_X=0
loop
exitwhen a_X>1
set Ur[a_X]=.0
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set Ir[a_X]=""
set a_X=a_X+1
endloop
set Pr=""
set a_X=0
loop
exitwhen a_X>1
set Ar[a_X]=""
set a_X=a_X+1
endloop
set Dr=""
set a_X=0
loop
exitwhen a_X>1
set Hr[a_X]=false
set a_X=a_X+1
endloop
set Jr=false
set a_X=0
loop
exitwhen a_X>1
set Kr[a_X]=.0
set a_X=a_X+1
endloop
set Lr=.0
set Xr=.0
set Cr=CreateGroup()
set a_X=0
loop
exitwhen a_X>1
set Vr[a_X]=.0
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set Br[a_X]=.0
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
call CreateGroup()
set a_X=a_X+1
endloop
set Mr=0
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set ws=CreateGroup()
set us=CreateGroup()
set rs=CreateGroup()
call CreateGroup()
set a_X=0
loop
exitwhen a_X>$C
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>$C
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>$C
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>$C
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>$D
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>20
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>$C
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>$C
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set ts=0
set a_X=0
loop
exitwhen a_X>1
set is[a_X]=true
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set Ss[a_X]=.0
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set cs=CreateGroup()
set os=CreateGroup()
set a_X=0
loop
exitwhen a_X>$C
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>$C
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set ls[a_X]=false
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set bs[a_X]=$C
set a_X=a_X+1
endloop
set ys=CreateGroup()
set ps=CreateGroup()
set es=CreateGroup()
set a_X=0
loop
exitwhen a_X>1
call CreateGroup()
set a_X=a_X+1
endloop
call CreateGroup()
set qs=CreateGroup()
set as=CreateGroup()
set ns=CreateGroup()
set a_X=0
loop
exitwhen a_X>1
set ds[a_X]=.0
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set fs[a_X]=""
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set Rs[a_X]=.0
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set Ts[a_X]=""
set a_X=a_X+1
endloop
set Ys=CreateGroup()
set a_X=0
loop
exitwhen a_X>1
set Gs[a_X]=.0
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set gs[a_X]=0
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set hs[a_X]=.0
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set Fs[a_X]=.0
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set ks[a_X]=.0
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set js[a_X]=.0
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set vs[a_X]=false
set a_X=a_X+1
endloop
set Qs=""
set Ws=.0
set Es=false
set Zs=.0
set Us=""
set Is=.0
set Ds=0
set a_X=0
loop
exitwhen a_X>1
set Hs[a_X]=0
set a_X=a_X+1
endloop
call CreateGroup()
set Ls=CreateGroup()
call CreateGroup()
set Xs=CreateGroup()
set Cs=0
set a_X=0
loop
exitwhen a_X>1
set Vs[a_X]=0
set a_X=a_X+1
endloop
set Bs=CreateGroup()
set a_X=0
loop
exitwhen a_X>1
set Ms[a_X]=""
set a_X=a_X+1
endloop
set wt=0
call CreateTimer()
set st=CreateGroup()
set tt=CreateGroup()
set St=CreateGroup()
set ct=CreateGroup()
set ot=CreateGroup()
set Ot=CreateGroup()
set lt=CreateGroup()
set bt=CreateGroup()
set yt=CreateGroup()
set pt=CreateGroup()
set a_X=0
loop
exitwhen a_X>1
set et[a_X]=false
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set qt[a_X]=true
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set at[a_X]=.0
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set nt[a_X]=0
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set dt[a_X]=true
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set ft[a_X]=0
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set Rt[a_X]=false
set a_X=a_X+1
endloop
call CreateGroup()
set a_X=0
loop
exitwhen a_X>2
set Tt[a_X]=CreateGroup()
set a_X=a_X+1
endloop
set Yt=CreateGroup()
set a_X=0
loop
exitwhen a_X>1
set Gt[a_X]=.0
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set gt=0
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set Ft=CreateGroup()
set kt=CreateGroup()
set jt=CreateGroup()
call CreateGroup()
call CreateGroup()
set a_X=0
loop
exitwhen a_X>1
set vt[a_X]=0
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>1
set a_X=a_X+1
endloop
call CreateGroup()
set mt=0
set a_X=0
loop
exitwhen a_X>1
set Qt[a_X]=0
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>16
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>$C
set Zt[a_X]=false
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>$C
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>$C
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>$C
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>$C
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>$C0
set a_X=a_X+1
endloop
set a_X=0
loop
exitwhen a_X>$C0
set a_X=a_X+1
endloop
set Jt=CreateTrigger()
call TriggerAddAction(Jt,e0)
set Kt=CreateTrigger()
call DisableTrigger(Kt)
call TriggerRegisterTimerEventPeriodic(Kt,1.)
call TriggerAddAction(Kt,r0)
set Lt=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(Lt,EVENT_PLAYER_UNIT_SPELL_CAST)
call TriggerAddCondition(Lt,Condition(i0))
call TriggerAddAction(Lt,a0)
set Xt=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(Xt,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(Xt,Condition(n0))
call TriggerAddAction(Xt,V0)
set Ct=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(Ct,EVENT_PLAYER_UNIT_SPELL_CAST)
call TriggerAddCondition(Ct,Condition(E0))
call TriggerAddAction(Ct,X0)
set Vt=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(Vt,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(Vt,Condition(O0))
call TriggerAddAction(Vt,R0)
set Bt=CreateTrigger()
call DisableTrigger(Bt)
call TriggerRegisterTimerEventPeriodic(Bt,.03)
call TriggerAddAction(Bt,P0)
set Nt=CreateTrigger()
call DisableTrigger(Nt)
call TriggerRegisterTimerEventPeriodic(Nt,1.)
call TriggerAddAction(Nt,s0)
set Mt=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(Mt,EVENT_PLAYER_UNIT_SPELL_CAST)
call TriggerAddCondition(Mt,Condition(S0))
call TriggerAddAction(Mt,t0)
set wi=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(wi,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(wi,Condition(T0))
call TriggerAddAction(wi,u0)
set ui=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(ui,EVENT_PLAYER_UNIT_SPELL_CAST)
call TriggerAddCondition(ui,Condition(U0))
call TriggerAddAction(ui,w0)
set ri=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(ri,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(ri,Condition(W0))
call TriggerAddAction(ri,y0)
set si=CreateTrigger()
call DisableTrigger(si)
call TriggerRegisterTimerEventPeriodic(si,.03)
call TriggerAddAction(si,vIv)
set ti=CreateTrigger()
call TriggerRegisterPlayerChatEvent(ti,Player(0),"set",false)
call TriggerRegisterPlayerChatEvent(ti,Player(1),"set",false)
call TriggerRegisterPlayerChatEvent(ti,Player(2),"set",false)
call TriggerRegisterPlayerChatEvent(ti,Player(3),"set",false)
call TriggerRegisterPlayerChatEvent(ti,Player(4),"set",false)
call TriggerRegisterPlayerChatEvent(ti,Player(5),"set",false)
call TriggerRegisterPlayerChatEvent(ti,Player(6),"set",false)
call TriggerRegisterPlayerChatEvent(ti,Player(7),"set",false)
call TriggerRegisterPlayerChatEvent(ti,Player(8),"set",false)
call TriggerRegisterPlayerChatEvent(ti,Player(9),"set",false)
call TriggerRegisterPlayerChatEvent(ti,Player($A),"set",false)
call TriggerRegisterPlayerChatEvent(ti,Player($B),"set",false)
call TriggerAddCondition(ti,Condition(vbv))
call TriggerAddAction(ti,vBv)
set ii=CreateTrigger()
call TriggerRegisterPlayerChatEvent(ii,Player(0),"elevator",false)
call TriggerRegisterPlayerChatEvent(ii,Player(1),"elevator",false)
call TriggerRegisterPlayerChatEvent(ii,Player(2),"elevator",false)
call TriggerRegisterPlayerChatEvent(ii,Player(3),"elevator",false)
call TriggerRegisterPlayerChatEvent(ii,Player(4),"elevator",false)
call TriggerRegisterPlayerChatEvent(ii,Player(5),"elevator",false)
call TriggerRegisterPlayerChatEvent(ii,Player(6),"elevator",false)
call TriggerRegisterPlayerChatEvent(ii,Player(7),"elevator",false)
call TriggerRegisterPlayerChatEvent(ii,Player(8),"elevator",false)
call TriggerRegisterPlayerChatEvent(ii,Player(9),"elevator",false)
call TriggerRegisterPlayerChatEvent(ii,Player($A),"elevator",false)
call TriggerRegisterPlayerChatEvent(ii,Player($B),"elevator",false)
call TriggerAddAction(ii,vfv)
set Si=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(Si,EVENT_PLAYER_UNIT_ISSUED_POINT_ORDER)
call TriggerAddCondition(Si,Condition(vFv))
call TriggerAddAction(Si,vgv)
set ci=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(ci,EVENT_PLAYER_UNIT_SPELL_CAST)
call TriggerAddCondition(ci,Condition(vHv))
call TriggerAddAction(ci,vjv)
set oi=CreateTrigger()
call TriggerRegisterPlayerChatEvent(oi,Player(0),"weather",false)
call TriggerRegisterPlayerChatEvent(oi,Player(1),"weather",false)
call TriggerRegisterPlayerChatEvent(oi,Player(2),"weather",false)
call TriggerRegisterPlayerChatEvent(oi,Player(3),"weather",false)
call TriggerRegisterPlayerChatEvent(oi,Player(4),"weather",false)
call TriggerRegisterPlayerChatEvent(oi,Player(5),"weather",false)
call TriggerRegisterPlayerChatEvent(oi,Player(6),"weather",false)
call TriggerRegisterPlayerChatEvent(oi,Player(7),"weather",false)
call TriggerRegisterPlayerChatEvent(oi,Player(8),"weather",false)
call TriggerRegisterPlayerChatEvent(oi,Player(9),"weather",false)
call TriggerRegisterPlayerChatEvent(oi,Player($A),"weather",false)
call TriggerRegisterPlayerChatEvent(oi,Player($B),"weather",false)
call TriggerAddCondition(oi,Condition(vkv))
call TriggerAddAction(oi,vKv)
set Oi=CreateTrigger()
call TriggerRegisterPlayerChatEvent(Oi,Player(0),"weather",false)
call TriggerRegisterPlayerChatEvent(Oi,Player(1),"weather",false)
call TriggerRegisterPlayerChatEvent(Oi,Player(2),"weather",false)
call TriggerRegisterPlayerChatEvent(Oi,Player(3),"weather",false)
call TriggerRegisterPlayerChatEvent(Oi,Player(4),"weather",false)
call TriggerRegisterPlayerChatEvent(Oi,Player(5),"weather",false)
call TriggerRegisterPlayerChatEvent(Oi,Player(6),"weather",false)
call TriggerRegisterPlayerChatEvent(Oi,Player(7),"weather",false)
call TriggerRegisterPlayerChatEvent(Oi,Player(8),"weather",false)
call TriggerRegisterPlayerChatEvent(Oi,Player(9),"weather",false)
call TriggerRegisterPlayerChatEvent(Oi,Player($A),"weather",false)
call TriggerRegisterPlayerChatEvent(Oi,Player($B),"weather",false)
call TriggerAddAction(Oi,vlv)
set li=CreateTrigger()
call TriggerRegisterPlayerChatEvent(li,Player(0),"aweather",false)
call TriggerRegisterPlayerChatEvent(li,Player(1),"aweather",false)
call TriggerRegisterPlayerChatEvent(li,Player(2),"aweather",false)
call TriggerRegisterPlayerChatEvent(li,Player(3),"aweather",false)
call TriggerRegisterPlayerChatEvent(li,Player(4),"aweather",false)
call TriggerRegisterPlayerChatEvent(li,Player(5),"aweather",false)
call TriggerRegisterPlayerChatEvent(li,Player(6),"aweather",false)
call TriggerRegisterPlayerChatEvent(li,Player(7),"aweather",false)
call TriggerRegisterPlayerChatEvent(li,Player(8),"aweather",false)
call TriggerRegisterPlayerChatEvent(li,Player(9),"aweather",false)
call TriggerRegisterPlayerChatEvent(li,Player($A),"aweather",false)
call TriggerRegisterPlayerChatEvent(li,Player($B),"aweather",false)
call TriggerAddCondition(li,Condition(vLv))
call TriggerAddAction(li,vmv)
set bi=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(bi,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(bi,Condition(vTv))
call TriggerAddAction(bi,vuv)
set yi=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(yi,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(yi,Condition(vUv))
call TriggerAddAction(yi,vwv)
set pi=CreateTrigger()
call TriggerRegisterPlayerChatEvent(pi,Player(0),"terrain",false)
call TriggerRegisterPlayerChatEvent(pi,Player(1),"terrain",false)
call TriggerRegisterPlayerChatEvent(pi,Player(2),"terrain",false)
call TriggerRegisterPlayerChatEvent(pi,Player(3),"terrain",false)
call TriggerRegisterPlayerChatEvent(pi,Player(4),"terrain",false)
call TriggerRegisterPlayerChatEvent(pi,Player(5),"terrain",false)
call TriggerRegisterPlayerChatEvent(pi,Player(6),"terrain",false)
call TriggerRegisterPlayerChatEvent(pi,Player(7),"terrain",false)
call TriggerRegisterPlayerChatEvent(pi,Player(8),"terrain",false)
call TriggerRegisterPlayerChatEvent(pi,Player(9),"terrain",false)
call TriggerRegisterPlayerChatEvent(pi,Player($A),"terrain",false)
call TriggerRegisterPlayerChatEvent(pi,Player($B),"terrain",false)
call TriggerAddCondition(pi,Condition(vWv))
call TriggerAddAction(pi,vyv)
set ei=CreateTrigger()
call TriggerRegisterPlayerChatEvent(ei,Player(0),"height",false)
call TriggerRegisterPlayerChatEvent(ei,Player(1),"height",false)
call TriggerRegisterPlayerChatEvent(ei,Player(2),"height",false)
call TriggerRegisterPlayerChatEvent(ei,Player(3),"height",false)
call TriggerRegisterPlayerChatEvent(ei,Player(4),"height",false)
call TriggerRegisterPlayerChatEvent(ei,Player(5),"height",false)
call TriggerRegisterPlayerChatEvent(ei,Player(6),"height",false)
call TriggerRegisterPlayerChatEvent(ei,Player(7),"height",false)
call TriggerRegisterPlayerChatEvent(ei,Player(8),"height",false)
call TriggerRegisterPlayerChatEvent(ei,Player(9),"height",false)
call TriggerRegisterPlayerChatEvent(ei,Player($A),"height",false)
call TriggerRegisterPlayerChatEvent(ei,Player($B),"height",false)
call TriggerAddCondition(ei,Condition(vYv))
call TriggerAddAction(ei,vzv)
set qi=CreateTrigger()
call TriggerRegisterTimerEventSingle(qi,.11)
call TriggerAddAction(qi,vZv)
set ai=CreateTrigger()
call TriggerRegisterTimerEventSingle(ai,.03)
call TriggerAddAction(ai,v_v)
set ni=CreateTrigger()
call TriggerRegisterTimerEventSingle(ni,.09)
call TriggerAddAction(ni,v0v)
set di=CreateTrigger()
call TriggerRegisterTimerEventSingle(di,.02)
call TriggerAddAction(di,v1v)
set fi=CreateTrigger()
call TriggerRegisterTimerEventSingle(fi,.04)
call TriggerAddAction(fi,v2v)
set Ri=CreateTrigger()
call TriggerRegisterTimerEventSingle(Ri,.05)
call TriggerAddAction(Ri,v3v)
set Ti=CreateTrigger()
call TriggerRegisterTimerEventSingle(Ti,.3)
call TriggerAddAction(Ti,v4v)
set Yi=CreateTrigger()
call TriggerRegisterTimerEventSingle(Yi,.06)
call TriggerAddAction(Yi,v5v)
set Gi=CreateTrigger()
call TriggerRegisterPlayerChatEvent(Gi,Player(0),"",false)
call TriggerRegisterPlayerChatEvent(Gi,Player(1),"",false)
call TriggerRegisterPlayerChatEvent(Gi,Player(2),"",false)
call TriggerRegisterPlayerChatEvent(Gi,Player(3),"",false)
call TriggerRegisterPlayerChatEvent(Gi,Player(4),"",false)
call TriggerRegisterPlayerChatEvent(Gi,Player(5),"",false)
call TriggerRegisterPlayerChatEvent(Gi,Player(6),"",false)
call TriggerRegisterPlayerChatEvent(Gi,Player(7),"",false)
call TriggerRegisterPlayerChatEvent(Gi,Player(8),"",false)
call TriggerRegisterPlayerChatEvent(Gi,Player(9),"",false)
call TriggerRegisterPlayerChatEvent(Gi,Player($A),"",false)
call TriggerRegisterPlayerChatEvent(Gi,Player($B),"",false)
call TriggerAddCondition(Gi,Condition(v6v))
call TriggerAddAction(Gi,v7v)
set gi=CreateTrigger()
call TriggerRegisterTimerEventSingle(gi,1.)
call TriggerAddAction(gi,v8v)
set hi=CreateTrigger()
call TriggerAddAction(hi,eev)
set Fi=CreateTrigger()
call TriggerRegisterTimerEvent(Fi,.01,false)
call TriggerAddAction(Fi,exv)
set ki=CreateTrigger()
call TriggerRegisterEnterRectSimple(ki,GetEntireMapRect())
call TriggerRegisterAnyUnitEventBJ(ki,EVENT_PLAYER_UNIT_CONSTRUCT_FINISH)
call TriggerRegisterAnyUnitEventBJ(ki,EVENT_PLAYER_UNIT_UPGRADE_FINISH)
call TriggerAddAction(ki,eov)
set ji=CreateTrigger()
call TriggerRegisterTimerEvent(ji,.5,false)
call TriggerAddAction(ji,erv)
set xi=CreateTrigger()
call TriggerAddAction(xi,eav)
set vi=CreateTrigger()
call TriggerRegisterPlayerChatEvent(vi,Player(0),"sfx",false)
call TriggerRegisterPlayerChatEvent(vi,Player(1),"sfx",false)
call TriggerRegisterPlayerChatEvent(vi,Player(2),"sfx",false)
call TriggerRegisterPlayerChatEvent(vi,Player(3),"sfx",false)
call TriggerRegisterPlayerChatEvent(vi,Player(4),"sfx",false)
call TriggerRegisterPlayerChatEvent(vi,Player(5),"sfx",false)
call TriggerRegisterPlayerChatEvent(vi,Player(6),"sfx",false)
call TriggerRegisterPlayerChatEvent(vi,Player(7),"sfx",false)
call TriggerRegisterPlayerChatEvent(vi,Player(8),"sfx",false)
call TriggerRegisterPlayerChatEvent(vi,Player(9),"sfx",false)
call TriggerRegisterPlayerChatEvent(vi,Player($A),"sfx",false)
call TriggerRegisterPlayerChatEvent(vi,Player($B),"sfx",false)
call TriggerAddCondition(vi,Condition(eVv))
call TriggerAddAction(vi,eEv)
set mi=CreateTrigger()
call TriggerRegisterPlayerChatEvent(mi,Player(0),"afx",false)
call TriggerRegisterPlayerChatEvent(mi,Player(1),"afx",false)
call TriggerRegisterPlayerChatEvent(mi,Player(2),"afx",false)
call TriggerRegisterPlayerChatEvent(mi,Player(3),"afx",false)
call TriggerRegisterPlayerChatEvent(mi,Player(4),"afx",false)
call TriggerRegisterPlayerChatEvent(mi,Player(5),"afx",false)
call TriggerRegisterPlayerChatEvent(mi,Player(6),"afx",false)
call TriggerRegisterPlayerChatEvent(mi,Player(7),"afx",false)
call TriggerRegisterPlayerChatEvent(mi,Player(8),"afx",false)
call TriggerRegisterPlayerChatEvent(mi,Player(9),"afx",false)
call TriggerRegisterPlayerChatEvent(mi,Player($A),"afx",false)
call TriggerRegisterPlayerChatEvent(mi,Player($B),"afx",false)
call TriggerAddCondition(mi,Condition(eOv))
call TriggerAddAction(mi,eRv)
set Qi=CreateTrigger()
call TriggerRegisterPlayerChatEvent(Qi,Player(0),"remove sfx",true)
call TriggerRegisterPlayerChatEvent(Qi,Player(1),"remove sfx",true)
call TriggerRegisterPlayerChatEvent(Qi,Player(2),"remove sfx",true)
call TriggerRegisterPlayerChatEvent(Qi,Player(3),"remove sfx",true)
call TriggerRegisterPlayerChatEvent(Qi,Player(4),"remove sfx",true)
call TriggerRegisterPlayerChatEvent(Qi,Player(5),"remove sfx",true)
call TriggerRegisterPlayerChatEvent(Qi,Player(6),"remove sfx",true)
call TriggerRegisterPlayerChatEvent(Qi,Player(7),"remove sfx",true)
call TriggerRegisterPlayerChatEvent(Qi,Player(8),"remove sfx",true)
call TriggerRegisterPlayerChatEvent(Qi,Player(9),"remove sfx",true)
call TriggerRegisterPlayerChatEvent(Qi,Player($A),"remove sfx",true)
call TriggerRegisterPlayerChatEvent(Qi,Player($B),"remove sfx",true)
call TriggerAddAction(Qi,eAv)
set Wi=CreateTrigger()
call TriggerRegisterPlayerChatEvent(Wi,Player(0),"remove afx",true)
call TriggerRegisterPlayerChatEvent(Wi,Player(1),"remove afx",true)
call TriggerRegisterPlayerChatEvent(Wi,Player(2),"remove afx",true)
call TriggerRegisterPlayerChatEvent(Wi,Player(3),"remove afx",true)
call TriggerRegisterPlayerChatEvent(Wi,Player(4),"remove afx",true)
call TriggerRegisterPlayerChatEvent(Wi,Player(5),"remove afx",true)
call TriggerRegisterPlayerChatEvent(Wi,Player(6),"remove afx",true)
call TriggerRegisterPlayerChatEvent(Wi,Player(7),"remove afx",true)
call TriggerRegisterPlayerChatEvent(Wi,Player(8),"remove afx",true)
call TriggerRegisterPlayerChatEvent(Wi,Player(9),"remove afx",true)
call TriggerRegisterPlayerChatEvent(Wi,Player($A),"remove afx",true)
call TriggerRegisterPlayerChatEvent(Wi,Player($B),"remove afx",true)
call TriggerAddAction(Wi,ebv)
set Ei=CreateTrigger()
call TriggerRegisterPlayerChatEvent(Ei,Player(0),"@missile",true)
call TriggerRegisterPlayerChatEvent(Ei,Player(1),"@missile",true)
call TriggerRegisterPlayerChatEvent(Ei,Player(2),"@missile",true)
call TriggerRegisterPlayerChatEvent(Ei,Player(3),"@missile",true)
call TriggerRegisterPlayerChatEvent(Ei,Player(4),"@missile",true)
call TriggerRegisterPlayerChatEvent(Ei,Player(5),"@missile",true)
call TriggerRegisterPlayerChatEvent(Ei,Player(6),"@missile",true)
call TriggerRegisterPlayerChatEvent(Ei,Player(7),"@missile",true)
call TriggerRegisterPlayerChatEvent(Ei,Player(8),"@missile",true)
call TriggerRegisterPlayerChatEvent(Ei,Player(9),"@missile",true)
call TriggerRegisterPlayerChatEvent(Ei,Player($A),"@missile",true)
call TriggerRegisterPlayerChatEvent(Ei,Player($B),"@missile",true)
call TriggerAddAction(Ei,ecv)
set Zi=CreateTrigger()
call TriggerRegisterPlayerChatEvent(Zi,Player(0),"add",false)
call TriggerRegisterPlayerChatEvent(Zi,Player(1),"add",false)
call TriggerRegisterPlayerChatEvent(Zi,Player(2),"add",false)
call TriggerRegisterPlayerChatEvent(Zi,Player(3),"add",false)
call TriggerRegisterPlayerChatEvent(Zi,Player(4),"add",false)
call TriggerRegisterPlayerChatEvent(Zi,Player(5),"add",false)
call TriggerRegisterPlayerChatEvent(Zi,Player(6),"add",false)
call TriggerRegisterPlayerChatEvent(Zi,Player(7),"add",false)
call TriggerRegisterPlayerChatEvent(Zi,Player(8),"add",false)
call TriggerRegisterPlayerChatEvent(Zi,Player(9),"add",false)
call TriggerRegisterPlayerChatEvent(Zi,Player($A),"add",false)
call TriggerRegisterPlayerChatEvent(Zi,Player($B),"add",false)
call TriggerAddCondition(Zi,Condition(eCv))
call TriggerAddAction(Zi,edv)
set Ui=CreateTrigger()
call TriggerRegisterPlayerChatEvent(Ui,Player(0),"max",false)
call TriggerRegisterPlayerChatEvent(Ui,Player(1),"max",false)
call TriggerRegisterPlayerChatEvent(Ui,Player(2),"max",false)
call TriggerRegisterPlayerChatEvent(Ui,Player(3),"max",false)
call TriggerRegisterPlayerChatEvent(Ui,Player(4),"max",false)
call TriggerRegisterPlayerChatEvent(Ui,Player(5),"max",false)
call TriggerRegisterPlayerChatEvent(Ui,Player(6),"max",false)
call TriggerRegisterPlayerChatEvent(Ui,Player(7),"max",false)
call TriggerRegisterPlayerChatEvent(Ui,Player(8),"max",false)
call TriggerRegisterPlayerChatEvent(Ui,Player(9),"max",false)
call TriggerRegisterPlayerChatEvent(Ui,Player($A),"max",false)
call TriggerRegisterPlayerChatEvent(Ui,Player($B),"max",false)
call TriggerAddCondition(Ui,Condition(eDv))
call TriggerAddAction(Ui,efv)
set Ii=CreateTrigger()
call AIv(Ii,"ai ",false)
call TriggerAddCondition(Ii,Condition(ejv))
call TriggerAddAction(Ii,eJv)
set Pi=CreateTrigger()
call Avv(Pi,EVENT_PLAYER_UNIT_DEATH)
call TriggerAddCondition(Pi,Condition(elv))
call TriggerAddAction(Pi,eLv)
set Ai=CreateTrigger()
call AIv(Ai,"'",false)
call TriggerAddCondition(Ai,Condition(ePv))
call TriggerAddAction(Ai,eqv)
set Di=CreateTrigger()
call AIv(Di,"@",false)
call TriggerAddCondition(Di,Condition(etv))
call TriggerAddAction(Di,eTv)
set Hi=CreateTrigger()
call AIv(Hi,"equip",false)
call TriggerAddAction(Hi,ewv)
set Ji=CreateTrigger()
call TriggerRegisterPlayerChatEvent(Ji,Player(0),"@",false)
call TriggerRegisterPlayerChatEvent(Ji,Player(1),"@",false)
call TriggerRegisterPlayerChatEvent(Ji,Player(2),"@",false)
call TriggerRegisterPlayerChatEvent(Ji,Player(3),"@",false)
call TriggerRegisterPlayerChatEvent(Ji,Player(4),"@",false)
call TriggerRegisterPlayerChatEvent(Ji,Player(5),"@",false)
call TriggerRegisterPlayerChatEvent(Ji,Player(6),"@",false)
call TriggerRegisterPlayerChatEvent(Ji,Player(7),"@",false)
call TriggerRegisterPlayerChatEvent(Ji,Player(8),"@",false)
call TriggerRegisterPlayerChatEvent(Ji,Player(9),"@",false)
call TriggerRegisterPlayerChatEvent(Ji,Player($A),"@",false)
call TriggerRegisterPlayerChatEvent(Ji,Player($B),"@",false)
call TriggerAddCondition(Ji,Condition(eYv))
call TriggerAddAction(Ji,ezv)
set Ki=CreateTrigger()
call AIv(Ki,"*",false)
call TriggerAddCondition(Ki,Condition(e_v))
call TriggerAddAction(Ki,e0v)
set Li=CreateTrigger()
call TriggerRegisterPlayerChatEvent(Li,Player(0),"item",false)
call TriggerRegisterPlayerChatEvent(Li,Player(1),"item",false)
call TriggerRegisterPlayerChatEvent(Li,Player(2),"item",false)
call TriggerRegisterPlayerChatEvent(Li,Player(3),"item",false)
call TriggerRegisterPlayerChatEvent(Li,Player(4),"item",false)
call TriggerRegisterPlayerChatEvent(Li,Player(5),"item",false)
call TriggerRegisterPlayerChatEvent(Li,Player(6),"item",false)
call TriggerRegisterPlayerChatEvent(Li,Player(7),"item",false)
call TriggerRegisterPlayerChatEvent(Li,Player(8),"item",false)
call TriggerRegisterPlayerChatEvent(Li,Player(9),"item",false)
call TriggerRegisterPlayerChatEvent(Li,Player($A),"item",false)
call TriggerRegisterPlayerChatEvent(Li,Player($B),"item",false)
call TriggerAddCondition(Li,Condition(e2v))
call TriggerAddAction(Li,e3v)
set Xi=CreateTrigger()
call AIv(Xi,"ic ",false)
call TriggerAddCondition(Xi,Condition(e6v))
call TriggerAddAction(Xi,e7v)
set Ci=CreateTrigger()
call AIv(Ci,"idod ",false)
call TriggerAddCondition(Ci,Condition(xvv))
call TriggerAddAction(Ci,xev)
set Vi=CreateTrigger()
call Avv(Vi,EVENT_PLAYER_UNIT_PICKUP_ITEM)
call TriggerAddAction(Vi,xxv)
set Bi=CreateTrigger()
call TriggerRegisterPlayerChatEvent(Bi,Player(0),"uidb",true)
call TriggerRegisterPlayerChatEvent(Bi,Player(1),"uidb",true)
call TriggerRegisterPlayerChatEvent(Bi,Player(2),"uidb",true)
call TriggerRegisterPlayerChatEvent(Bi,Player(3),"uidb",true)
call TriggerRegisterPlayerChatEvent(Bi,Player(4),"uidb",true)
call TriggerRegisterPlayerChatEvent(Bi,Player(5),"uidb",true)
call TriggerRegisterPlayerChatEvent(Bi,Player(6),"uidb",true)
call TriggerRegisterPlayerChatEvent(Bi,Player(7),"uidb",true)
call TriggerRegisterPlayerChatEvent(Bi,Player(8),"uidb",true)
call TriggerRegisterPlayerChatEvent(Bi,Player(9),"uidb",true)
call TriggerRegisterPlayerChatEvent(Bi,Player($A),"uidb",true)
call TriggerRegisterPlayerChatEvent(Bi,Player($B),"uidb",true)
call TriggerAddAction(Bi,xov)
set Ni=CreateTrigger()
call TriggerRegisterPlayerChatEvent(Ni,Player(0),"expgain",false)
call TriggerRegisterPlayerChatEvent(Ni,Player(1),"expgain",false)
call TriggerRegisterPlayerChatEvent(Ni,Player(2),"expgain",false)
call TriggerRegisterPlayerChatEvent(Ni,Player(3),"expgain",false)
call TriggerRegisterPlayerChatEvent(Ni,Player(4),"expgain",false)
call TriggerRegisterPlayerChatEvent(Ni,Player(5),"expgain",false)
call TriggerRegisterPlayerChatEvent(Ni,Player(6),"expgain",false)
call TriggerRegisterPlayerChatEvent(Ni,Player(7),"expgain",false)
call TriggerRegisterPlayerChatEvent(Ni,Player(8),"expgain",false)
call TriggerRegisterPlayerChatEvent(Ni,Player(9),"expgain",false)
call TriggerRegisterPlayerChatEvent(Ni,Player($A),"expgain",false)
call TriggerRegisterPlayerChatEvent(Ni,Player($B),"expgain",false)
call TriggerAddCondition(Ni,Condition(xav))
call TriggerAddAction(Ni,xnv)
set Mi=CreateTrigger()
call TriggerRegisterPlayerUnitEventSimple(Mi,Player(bj_PLAYER_NEUTRAL_VICTIM),EVENT_PLAYER_UNIT_SELL)
call TriggerAddCondition(Mi,Condition(xVv))
call TriggerAddAction(Mi,xEv)
set wS=CreateTrigger()
call AIv(wS,"delete attack",true)
call TriggerAddAction(wS,xRv)
set uS=CreateTrigger()
call AIv(uS,"@move",true)
call TriggerAddAction(uS,xNv)
set rS=CreateTrigger()
call TriggerRegisterPlayerChatEvent(rS,Player(0),"rules",false)
call TriggerRegisterPlayerChatEvent(rS,Player(1),"rules",false)
call TriggerRegisterPlayerChatEvent(rS,Player(2),"rules",false)
call TriggerRegisterPlayerChatEvent(rS,Player(3),"rules",false)
call TriggerRegisterPlayerChatEvent(rS,Player(4),"rules",false)
call TriggerRegisterPlayerChatEvent(rS,Player(5),"rules",false)
call TriggerRegisterPlayerChatEvent(rS,Player(6),"rules",false)
call TriggerRegisterPlayerChatEvent(rS,Player(7),"rules",false)
call TriggerRegisterPlayerChatEvent(rS,Player(8),"rules",false)
call TriggerRegisterPlayerChatEvent(rS,Player(9),"rules",false)
call TriggerRegisterPlayerChatEvent(rS,Player($A),"rules",false)
call TriggerRegisterPlayerChatEvent(rS,Player($B),"rules",false)
call TriggerAddAction(rS,xBv)
set sS=CreateTrigger()
call TriggerRegisterPlayerChatEvent(sS,Player(0),"on",false)
call TriggerRegisterPlayerChatEvent(sS,Player(1),"on",false)
call TriggerRegisterPlayerChatEvent(sS,Player(2),"on",false)
call TriggerRegisterPlayerChatEvent(sS,Player(3),"on",false)
call TriggerRegisterPlayerChatEvent(sS,Player(4),"on",false)
call TriggerRegisterPlayerChatEvent(sS,Player(5),"on",false)
call TriggerRegisterPlayerChatEvent(sS,Player(6),"on",false)
call TriggerRegisterPlayerChatEvent(sS,Player(7),"on",false)
call TriggerRegisterPlayerChatEvent(sS,Player(8),"on",false)
call TriggerRegisterPlayerChatEvent(sS,Player(9),"on",false)
call TriggerRegisterPlayerChatEvent(sS,Player($A),"on",false)
call TriggerRegisterPlayerChatEvent(sS,Player($B),"on",false)
call TriggerRegisterPlayerChatEvent(sS,Player(0),"off",false)
call TriggerRegisterPlayerChatEvent(sS,Player(1),"off",false)
call TriggerRegisterPlayerChatEvent(sS,Player(2),"off",false)
call TriggerRegisterPlayerChatEvent(sS,Player(3),"off",false)
call TriggerRegisterPlayerChatEvent(sS,Player(4),"off",false)
call TriggerRegisterPlayerChatEvent(sS,Player(5),"off",false)
call TriggerRegisterPlayerChatEvent(sS,Player(6),"off",false)
call TriggerRegisterPlayerChatEvent(sS,Player(7),"off",false)
call TriggerRegisterPlayerChatEvent(sS,Player(8),"off",false)
call TriggerRegisterPlayerChatEvent(sS,Player(9),"off",false)
call TriggerRegisterPlayerChatEvent(sS,Player($A),"off",false)
call TriggerRegisterPlayerChatEvent(sS,Player($B),"off",false)
call TriggerAddAction(sS,xcv)
set tS=CreateTrigger()
call TriggerRegisterPlayerChatEvent(tS,Player(0),"timer",false)
call TriggerRegisterPlayerChatEvent(tS,Player(1),"timer",false)
call TriggerRegisterPlayerChatEvent(tS,Player(2),"timer",false)
call TriggerRegisterPlayerChatEvent(tS,Player(3),"timer",false)
call TriggerRegisterPlayerChatEvent(tS,Player(4),"timer",false)
call TriggerRegisterPlayerChatEvent(tS,Player(5),"timer",false)
call TriggerRegisterPlayerChatEvent(tS,Player(6),"timer",false)
call TriggerRegisterPlayerChatEvent(tS,Player(7),"timer",false)
call TriggerRegisterPlayerChatEvent(tS,Player(8),"timer",false)
call TriggerRegisterPlayerChatEvent(tS,Player(9),"timer",false)
call TriggerRegisterPlayerChatEvent(tS,Player($A),"timer",false)
call TriggerRegisterPlayerChatEvent(tS,Player($B),"timer",false)
call TriggerAddAction(tS,xCv)
set iS=CreateTrigger()
call AIv(iS,"roll",false)
call TriggerAddCondition(iS,Condition(xdv))
call TriggerAddAction(iS,xDv)
set SS=CreateTrigger()
call TriggerRegisterPlayerChatEvent(SS,Player(0),"watertint",false)
call TriggerRegisterPlayerChatEvent(SS,Player(1),"watertint",false)
call TriggerRegisterPlayerChatEvent(SS,Player(2),"watertint",false)
call TriggerRegisterPlayerChatEvent(SS,Player(3),"watertint",false)
call TriggerRegisterPlayerChatEvent(SS,Player(4),"watertint",false)
call TriggerRegisterPlayerChatEvent(SS,Player(5),"watertint",false)
call TriggerRegisterPlayerChatEvent(SS,Player(6),"watertint",false)
call TriggerRegisterPlayerChatEvent(SS,Player(7),"watertint",false)
call TriggerRegisterPlayerChatEvent(SS,Player(8),"watertint",false)
call TriggerRegisterPlayerChatEvent(SS,Player(9),"watertint",false)
call TriggerRegisterPlayerChatEvent(SS,Player($A),"watertint",false)
call TriggerRegisterPlayerChatEvent(SS,Player($B),"watertint",false)
call TriggerAddCondition(SS,Condition(xfv))
call TriggerAddAction(SS,xFv)
set cS=CreateTrigger()
call TriggerRegisterPlayerChatEvent(cS,Player(0),"sky",false)
call TriggerRegisterPlayerChatEvent(cS,Player(1),"sky",false)
call TriggerRegisterPlayerChatEvent(cS,Player(2),"sky",false)
call TriggerRegisterPlayerChatEvent(cS,Player(3),"sky",false)
call TriggerRegisterPlayerChatEvent(cS,Player(4),"sky",false)
call TriggerRegisterPlayerChatEvent(cS,Player(5),"sky",false)
call TriggerRegisterPlayerChatEvent(cS,Player(6),"sky",false)
call TriggerRegisterPlayerChatEvent(cS,Player(7),"sky",false)
call TriggerRegisterPlayerChatEvent(cS,Player(8),"sky",false)
call TriggerRegisterPlayerChatEvent(cS,Player(9),"sky",false)
call TriggerRegisterPlayerChatEvent(cS,Player($A),"sky",false)
call TriggerRegisterPlayerChatEvent(cS,Player($B),"sky",false)
call TriggerAddCondition(cS,Condition(xgv))
call TriggerAddAction(cS,xGv)
set oS=CreateTrigger()
call AIv(oS,"gate",false)
call TriggerAddAction(oS,xmv)
set OS=CreateTrigger()
call TriggerRegisterPlayerChatEvent(OS,Player(0),"tree",false)
call TriggerRegisterPlayerChatEvent(OS,Player(1),"tree",false)
call TriggerRegisterPlayerChatEvent(OS,Player(2),"tree",false)
call TriggerRegisterPlayerChatEvent(OS,Player(3),"tree",false)
call TriggerRegisterPlayerChatEvent(OS,Player(4),"tree",false)
call TriggerRegisterPlayerChatEvent(OS,Player(5),"tree",false)
call TriggerRegisterPlayerChatEvent(OS,Player(6),"tree",false)
call TriggerRegisterPlayerChatEvent(OS,Player(7),"tree",false)
call TriggerRegisterPlayerChatEvent(OS,Player(8),"tree",false)
call TriggerRegisterPlayerChatEvent(OS,Player(9),"tree",false)
call TriggerRegisterPlayerChatEvent(OS,Player($A),"tree",false)
call TriggerRegisterPlayerChatEvent(OS,Player($B),"tree",false)
call TriggerAddAction(OS,xuv)
set lS=CreateTrigger()
call TriggerRegisterPlayerChatEvent(lS,Player(0),"time",false)
call TriggerRegisterPlayerChatEvent(lS,Player(1),"time",false)
call TriggerRegisterPlayerChatEvent(lS,Player(2),"time",false)
call TriggerRegisterPlayerChatEvent(lS,Player(3),"time",false)
call TriggerRegisterPlayerChatEvent(lS,Player(4),"time",false)
call TriggerRegisterPlayerChatEvent(lS,Player(5),"time",false)
call TriggerRegisterPlayerChatEvent(lS,Player(6),"time",false)
call TriggerRegisterPlayerChatEvent(lS,Player(7),"time",false)
call TriggerRegisterPlayerChatEvent(lS,Player(8),"time",false)
call TriggerRegisterPlayerChatEvent(lS,Player(9),"time",false)
call TriggerRegisterPlayerChatEvent(lS,Player($A),"time",false)
call TriggerRegisterPlayerChatEvent(lS,Player($B),"time",false)
call TriggerAddCondition(lS,Condition(xUv))
call TriggerAddAction(lS,xwv)
set bS=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(bS,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(bS,Condition(xWv))
call TriggerAddAction(bS,xyv)
set yS=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(yS,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(yS,Condition(xYv))
call TriggerAddAction(yS,xzv)
set pS=CreateTrigger()
call Avv(pS,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(pS,Condition(xZv))
call TriggerAddAction(pS,x_v)
set eS=CreateTrigger()
call Avv(eS,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(eS,Condition(x0v))
call TriggerAddAction(eS,x1v)
set qS=CreateTrigger()
call Avv(qS,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(qS,Condition(x2v))
call TriggerAddAction(qS,x3v)
set aS=CreateTrigger()
call Avv(aS,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(aS,Condition(x4v))
call TriggerAddAction(aS,x5v)
set nS=CreateTrigger()
call TriggerAddCondition(nS,Condition(x6v))
call TriggerAddAction(nS,x7v)
set dS=CreateTrigger()
call TriggerRegisterPlayerEventLeave(dS,Player(0))
call TriggerRegisterPlayerEventLeave(dS,Player(1))
call TriggerRegisterPlayerEventLeave(dS,Player(2))
call TriggerRegisterPlayerEventLeave(dS,Player(3))
call TriggerRegisterPlayerEventLeave(dS,Player(4))
call TriggerRegisterPlayerEventLeave(dS,Player(5))
call TriggerRegisterPlayerEventLeave(dS,Player(6))
call TriggerRegisterPlayerEventLeave(dS,Player(7))
call TriggerRegisterPlayerEventLeave(dS,Player(8))
call TriggerRegisterPlayerEventLeave(dS,Player(9))
call TriggerRegisterPlayerEventLeave(dS,Player($A))
call TriggerRegisterPlayerEventLeave(dS,Player($B))
call TriggerAddAction(dS,x9v)
set fS=CreateTrigger()
call TriggerRegisterPlayerChatEvent(fS,Player(0),"bh",true)
call TriggerRegisterPlayerChatEvent(fS,Player(1),"bh",true)
call TriggerRegisterPlayerChatEvent(fS,Player(2),"bh",true)
call TriggerRegisterPlayerChatEvent(fS,Player(3),"bh",true)
call TriggerRegisterPlayerChatEvent(fS,Player(4),"bh",true)
call TriggerRegisterPlayerChatEvent(fS,Player(5),"bh",true)
call TriggerRegisterPlayerChatEvent(fS,Player(6),"bh",true)
call TriggerRegisterPlayerChatEvent(fS,Player(7),"bh",true)
call TriggerRegisterPlayerChatEvent(fS,Player(8),"bh",true)
call TriggerRegisterPlayerChatEvent(fS,Player(9),"bh",true)
call TriggerRegisterPlayerChatEvent(fS,Player($A),"bh",true)
call TriggerRegisterPlayerChatEvent(fS,Player($B),"bh",true)
call TriggerAddCondition(fS,Condition(ovv))
call TriggerAddAction(fS,oev)
set RS=CreateTrigger()
call TriggerRegisterTimerExpireEventBJ(RS,xw)
call TriggerAddAction(RS,oxv)
set TS=CreateTrigger()
call TriggerRegisterPlayerChatEvent(TS,Player(0),"settranslocationpoint",true)
call TriggerRegisterPlayerChatEvent(TS,Player(1),"settranslocationpoint",true)
call TriggerRegisterPlayerChatEvent(TS,Player(2),"settranslocationpoint",true)
call TriggerRegisterPlayerChatEvent(TS,Player(3),"settranslocationpoint",true)
call TriggerRegisterPlayerChatEvent(TS,Player(4),"settranslocationpoint",true)
call TriggerRegisterPlayerChatEvent(TS,Player(5),"settranslocationpoint",true)
call TriggerRegisterPlayerChatEvent(TS,Player(6),"settranslocationpoint",true)
call TriggerRegisterPlayerChatEvent(TS,Player(7),"settranslocationpoint",true)
call TriggerRegisterPlayerChatEvent(TS,Player(8),"settranslocationpoint",true)
call TriggerRegisterPlayerChatEvent(TS,Player(9),"settranslocationpoint",true)
call TriggerRegisterPlayerChatEvent(TS,Player($A),"settranslocationpoint",true)
call TriggerRegisterPlayerChatEvent(TS,Player($B),"settranslocationpoint",true)
call TriggerAddAction(TS,orv)
set YS=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(YS,EVENT_PLAYER_UNIT_SELL)
call TriggerAddAction(YS,oav)
set GS=CreateTrigger()
call Avv(GS,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(GS,Condition(onv))
call TriggerAddAction(GS,oVv)
set gS=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gS,EVENT_PLAYER_UNIT_CONSTRUCT_FINISH)
call TriggerAddAction(gS,oEv)
set hS=CreateTrigger()
call Avv(hS,EVENT_PLAYER_UNIT_ISSUED_POINT_ORDER)
call TriggerAddCondition(hS,Condition(oXv))
call TriggerAddAction(hS,oOv)
set FS=CreateTrigger()
call Avv(FS,EVENT_PLAYER_UNIT_ISSUED_POINT_ORDER)
call TriggerAddCondition(FS,Condition(oRv))
call TriggerAddAction(FS,oIv)
set kS=CreateTrigger()
call Avv(kS,EVENT_PLAYER_UNIT_ISSUED_TARGET_ORDER)
call TriggerAddCondition(kS,Condition(oAv))
call TriggerAddAction(kS,oNv)
set jS=CreateTrigger()
call Avv(jS,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(jS,Condition(obv))
call TriggerAddAction(jS,oBv)
set xS=CreateTrigger()
call Avv(xS,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(xS,Condition(ocv))
call TriggerAddAction(xS,oCv)
set vS=CreateTrigger()
call Avv(vS,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(vS,Condition(odv))
call TriggerAddAction(vS,oDv)
set mS=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(mS,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(mS,Condition(oFv))
call TriggerAddAction(mS,ogv)
set QS=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(QS,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(QS,Condition(ohv))
call TriggerAddAction(QS,oHv)
set WS=CreateTrigger()
call Avv(WS,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddAction(WS,okv)
call TriggerAddCondition(WS,Condition(oKv))
set ES=CreateTrigger()
call Avv(ES,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddAction(ES,olv)
call TriggerAddCondition(ES,Condition(oLv))
set ZS=CreateTrigger()
call Avv(ZS,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddAction(ZS,omv)
call TriggerAddCondition(ZS,Condition(oMv))
set US=CreateTrigger()
call Avv(US,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddAction(US,opv)
call TriggerAddCondition(US,Condition(oPv))
set IS=CreateTrigger()
call TriggerAddAction(IS,oqv)
set PS=CreateTrigger()
call DisableTrigger(PS)
call TriggerRegisterTimerEventPeriodic(PS,.02)
call TriggerAddAction(PS,otv)
set AS=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(AS,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(AS,Condition(oTv))
call TriggerAddAction(AS,ouv)
set DS=CreateTrigger()
call TriggerAddAction(DS,oUv)
set HS=CreateTrigger()
call DisableTrigger(HS)
call TriggerRegisterTimerEventPeriodic(HS,.02)
call TriggerAddAction(HS,oWv)
set JS=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(JS,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(JS,Condition(oyv))
call TriggerAddAction(JS,oYv)
set KS=CreateTrigger()
call TriggerAddAction(KS,ozv)
set LS=CreateTrigger()
call TriggerAddAction(LS,oZv)
set XS=CreateTrigger()
call DisableTrigger(XS)
call TriggerRegisterTimerEventPeriodic(XS,.02)
call TriggerAddAction(XS,o0v)
set CS=CreateTrigger()
call DisableTrigger(CS)
call TriggerRegisterTimerEventPeriodic(CS,.02)
call TriggerAddAction(CS,o2v)
set VS=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(VS,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(VS,Condition(o3v))
call TriggerAddAction(VS,o4v)
set BS=CreateTrigger()
call AIv(BS,"undead",false)
call TriggerAddAction(BS,o8v)
set NS=CreateTrigger()
call AIv(NS,"tauren",false)
call TriggerAddAction(NS,rxv)
set MS=CreateTrigger()
call AIv(MS,"mechanical",false)
call TriggerAddAction(MS,rav)
set wc=CreateTrigger()
call AIv(wc,"building",false)
call TriggerAddAction(wc,rEv)
set uc=CreateTrigger()
call AIv(uc,"worker",false)
call TriggerAddAction(uc,rIv)
set rc=CreateTrigger()
call TriggerRegisterPlayerChatEvent(rc,Player(0),"item",false)
call TriggerRegisterPlayerChatEvent(rc,Player(1),"item",false)
call TriggerRegisterPlayerChatEvent(rc,Player(2),"item",false)
call TriggerRegisterPlayerChatEvent(rc,Player(3),"item",false)
call TriggerRegisterPlayerChatEvent(rc,Player(4),"item",false)
call TriggerRegisterPlayerChatEvent(rc,Player(5),"item",false)
call TriggerRegisterPlayerChatEvent(rc,Player(6),"item",false)
call TriggerRegisterPlayerChatEvent(rc,Player(7),"item",false)
call TriggerRegisterPlayerChatEvent(rc,Player(8),"item",false)
call TriggerRegisterPlayerChatEvent(rc,Player(9),"item",false)
call TriggerRegisterPlayerChatEvent(rc,Player($A),"item",false)
call TriggerRegisterPlayerChatEvent(rc,Player($B),"item",false)
call TriggerAddCondition(rc,Condition(rNv))
call TriggerAddAction(rc,rbv)
set sc=CreateTrigger()
call TriggerRegisterPlayerChatEvent(sc,Player(0),"item",false)
call TriggerRegisterPlayerChatEvent(sc,Player(1),"item",false)
call TriggerRegisterPlayerChatEvent(sc,Player(2),"item",false)
call TriggerRegisterPlayerChatEvent(sc,Player(3),"item",false)
call TriggerRegisterPlayerChatEvent(sc,Player(4),"item",false)
call TriggerRegisterPlayerChatEvent(sc,Player(5),"item",false)
call TriggerRegisterPlayerChatEvent(sc,Player(6),"item",false)
call TriggerRegisterPlayerChatEvent(sc,Player(7),"item",false)
call TriggerRegisterPlayerChatEvent(sc,Player(8),"item",false)
call TriggerRegisterPlayerChatEvent(sc,Player(9),"item",false)
call TriggerRegisterPlayerChatEvent(sc,Player($A),"item",false)
call TriggerRegisterPlayerChatEvent(sc,Player($B),"item",false)
call TriggerAddCondition(sc,Condition(rcv))
call TriggerAddAction(sc,rCv)
set tc=CreateTrigger()
call TriggerRegisterPlayerChatEvent(tc,Player(0),"item",false)
call TriggerRegisterPlayerChatEvent(tc,Player(1),"item",false)
call TriggerRegisterPlayerChatEvent(tc,Player(2),"item",false)
call TriggerRegisterPlayerChatEvent(tc,Player(3),"item",false)
call TriggerRegisterPlayerChatEvent(tc,Player(4),"item",false)
call TriggerRegisterPlayerChatEvent(tc,Player(5),"item",false)
call TriggerRegisterPlayerChatEvent(tc,Player(6),"item",false)
call TriggerRegisterPlayerChatEvent(tc,Player(7),"item",false)
call TriggerRegisterPlayerChatEvent(tc,Player(8),"item",false)
call TriggerRegisterPlayerChatEvent(tc,Player(9),"item",false)
call TriggerRegisterPlayerChatEvent(tc,Player($A),"item",false)
call TriggerRegisterPlayerChatEvent(tc,Player($B),"item",false)
call TriggerAddCondition(tc,Condition(rDv))
call TriggerAddAction(tc,rfv)
set ic=CreateTrigger()
call TriggerRegisterPlayerChatEvent(ic,Player(0),"item",false)
call TriggerRegisterPlayerChatEvent(ic,Player(1),"item",false)
call TriggerRegisterPlayerChatEvent(ic,Player(2),"item",false)
call TriggerRegisterPlayerChatEvent(ic,Player(3),"item",false)
call TriggerRegisterPlayerChatEvent(ic,Player(4),"item",false)
call TriggerRegisterPlayerChatEvent(ic,Player(5),"item",false)
call TriggerRegisterPlayerChatEvent(ic,Player(6),"item",false)
call TriggerRegisterPlayerChatEvent(ic,Player(7),"item",false)
call TriggerRegisterPlayerChatEvent(ic,Player(8),"item",false)
call TriggerRegisterPlayerChatEvent(ic,Player(9),"item",false)
call TriggerRegisterPlayerChatEvent(ic,Player($A),"item",false)
call TriggerRegisterPlayerChatEvent(ic,Player($B),"item",false)
call TriggerAddCondition(ic,Condition(rgv))
call TriggerAddAction(ic,rGv)
set Sc=CreateTrigger()
call TriggerRegisterPlayerChatEvent(Sc,Player(0),"frostblast",false)
call TriggerRegisterPlayerChatEvent(Sc,Player(1),"frostblast",false)
call TriggerRegisterPlayerChatEvent(Sc,Player(2),"frostblast",false)
call TriggerRegisterPlayerChatEvent(Sc,Player(3),"frostblast",false)
call TriggerRegisterPlayerChatEvent(Sc,Player(4),"frostblast",false)
call TriggerRegisterPlayerChatEvent(Sc,Player(5),"frostblast",false)
call TriggerRegisterPlayerChatEvent(Sc,Player(6),"frostblast",false)
call TriggerRegisterPlayerChatEvent(Sc,Player(7),"frostblast",false)
call TriggerRegisterPlayerChatEvent(Sc,Player(8),"frostblast",false)
call TriggerRegisterPlayerChatEvent(Sc,Player(9),"frostblast",false)
call TriggerRegisterPlayerChatEvent(Sc,Player($A),"frostblast",false)
call TriggerRegisterPlayerChatEvent(Sc,Player($B),"frostblast",false)
call TriggerAddAction(Sc,rJv)
set cc=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(cc,EVENT_PLAYER_UNIT_SPELL_FINISH)
call TriggerAddCondition(cc,Condition(rkv))
call TriggerAddAction(cc,rKv)
set oc=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(oc,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(oc,Condition(rlv))
call TriggerAddAction(oc,rLv)
set Oc=CreateTrigger()
call AIv(Oc,"focus",false)
call TriggerAddAction(Oc,rPv)
set lc=CreateTrigger()
call AIv(lc,"stickygrenade",false)
call TriggerAddAction(lc,rSv)
set bc=CreateTrigger()
call AIv(bc,"etherealform",false)
call TriggerAddAction(bc,rUv)
set yc=CreateTrigger()
call AIv(yc,"boosterjets",false)
call TriggerAddAction(yc,rYv)
set pc=CreateTrigger()
call AIv(pc,"heroaltertime",false)
call TriggerAddAction(pc,r0v)
set ec=CreateTrigger()
call AIv(ec,"clotofenergy",false)
call TriggerAddAction(ec,r4v)
set qc=CreateTrigger()
call AIv(qc,"translocation",false)
call TriggerAddAction(qc,r8v)
set ac=CreateTrigger()
call AIv(ac,"immunitytoprolongedlossofcontrol",false)
call TriggerAddAction(ac,ixv)
set nc=CreateTrigger()
call AIv(nc,"nocooldown",false)
call TriggerAddAction(nc,iav)
set dc=CreateTrigger()
call AIv(dc,"heromagearmor",false)
call TriggerAddAction(dc,iXv)
set fc=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(fc,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(fc,Condition(iOv))
call TriggerAddAction(fc,iRv)
set Rc=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(Rc,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(Rc,Condition(iIv))
call TriggerAddAction(Rc,iAv)
set Tc=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(Tc,EVENT_PLAYER_UNIT_SPELL_CAST)
call TriggerAddCondition(Tc,Condition(iNv))
call TriggerAddAction(Tc,ibv)
set Yc=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(Yc,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(Yc,Condition(icv))
call TriggerAddAction(Yc,iCv)
set Gc=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(Gc,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(Gc,Condition(idv))
call TriggerAddAction(Gc,iDv)
set gc=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(gc,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(gc,Condition(ifv))
call TriggerAddAction(gc,iFv)
set hc=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(hc,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(hc,Condition(igv))
call TriggerAddAction(hc,iGv)
set Fc=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(Fc,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(Fc,Condition(ijv))
call TriggerAddAction(Fc,iJv)
set kc=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(kc,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(kc,Condition(ikv))
call TriggerAddAction(kc,iKv)
set jc=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(jc,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(jc,Condition(ilv))
call TriggerAddAction(jc,iLv)
set xc=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(xc,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(xc,Condition(imv))
call TriggerAddAction(xc,iMv)
set vc=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(vc,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(vc,Condition(ipv))
call TriggerAddAction(vc,iPv)
set mc=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(mc,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(mc,Condition(isv))
call TriggerAddAction(mc,iSv)
set Qc=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(Qc,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(Qc,Condition(itv))
call TriggerAddAction(Qc,iTv)
set Wc=CreateTrigger()
call TriggerAddCondition(Wc,Condition(iuv))
call TriggerAddAction(Wc,iUv)
set Ec=CreateTrigger()
call TriggerRegisterTimerEventPeriodic(Ec,.01)
call TriggerAddAction(Ec,iyv)
set Zc=CreateTrigger()
call TriggerRegisterTimerEventPeriodic(Zc,.01)
call TriggerAddAction(Zc,izv)
set Uc=CreateTrigger()
call TriggerAddCondition(Uc,Condition(iZv))
call TriggerAddAction(Uc,i_v)
set Ic=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(Ic,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(Ic,Condition(i0v))
call TriggerAddAction(Ic,i1v)
set Pc=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(Pc,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(Pc,Condition(i2v))
call TriggerAddAction(Pc,i3v)
set Ac=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(Ac,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(Ac,Condition(i4v))
call TriggerAddAction(Ac,i5v)
set Dc=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(Dc,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(Dc,Condition(i6v))
call TriggerAddAction(Dc,i7v)
set Hc=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(Hc,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(Hc,Condition(i8v))
call TriggerAddAction(Hc,i9v)
set Jc=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(Jc,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(Jc,Condition(avv))
call TriggerAddAction(Jc,aev)
set Kc=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(Kc,EVENT_PLAYER_UNIT_SPELL_CAST)
call TriggerAddCondition(Kc,Condition(axv))
call TriggerAddAction(Kc,aov)
set Lc=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(Lc,EVENT_PLAYER_UNIT_SPELL_CAST)
call TriggerAddCondition(Lc,Condition(arv))
call TriggerAddAction(Lc,aiv)
set Xc=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(Xc,EVENT_PLAYER_UNIT_SPELL_ENDCAST)
call TriggerAddCondition(Xc,Condition(aav))
call TriggerAddAction(Xc,anv)
set Cc=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(Cc,EVENT_PLAYER_UNIT_SPELL_CAST)
call TriggerAddCondition(Cc,Condition(aVv))
call TriggerAddAction(Cc,aEv)
set Vc=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(Vc,EVENT_PLAYER_UNIT_SPELL_ENDCAST)
call TriggerAddCondition(Vc,Condition(aXv))
call TriggerAddAction(Vc,aOv)
set Bc=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(Bc,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(Bc,Condition(aRv))
call TriggerAddAction(Bc,aIv)
set Nc=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(Nc,EVENT_PLAYER_UNIT_DEATH)
call TriggerAddCondition(Nc,Condition(aAv))
call TriggerAddAction(Nc,aNv)
set Mc=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(Mc,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(Mc,Condition(abv))
call TriggerAddAction(Mc,aBv)
set wo=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(wo,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(wo,Condition(acv))
call TriggerAddAction(wo,aCv)
set uo=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(uo,EVENT_PLAYER_UNIT_SPELL_FINISH)
call TriggerAddCondition(uo,Condition(adv))
call TriggerAddAction(uo,aDv)
set ro=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(ro,EVENT_PLAYER_UNIT_SPELL_FINISH)
call TriggerAddCondition(ro,Condition(afv))
call TriggerAddAction(ro,aFv)
set so=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(so,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(so,Condition(agv))
call TriggerAddAction(so,aGv)
set io=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(io,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(io,Condition(ajv))
call TriggerAddAction(io,aJv)
set So=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(So,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(So,Condition(akv))
call TriggerAddAction(So,aKv)
set co=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(co,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(co,Condition(alv))
call TriggerAddAction(co,aLv)
set oo=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(oo,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(oo,Condition(amv))
call TriggerAddAction(oo,aMv)
set Oo=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(Oo,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(Oo,Condition(apv))
call TriggerAddAction(Oo,aPv)
set lo=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(lo,EVENT_PLAYER_UNIT_ATTACKED)
call TriggerAddCondition(lo,Condition(aqv))
call TriggerAddAction(lo,aQv)
set bo=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(bo,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(bo,Condition(asv))
call TriggerAddAction(bo,aSv)
set yo=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(yo,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(yo,Condition(atv))
call TriggerAddAction(yo,aTv)
set po=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(po,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(po,Condition(auv))
call TriggerAddAction(po,aUv)
set eo=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(eo,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(eo,Condition(ayv))
call TriggerAddAction(eo,aYv)
set qo=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(qo,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(qo,Condition(aZv))
call TriggerAddAction(qo,a_v)
set ao=CreateTrigger()
call TriggerRegisterTimerEventPeriodic(ao,.01)
call TriggerAddAction(ao,a2v)
set no=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(no,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(no,Condition(a3v))
call TriggerAddAction(no,a4v)
set do=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(do,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(do,Condition(a5v))
call TriggerAddAction(do,a6v)
set fo=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(fo,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(fo,Condition(a7v))
call TriggerAddAction(fo,a8v)
set Ro=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(Ro,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(Ro,Condition(a9v))
call TriggerAddAction(Ro,nvv)
set To=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(To,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(To,Condition(nev))
call TriggerAddAction(To,nxv)
set Yo=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(Yo,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(Yo,Condition(nov))
call TriggerAddAction(Yo,nrv)
set Go=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(Go,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(Go,Condition(niv))
call TriggerAddAction(Go,nav)
set go=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(go,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(go,Condition(nnv))
call TriggerAddAction(go,nVv)
set ho=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(ho,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(ho,Condition(nEv))
call TriggerAddAction(ho,nXv)
set Fo=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(Fo,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(Fo,Condition(nOv))
call TriggerAddAction(Fo,nRv)
set ko=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(ko,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(ko,Condition(nIv))
call TriggerAddAction(ko,nAv)
set jo=CreateTrigger()
call Avv(jo,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(jo,Condition(nNv))
call TriggerAddAction(jo,nbv)
set xo=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(xo,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(xo,Condition(nBv))
call TriggerAddAction(xo,ncv)
set vo=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(vo,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(vo,Condition(nCv))
call TriggerAddAction(vo,ndv)
set mo=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(mo,EVENT_PLAYER_UNIT_SPELL_CAST)
call TriggerAddCondition(mo,Condition(nDv))
call TriggerAddAction(mo,nfv)
set Qo=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(Qo,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddAction(Qo,nGv)
set Wo=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(Wo,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(Wo,Condition(nhv))
call TriggerAddAction(Wo,nHv)
set Eo=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(Eo,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(Eo,Condition(njv))
call TriggerAddAction(Eo,nJv)
set Zo=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(Zo,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(Zo,Condition(nkv))
call TriggerAddAction(Zo,nKv)
set Uo=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(Uo,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(Uo,Condition(nlv))
call TriggerAddAction(Uo,nLv)
set Io=CreateTrigger()
call TriggerRegisterTimerEvent(Io,1.,true)
call TriggerAddAction(Io,nMv)
set Po=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(Po,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(Po,Condition(nsv))
call TriggerAddAction(Po,nSv)
set Ao=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(Ao,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(Ao,Condition(nuv))
call TriggerAddAction(Ao,nUv)
set Do=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(Do,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(Do,Condition(nyv))
call TriggerAddAction(Do,nYv)
set Ho=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(Ho,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(Ho,Condition(n_v))
call TriggerAddAction(Ho,n0v)
set Jo=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(Jo,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(Jo,Condition(n3v))
call TriggerAddAction(Jo,n4v)
set Ko=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(Ko,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(Ko,Condition(n5v))
call TriggerAddAction(Ko,n6v)
set Lo=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(Lo,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(Lo,Condition(n9v))
call TriggerAddAction(Lo,Vvv)
set Xo=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(Xo,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(Xo,Condition(Vxv))
call TriggerAddAction(Xo,Vov)
set Co=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(Co,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(Co,Condition(Vrv))
call TriggerAddAction(Co,Viv)
set Vo=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(Vo,EVENT_PLAYER_UNIT_SPELL_FINISH)
call TriggerAddCondition(Vo,Condition(Vav))
call TriggerAddAction(Vo,Vnv)
set Bo=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(Bo,EVENT_PLAYER_UNIT_SPELL_CAST)
call TriggerAddCondition(Bo,Condition(VVv))
call TriggerAddAction(Bo,VEv)
set No=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(No,EVENT_PLAYER_UNIT_SPELL_CAST)
call TriggerAddCondition(No,Condition(VXv))
call TriggerAddAction(No,VOv)
set Mo=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(Mo,EVENT_PLAYER_UNIT_SPELL_CAST)
call TriggerAddCondition(Mo,Condition(VRv))
call TriggerAddAction(Mo,VIv)
set wO=CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(wO,EVENT_PLAYER_UNIT_SPELL_CAST)
call TriggerAddCondition(wO,Condition(VAv))
call TriggerAddAction(wO,VNv)
set uO=CreateTrigger()
call Avv(uO,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(uO,Condition(Vbv))
call TriggerAddAction(uO,VBv)
set rO=CreateTrigger()
call Avv(rO,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(rO,Condition(Vcv))
call TriggerAddAction(rO,VCv)
set sO=CreateTrigger()
call Avv(sO,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(sO,Condition(Vdv))
call TriggerAddAction(sO,VDv)
set tO=CreateTrigger()
call Avv(tO,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(tO,Condition(Vfv))
call TriggerAddAction(tO,VFv)
set iO=CreateTrigger()
call Avv(iO,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(iO,Condition(Vgv))
call TriggerAddAction(iO,VGv)
set SO=CreateTrigger()
call Avv(SO,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(SO,Condition(Vhv))
call TriggerAddAction(SO,VHv)
set cO=CreateTrigger()
call Avv(cO,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(cO,Condition(Vjv))
call TriggerAddAction(cO,VJv)
set oO=CreateTrigger()
call Avv(oO,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(oO,Condition(Vlv))
call TriggerAddAction(oO,VLv)
set OO=CreateTrigger()
call Avv(OO,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(OO,Condition(VMv))
call TriggerAddAction(OO,Vpv)
set lO=CreateTrigger()
call Avv(lO,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(lO,Condition(VQv))
call TriggerAddAction(lO,Vsv)
set bO=CreateTrigger()
call Avv(bO,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(bO,Condition(VSv))
call TriggerAddAction(bO,Vtv)
set yO=CreateTrigger()
call Avv(yO,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(yO,Condition(Vuv))
call TriggerAddAction(yO,VUv)
set pO=CreateTrigger()
call Avv(pO,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(pO,Condition(VWv))
call TriggerAddAction(pO,Vyv)
set eO=CreateTrigger()
call Avv(eO,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(eO,Condition(VYv))
call TriggerAddAction(eO,Vzv)
set qO=CreateTrigger()
call Avv(qO,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(qO,Condition(V_v))
call TriggerAddAction(qO,V0v)
set aO=CreateTrigger()
call Avv(aO,EVENT_PLAYER_UNIT_SPELL_ENDCAST)
call TriggerAddCondition(aO,Condition(V1v))
call TriggerAddAction(aO,V2v)
set nO=CreateTrigger()
call Avv(nO,EVENT_PLAYER_UNIT_SPELL_EFFECT)
call TriggerAddCondition(nO,Condition(V3v))
call TriggerAddAction(nO,V4v)
set dO=CreateTrigger()
call TriggerAddAction(dO,V5v)
call ConditionalTriggerExecute(Jt)
call ConditionalTriggerExecute(hi)
call ConditionalTriggerExecute(xi)
set aPX=CreateTrigger()
call TriggerAddCondition(aPX,Condition(V6v))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package Abilities.","when calling error in Abilities, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(V7v))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package AbilityIds.","when calling error in AbilityIds, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(V8v))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package Real.","when calling error in Real, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(V9v))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package Integer.","when calling error in Integer, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(Evv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package Angle.","when calling error in Angle, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(Eev))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package AttachmentPoints.","when calling error in AttachmentPoints, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(Exv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package String.","when calling error in String, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(Eov))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package Vectors.","when calling error in Vectors, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(Erv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package Destructable.","when calling error in Destructable, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(Eiv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package Maths.","when calling error in Maths, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(Eav))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package Player.","when calling error in Player, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(Env))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package Printing.","when calling error in Printing, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(EVv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package Basics.","when calling error in Basics, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(EEv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package GameTimer.","when calling error in GameTimer, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(EXv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package MagicFunctions.","when calling error in MagicFunctions, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(EOv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package ErrorHandling.","when calling error in ErrorHandling, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(ERv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package Matrices.","when calling error in Matrices, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(EIv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package Quaternion.","when calling error in Quaternion, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(EAv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package Table.","when calling error in Table, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(ENv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package Playercolor.","when calling error in Playercolor, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(Ebv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package Colors.","when calling error in Colors, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(EBv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package Group.","when calling error in Group, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(Ecv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package Lightning.","when calling error in Lightning, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(ECv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package WeatherEffects.","when calling error in WeatherEffects, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(Edv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package Framehandle.","when calling error in Framehandle, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(EDv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package TypeCasting.","when calling error in TypeCasting, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(Efv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package ClosureForGroups.","when calling error in ClosureForGroups, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(EFv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package LinkedList.","when calling error in LinkedList, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(Egv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package BitwiseInit.","when calling error in BitwiseInit, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(EGv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package StringUtils.","when calling error in StringUtils, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(Ehv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package Execute.","when calling error in Execute, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(EHv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package BigString.","when calling error in BigString, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(Ejv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package Base64.","when calling error in Base64, line 38")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(EJv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package BitSet.","when calling error in BitSet, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(Ekv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package Buildings.","when calling error in Buildings, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(EKv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package TargetsAllowed.","when calling error in TargetsAllowed, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(Elv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package Doodads.","when calling error in Doodads, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(ELv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package Icons.","when calling error in Icons, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(Emv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package Objects.","when calling error in Objects, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(EMv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package Sounds.","when calling error in Sounds, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(Epv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package Soundsets.","when calling error in Soundsets, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(EPv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package Textures.","when calling error in Textures, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(Eqv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package UI.","when calling error in UI, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(EQv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package Units.","when calling error in Units, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(Esv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package UnitAnimations.","when calling error in UnitAnimations, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(ESv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package UnitIds.","when calling error in UnitIds, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(Etv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package CancelAutomaticTargetFinding.","when calling error in CancelAutomaticTargetFinding, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(ETv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package ObjectIds.","when calling error in ObjectIds, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(Euv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package MapBounds.","when calling error in MapBounds, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(EUv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package DummyRecycler.","when calling error in DummyRecycler, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(Ewv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package HashList.","when calling error in HashList, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(EWv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package TimerUtils.","when calling error in TimerUtils, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(Eyv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package ClosureTimers.","when calling error in ClosureTimers, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(EYv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package Preloader.","when calling error in Preloader, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(Ezv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package ObjectIdGenerator.","when calling error in ObjectIdGenerator, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(EZv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package ChannelAbilityPreset.","when calling error in ChannelAbilityPreset, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(E_v))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package Orders.","when calling error in Orders, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(E0v))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package Cleave.","when calling error in Cleave, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(E1v))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package EventHelper.","when calling error in EventHelper, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(E2v))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package RegisterEvents.","when calling error in RegisterEvents, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(E3v))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package OnUnitEnterLeave.","when calling error in OnUnitEnterLeave, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(E4v))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package UnitIndexer.","when calling error in UnitIndexer, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(E5v))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package ClosureEvents.","when calling error in ClosureEvents, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(E6v))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package ClosureFrames.","when calling error in ClosureFrames, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(E7v))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package DebugFile.","when calling error in DebugFile, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(E8v))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package Dummy.","when calling error in Dummy, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(E9v))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package TableJurst.","when calling error in TableJurst, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(Xvv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package EmergencyEvade.","when calling error in EmergencyEvade, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(Xev))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package FlyHeightFixer.","when calling error in FlyHeightFixer, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(Xxv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package HashSet.","when calling error in HashSet, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(Xov))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package Utility.","when calling error in Utility, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(Xrv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package PlayerUtil.","when calling error in PlayerUtil, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(Xiv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package Formations.","when calling error in Formations, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(Xav))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package FramehandleNames.","when calling error in FramehandleNames, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(Xnv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package NetworkConfig.","when calling error in NetworkConfig, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(XVv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package GamecacheKeys.","when calling error in GamecacheKeys, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(XEv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package IOTaskExecutor.","when calling error in IOTaskExecutor, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(XXv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package Metadata.","when calling error in Metadata, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(XOv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package ScmdWrapper.","when calling error in ScmdWrapper, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(XRv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package ScmdPermissions.","when calling error in ScmdPermissions, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(XIv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package SafetyChecks_config.","when calling error in SafetyChecks_config, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(XAv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package SafetyChecks.","when calling error in SafetyChecks, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(XNv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package ScmdDataTypes.","when calling error in ScmdDataTypes, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(Xbv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package ScmdSystemMessaging.","when calling error in ScmdSystemMessaging, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(XBv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package ScmdParser.","when calling error in ScmdParser, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(Xcv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package ScmdReader.","when calling error in ScmdReader, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(XCv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package SyncSimple_config.","when calling error in SyncSimple_config, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(Xdv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package SyncSimple.","when calling error in SyncSimple, line 68")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(XDv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package StringBuffer.","when calling error in StringBuffer, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(Xfv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package OrderedStringBuffer.","when calling error in OrderedStringBuffer, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(XFv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package StringEncoder.","when calling error in StringEncoder, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(Xgv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package Network.","when calling error in Network, line 181")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(XGv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package NetworkData.","when calling error in NetworkData, line 175")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(Xhv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package Obliterate.","when calling error in Obliterate, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(XHv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package PacketIO_config.","when calling error in PacketIO_config, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(Xjv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package PacketIO.","when calling error in PacketIO, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(XJv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package PreloadIO.","when calling error in PreloadIO, line 14")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(Xkv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package Persistable.","when calling error in Persistable, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(XKv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package PlayerDefinedUnitTypes.","when calling error in PlayerDefinedUnitTypes, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(Xlv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package RectDrawing.","when calling error in RectDrawing, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(XLv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package RollTheBones.","when calling error in RollTheBones, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(Xmv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package SLangChatSystem.","when calling error in SLangChatSystem, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(XMv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package SotfrpGuiWrapper.","when calling error in SotfrpGuiWrapper, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(Xpv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package UpgradeObjEditing.","when calling error in UpgradeObjEditing, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(XPv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package SotfrpGuiPresets.","when calling error in SotfrpGuiPresets, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(Xqv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package Utf8CodeUnit.","when calling error in Utf8CodeUnit, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(XQv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package SaveableHandles.","when calling error in SaveableHandles, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(Xsv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package SotfrpGuiCoreUnit.","when calling error in SotfrpGuiCoreUnit, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(XSv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package SotFRP_Locale.","when calling error in SotFRP_Locale, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(Xtv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package SLangPlayerFunctions.","when calling error in SLangPlayerFunctions, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(XTv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package SLangSpecialEffectFunctions.","when calling error in SLangSpecialEffectFunctions, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(Xuv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package SLangTriggerFunctions.","when calling error in SLangTriggerFunctions, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(XUv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package ScmdCameraSetupBuiltins.","when calling error in ScmdCameraSetupBuiltins, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(Xwv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package ScmdCoreBuiltins.","when calling error in ScmdCoreBuiltins, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(XWv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package ScmdFogOfWarBuiltins.","when calling error in ScmdFogOfWarBuiltins, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(Xyv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package ScmdItemBuiltins.","when calling error in ScmdItemBuiltins, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(XYv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package ScmdPlayerCameraSettingsBuiltins.","when calling error in ScmdPlayerCameraSettingsBuiltins, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(Xzv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package ScmdPlayerStateControlBuiltins.","when calling error in ScmdPlayerStateControlBuiltins, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(XZv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package ScmdRectBuiltins.","when calling error in ScmdRectBuiltins, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(X_v))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package ScmdSoundFunctions.","when calling error in ScmdSoundFunctions, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(X0v))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package ScmdSystemsSettingsBuiltins.","when calling error in ScmdSystemsSettingsBuiltins, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(X1v))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package ScmdUnitBuiltins.","when calling error in ScmdUnitBuiltins, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(X2v))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package ScmdUnitParamLinkingBuiltins.","when calling error in ScmdUnitParamLinkingBuiltins, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(X3v))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package ScmdWeatherEffectFunctions.","when calling error in ScmdWeatherEffectFunctions, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(X4v))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package ShieldWall.","when calling error in ShieldWall, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(X5v))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package SotFRP_AbilList.","when calling error in SotFRP_AbilList, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(X6v))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package TouchOfKarma.","when calling error in TouchOfKarma, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(X7v))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package StickyGrenade.","when calling error in StickyGrenade, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(X8v))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package SotFRP_HeroAbilList.","when calling error in SotFRP_HeroAbilList, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(X9v))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package SotFRP_AbilitySystem.","when calling error in SotFRP_AbilitySystem, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(Ovv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package SotFRP_Init.","when calling error in SotFRP_Init, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(Oev))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package SotfrpGuiRegions.","when calling error in SotfrpGuiRegions, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(Oxv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package SotFRP_LegacyLoad.","when calling error in SotFRP_LegacyLoad, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(Oov))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package SotFRP_SaveLoad.","when calling error in SotFRP_SaveLoad, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(Orv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package SotfrpGuiDestructables.","when calling error in SotfrpGuiDestructables, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(Oiv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package SotfrpGuiLocust.","when calling error in SotfrpGuiLocust, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(Oav))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package Stack.","when calling error in Stack, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(Onv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package TypeCastingJurst.","when calling error in TypeCastingJurst, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(OVv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package UniqueIdValidator.","when calling error in UniqueIdValidator, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(OEv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package UnitEditor.","when calling error in UnitEditor, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(OXv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package UnitShops.","when calling error in UnitShops, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(OOv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package UnitShopsBuiltins.","when calling error in UnitShopsBuiltins, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(ORv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package Utf8StringSplitter.","when calling error in Utf8StringSplitter, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(OIv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package Vector.","when calling error in Vector, line 1")
endif
call TriggerClearConditions(aPX)
call TriggerAddCondition(aPX,Condition(OAv))
if not TriggerEvaluate(aPX)then
call Cdv("Could not initialize package upperButtonBar.","when calling error in upperButtonBar, line 1")
endif
call TriggerClearConditions(aPX)
call DestroyTrigger(aPX)
set aPX=null
endfunction
function H0u takes nothing returns nothing
call SetPlayerStartLocation(Player(0),0)
call ForcePlayerStartLocation(Player(0),0)
call SetPlayerColor(Player(0),ConvertPlayerColor(0))
call SetPlayerRacePreference(Player(0),RACE_PREF_RANDOM)
call SetPlayerRaceSelectable(Player(0),true)
call SetPlayerController(Player(0),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(1),1)
call ForcePlayerStartLocation(Player(1),1)
call SetPlayerColor(Player(1),ConvertPlayerColor(1))
call SetPlayerRacePreference(Player(1),RACE_PREF_RANDOM)
call SetPlayerRaceSelectable(Player(1),true)
call SetPlayerController(Player(1),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(2),2)
call ForcePlayerStartLocation(Player(2),2)
call SetPlayerColor(Player(2),ConvertPlayerColor(2))
call SetPlayerRacePreference(Player(2),RACE_PREF_RANDOM)
call SetPlayerRaceSelectable(Player(2),true)
call SetPlayerController(Player(2),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(3),3)
call ForcePlayerStartLocation(Player(3),3)
call SetPlayerColor(Player(3),ConvertPlayerColor(3))
call SetPlayerRacePreference(Player(3),RACE_PREF_RANDOM)
call SetPlayerRaceSelectable(Player(3),true)
call SetPlayerController(Player(3),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(4),4)
call ForcePlayerStartLocation(Player(4),4)
call SetPlayerColor(Player(4),ConvertPlayerColor(4))
call SetPlayerRacePreference(Player(4),RACE_PREF_RANDOM)
call SetPlayerRaceSelectable(Player(4),true)
call SetPlayerController(Player(4),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(5),5)
call ForcePlayerStartLocation(Player(5),5)
call SetPlayerColor(Player(5),ConvertPlayerColor(5))
call SetPlayerRacePreference(Player(5),RACE_PREF_RANDOM)
call SetPlayerRaceSelectable(Player(5),true)
call SetPlayerController(Player(5),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(6),6)
call ForcePlayerStartLocation(Player(6),6)
call SetPlayerColor(Player(6),ConvertPlayerColor(6))
call SetPlayerRacePreference(Player(6),RACE_PREF_RANDOM)
call SetPlayerRaceSelectable(Player(6),true)
call SetPlayerController(Player(6),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(7),7)
call ForcePlayerStartLocation(Player(7),7)
call SetPlayerColor(Player(7),ConvertPlayerColor(7))
call SetPlayerRacePreference(Player(7),RACE_PREF_RANDOM)
call SetPlayerRaceSelectable(Player(7),true)
call SetPlayerController(Player(7),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(8),8)
call ForcePlayerStartLocation(Player(8),8)
call SetPlayerColor(Player(8),ConvertPlayerColor(8))
call SetPlayerRacePreference(Player(8),RACE_PREF_RANDOM)
call SetPlayerRaceSelectable(Player(8),true)
call SetPlayerController(Player(8),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(9),9)
call ForcePlayerStartLocation(Player(9),9)
call SetPlayerColor(Player(9),ConvertPlayerColor(9))
call SetPlayerRacePreference(Player(9),RACE_PREF_RANDOM)
call SetPlayerRaceSelectable(Player(9),true)
call SetPlayerController(Player(9),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player($A),$A)
call ForcePlayerStartLocation(Player($A),$A)
call SetPlayerColor(Player($A),ConvertPlayerColor($A))
call SetPlayerRacePreference(Player($A),RACE_PREF_RANDOM)
call SetPlayerRaceSelectable(Player($A),true)
call SetPlayerController(Player($A),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player($B),$B)
call ForcePlayerStartLocation(Player($B),$B)
call SetPlayerColor(Player($B),ConvertPlayerColor($B))
call SetPlayerRacePreference(Player($B),RACE_PREF_RANDOM)
call SetPlayerRaceSelectable(Player($B),true)
call SetPlayerController(Player($B),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player($C),$C)
call ForcePlayerStartLocation(Player($C),$C)
call SetPlayerColor(Player($C),ConvertPlayerColor($C))
call SetPlayerRacePreference(Player($C),RACE_PREF_RANDOM)
call SetPlayerRaceSelectable(Player($C),true)
call SetPlayerController(Player($C),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player($D),$D)
call ForcePlayerStartLocation(Player($D),$D)
call SetPlayerColor(Player($D),ConvertPlayerColor($D))
call SetPlayerRacePreference(Player($D),RACE_PREF_RANDOM)
call SetPlayerRaceSelectable(Player($D),true)
call SetPlayerController(Player($D),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player($E),$E)
call ForcePlayerStartLocation(Player($E),$E)
call SetPlayerColor(Player($E),ConvertPlayerColor($E))
call SetPlayerRacePreference(Player($E),RACE_PREF_RANDOM)
call SetPlayerRaceSelectable(Player($E),true)
call SetPlayerController(Player($E),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player($F),$F)
call ForcePlayerStartLocation(Player($F),$F)
call SetPlayerColor(Player($F),ConvertPlayerColor($F))
call SetPlayerRacePreference(Player($F),RACE_PREF_RANDOM)
call SetPlayerRaceSelectable(Player($F),true)
call SetPlayerController(Player($F),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(16),16)
call ForcePlayerStartLocation(Player(16),16)
call SetPlayerColor(Player(16),ConvertPlayerColor(16))
call SetPlayerRacePreference(Player(16),RACE_PREF_RANDOM)
call SetPlayerRaceSelectable(Player(16),true)
call SetPlayerController(Player(16),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(17),17)
call ForcePlayerStartLocation(Player(17),17)
call SetPlayerColor(Player(17),ConvertPlayerColor(17))
call SetPlayerRacePreference(Player(17),RACE_PREF_RANDOM)
call SetPlayerRaceSelectable(Player(17),true)
call SetPlayerController(Player(17),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(18),18)
call ForcePlayerStartLocation(Player(18),18)
call SetPlayerColor(Player(18),ConvertPlayerColor(18))
call SetPlayerRacePreference(Player(18),RACE_PREF_RANDOM)
call SetPlayerRaceSelectable(Player(18),true)
call SetPlayerController(Player(18),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(19),19)
call ForcePlayerStartLocation(Player(19),19)
call SetPlayerColor(Player(19),ConvertPlayerColor(19))
call SetPlayerRacePreference(Player(19),RACE_PREF_RANDOM)
call SetPlayerRaceSelectable(Player(19),true)
call SetPlayerController(Player(19),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(20),20)
call ForcePlayerStartLocation(Player(20),20)
call SetPlayerColor(Player(20),ConvertPlayerColor(20))
call SetPlayerRacePreference(Player(20),RACE_PREF_RANDOM)
call SetPlayerRaceSelectable(Player(20),true)
call SetPlayerController(Player(20),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(21),21)
call ForcePlayerStartLocation(Player(21),21)
call SetPlayerColor(Player(21),ConvertPlayerColor(21))
call SetPlayerRacePreference(Player(21),RACE_PREF_RANDOM)
call SetPlayerRaceSelectable(Player(21),true)
call SetPlayerController(Player(21),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(22),22)
call ForcePlayerStartLocation(Player(22),22)
call SetPlayerColor(Player(22),ConvertPlayerColor(22))
call SetPlayerRacePreference(Player(22),RACE_PREF_RANDOM)
call SetPlayerRaceSelectable(Player(22),true)
call SetPlayerController(Player(22),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(23),23)
call ForcePlayerStartLocation(Player(23),23)
call SetPlayerColor(Player(23),ConvertPlayerColor(23))
call SetPlayerRacePreference(Player(23),RACE_PREF_RANDOM)
call SetPlayerRaceSelectable(Player(23),true)
call SetPlayerController(Player(23),MAP_CONTROL_USER)
endfunction
function J0u takes nothing returns nothing
call SetPlayerTeam(Player(0),0)
call SetPlayerTeam(Player(1),1)
call SetPlayerTeam(Player(2),1)
call SetPlayerTeam(Player(3),1)
call SetPlayerTeam(Player(4),1)
call SetPlayerTeam(Player(5),1)
call SetPlayerTeam(Player(6),1)
call SetPlayerTeam(Player(7),1)
call SetPlayerTeam(Player(8),1)
call SetPlayerTeam(Player(9),1)
call SetPlayerTeam(Player($A),1)
call SetPlayerTeam(Player($B),1)
call SetPlayerTeam(Player($C),1)
call SetPlayerTeam(Player($D),1)
call SetPlayerTeam(Player($E),1)
call SetPlayerTeam(Player($F),1)
call SetPlayerTeam(Player(16),1)
call SetPlayerTeam(Player(17),1)
call SetPlayerTeam(Player(18),1)
call SetPlayerTeam(Player(19),1)
call SetPlayerTeam(Player(20),1)
call SetPlayerTeam(Player(21),1)
call SetPlayerTeam(Player(22),1)
call SetPlayerTeam(Player(23),1)
call SetPlayerAllianceStateAllyBJ(Player(1),Player(2),true)
call SetPlayerAllianceStateAllyBJ(Player(1),Player(3),true)
call SetPlayerAllianceStateAllyBJ(Player(1),Player(4),true)
call SetPlayerAllianceStateAllyBJ(Player(1),Player(5),true)
call SetPlayerAllianceStateAllyBJ(Player(1),Player(6),true)
call SetPlayerAllianceStateAllyBJ(Player(1),Player(7),true)
call SetPlayerAllianceStateAllyBJ(Player(1),Player(8),true)
call SetPlayerAllianceStateAllyBJ(Player(1),Player(9),true)
call SetPlayerAllianceStateAllyBJ(Player(1),Player($A),true)
call SetPlayerAllianceStateAllyBJ(Player(1),Player($B),true)
call SetPlayerAllianceStateAllyBJ(Player(1),Player($C),true)
call SetPlayerAllianceStateAllyBJ(Player(1),Player($D),true)
call SetPlayerAllianceStateAllyBJ(Player(1),Player($E),true)
call SetPlayerAllianceStateAllyBJ(Player(1),Player($F),true)
call SetPlayerAllianceStateAllyBJ(Player(1),Player(16),true)
call SetPlayerAllianceStateAllyBJ(Player(1),Player(17),true)
call SetPlayerAllianceStateAllyBJ(Player(1),Player(18),true)
call SetPlayerAllianceStateAllyBJ(Player(1),Player(19),true)
call SetPlayerAllianceStateAllyBJ(Player(1),Player(20),true)
call SetPlayerAllianceStateAllyBJ(Player(1),Player(21),true)
call SetPlayerAllianceStateAllyBJ(Player(1),Player(22),true)
call SetPlayerAllianceStateAllyBJ(Player(1),Player(23),true)
call SetPlayerAllianceStateAllyBJ(Player(2),Player(1),true)
call SetPlayerAllianceStateAllyBJ(Player(2),Player(3),true)
call SetPlayerAllianceStateAllyBJ(Player(2),Player(4),true)
call SetPlayerAllianceStateAllyBJ(Player(2),Player(5),true)
call SetPlayerAllianceStateAllyBJ(Player(2),Player(6),true)
call SetPlayerAllianceStateAllyBJ(Player(2),Player(7),true)
call SetPlayerAllianceStateAllyBJ(Player(2),Player(8),true)
call SetPlayerAllianceStateAllyBJ(Player(2),Player(9),true)
call SetPlayerAllianceStateAllyBJ(Player(2),Player($A),true)
call SetPlayerAllianceStateAllyBJ(Player(2),Player($B),true)
call SetPlayerAllianceStateAllyBJ(Player(2),Player($C),true)
call SetPlayerAllianceStateAllyBJ(Player(2),Player($D),true)
call SetPlayerAllianceStateAllyBJ(Player(2),Player($E),true)
call SetPlayerAllianceStateAllyBJ(Player(2),Player($F),true)
call SetPlayerAllianceStateAllyBJ(Player(2),Player(16),true)
call SetPlayerAllianceStateAllyBJ(Player(2),Player(17),true)
call SetPlayerAllianceStateAllyBJ(Player(2),Player(18),true)
call SetPlayerAllianceStateAllyBJ(Player(2),Player(19),true)
call SetPlayerAllianceStateAllyBJ(Player(2),Player(20),true)
call SetPlayerAllianceStateAllyBJ(Player(2),Player(21),true)
call SetPlayerAllianceStateAllyBJ(Player(2),Player(22),true)
call SetPlayerAllianceStateAllyBJ(Player(2),Player(23),true)
call SetPlayerAllianceStateAllyBJ(Player(3),Player(1),true)
call SetPlayerAllianceStateAllyBJ(Player(3),Player(2),true)
call SetPlayerAllianceStateAllyBJ(Player(3),Player(4),true)
call SetPlayerAllianceStateAllyBJ(Player(3),Player(5),true)
call SetPlayerAllianceStateAllyBJ(Player(3),Player(6),true)
call SetPlayerAllianceStateAllyBJ(Player(3),Player(7),true)
call SetPlayerAllianceStateAllyBJ(Player(3),Player(8),true)
call SetPlayerAllianceStateAllyBJ(Player(3),Player(9),true)
call SetPlayerAllianceStateAllyBJ(Player(3),Player($A),true)
call SetPlayerAllianceStateAllyBJ(Player(3),Player($B),true)
call SetPlayerAllianceStateAllyBJ(Player(3),Player($C),true)
call SetPlayerAllianceStateAllyBJ(Player(3),Player($D),true)
call SetPlayerAllianceStateAllyBJ(Player(3),Player($E),true)
call SetPlayerAllianceStateAllyBJ(Player(3),Player($F),true)
call SetPlayerAllianceStateAllyBJ(Player(3),Player(16),true)
call SetPlayerAllianceStateAllyBJ(Player(3),Player(17),true)
call SetPlayerAllianceStateAllyBJ(Player(3),Player(18),true)
call SetPlayerAllianceStateAllyBJ(Player(3),Player(19),true)
call SetPlayerAllianceStateAllyBJ(Player(3),Player(20),true)
call SetPlayerAllianceStateAllyBJ(Player(3),Player(21),true)
call SetPlayerAllianceStateAllyBJ(Player(3),Player(22),true)
call SetPlayerAllianceStateAllyBJ(Player(3),Player(23),true)
call SetPlayerAllianceStateAllyBJ(Player(4),Player(1),true)
call SetPlayerAllianceStateAllyBJ(Player(4),Player(2),true)
call SetPlayerAllianceStateAllyBJ(Player(4),Player(3),true)
call SetPlayerAllianceStateAllyBJ(Player(4),Player(5),true)
call SetPlayerAllianceStateAllyBJ(Player(4),Player(6),true)
call SetPlayerAllianceStateAllyBJ(Player(4),Player(7),true)
call SetPlayerAllianceStateAllyBJ(Player(4),Player(8),true)
call SetPlayerAllianceStateAllyBJ(Player(4),Player(9),true)
call SetPlayerAllianceStateAllyBJ(Player(4),Player($A),true)
call SetPlayerAllianceStateAllyBJ(Player(4),Player($B),true)
call SetPlayerAllianceStateAllyBJ(Player(4),Player($C),true)
call SetPlayerAllianceStateAllyBJ(Player(4),Player($D),true)
call SetPlayerAllianceStateAllyBJ(Player(4),Player($E),true)
call SetPlayerAllianceStateAllyBJ(Player(4),Player($F),true)
call SetPlayerAllianceStateAllyBJ(Player(4),Player(16),true)
call SetPlayerAllianceStateAllyBJ(Player(4),Player(17),true)
call SetPlayerAllianceStateAllyBJ(Player(4),Player(18),true)
call SetPlayerAllianceStateAllyBJ(Player(4),Player(19),true)
call SetPlayerAllianceStateAllyBJ(Player(4),Player(20),true)
call SetPlayerAllianceStateAllyBJ(Player(4),Player(21),true)
call SetPlayerAllianceStateAllyBJ(Player(4),Player(22),true)
call SetPlayerAllianceStateAllyBJ(Player(4),Player(23),true)
call SetPlayerAllianceStateAllyBJ(Player(5),Player(1),true)
call SetPlayerAllianceStateAllyBJ(Player(5),Player(2),true)
call SetPlayerAllianceStateAllyBJ(Player(5),Player(3),true)
call SetPlayerAllianceStateAllyBJ(Player(5),Player(4),true)
call SetPlayerAllianceStateAllyBJ(Player(5),Player(6),true)
call SetPlayerAllianceStateAllyBJ(Player(5),Player(7),true)
call SetPlayerAllianceStateAllyBJ(Player(5),Player(8),true)
call SetPlayerAllianceStateAllyBJ(Player(5),Player(9),true)
call SetPlayerAllianceStateAllyBJ(Player(5),Player($A),true)
call SetPlayerAllianceStateAllyBJ(Player(5),Player($B),true)
call SetPlayerAllianceStateAllyBJ(Player(5),Player($C),true)
call SetPlayerAllianceStateAllyBJ(Player(5),Player($D),true)
call SetPlayerAllianceStateAllyBJ(Player(5),Player($E),true)
call SetPlayerAllianceStateAllyBJ(Player(5),Player($F),true)
call SetPlayerAllianceStateAllyBJ(Player(5),Player(16),true)
call SetPlayerAllianceStateAllyBJ(Player(5),Player(17),true)
call SetPlayerAllianceStateAllyBJ(Player(5),Player(18),true)
call SetPlayerAllianceStateAllyBJ(Player(5),Player(19),true)
call SetPlayerAllianceStateAllyBJ(Player(5),Player(20),true)
call SetPlayerAllianceStateAllyBJ(Player(5),Player(21),true)
call SetPlayerAllianceStateAllyBJ(Player(5),Player(22),true)
call SetPlayerAllianceStateAllyBJ(Player(5),Player(23),true)
call SetPlayerAllianceStateAllyBJ(Player(6),Player(1),true)
call SetPlayerAllianceStateAllyBJ(Player(6),Player(2),true)
call SetPlayerAllianceStateAllyBJ(Player(6),Player(3),true)
call SetPlayerAllianceStateAllyBJ(Player(6),Player(4),true)
call SetPlayerAllianceStateAllyBJ(Player(6),Player(5),true)
call SetPlayerAllianceStateAllyBJ(Player(6),Player(7),true)
call SetPlayerAllianceStateAllyBJ(Player(6),Player(8),true)
call SetPlayerAllianceStateAllyBJ(Player(6),Player(9),true)
call SetPlayerAllianceStateAllyBJ(Player(6),Player($A),true)
call SetPlayerAllianceStateAllyBJ(Player(6),Player($B),true)
call SetPlayerAllianceStateAllyBJ(Player(6),Player($C),true)
call SetPlayerAllianceStateAllyBJ(Player(6),Player($D),true)
call SetPlayerAllianceStateAllyBJ(Player(6),Player($E),true)
call SetPlayerAllianceStateAllyBJ(Player(6),Player($F),true)
call SetPlayerAllianceStateAllyBJ(Player(6),Player(16),true)
call SetPlayerAllianceStateAllyBJ(Player(6),Player(17),true)
call SetPlayerAllianceStateAllyBJ(Player(6),Player(18),true)
call SetPlayerAllianceStateAllyBJ(Player(6),Player(19),true)
call SetPlayerAllianceStateAllyBJ(Player(6),Player(20),true)
call SetPlayerAllianceStateAllyBJ(Player(6),Player(21),true)
call SetPlayerAllianceStateAllyBJ(Player(6),Player(22),true)
call SetPlayerAllianceStateAllyBJ(Player(6),Player(23),true)
call SetPlayerAllianceStateAllyBJ(Player(7),Player(1),true)
call SetPlayerAllianceStateAllyBJ(Player(7),Player(2),true)
call SetPlayerAllianceStateAllyBJ(Player(7),Player(3),true)
call SetPlayerAllianceStateAllyBJ(Player(7),Player(4),true)
call SetPlayerAllianceStateAllyBJ(Player(7),Player(5),true)
call SetPlayerAllianceStateAllyBJ(Player(7),Player(6),true)
call SetPlayerAllianceStateAllyBJ(Player(7),Player(8),true)
call SetPlayerAllianceStateAllyBJ(Player(7),Player(9),true)
call SetPlayerAllianceStateAllyBJ(Player(7),Player($A),true)
call SetPlayerAllianceStateAllyBJ(Player(7),Player($B),true)
call SetPlayerAllianceStateAllyBJ(Player(7),Player($C),true)
call SetPlayerAllianceStateAllyBJ(Player(7),Player($D),true)
call SetPlayerAllianceStateAllyBJ(Player(7),Player($E),true)
call SetPlayerAllianceStateAllyBJ(Player(7),Player($F),true)
call SetPlayerAllianceStateAllyBJ(Player(7),Player(16),true)
call SetPlayerAllianceStateAllyBJ(Player(7),Player(17),true)
call SetPlayerAllianceStateAllyBJ(Player(7),Player(18),true)
call SetPlayerAllianceStateAllyBJ(Player(7),Player(19),true)
call SetPlayerAllianceStateAllyBJ(Player(7),Player(20),true)
call SetPlayerAllianceStateAllyBJ(Player(7),Player(21),true)
call SetPlayerAllianceStateAllyBJ(Player(7),Player(22),true)
call SetPlayerAllianceStateAllyBJ(Player(7),Player(23),true)
call SetPlayerAllianceStateAllyBJ(Player(8),Player(1),true)
call SetPlayerAllianceStateAllyBJ(Player(8),Player(2),true)
call SetPlayerAllianceStateAllyBJ(Player(8),Player(3),true)
call SetPlayerAllianceStateAllyBJ(Player(8),Player(4),true)
call SetPlayerAllianceStateAllyBJ(Player(8),Player(5),true)
call SetPlayerAllianceStateAllyBJ(Player(8),Player(6),true)
call SetPlayerAllianceStateAllyBJ(Player(8),Player(7),true)
call SetPlayerAllianceStateAllyBJ(Player(8),Player(9),true)
call SetPlayerAllianceStateAllyBJ(Player(8),Player($A),true)
call SetPlayerAllianceStateAllyBJ(Player(8),Player($B),true)
call SetPlayerAllianceStateAllyBJ(Player(8),Player($C),true)
call SetPlayerAllianceStateAllyBJ(Player(8),Player($D),true)
call SetPlayerAllianceStateAllyBJ(Player(8),Player($E),true)
call SetPlayerAllianceStateAllyBJ(Player(8),Player($F),true)
call SetPlayerAllianceStateAllyBJ(Player(8),Player(16),true)
call SetPlayerAllianceStateAllyBJ(Player(8),Player(17),true)
call SetPlayerAllianceStateAllyBJ(Player(8),Player(18),true)
call SetPlayerAllianceStateAllyBJ(Player(8),Player(19),true)
call SetPlayerAllianceStateAllyBJ(Player(8),Player(20),true)
call SetPlayerAllianceStateAllyBJ(Player(8),Player(21),true)
call SetPlayerAllianceStateAllyBJ(Player(8),Player(22),true)
call SetPlayerAllianceStateAllyBJ(Player(8),Player(23),true)
call SetPlayerAllianceStateAllyBJ(Player(9),Player(1),true)
call SetPlayerAllianceStateAllyBJ(Player(9),Player(2),true)
call SetPlayerAllianceStateAllyBJ(Player(9),Player(3),true)
call SetPlayerAllianceStateAllyBJ(Player(9),Player(4),true)
call SetPlayerAllianceStateAllyBJ(Player(9),Player(5),true)
call SetPlayerAllianceStateAllyBJ(Player(9),Player(6),true)
call SetPlayerAllianceStateAllyBJ(Player(9),Player(7),true)
call SetPlayerAllianceStateAllyBJ(Player(9),Player(8),true)
call SetPlayerAllianceStateAllyBJ(Player(9),Player($A),true)
call SetPlayerAllianceStateAllyBJ(Player(9),Player($B),true)
call SetPlayerAllianceStateAllyBJ(Player(9),Player($C),true)
call SetPlayerAllianceStateAllyBJ(Player(9),Player($D),true)
call SetPlayerAllianceStateAllyBJ(Player(9),Player($E),true)
call SetPlayerAllianceStateAllyBJ(Player(9),Player($F),true)
call SetPlayerAllianceStateAllyBJ(Player(9),Player(16),true)
call SetPlayerAllianceStateAllyBJ(Player(9),Player(17),true)
call SetPlayerAllianceStateAllyBJ(Player(9),Player(18),true)
call SetPlayerAllianceStateAllyBJ(Player(9),Player(19),true)
call SetPlayerAllianceStateAllyBJ(Player(9),Player(20),true)
call SetPlayerAllianceStateAllyBJ(Player(9),Player(21),true)
call SetPlayerAllianceStateAllyBJ(Player(9),Player(22),true)
call SetPlayerAllianceStateAllyBJ(Player(9),Player(23),true)
call SetPlayerAllianceStateAllyBJ(Player($A),Player(1),true)
call SetPlayerAllianceStateAllyBJ(Player($A),Player(2),true)
call SetPlayerAllianceStateAllyBJ(Player($A),Player(3),true)
call SetPlayerAllianceStateAllyBJ(Player($A),Player(4),true)
call SetPlayerAllianceStateAllyBJ(Player($A),Player(5),true)
call SetPlayerAllianceStateAllyBJ(Player($A),Player(6),true)
call SetPlayerAllianceStateAllyBJ(Player($A),Player(7),true)
call SetPlayerAllianceStateAllyBJ(Player($A),Player(8),true)
call SetPlayerAllianceStateAllyBJ(Player($A),Player(9),true)
call SetPlayerAllianceStateAllyBJ(Player($A),Player($B),true)
call SetPlayerAllianceStateAllyBJ(Player($A),Player($C),true)
call SetPlayerAllianceStateAllyBJ(Player($A),Player($D),true)
call SetPlayerAllianceStateAllyBJ(Player($A),Player($E),true)
call SetPlayerAllianceStateAllyBJ(Player($A),Player($F),true)
call SetPlayerAllianceStateAllyBJ(Player($A),Player(16),true)
call SetPlayerAllianceStateAllyBJ(Player($A),Player(17),true)
call SetPlayerAllianceStateAllyBJ(Player($A),Player(18),true)
call SetPlayerAllianceStateAllyBJ(Player($A),Player(19),true)
call SetPlayerAllianceStateAllyBJ(Player($A),Player(20),true)
call SetPlayerAllianceStateAllyBJ(Player($A),Player(21),true)
call SetPlayerAllianceStateAllyBJ(Player($A),Player(22),true)
call SetPlayerAllianceStateAllyBJ(Player($A),Player(23),true)
call SetPlayerAllianceStateAllyBJ(Player($B),Player(1),true)
call SetPlayerAllianceStateAllyBJ(Player($B),Player(2),true)
call SetPlayerAllianceStateAllyBJ(Player($B),Player(3),true)
call SetPlayerAllianceStateAllyBJ(Player($B),Player(4),true)
call SetPlayerAllianceStateAllyBJ(Player($B),Player(5),true)
call SetPlayerAllianceStateAllyBJ(Player($B),Player(6),true)
call SetPlayerAllianceStateAllyBJ(Player($B),Player(7),true)
call SetPlayerAllianceStateAllyBJ(Player($B),Player(8),true)
call SetPlayerAllianceStateAllyBJ(Player($B),Player(9),true)
call SetPlayerAllianceStateAllyBJ(Player($B),Player($A),true)
call SetPlayerAllianceStateAllyBJ(Player($B),Player($C),true)
call SetPlayerAllianceStateAllyBJ(Player($B),Player($D),true)
call SetPlayerAllianceStateAllyBJ(Player($B),Player($E),true)
call SetPlayerAllianceStateAllyBJ(Player($B),Player($F),true)
call SetPlayerAllianceStateAllyBJ(Player($B),Player(16),true)
call SetPlayerAllianceStateAllyBJ(Player($B),Player(17),true)
call SetPlayerAllianceStateAllyBJ(Player($B),Player(18),true)
call SetPlayerAllianceStateAllyBJ(Player($B),Player(19),true)
call SetPlayerAllianceStateAllyBJ(Player($B),Player(20),true)
call SetPlayerAllianceStateAllyBJ(Player($B),Player(21),true)
call SetPlayerAllianceStateAllyBJ(Player($B),Player(22),true)
call SetPlayerAllianceStateAllyBJ(Player($B),Player(23),true)
call SetPlayerAllianceStateAllyBJ(Player($C),Player(1),true)
call SetPlayerAllianceStateAllyBJ(Player($C),Player(2),true)
call SetPlayerAllianceStateAllyBJ(Player($C),Player(3),true)
call SetPlayerAllianceStateAllyBJ(Player($C),Player(4),true)
call SetPlayerAllianceStateAllyBJ(Player($C),Player(5),true)
call SetPlayerAllianceStateAllyBJ(Player($C),Player(6),true)
call SetPlayerAllianceStateAllyBJ(Player($C),Player(7),true)
call SetPlayerAllianceStateAllyBJ(Player($C),Player(8),true)
call SetPlayerAllianceStateAllyBJ(Player($C),Player(9),true)
call SetPlayerAllianceStateAllyBJ(Player($C),Player($A),true)
call SetPlayerAllianceStateAllyBJ(Player($C),Player($B),true)
call SetPlayerAllianceStateAllyBJ(Player($C),Player($D),true)
call SetPlayerAllianceStateAllyBJ(Player($C),Player($E),true)
call SetPlayerAllianceStateAllyBJ(Player($C),Player($F),true)
call SetPlayerAllianceStateAllyBJ(Player($C),Player(16),true)
call SetPlayerAllianceStateAllyBJ(Player($C),Player(17),true)
call SetPlayerAllianceStateAllyBJ(Player($C),Player(18),true)
call SetPlayerAllianceStateAllyBJ(Player($C),Player(19),true)
call SetPlayerAllianceStateAllyBJ(Player($C),Player(20),true)
call SetPlayerAllianceStateAllyBJ(Player($C),Player(21),true)
call SetPlayerAllianceStateAllyBJ(Player($C),Player(22),true)
call SetPlayerAllianceStateAllyBJ(Player($C),Player(23),true)
call SetPlayerAllianceStateAllyBJ(Player($D),Player(1),true)
call SetPlayerAllianceStateAllyBJ(Player($D),Player(2),true)
call SetPlayerAllianceStateAllyBJ(Player($D),Player(3),true)
call SetPlayerAllianceStateAllyBJ(Player($D),Player(4),true)
call SetPlayerAllianceStateAllyBJ(Player($D),Player(5),true)
call SetPlayerAllianceStateAllyBJ(Player($D),Player(6),true)
call SetPlayerAllianceStateAllyBJ(Player($D),Player(7),true)
call SetPlayerAllianceStateAllyBJ(Player($D),Player(8),true)
call SetPlayerAllianceStateAllyBJ(Player($D),Player(9),true)
call SetPlayerAllianceStateAllyBJ(Player($D),Player($A),true)
call SetPlayerAllianceStateAllyBJ(Player($D),Player($B),true)
call SetPlayerAllianceStateAllyBJ(Player($D),Player($C),true)
call SetPlayerAllianceStateAllyBJ(Player($D),Player($E),true)
call SetPlayerAllianceStateAllyBJ(Player($D),Player($F),true)
call SetPlayerAllianceStateAllyBJ(Player($D),Player(16),true)
call SetPlayerAllianceStateAllyBJ(Player($D),Player(17),true)
call SetPlayerAllianceStateAllyBJ(Player($D),Player(18),true)
call SetPlayerAllianceStateAllyBJ(Player($D),Player(19),true)
call SetPlayerAllianceStateAllyBJ(Player($D),Player(20),true)
call SetPlayerAllianceStateAllyBJ(Player($D),Player(21),true)
call SetPlayerAllianceStateAllyBJ(Player($D),Player(22),true)
call SetPlayerAllianceStateAllyBJ(Player($D),Player(23),true)
call SetPlayerAllianceStateAllyBJ(Player($E),Player(1),true)
call SetPlayerAllianceStateAllyBJ(Player($E),Player(2),true)
call SetPlayerAllianceStateAllyBJ(Player($E),Player(3),true)
call SetPlayerAllianceStateAllyBJ(Player($E),Player(4),true)
call SetPlayerAllianceStateAllyBJ(Player($E),Player(5),true)
call SetPlayerAllianceStateAllyBJ(Player($E),Player(6),true)
call SetPlayerAllianceStateAllyBJ(Player($E),Player(7),true)
call SetPlayerAllianceStateAllyBJ(Player($E),Player(8),true)
call SetPlayerAllianceStateAllyBJ(Player($E),Player(9),true)
call SetPlayerAllianceStateAllyBJ(Player($E),Player($A),true)
call SetPlayerAllianceStateAllyBJ(Player($E),Player($B),true)
call SetPlayerAllianceStateAllyBJ(Player($E),Player($C),true)
call SetPlayerAllianceStateAllyBJ(Player($E),Player($D),true)
call SetPlayerAllianceStateAllyBJ(Player($E),Player($F),true)
call SetPlayerAllianceStateAllyBJ(Player($E),Player(16),true)
call SetPlayerAllianceStateAllyBJ(Player($E),Player(17),true)
call SetPlayerAllianceStateAllyBJ(Player($E),Player(18),true)
call SetPlayerAllianceStateAllyBJ(Player($E),Player(19),true)
call SetPlayerAllianceStateAllyBJ(Player($E),Player(20),true)
call SetPlayerAllianceStateAllyBJ(Player($E),Player(21),true)
call SetPlayerAllianceStateAllyBJ(Player($E),Player(22),true)
call SetPlayerAllianceStateAllyBJ(Player($E),Player(23),true)
call SetPlayerAllianceStateAllyBJ(Player($F),Player(1),true)
call SetPlayerAllianceStateAllyBJ(Player($F),Player(2),true)
call SetPlayerAllianceStateAllyBJ(Player($F),Player(3),true)
call SetPlayerAllianceStateAllyBJ(Player($F),Player(4),true)
call SetPlayerAllianceStateAllyBJ(Player($F),Player(5),true)
call SetPlayerAllianceStateAllyBJ(Player($F),Player(6),true)
call SetPlayerAllianceStateAllyBJ(Player($F),Player(7),true)
call SetPlayerAllianceStateAllyBJ(Player($F),Player(8),true)
call SetPlayerAllianceStateAllyBJ(Player($F),Player(9),true)
call SetPlayerAllianceStateAllyBJ(Player($F),Player($A),true)
call SetPlayerAllianceStateAllyBJ(Player($F),Player($B),true)
call SetPlayerAllianceStateAllyBJ(Player($F),Player($C),true)
call SetPlayerAllianceStateAllyBJ(Player($F),Player($D),true)
call SetPlayerAllianceStateAllyBJ(Player($F),Player($E),true)
call SetPlayerAllianceStateAllyBJ(Player($F),Player(16),true)
call SetPlayerAllianceStateAllyBJ(Player($F),Player(17),true)
call SetPlayerAllianceStateAllyBJ(Player($F),Player(18),true)
call SetPlayerAllianceStateAllyBJ(Player($F),Player(19),true)
call SetPlayerAllianceStateAllyBJ(Player($F),Player(20),true)
call SetPlayerAllianceStateAllyBJ(Player($F),Player(21),true)
call SetPlayerAllianceStateAllyBJ(Player($F),Player(22),true)
call SetPlayerAllianceStateAllyBJ(Player($F),Player(23),true)
call SetPlayerAllianceStateAllyBJ(Player(16),Player(1),true)
call SetPlayerAllianceStateAllyBJ(Player(16),Player(2),true)
call SetPlayerAllianceStateAllyBJ(Player(16),Player(3),true)
call SetPlayerAllianceStateAllyBJ(Player(16),Player(4),true)
call SetPlayerAllianceStateAllyBJ(Player(16),Player(5),true)
call SetPlayerAllianceStateAllyBJ(Player(16),Player(6),true)
call SetPlayerAllianceStateAllyBJ(Player(16),Player(7),true)
call SetPlayerAllianceStateAllyBJ(Player(16),Player(8),true)
call SetPlayerAllianceStateAllyBJ(Player(16),Player(9),true)
call SetPlayerAllianceStateAllyBJ(Player(16),Player($A),true)
call SetPlayerAllianceStateAllyBJ(Player(16),Player($B),true)
call SetPlayerAllianceStateAllyBJ(Player(16),Player($C),true)
call SetPlayerAllianceStateAllyBJ(Player(16),Player($D),true)
call SetPlayerAllianceStateAllyBJ(Player(16),Player($E),true)
call SetPlayerAllianceStateAllyBJ(Player(16),Player($F),true)
call SetPlayerAllianceStateAllyBJ(Player(16),Player(17),true)
call SetPlayerAllianceStateAllyBJ(Player(16),Player(18),true)
call SetPlayerAllianceStateAllyBJ(Player(16),Player(19),true)
call SetPlayerAllianceStateAllyBJ(Player(16),Player(20),true)
call SetPlayerAllianceStateAllyBJ(Player(16),Player(21),true)
call SetPlayerAllianceStateAllyBJ(Player(16),Player(22),true)
call SetPlayerAllianceStateAllyBJ(Player(16),Player(23),true)
call SetPlayerAllianceStateAllyBJ(Player(17),Player(1),true)
call SetPlayerAllianceStateAllyBJ(Player(17),Player(2),true)
call SetPlayerAllianceStateAllyBJ(Player(17),Player(3),true)
call SetPlayerAllianceStateAllyBJ(Player(17),Player(4),true)
call SetPlayerAllianceStateAllyBJ(Player(17),Player(5),true)
call SetPlayerAllianceStateAllyBJ(Player(17),Player(6),true)
call SetPlayerAllianceStateAllyBJ(Player(17),Player(7),true)
call SetPlayerAllianceStateAllyBJ(Player(17),Player(8),true)
call SetPlayerAllianceStateAllyBJ(Player(17),Player(9),true)
call SetPlayerAllianceStateAllyBJ(Player(17),Player($A),true)
call SetPlayerAllianceStateAllyBJ(Player(17),Player($B),true)
call SetPlayerAllianceStateAllyBJ(Player(17),Player($C),true)
call SetPlayerAllianceStateAllyBJ(Player(17),Player($D),true)
call SetPlayerAllianceStateAllyBJ(Player(17),Player($E),true)
call SetPlayerAllianceStateAllyBJ(Player(17),Player($F),true)
call SetPlayerAllianceStateAllyBJ(Player(17),Player(16),true)
call SetPlayerAllianceStateAllyBJ(Player(17),Player(18),true)
call SetPlayerAllianceStateAllyBJ(Player(17),Player(19),true)
call SetPlayerAllianceStateAllyBJ(Player(17),Player(20),true)
call SetPlayerAllianceStateAllyBJ(Player(17),Player(21),true)
call SetPlayerAllianceStateAllyBJ(Player(17),Player(22),true)
call SetPlayerAllianceStateAllyBJ(Player(17),Player(23),true)
call SetPlayerAllianceStateAllyBJ(Player(18),Player(1),true)
call SetPlayerAllianceStateAllyBJ(Player(18),Player(2),true)
call SetPlayerAllianceStateAllyBJ(Player(18),Player(3),true)
call SetPlayerAllianceStateAllyBJ(Player(18),Player(4),true)
call SetPlayerAllianceStateAllyBJ(Player(18),Player(5),true)
call SetPlayerAllianceStateAllyBJ(Player(18),Player(6),true)
call SetPlayerAllianceStateAllyBJ(Player(18),Player(7),true)
call SetPlayerAllianceStateAllyBJ(Player(18),Player(8),true)
call SetPlayerAllianceStateAllyBJ(Player(18),Player(9),true)
call SetPlayerAllianceStateAllyBJ(Player(18),Player($A),true)
call SetPlayerAllianceStateAllyBJ(Player(18),Player($B),true)
call SetPlayerAllianceStateAllyBJ(Player(18),Player($C),true)
call SetPlayerAllianceStateAllyBJ(Player(18),Player($D),true)
call SetPlayerAllianceStateAllyBJ(Player(18),Player($E),true)
call SetPlayerAllianceStateAllyBJ(Player(18),Player($F),true)
call SetPlayerAllianceStateAllyBJ(Player(18),Player(16),true)
call SetPlayerAllianceStateAllyBJ(Player(18),Player(17),true)
call SetPlayerAllianceStateAllyBJ(Player(18),Player(19),true)
call SetPlayerAllianceStateAllyBJ(Player(18),Player(20),true)
call SetPlayerAllianceStateAllyBJ(Player(18),Player(21),true)
call SetPlayerAllianceStateAllyBJ(Player(18),Player(22),true)
call SetPlayerAllianceStateAllyBJ(Player(18),Player(23),true)
call SetPlayerAllianceStateAllyBJ(Player(19),Player(1),true)
call SetPlayerAllianceStateAllyBJ(Player(19),Player(2),true)
call SetPlayerAllianceStateAllyBJ(Player(19),Player(3),true)
call SetPlayerAllianceStateAllyBJ(Player(19),Player(4),true)
call SetPlayerAllianceStateAllyBJ(Player(19),Player(5),true)
call SetPlayerAllianceStateAllyBJ(Player(19),Player(6),true)
call SetPlayerAllianceStateAllyBJ(Player(19),Player(7),true)
call SetPlayerAllianceStateAllyBJ(Player(19),Player(8),true)
call SetPlayerAllianceStateAllyBJ(Player(19),Player(9),true)
call SetPlayerAllianceStateAllyBJ(Player(19),Player($A),true)
call SetPlayerAllianceStateAllyBJ(Player(19),Player($B),true)
call SetPlayerAllianceStateAllyBJ(Player(19),Player($C),true)
call SetPlayerAllianceStateAllyBJ(Player(19),Player($D),true)
call SetPlayerAllianceStateAllyBJ(Player(19),Player($E),true)
call SetPlayerAllianceStateAllyBJ(Player(19),Player($F),true)
call SetPlayerAllianceStateAllyBJ(Player(19),Player(16),true)
call SetPlayerAllianceStateAllyBJ(Player(19),Player(17),true)
call SetPlayerAllianceStateAllyBJ(Player(19),Player(18),true)
call SetPlayerAllianceStateAllyBJ(Player(19),Player(20),true)
call SetPlayerAllianceStateAllyBJ(Player(19),Player(21),true)
call SetPlayerAllianceStateAllyBJ(Player(19),Player(22),true)
call SetPlayerAllianceStateAllyBJ(Player(19),Player(23),true)
call SetPlayerAllianceStateAllyBJ(Player(20),Player(1),true)
call SetPlayerAllianceStateAllyBJ(Player(20),Player(2),true)
call SetPlayerAllianceStateAllyBJ(Player(20),Player(3),true)
call SetPlayerAllianceStateAllyBJ(Player(20),Player(4),true)
call SetPlayerAllianceStateAllyBJ(Player(20),Player(5),true)
call SetPlayerAllianceStateAllyBJ(Player(20),Player(6),true)
call SetPlayerAllianceStateAllyBJ(Player(20),Player(7),true)
call SetPlayerAllianceStateAllyBJ(Player(20),Player(8),true)
call SetPlayerAllianceStateAllyBJ(Player(20),Player(9),true)
call SetPlayerAllianceStateAllyBJ(Player(20),Player($A),true)
call SetPlayerAllianceStateAllyBJ(Player(20),Player($B),true)
call SetPlayerAllianceStateAllyBJ(Player(20),Player($C),true)
call SetPlayerAllianceStateAllyBJ(Player(20),Player($D),true)
call SetPlayerAllianceStateAllyBJ(Player(20),Player($E),true)
call SetPlayerAllianceStateAllyBJ(Player(20),Player($F),true)
call SetPlayerAllianceStateAllyBJ(Player(20),Player(16),true)
call SetPlayerAllianceStateAllyBJ(Player(20),Player(17),true)
call SetPlayerAllianceStateAllyBJ(Player(20),Player(18),true)
call SetPlayerAllianceStateAllyBJ(Player(20),Player(19),true)
call SetPlayerAllianceStateAllyBJ(Player(20),Player(21),true)
call SetPlayerAllianceStateAllyBJ(Player(20),Player(22),true)
call SetPlayerAllianceStateAllyBJ(Player(20),Player(23),true)
call SetPlayerAllianceStateAllyBJ(Player(21),Player(1),true)
call SetPlayerAllianceStateAllyBJ(Player(21),Player(2),true)
call SetPlayerAllianceStateAllyBJ(Player(21),Player(3),true)
call SetPlayerAllianceStateAllyBJ(Player(21),Player(4),true)
call SetPlayerAllianceStateAllyBJ(Player(21),Player(5),true)
call SetPlayerAllianceStateAllyBJ(Player(21),Player(6),true)
call SetPlayerAllianceStateAllyBJ(Player(21),Player(7),true)
call SetPlayerAllianceStateAllyBJ(Player(21),Player(8),true)
call SetPlayerAllianceStateAllyBJ(Player(21),Player(9),true)
call SetPlayerAllianceStateAllyBJ(Player(21),Player($A),true)
call SetPlayerAllianceStateAllyBJ(Player(21),Player($B),true)
call SetPlayerAllianceStateAllyBJ(Player(21),Player($C),true)
call SetPlayerAllianceStateAllyBJ(Player(21),Player($D),true)
call SetPlayerAllianceStateAllyBJ(Player(21),Player($E),true)
call SetPlayerAllianceStateAllyBJ(Player(21),Player($F),true)
call SetPlayerAllianceStateAllyBJ(Player(21),Player(16),true)
call SetPlayerAllianceStateAllyBJ(Player(21),Player(17),true)
call SetPlayerAllianceStateAllyBJ(Player(21),Player(18),true)
call SetPlayerAllianceStateAllyBJ(Player(21),Player(19),true)
call SetPlayerAllianceStateAllyBJ(Player(21),Player(20),true)
call SetPlayerAllianceStateAllyBJ(Player(21),Player(22),true)
call SetPlayerAllianceStateAllyBJ(Player(21),Player(23),true)
call SetPlayerAllianceStateAllyBJ(Player(22),Player(1),true)
call SetPlayerAllianceStateAllyBJ(Player(22),Player(2),true)
call SetPlayerAllianceStateAllyBJ(Player(22),Player(3),true)
call SetPlayerAllianceStateAllyBJ(Player(22),Player(4),true)
call SetPlayerAllianceStateAllyBJ(Player(22),Player(5),true)
call SetPlayerAllianceStateAllyBJ(Player(22),Player(6),true)
call SetPlayerAllianceStateAllyBJ(Player(22),Player(7),true)
call SetPlayerAllianceStateAllyBJ(Player(22),Player(8),true)
call SetPlayerAllianceStateAllyBJ(Player(22),Player(9),true)
call SetPlayerAllianceStateAllyBJ(Player(22),Player($A),true)
call SetPlayerAllianceStateAllyBJ(Player(22),Player($B),true)
call SetPlayerAllianceStateAllyBJ(Player(22),Player($C),true)
call SetPlayerAllianceStateAllyBJ(Player(22),Player($D),true)
call SetPlayerAllianceStateAllyBJ(Player(22),Player($E),true)
call SetPlayerAllianceStateAllyBJ(Player(22),Player($F),true)
call SetPlayerAllianceStateAllyBJ(Player(22),Player(16),true)
call SetPlayerAllianceStateAllyBJ(Player(22),Player(17),true)
call SetPlayerAllianceStateAllyBJ(Player(22),Player(18),true)
call SetPlayerAllianceStateAllyBJ(Player(22),Player(19),true)
call SetPlayerAllianceStateAllyBJ(Player(22),Player(20),true)
call SetPlayerAllianceStateAllyBJ(Player(22),Player(21),true)
call SetPlayerAllianceStateAllyBJ(Player(22),Player(23),true)
call SetPlayerAllianceStateAllyBJ(Player(23),Player(1),true)
call SetPlayerAllianceStateAllyBJ(Player(23),Player(2),true)
call SetPlayerAllianceStateAllyBJ(Player(23),Player(3),true)
call SetPlayerAllianceStateAllyBJ(Player(23),Player(4),true)
call SetPlayerAllianceStateAllyBJ(Player(23),Player(5),true)
call SetPlayerAllianceStateAllyBJ(Player(23),Player(6),true)
call SetPlayerAllianceStateAllyBJ(Player(23),Player(7),true)
call SetPlayerAllianceStateAllyBJ(Player(23),Player(8),true)
call SetPlayerAllianceStateAllyBJ(Player(23),Player(9),true)
call SetPlayerAllianceStateAllyBJ(Player(23),Player($A),true)
call SetPlayerAllianceStateAllyBJ(Player(23),Player($B),true)
call SetPlayerAllianceStateAllyBJ(Player(23),Player($C),true)
call SetPlayerAllianceStateAllyBJ(Player(23),Player($D),true)
call SetPlayerAllianceStateAllyBJ(Player(23),Player($E),true)
call SetPlayerAllianceStateAllyBJ(Player(23),Player($F),true)
call SetPlayerAllianceStateAllyBJ(Player(23),Player(16),true)
call SetPlayerAllianceStateAllyBJ(Player(23),Player(17),true)
call SetPlayerAllianceStateAllyBJ(Player(23),Player(18),true)
call SetPlayerAllianceStateAllyBJ(Player(23),Player(19),true)
call SetPlayerAllianceStateAllyBJ(Player(23),Player(20),true)
call SetPlayerAllianceStateAllyBJ(Player(23),Player(21),true)
call SetPlayerAllianceStateAllyBJ(Player(23),Player(22),true)
endfunction
function K0u takes nothing returns nothing
call SetStartLocPrioCount(0,23)
call SetStartLocPrio(0,0,1,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,1,2,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,2,3,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,3,4,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,4,5,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,5,6,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,6,7,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,7,8,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,8,9,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,9,$A,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,$A,$B,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,$B,$C,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,$C,$D,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,$D,$E,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,$E,$F,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,$F,16,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,16,17,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,17,18,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,18,19,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,19,20,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,20,21,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,21,22,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,22,23,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(1,23)
call SetStartLocPrio(1,0,0,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(1,1,2,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(1,2,3,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(1,3,4,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(1,4,5,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(1,5,6,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(1,6,7,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(1,7,8,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(1,8,9,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(1,9,$A,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(1,$A,$B,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(1,$B,$C,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(1,$C,$D,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(1,$D,$E,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(1,$E,$F,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(1,$F,16,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(1,16,17,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(1,17,18,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(1,18,19,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(1,19,20,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(1,20,21,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(1,21,22,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(1,22,23,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(2,23)
call SetStartLocPrio(2,0,0,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(2,1,1,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(2,2,3,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(2,3,4,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(2,4,5,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(2,5,6,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(2,6,7,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(2,7,8,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(2,8,9,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(2,9,$A,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(2,$A,$B,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(2,$B,$C,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(2,$C,$D,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(2,$D,$E,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(2,$E,$F,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(2,$F,16,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(2,16,17,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(2,17,18,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(2,18,19,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(2,19,20,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(2,20,21,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(2,21,22,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(2,22,23,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(3,23)
call SetStartLocPrio(3,0,0,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(3,1,1,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(3,2,2,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(3,3,4,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(3,4,5,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(3,5,6,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(3,6,7,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(3,7,8,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(3,8,9,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(3,9,$A,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(3,$A,$B,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(3,$B,$C,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(3,$C,$D,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(3,$D,$E,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(3,$E,$F,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(3,$F,16,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(3,16,17,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(3,17,18,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(3,18,19,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(3,19,20,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(3,20,21,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(3,21,22,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(3,22,23,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(4,23)
call SetStartLocPrio(4,0,0,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(4,1,1,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(4,2,2,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(4,3,3,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(4,4,5,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(4,5,6,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(4,6,7,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(4,7,8,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(4,8,9,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(4,9,$A,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(4,$A,$B,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(4,$B,$C,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(4,$C,$D,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(4,$D,$E,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(4,$E,$F,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(4,$F,16,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(4,16,17,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(4,17,18,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(4,18,19,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(4,19,20,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(4,20,21,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(4,21,22,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(4,22,23,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(5,23)
call SetStartLocPrio(5,0,0,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(5,1,1,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(5,2,2,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(5,3,3,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(5,4,4,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(5,5,6,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(5,6,7,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(5,7,8,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(5,8,9,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(5,9,$A,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(5,$A,$B,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(5,$B,$C,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(5,$C,$D,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(5,$D,$E,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(5,$E,$F,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(5,$F,16,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(5,16,17,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(5,17,18,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(5,18,19,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(5,19,20,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(5,20,21,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(5,21,22,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(5,22,23,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(6,23)
call SetStartLocPrio(6,0,0,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(6,1,1,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(6,2,2,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(6,3,3,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(6,4,4,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(6,5,5,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(6,6,7,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(6,7,8,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(6,8,9,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(6,9,$A,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(6,$A,$B,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(6,$B,$C,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(6,$C,$D,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(6,$D,$E,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(6,$E,$F,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(6,$F,16,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(6,16,17,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(6,17,18,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(6,18,19,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(6,19,20,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(6,20,21,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(6,21,22,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(6,22,23,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(7,23)
call SetStartLocPrio(7,0,0,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(7,1,1,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(7,2,2,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(7,3,3,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(7,4,4,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(7,5,5,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(7,6,6,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(7,7,8,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(7,8,9,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(7,9,$A,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(7,$A,$B,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(7,$B,$C,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(7,$C,$D,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(7,$D,$E,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(7,$E,$F,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(7,$F,16,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(7,16,17,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(7,17,18,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(7,18,19,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(7,19,20,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(7,20,21,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(7,21,22,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(7,22,23,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(8,23)
call SetStartLocPrio(8,0,0,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(8,1,1,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(8,2,2,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(8,3,3,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(8,4,4,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(8,5,5,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(8,6,6,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(8,7,7,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(8,8,9,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(8,9,$A,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(8,$A,$B,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(8,$B,$C,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(8,$C,$D,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(8,$D,$E,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(8,$E,$F,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(8,$F,16,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(8,16,17,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(8,17,18,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(8,18,19,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(8,19,20,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(8,20,21,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(8,21,22,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(8,22,23,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(9,23)
call SetStartLocPrio(9,0,0,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(9,1,1,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(9,2,2,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(9,3,3,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(9,4,4,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(9,5,5,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(9,6,6,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(9,7,7,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(9,8,8,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(9,9,$A,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(9,$A,$B,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(9,$B,$C,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(9,$C,$D,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(9,$D,$E,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(9,$E,$F,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(9,$F,16,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(9,16,17,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(9,17,18,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(9,18,19,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(9,19,20,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(9,20,21,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(9,21,22,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(9,22,23,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount($A,23)
call SetStartLocPrio($A,0,0,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($A,1,1,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($A,2,2,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($A,3,3,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($A,4,4,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($A,5,5,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($A,6,6,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($A,7,7,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($A,8,8,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($A,9,9,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($A,$A,$B,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($A,$B,$C,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($A,$C,$D,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($A,$D,$E,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($A,$E,$F,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($A,$F,16,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($A,16,17,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($A,17,18,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($A,18,19,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($A,19,20,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($A,20,21,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($A,21,22,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($A,22,23,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount($B,23)
call SetStartLocPrio($B,0,0,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($B,1,1,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($B,2,2,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($B,3,3,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($B,4,4,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($B,5,5,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($B,6,6,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($B,7,7,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($B,8,8,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($B,9,9,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($B,$A,$A,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($B,$B,$C,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($B,$C,$D,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($B,$D,$E,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($B,$E,$F,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($B,$F,16,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($B,16,17,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($B,17,18,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($B,18,19,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($B,19,20,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($B,20,21,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($B,21,22,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($B,22,23,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount($C,23)
call SetStartLocPrio($C,0,0,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($C,1,1,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($C,2,2,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($C,3,3,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($C,4,4,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($C,5,5,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($C,6,6,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($C,7,7,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($C,8,8,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($C,9,9,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($C,$A,$A,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($C,$B,$B,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($C,$C,$D,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($C,$D,$E,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($C,$E,$F,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($C,$F,16,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($C,16,17,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($C,17,18,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($C,18,19,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($C,19,20,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($C,20,21,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($C,21,22,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($C,22,23,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount($D,23)
call SetStartLocPrio($D,0,0,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($D,1,1,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($D,2,2,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($D,3,3,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($D,4,4,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($D,5,5,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($D,6,6,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($D,7,7,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($D,8,8,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($D,9,9,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($D,$A,$A,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($D,$B,$B,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($D,$C,$C,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($D,$D,$E,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($D,$E,$F,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($D,$F,16,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($D,16,17,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($D,17,18,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($D,18,19,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($D,19,20,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($D,20,21,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($D,21,22,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($D,22,23,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount($E,23)
call SetStartLocPrio($E,0,0,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($E,1,1,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($E,2,2,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($E,3,3,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($E,4,4,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($E,5,5,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($E,6,6,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($E,7,7,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($E,8,8,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($E,9,9,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($E,$A,$A,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($E,$B,$B,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($E,$C,$C,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($E,$D,$D,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($E,$E,$F,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($E,$F,16,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($E,16,17,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($E,17,18,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($E,18,19,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($E,19,20,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($E,20,21,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($E,21,22,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($E,22,23,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount($F,23)
call SetStartLocPrio($F,0,0,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($F,1,1,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($F,2,2,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($F,3,3,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($F,4,4,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($F,5,5,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($F,6,6,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($F,7,7,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($F,8,8,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($F,9,9,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($F,$A,$A,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($F,$B,$B,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($F,$C,$C,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($F,$D,$D,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($F,$E,$E,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($F,$F,16,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($F,16,17,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($F,17,18,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($F,18,19,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($F,19,20,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($F,20,21,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($F,21,22,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($F,22,23,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(16,23)
call SetStartLocPrio(16,0,0,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(16,1,1,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(16,2,2,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(16,3,3,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(16,4,4,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(16,5,5,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(16,6,6,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(16,7,7,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(16,8,8,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(16,9,9,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(16,$A,$A,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(16,$B,$B,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(16,$C,$C,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(16,$D,$D,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(16,$E,$E,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(16,$F,$F,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(16,16,17,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(16,17,18,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(16,18,19,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(16,19,20,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(16,20,21,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(16,21,22,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(16,22,23,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(17,23)
call SetStartLocPrio(17,0,0,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(17,1,1,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(17,2,2,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(17,3,3,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(17,4,4,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(17,5,5,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(17,6,6,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(17,7,7,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(17,8,8,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(17,9,9,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(17,$A,$A,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(17,$B,$B,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(17,$C,$C,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(17,$D,$D,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(17,$E,$E,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(17,$F,$F,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(17,16,16,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(17,17,18,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(17,18,19,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(17,19,20,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(17,20,21,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(17,21,22,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(17,22,23,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(18,23)
call SetStartLocPrio(18,0,0,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(18,1,1,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(18,2,2,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(18,3,3,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(18,4,4,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(18,5,5,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(18,6,6,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(18,7,7,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(18,8,8,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(18,9,9,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(18,$A,$A,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(18,$B,$B,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(18,$C,$C,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(18,$D,$D,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(18,$E,$E,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(18,$F,$F,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(18,16,16,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(18,17,17,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(18,18,19,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(18,19,20,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(18,20,21,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(18,21,22,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(18,22,23,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(19,23)
call SetStartLocPrio(19,0,0,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(19,1,1,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(19,2,2,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(19,3,3,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(19,4,4,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(19,5,5,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(19,6,6,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(19,7,7,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(19,8,8,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(19,9,9,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(19,$A,$A,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(19,$B,$B,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(19,$C,$C,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(19,$D,$D,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(19,$E,$E,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(19,$F,$F,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(19,16,16,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(19,17,17,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(19,18,18,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(19,19,20,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(19,20,21,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(19,21,22,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(19,22,23,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(20,23)
call SetStartLocPrio(20,0,0,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(20,1,1,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(20,2,2,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(20,3,3,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(20,4,4,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(20,5,5,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(20,6,6,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(20,7,7,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(20,8,8,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(20,9,9,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(20,$A,$A,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(20,$B,$B,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(20,$C,$C,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(20,$D,$D,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(20,$E,$E,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(20,$F,$F,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(20,16,16,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(20,17,17,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(20,18,18,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(20,19,19,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(20,20,21,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(20,21,22,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(20,22,23,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(21,23)
call SetStartLocPrio(21,0,0,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(21,1,1,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(21,2,2,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(21,3,3,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(21,4,4,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(21,5,5,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(21,6,6,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(21,7,7,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(21,8,8,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(21,9,9,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(21,$A,$A,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(21,$B,$B,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(21,$C,$C,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(21,$D,$D,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(21,$E,$E,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(21,$F,$F,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(21,16,16,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(21,17,17,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(21,18,18,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(21,19,19,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(21,20,20,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(21,21,22,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(21,22,23,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(22,23)
call SetStartLocPrio(22,0,0,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(22,1,1,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(22,2,2,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(22,3,3,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(22,4,4,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(22,5,5,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(22,6,6,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(22,7,7,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(22,8,8,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(22,9,9,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(22,$A,$A,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(22,$B,$B,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(22,$C,$C,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(22,$D,$D,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(22,$E,$E,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(22,$F,$F,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(22,16,16,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(22,17,17,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(22,18,18,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(22,19,19,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(22,20,20,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(22,21,21,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(22,22,23,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(23,23)
call SetStartLocPrio(23,0,0,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(23,1,1,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(23,2,2,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(23,3,3,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(23,4,4,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(23,5,5,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(23,6,6,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(23,7,7,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(23,8,8,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(23,9,9,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(23,$A,$A,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(23,$B,$B,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(23,$C,$C,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(23,$D,$D,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(23,$E,$E,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(23,$F,$F,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(23,16,16,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(23,17,17,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(23,18,18,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(23,19,19,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(23,20,20,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(23,21,21,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(23,22,22,MAP_LOC_PRIO_HIGH)
endfunction
function InitCustomTeams takes nothing returns nothing
call SetPlayerTeam(Player(0),0)
call SetPlayerTeam(Player(1),1)
call SetPlayerTeam(Player(2),1)
call SetPlayerTeam(Player(3),1)
call SetPlayerTeam(Player(4),1)
call SetPlayerTeam(Player(5),1)
call SetPlayerTeam(Player(6),1)
call SetPlayerTeam(Player(7),1)
call SetPlayerTeam(Player(8),1)
call SetPlayerTeam(Player(9),1)
call SetPlayerTeam(Player($A),1)
call SetPlayerTeam(Player($B),1)
call SetPlayerTeam(Player($C),1)
call SetPlayerTeam(Player($D),1)
call SetPlayerTeam(Player($E),1)
call SetPlayerTeam(Player($F),1)
call SetPlayerTeam(Player(16),1)
call SetPlayerTeam(Player(17),1)
call SetPlayerTeam(Player(18),1)
call SetPlayerTeam(Player(19),1)
call SetPlayerTeam(Player(20),1)
call SetPlayerTeam(Player(21),1)
call SetPlayerTeam(Player(22),1)
call SetPlayerTeam(Player(23),1)
call SetPlayerAllianceStateAllyBJ(Player(1),Player(2),true)
call SetPlayerAllianceStateAllyBJ(Player(1),Player(3),true)
call SetPlayerAllianceStateAllyBJ(Player(1),Player(4),true)
call SetPlayerAllianceStateAllyBJ(Player(1),Player(5),true)
call SetPlayerAllianceStateAllyBJ(Player(1),Player(6),true)
call SetPlayerAllianceStateAllyBJ(Player(1),Player(7),true)
call SetPlayerAllianceStateAllyBJ(Player(1),Player(8),true)
call SetPlayerAllianceStateAllyBJ(Player(1),Player(9),true)
call SetPlayerAllianceStateAllyBJ(Player(1),Player($A),true)
call SetPlayerAllianceStateAllyBJ(Player(1),Player($B),true)
call SetPlayerAllianceStateAllyBJ(Player(1),Player($C),true)
call SetPlayerAllianceStateAllyBJ(Player(1),Player($D),true)
call SetPlayerAllianceStateAllyBJ(Player(1),Player($E),true)
call SetPlayerAllianceStateAllyBJ(Player(1),Player($F),true)
call SetPlayerAllianceStateAllyBJ(Player(1),Player(16),true)
call SetPlayerAllianceStateAllyBJ(Player(1),Player(17),true)
call SetPlayerAllianceStateAllyBJ(Player(1),Player(18),true)
call SetPlayerAllianceStateAllyBJ(Player(1),Player(19),true)
call SetPlayerAllianceStateAllyBJ(Player(1),Player(20),true)
call SetPlayerAllianceStateAllyBJ(Player(1),Player(21),true)
call SetPlayerAllianceStateAllyBJ(Player(1),Player(22),true)
call SetPlayerAllianceStateAllyBJ(Player(1),Player(23),true)
call SetPlayerAllianceStateAllyBJ(Player(2),Player(1),true)
call SetPlayerAllianceStateAllyBJ(Player(2),Player(3),true)
call SetPlayerAllianceStateAllyBJ(Player(2),Player(4),true)
call SetPlayerAllianceStateAllyBJ(Player(2),Player(5),true)
call SetPlayerAllianceStateAllyBJ(Player(2),Player(6),true)
call SetPlayerAllianceStateAllyBJ(Player(2),Player(7),true)
call SetPlayerAllianceStateAllyBJ(Player(2),Player(8),true)
call SetPlayerAllianceStateAllyBJ(Player(2),Player(9),true)
call SetPlayerAllianceStateAllyBJ(Player(2),Player($A),true)
call SetPlayerAllianceStateAllyBJ(Player(2),Player($B),true)
call SetPlayerAllianceStateAllyBJ(Player(2),Player($C),true)
call SetPlayerAllianceStateAllyBJ(Player(2),Player($D),true)
call SetPlayerAllianceStateAllyBJ(Player(2),Player($E),true)
call SetPlayerAllianceStateAllyBJ(Player(2),Player($F),true)
call SetPlayerAllianceStateAllyBJ(Player(2),Player(16),true)
call SetPlayerAllianceStateAllyBJ(Player(2),Player(17),true)
call SetPlayerAllianceStateAllyBJ(Player(2),Player(18),true)
call SetPlayerAllianceStateAllyBJ(Player(2),Player(19),true)
call SetPlayerAllianceStateAllyBJ(Player(2),Player(20),true)
call SetPlayerAllianceStateAllyBJ(Player(2),Player(21),true)
call SetPlayerAllianceStateAllyBJ(Player(2),Player(22),true)
call SetPlayerAllianceStateAllyBJ(Player(2),Player(23),true)
call SetPlayerAllianceStateAllyBJ(Player(3),Player(1),true)
call SetPlayerAllianceStateAllyBJ(Player(3),Player(2),true)
call SetPlayerAllianceStateAllyBJ(Player(3),Player(4),true)
call SetPlayerAllianceStateAllyBJ(Player(3),Player(5),true)
call SetPlayerAllianceStateAllyBJ(Player(3),Player(6),true)
call SetPlayerAllianceStateAllyBJ(Player(3),Player(7),true)
call SetPlayerAllianceStateAllyBJ(Player(3),Player(8),true)
call SetPlayerAllianceStateAllyBJ(Player(3),Player(9),true)
call SetPlayerAllianceStateAllyBJ(Player(3),Player($A),true)
call SetPlayerAllianceStateAllyBJ(Player(3),Player($B),true)
call SetPlayerAllianceStateAllyBJ(Player(3),Player($C),true)
call SetPlayerAllianceStateAllyBJ(Player(3),Player($D),true)
call SetPlayerAllianceStateAllyBJ(Player(3),Player($E),true)
call SetPlayerAllianceStateAllyBJ(Player(3),Player($F),true)
call SetPlayerAllianceStateAllyBJ(Player(3),Player(16),true)
call SetPlayerAllianceStateAllyBJ(Player(3),Player(17),true)
call SetPlayerAllianceStateAllyBJ(Player(3),Player(18),true)
call SetPlayerAllianceStateAllyBJ(Player(3),Player(19),true)
call SetPlayerAllianceStateAllyBJ(Player(3),Player(20),true)
call SetPlayerAllianceStateAllyBJ(Player(3),Player(21),true)
call SetPlayerAllianceStateAllyBJ(Player(3),Player(22),true)
call SetPlayerAllianceStateAllyBJ(Player(3),Player(23),true)
call SetPlayerAllianceStateAllyBJ(Player(4),Player(1),true)
call SetPlayerAllianceStateAllyBJ(Player(4),Player(2),true)
call SetPlayerAllianceStateAllyBJ(Player(4),Player(3),true)
call SetPlayerAllianceStateAllyBJ(Player(4),Player(5),true)
call SetPlayerAllianceStateAllyBJ(Player(4),Player(6),true)
call SetPlayerAllianceStateAllyBJ(Player(4),Player(7),true)
call SetPlayerAllianceStateAllyBJ(Player(4),Player(8),true)
call SetPlayerAllianceStateAllyBJ(Player(4),Player(9),true)
call SetPlayerAllianceStateAllyBJ(Player(4),Player($A),true)
call SetPlayerAllianceStateAllyBJ(Player(4),Player($B),true)
call SetPlayerAllianceStateAllyBJ(Player(4),Player($C),true)
call SetPlayerAllianceStateAllyBJ(Player(4),Player($D),true)
call SetPlayerAllianceStateAllyBJ(Player(4),Player($E),true)
call SetPlayerAllianceStateAllyBJ(Player(4),Player($F),true)
call SetPlayerAllianceStateAllyBJ(Player(4),Player(16),true)
call SetPlayerAllianceStateAllyBJ(Player(4),Player(17),true)
call SetPlayerAllianceStateAllyBJ(Player(4),Player(18),true)
call SetPlayerAllianceStateAllyBJ(Player(4),Player(19),true)
call SetPlayerAllianceStateAllyBJ(Player(4),Player(20),true)
call SetPlayerAllianceStateAllyBJ(Player(4),Player(21),true)
call SetPlayerAllianceStateAllyBJ(Player(4),Player(22),true)
call SetPlayerAllianceStateAllyBJ(Player(4),Player(23),true)
call SetPlayerAllianceStateAllyBJ(Player(5),Player(1),true)
call SetPlayerAllianceStateAllyBJ(Player(5),Player(2),true)
call SetPlayerAllianceStateAllyBJ(Player(5),Player(3),true)
call SetPlayerAllianceStateAllyBJ(Player(5),Player(4),true)
call SetPlayerAllianceStateAllyBJ(Player(5),Player(6),true)
call SetPlayerAllianceStateAllyBJ(Player(5),Player(7),true)
call SetPlayerAllianceStateAllyBJ(Player(5),Player(8),true)
call SetPlayerAllianceStateAllyBJ(Player(5),Player(9),true)
call SetPlayerAllianceStateAllyBJ(Player(5),Player($A),true)
call SetPlayerAllianceStateAllyBJ(Player(5),Player($B),true)
call SetPlayerAllianceStateAllyBJ(Player(5),Player($C),true)
call SetPlayerAllianceStateAllyBJ(Player(5),Player($D),true)
call SetPlayerAllianceStateAllyBJ(Player(5),Player($E),true)
call SetPlayerAllianceStateAllyBJ(Player(5),Player($F),true)
call SetPlayerAllianceStateAllyBJ(Player(5),Player(16),true)
call SetPlayerAllianceStateAllyBJ(Player(5),Player(17),true)
call SetPlayerAllianceStateAllyBJ(Player(5),Player(18),true)
call SetPlayerAllianceStateAllyBJ(Player(5),Player(19),true)
call SetPlayerAllianceStateAllyBJ(Player(5),Player(20),true)
call SetPlayerAllianceStateAllyBJ(Player(5),Player(21),true)
call SetPlayerAllianceStateAllyBJ(Player(5),Player(22),true)
call SetPlayerAllianceStateAllyBJ(Player(5),Player(23),true)
call SetPlayerAllianceStateAllyBJ(Player(6),Player(1),true)
call SetPlayerAllianceStateAllyBJ(Player(6),Player(2),true)
call SetPlayerAllianceStateAllyBJ(Player(6),Player(3),true)
call SetPlayerAllianceStateAllyBJ(Player(6),Player(4),true)
call SetPlayerAllianceStateAllyBJ(Player(6),Player(5),true)
call SetPlayerAllianceStateAllyBJ(Player(6),Player(7),true)
call SetPlayerAllianceStateAllyBJ(Player(6),Player(8),true)
call SetPlayerAllianceStateAllyBJ(Player(6),Player(9),true)
call SetPlayerAllianceStateAllyBJ(Player(6),Player($A),true)
call SetPlayerAllianceStateAllyBJ(Player(6),Player($B),true)
call SetPlayerAllianceStateAllyBJ(Player(6),Player($C),true)
call SetPlayerAllianceStateAllyBJ(Player(6),Player($D),true)
call SetPlayerAllianceStateAllyBJ(Player(6),Player($E),true)
call SetPlayerAllianceStateAllyBJ(Player(6),Player($F),true)
call SetPlayerAllianceStateAllyBJ(Player(6),Player(16),true)
call SetPlayerAllianceStateAllyBJ(Player(6),Player(17),true)
call SetPlayerAllianceStateAllyBJ(Player(6),Player(18),true)
call SetPlayerAllianceStateAllyBJ(Player(6),Player(19),true)
call SetPlayerAllianceStateAllyBJ(Player(6),Player(20),true)
call SetPlayerAllianceStateAllyBJ(Player(6),Player(21),true)
call SetPlayerAllianceStateAllyBJ(Player(6),Player(22),true)
call SetPlayerAllianceStateAllyBJ(Player(6),Player(23),true)
call SetPlayerAllianceStateAllyBJ(Player(7),Player(1),true)
call SetPlayerAllianceStateAllyBJ(Player(7),Player(2),true)
call SetPlayerAllianceStateAllyBJ(Player(7),Player(3),true)
call SetPlayerAllianceStateAllyBJ(Player(7),Player(4),true)
call SetPlayerAllianceStateAllyBJ(Player(7),Player(5),true)
call SetPlayerAllianceStateAllyBJ(Player(7),Player(6),true)
call SetPlayerAllianceStateAllyBJ(Player(7),Player(8),true)
call SetPlayerAllianceStateAllyBJ(Player(7),Player(9),true)
call SetPlayerAllianceStateAllyBJ(Player(7),Player($A),true)
call SetPlayerAllianceStateAllyBJ(Player(7),Player($B),true)
call SetPlayerAllianceStateAllyBJ(Player(7),Player($C),true)
call SetPlayerAllianceStateAllyBJ(Player(7),Player($D),true)
call SetPlayerAllianceStateAllyBJ(Player(7),Player($E),true)
call SetPlayerAllianceStateAllyBJ(Player(7),Player($F),true)
call SetPlayerAllianceStateAllyBJ(Player(7),Player(16),true)
call SetPlayerAllianceStateAllyBJ(Player(7),Player(17),true)
call SetPlayerAllianceStateAllyBJ(Player(7),Player(18),true)
call SetPlayerAllianceStateAllyBJ(Player(7),Player(19),true)
call SetPlayerAllianceStateAllyBJ(Player(7),Player(20),true)
call SetPlayerAllianceStateAllyBJ(Player(7),Player(21),true)
call SetPlayerAllianceStateAllyBJ(Player(7),Player(22),true)
call SetPlayerAllianceStateAllyBJ(Player(7),Player(23),true)
call SetPlayerAllianceStateAllyBJ(Player(8),Player(1),true)
call SetPlayerAllianceStateAllyBJ(Player(8),Player(2),true)
call SetPlayerAllianceStateAllyBJ(Player(8),Player(3),true)
call SetPlayerAllianceStateAllyBJ(Player(8),Player(4),true)
call SetPlayerAllianceStateAllyBJ(Player(8),Player(5),true)
call SetPlayerAllianceStateAllyBJ(Player(8),Player(6),true)
call SetPlayerAllianceStateAllyBJ(Player(8),Player(7),true)
call SetPlayerAllianceStateAllyBJ(Player(8),Player(9),true)
call SetPlayerAllianceStateAllyBJ(Player(8),Player($A),true)
call SetPlayerAllianceStateAllyBJ(Player(8),Player($B),true)
call SetPlayerAllianceStateAllyBJ(Player(8),Player($C),true)
call SetPlayerAllianceStateAllyBJ(Player(8),Player($D),true)
call SetPlayerAllianceStateAllyBJ(Player(8),Player($E),true)
call SetPlayerAllianceStateAllyBJ(Player(8),Player($F),true)
call SetPlayerAllianceStateAllyBJ(Player(8),Player(16),true)
call SetPlayerAllianceStateAllyBJ(Player(8),Player(17),true)
call SetPlayerAllianceStateAllyBJ(Player(8),Player(18),true)
call SetPlayerAllianceStateAllyBJ(Player(8),Player(19),true)
call SetPlayerAllianceStateAllyBJ(Player(8),Player(20),true)
call SetPlayerAllianceStateAllyBJ(Player(8),Player(21),true)
call SetPlayerAllianceStateAllyBJ(Player(8),Player(22),true)
call SetPlayerAllianceStateAllyBJ(Player(8),Player(23),true)
call SetPlayerAllianceStateAllyBJ(Player(9),Player(1),true)
call SetPlayerAllianceStateAllyBJ(Player(9),Player(2),true)
call SetPlayerAllianceStateAllyBJ(Player(9),Player(3),true)
call SetPlayerAllianceStateAllyBJ(Player(9),Player(4),true)
call SetPlayerAllianceStateAllyBJ(Player(9),Player(5),true)
call SetPlayerAllianceStateAllyBJ(Player(9),Player(6),true)
call SetPlayerAllianceStateAllyBJ(Player(9),Player(7),true)
call SetPlayerAllianceStateAllyBJ(Player(9),Player(8),true)
call SetPlayerAllianceStateAllyBJ(Player(9),Player($A),true)
call SetPlayerAllianceStateAllyBJ(Player(9),Player($B),true)
call SetPlayerAllianceStateAllyBJ(Player(9),Player($C),true)
call SetPlayerAllianceStateAllyBJ(Player(9),Player($D),true)
call SetPlayerAllianceStateAllyBJ(Player(9),Player($E),true)
call SetPlayerAllianceStateAllyBJ(Player(9),Player($F),true)
call SetPlayerAllianceStateAllyBJ(Player(9),Player(16),true)
call SetPlayerAllianceStateAllyBJ(Player(9),Player(17),true)
call SetPlayerAllianceStateAllyBJ(Player(9),Player(18),true)
call SetPlayerAllianceStateAllyBJ(Player(9),Player(19),true)
call SetPlayerAllianceStateAllyBJ(Player(9),Player(20),true)
call SetPlayerAllianceStateAllyBJ(Player(9),Player(21),true)
call SetPlayerAllianceStateAllyBJ(Player(9),Player(22),true)
call SetPlayerAllianceStateAllyBJ(Player(9),Player(23),true)
call SetPlayerAllianceStateAllyBJ(Player($A),Player(1),true)
call SetPlayerAllianceStateAllyBJ(Player($A),Player(2),true)
call SetPlayerAllianceStateAllyBJ(Player($A),Player(3),true)
call SetPlayerAllianceStateAllyBJ(Player($A),Player(4),true)
call SetPlayerAllianceStateAllyBJ(Player($A),Player(5),true)
call SetPlayerAllianceStateAllyBJ(Player($A),Player(6),true)
call SetPlayerAllianceStateAllyBJ(Player($A),Player(7),true)
call SetPlayerAllianceStateAllyBJ(Player($A),Player(8),true)
call SetPlayerAllianceStateAllyBJ(Player($A),Player(9),true)
call SetPlayerAllianceStateAllyBJ(Player($A),Player($B),true)
call SetPlayerAllianceStateAllyBJ(Player($A),Player($C),true)
call SetPlayerAllianceStateAllyBJ(Player($A),Player($D),true)
call SetPlayerAllianceStateAllyBJ(Player($A),Player($E),true)
call SetPlayerAllianceStateAllyBJ(Player($A),Player($F),true)
call SetPlayerAllianceStateAllyBJ(Player($A),Player(16),true)
call SetPlayerAllianceStateAllyBJ(Player($A),Player(17),true)
call SetPlayerAllianceStateAllyBJ(Player($A),Player(18),true)
call SetPlayerAllianceStateAllyBJ(Player($A),Player(19),true)
call SetPlayerAllianceStateAllyBJ(Player($A),Player(20),true)
call SetPlayerAllianceStateAllyBJ(Player($A),Player(21),true)
call SetPlayerAllianceStateAllyBJ(Player($A),Player(22),true)
call SetPlayerAllianceStateAllyBJ(Player($A),Player(23),true)
call SetPlayerAllianceStateAllyBJ(Player($B),Player(1),true)
call SetPlayerAllianceStateAllyBJ(Player($B),Player(2),true)
call SetPlayerAllianceStateAllyBJ(Player($B),Player(3),true)
call SetPlayerAllianceStateAllyBJ(Player($B),Player(4),true)
call SetPlayerAllianceStateAllyBJ(Player($B),Player(5),true)
call SetPlayerAllianceStateAllyBJ(Player($B),Player(6),true)
call SetPlayerAllianceStateAllyBJ(Player($B),Player(7),true)
call SetPlayerAllianceStateAllyBJ(Player($B),Player(8),true)
call SetPlayerAllianceStateAllyBJ(Player($B),Player(9),true)
call SetPlayerAllianceStateAllyBJ(Player($B),Player($A),true)
call SetPlayerAllianceStateAllyBJ(Player($B),Player($C),true)
call SetPlayerAllianceStateAllyBJ(Player($B),Player($D),true)
call SetPlayerAllianceStateAllyBJ(Player($B),Player($E),true)
call SetPlayerAllianceStateAllyBJ(Player($B),Player($F),true)
call SetPlayerAllianceStateAllyBJ(Player($B),Player(16),true)
call SetPlayerAllianceStateAllyBJ(Player($B),Player(17),true)
call SetPlayerAllianceStateAllyBJ(Player($B),Player(18),true)
call SetPlayerAllianceStateAllyBJ(Player($B),Player(19),true)
call SetPlayerAllianceStateAllyBJ(Player($B),Player(20),true)
call SetPlayerAllianceStateAllyBJ(Player($B),Player(21),true)
call SetPlayerAllianceStateAllyBJ(Player($B),Player(22),true)
call SetPlayerAllianceStateAllyBJ(Player($B),Player(23),true)
call SetPlayerAllianceStateAllyBJ(Player($C),Player(1),true)
call SetPlayerAllianceStateAllyBJ(Player($C),Player(2),true)
call SetPlayerAllianceStateAllyBJ(Player($C),Player(3),true)
call SetPlayerAllianceStateAllyBJ(Player($C),Player(4),true)
call SetPlayerAllianceStateAllyBJ(Player($C),Player(5),true)
call SetPlayerAllianceStateAllyBJ(Player($C),Player(6),true)
call SetPlayerAllianceStateAllyBJ(Player($C),Player(7),true)
call SetPlayerAllianceStateAllyBJ(Player($C),Player(8),true)
call SetPlayerAllianceStateAllyBJ(Player($C),Player(9),true)
call SetPlayerAllianceStateAllyBJ(Player($C),Player($A),true)
call SetPlayerAllianceStateAllyBJ(Player($C),Player($B),true)
call SetPlayerAllianceStateAllyBJ(Player($C),Player($D),true)
call SetPlayerAllianceStateAllyBJ(Player($C),Player($E),true)
call SetPlayerAllianceStateAllyBJ(Player($C),Player($F),true)
call SetPlayerAllianceStateAllyBJ(Player($C),Player(16),true)
call SetPlayerAllianceStateAllyBJ(Player($C),Player(17),true)
call SetPlayerAllianceStateAllyBJ(Player($C),Player(18),true)
call SetPlayerAllianceStateAllyBJ(Player($C),Player(19),true)
call SetPlayerAllianceStateAllyBJ(Player($C),Player(20),true)
call SetPlayerAllianceStateAllyBJ(Player($C),Player(21),true)
call SetPlayerAllianceStateAllyBJ(Player($C),Player(22),true)
call SetPlayerAllianceStateAllyBJ(Player($C),Player(23),true)
call SetPlayerAllianceStateAllyBJ(Player($D),Player(1),true)
call SetPlayerAllianceStateAllyBJ(Player($D),Player(2),true)
call SetPlayerAllianceStateAllyBJ(Player($D),Player(3),true)
call SetPlayerAllianceStateAllyBJ(Player($D),Player(4),true)
call SetPlayerAllianceStateAllyBJ(Player($D),Player(5),true)
call SetPlayerAllianceStateAllyBJ(Player($D),Player(6),true)
call SetPlayerAllianceStateAllyBJ(Player($D),Player(7),true)
call SetPlayerAllianceStateAllyBJ(Player($D),Player(8),true)
call SetPlayerAllianceStateAllyBJ(Player($D),Player(9),true)
call SetPlayerAllianceStateAllyBJ(Player($D),Player($A),true)
call SetPlayerAllianceStateAllyBJ(Player($D),Player($B),true)
call SetPlayerAllianceStateAllyBJ(Player($D),Player($C),true)
call SetPlayerAllianceStateAllyBJ(Player($D),Player($E),true)
call SetPlayerAllianceStateAllyBJ(Player($D),Player($F),true)
call SetPlayerAllianceStateAllyBJ(Player($D),Player(16),true)
call SetPlayerAllianceStateAllyBJ(Player($D),Player(17),true)
call SetPlayerAllianceStateAllyBJ(Player($D),Player(18),true)
call SetPlayerAllianceStateAllyBJ(Player($D),Player(19),true)
call SetPlayerAllianceStateAllyBJ(Player($D),Player(20),true)
call SetPlayerAllianceStateAllyBJ(Player($D),Player(21),true)
call SetPlayerAllianceStateAllyBJ(Player($D),Player(22),true)
call SetPlayerAllianceStateAllyBJ(Player($D),Player(23),true)
call SetPlayerAllianceStateAllyBJ(Player($E),Player(1),true)
call SetPlayerAllianceStateAllyBJ(Player($E),Player(2),true)
call SetPlayerAllianceStateAllyBJ(Player($E),Player(3),true)
call SetPlayerAllianceStateAllyBJ(Player($E),Player(4),true)
call SetPlayerAllianceStateAllyBJ(Player($E),Player(5),true)
call SetPlayerAllianceStateAllyBJ(Player($E),Player(6),true)
call SetPlayerAllianceStateAllyBJ(Player($E),Player(7),true)
call SetPlayerAllianceStateAllyBJ(Player($E),Player(8),true)
call SetPlayerAllianceStateAllyBJ(Player($E),Player(9),true)
call SetPlayerAllianceStateAllyBJ(Player($E),Player($A),true)
call SetPlayerAllianceStateAllyBJ(Player($E),Player($B),true)
call SetPlayerAllianceStateAllyBJ(Player($E),Player($C),true)
call SetPlayerAllianceStateAllyBJ(Player($E),Player($D),true)
call SetPlayerAllianceStateAllyBJ(Player($E),Player($F),true)
call SetPlayerAllianceStateAllyBJ(Player($E),Player(16),true)
call SetPlayerAllianceStateAllyBJ(Player($E),Player(17),true)
call SetPlayerAllianceStateAllyBJ(Player($E),Player(18),true)
call SetPlayerAllianceStateAllyBJ(Player($E),Player(19),true)
call SetPlayerAllianceStateAllyBJ(Player($E),Player(20),true)
call SetPlayerAllianceStateAllyBJ(Player($E),Player(21),true)
call SetPlayerAllianceStateAllyBJ(Player($E),Player(22),true)
call SetPlayerAllianceStateAllyBJ(Player($E),Player(23),true)
call SetPlayerAllianceStateAllyBJ(Player($F),Player(1),true)
call SetPlayerAllianceStateAllyBJ(Player($F),Player(2),true)
call SetPlayerAllianceStateAllyBJ(Player($F),Player(3),true)
call SetPlayerAllianceStateAllyBJ(Player($F),Player(4),true)
call SetPlayerAllianceStateAllyBJ(Player($F),Player(5),true)
call SetPlayerAllianceStateAllyBJ(Player($F),Player(6),true)
call SetPlayerAllianceStateAllyBJ(Player($F),Player(7),true)
call SetPlayerAllianceStateAllyBJ(Player($F),Player(8),true)
call SetPlayerAllianceStateAllyBJ(Player($F),Player(9),true)
call SetPlayerAllianceStateAllyBJ(Player($F),Player($A),true)
call SetPlayerAllianceStateAllyBJ(Player($F),Player($B),true)
call SetPlayerAllianceStateAllyBJ(Player($F),Player($C),true)
call SetPlayerAllianceStateAllyBJ(Player($F),Player($D),true)
call SetPlayerAllianceStateAllyBJ(Player($F),Player($E),true)
call SetPlayerAllianceStateAllyBJ(Player($F),Player(16),true)
call SetPlayerAllianceStateAllyBJ(Player($F),Player(17),true)
call SetPlayerAllianceStateAllyBJ(Player($F),Player(18),true)
call SetPlayerAllianceStateAllyBJ(Player($F),Player(19),true)
call SetPlayerAllianceStateAllyBJ(Player($F),Player(20),true)
call SetPlayerAllianceStateAllyBJ(Player($F),Player(21),true)
call SetPlayerAllianceStateAllyBJ(Player($F),Player(22),true)
call SetPlayerAllianceStateAllyBJ(Player($F),Player(23),true)
call SetPlayerAllianceStateAllyBJ(Player(16),Player(1),true)
call SetPlayerAllianceStateAllyBJ(Player(16),Player(2),true)
call SetPlayerAllianceStateAllyBJ(Player(16),Player(3),true)
call SetPlayerAllianceStateAllyBJ(Player(16),Player(4),true)
call SetPlayerAllianceStateAllyBJ(Player(16),Player(5),true)
call SetPlayerAllianceStateAllyBJ(Player(16),Player(6),true)
call SetPlayerAllianceStateAllyBJ(Player(16),Player(7),true)
call SetPlayerAllianceStateAllyBJ(Player(16),Player(8),true)
call SetPlayerAllianceStateAllyBJ(Player(16),Player(9),true)
call SetPlayerAllianceStateAllyBJ(Player(16),Player($A),true)
call SetPlayerAllianceStateAllyBJ(Player(16),Player($B),true)
call SetPlayerAllianceStateAllyBJ(Player(16),Player($C),true)
call SetPlayerAllianceStateAllyBJ(Player(16),Player($D),true)
call SetPlayerAllianceStateAllyBJ(Player(16),Player($E),true)
call SetPlayerAllianceStateAllyBJ(Player(16),Player($F),true)
call SetPlayerAllianceStateAllyBJ(Player(16),Player(17),true)
call SetPlayerAllianceStateAllyBJ(Player(16),Player(18),true)
call SetPlayerAllianceStateAllyBJ(Player(16),Player(19),true)
call SetPlayerAllianceStateAllyBJ(Player(16),Player(20),true)
call SetPlayerAllianceStateAllyBJ(Player(16),Player(21),true)
call SetPlayerAllianceStateAllyBJ(Player(16),Player(22),true)
call SetPlayerAllianceStateAllyBJ(Player(16),Player(23),true)
call SetPlayerAllianceStateAllyBJ(Player(17),Player(1),true)
call SetPlayerAllianceStateAllyBJ(Player(17),Player(2),true)
call SetPlayerAllianceStateAllyBJ(Player(17),Player(3),true)
call SetPlayerAllianceStateAllyBJ(Player(17),Player(4),true)
call SetPlayerAllianceStateAllyBJ(Player(17),Player(5),true)
call SetPlayerAllianceStateAllyBJ(Player(17),Player(6),true)
call SetPlayerAllianceStateAllyBJ(Player(17),Player(7),true)
call SetPlayerAllianceStateAllyBJ(Player(17),Player(8),true)
call SetPlayerAllianceStateAllyBJ(Player(17),Player(9),true)
call SetPlayerAllianceStateAllyBJ(Player(17),Player($A),true)
call SetPlayerAllianceStateAllyBJ(Player(17),Player($B),true)
call SetPlayerAllianceStateAllyBJ(Player(17),Player($C),true)
call SetPlayerAllianceStateAllyBJ(Player(17),Player($D),true)
call SetPlayerAllianceStateAllyBJ(Player(17),Player($E),true)
call SetPlayerAllianceStateAllyBJ(Player(17),Player($F),true)
call SetPlayerAllianceStateAllyBJ(Player(17),Player(16),true)
call SetPlayerAllianceStateAllyBJ(Player(17),Player(18),true)
call SetPlayerAllianceStateAllyBJ(Player(17),Player(19),true)
call SetPlayerAllianceStateAllyBJ(Player(17),Player(20),true)
call SetPlayerAllianceStateAllyBJ(Player(17),Player(21),true)
call SetPlayerAllianceStateAllyBJ(Player(17),Player(22),true)
call SetPlayerAllianceStateAllyBJ(Player(17),Player(23),true)
call SetPlayerAllianceStateAllyBJ(Player(18),Player(1),true)
call SetPlayerAllianceStateAllyBJ(Player(18),Player(2),true)
call SetPlayerAllianceStateAllyBJ(Player(18),Player(3),true)
call SetPlayerAllianceStateAllyBJ(Player(18),Player(4),true)
call SetPlayerAllianceStateAllyBJ(Player(18),Player(5),true)
call SetPlayerAllianceStateAllyBJ(Player(18),Player(6),true)
call SetPlayerAllianceStateAllyBJ(Player(18),Player(7),true)
call SetPlayerAllianceStateAllyBJ(Player(18),Player(8),true)
call SetPlayerAllianceStateAllyBJ(Player(18),Player(9),true)
call SetPlayerAllianceStateAllyBJ(Player(18),Player($A),true)
call SetPlayerAllianceStateAllyBJ(Player(18),Player($B),true)
call SetPlayerAllianceStateAllyBJ(Player(18),Player($C),true)
call SetPlayerAllianceStateAllyBJ(Player(18),Player($D),true)
call SetPlayerAllianceStateAllyBJ(Player(18),Player($E),true)
call SetPlayerAllianceStateAllyBJ(Player(18),Player($F),true)
call SetPlayerAllianceStateAllyBJ(Player(18),Player(16),true)
call SetPlayerAllianceStateAllyBJ(Player(18),Player(17),true)
call SetPlayerAllianceStateAllyBJ(Player(18),Player(19),true)
call SetPlayerAllianceStateAllyBJ(Player(18),Player(20),true)
call SetPlayerAllianceStateAllyBJ(Player(18),Player(21),true)
call SetPlayerAllianceStateAllyBJ(Player(18),Player(22),true)
call SetPlayerAllianceStateAllyBJ(Player(18),Player(23),true)
call SetPlayerAllianceStateAllyBJ(Player(19),Player(1),true)
call SetPlayerAllianceStateAllyBJ(Player(19),Player(2),true)
call SetPlayerAllianceStateAllyBJ(Player(19),Player(3),true)
call SetPlayerAllianceStateAllyBJ(Player(19),Player(4),true)
call SetPlayerAllianceStateAllyBJ(Player(19),Player(5),true)
call SetPlayerAllianceStateAllyBJ(Player(19),Player(6),true)
call SetPlayerAllianceStateAllyBJ(Player(19),Player(7),true)
call SetPlayerAllianceStateAllyBJ(Player(19),Player(8),true)
call SetPlayerAllianceStateAllyBJ(Player(19),Player(9),true)
call SetPlayerAllianceStateAllyBJ(Player(19),Player($A),true)
call SetPlayerAllianceStateAllyBJ(Player(19),Player($B),true)
call SetPlayerAllianceStateAllyBJ(Player(19),Player($C),true)
call SetPlayerAllianceStateAllyBJ(Player(19),Player($D),true)
call SetPlayerAllianceStateAllyBJ(Player(19),Player($E),true)
call SetPlayerAllianceStateAllyBJ(Player(19),Player($F),true)
call SetPlayerAllianceStateAllyBJ(Player(19),Player(16),true)
call SetPlayerAllianceStateAllyBJ(Player(19),Player(17),true)
call SetPlayerAllianceStateAllyBJ(Player(19),Player(18),true)
call SetPlayerAllianceStateAllyBJ(Player(19),Player(20),true)
call SetPlayerAllianceStateAllyBJ(Player(19),Player(21),true)
call SetPlayerAllianceStateAllyBJ(Player(19),Player(22),true)
call SetPlayerAllianceStateAllyBJ(Player(19),Player(23),true)
call SetPlayerAllianceStateAllyBJ(Player(20),Player(1),true)
call SetPlayerAllianceStateAllyBJ(Player(20),Player(2),true)
call SetPlayerAllianceStateAllyBJ(Player(20),Player(3),true)
call SetPlayerAllianceStateAllyBJ(Player(20),Player(4),true)
call SetPlayerAllianceStateAllyBJ(Player(20),Player(5),true)
call SetPlayerAllianceStateAllyBJ(Player(20),Player(6),true)
call SetPlayerAllianceStateAllyBJ(Player(20),Player(7),true)
call SetPlayerAllianceStateAllyBJ(Player(20),Player(8),true)
call SetPlayerAllianceStateAllyBJ(Player(20),Player(9),true)
call SetPlayerAllianceStateAllyBJ(Player(20),Player($A),true)
call SetPlayerAllianceStateAllyBJ(Player(20),Player($B),true)
call SetPlayerAllianceStateAllyBJ(Player(20),Player($C),true)
call SetPlayerAllianceStateAllyBJ(Player(20),Player($D),true)
call SetPlayerAllianceStateAllyBJ(Player(20),Player($E),true)
call SetPlayerAllianceStateAllyBJ(Player(20),Player($F),true)
call SetPlayerAllianceStateAllyBJ(Player(20),Player(16),true)
call SetPlayerAllianceStateAllyBJ(Player(20),Player(17),true)
call SetPlayerAllianceStateAllyBJ(Player(20),Player(18),true)
call SetPlayerAllianceStateAllyBJ(Player(20),Player(19),true)
call SetPlayerAllianceStateAllyBJ(Player(20),Player(21),true)
call SetPlayerAllianceStateAllyBJ(Player(20),Player(22),true)
call SetPlayerAllianceStateAllyBJ(Player(20),Player(23),true)
call SetPlayerAllianceStateAllyBJ(Player(21),Player(1),true)
call SetPlayerAllianceStateAllyBJ(Player(21),Player(2),true)
call SetPlayerAllianceStateAllyBJ(Player(21),Player(3),true)
call SetPlayerAllianceStateAllyBJ(Player(21),Player(4),true)
call SetPlayerAllianceStateAllyBJ(Player(21),Player(5),true)
call SetPlayerAllianceStateAllyBJ(Player(21),Player(6),true)
call SetPlayerAllianceStateAllyBJ(Player(21),Player(7),true)
call SetPlayerAllianceStateAllyBJ(Player(21),Player(8),true)
call SetPlayerAllianceStateAllyBJ(Player(21),Player(9),true)
call SetPlayerAllianceStateAllyBJ(Player(21),Player($A),true)
call SetPlayerAllianceStateAllyBJ(Player(21),Player($B),true)
call SetPlayerAllianceStateAllyBJ(Player(21),Player($C),true)
call SetPlayerAllianceStateAllyBJ(Player(21),Player($D),true)
call SetPlayerAllianceStateAllyBJ(Player(21),Player($E),true)
call SetPlayerAllianceStateAllyBJ(Player(21),Player($F),true)
call SetPlayerAllianceStateAllyBJ(Player(21),Player(16),true)
call SetPlayerAllianceStateAllyBJ(Player(21),Player(17),true)
call SetPlayerAllianceStateAllyBJ(Player(21),Player(18),true)
call SetPlayerAllianceStateAllyBJ(Player(21),Player(19),true)
call SetPlayerAllianceStateAllyBJ(Player(21),Player(20),true)
call SetPlayerAllianceStateAllyBJ(Player(21),Player(22),true)
call SetPlayerAllianceStateAllyBJ(Player(21),Player(23),true)
call SetPlayerAllianceStateAllyBJ(Player(22),Player(1),true)
call SetPlayerAllianceStateAllyBJ(Player(22),Player(2),true)
call SetPlayerAllianceStateAllyBJ(Player(22),Player(3),true)
call SetPlayerAllianceStateAllyBJ(Player(22),Player(4),true)
call SetPlayerAllianceStateAllyBJ(Player(22),Player(5),true)
call SetPlayerAllianceStateAllyBJ(Player(22),Player(6),true)
call SetPlayerAllianceStateAllyBJ(Player(22),Player(7),true)
call SetPlayerAllianceStateAllyBJ(Player(22),Player(8),true)
call SetPlayerAllianceStateAllyBJ(Player(22),Player(9),true)
call SetPlayerAllianceStateAllyBJ(Player(22),Player($A),true)
call SetPlayerAllianceStateAllyBJ(Player(22),Player($B),true)
call SetPlayerAllianceStateAllyBJ(Player(22),Player($C),true)
call SetPlayerAllianceStateAllyBJ(Player(22),Player($D),true)
call SetPlayerAllianceStateAllyBJ(Player(22),Player($E),true)
call SetPlayerAllianceStateAllyBJ(Player(22),Player($F),true)
call SetPlayerAllianceStateAllyBJ(Player(22),Player(16),true)
call SetPlayerAllianceStateAllyBJ(Player(22),Player(17),true)
call SetPlayerAllianceStateAllyBJ(Player(22),Player(18),true)
call SetPlayerAllianceStateAllyBJ(Player(22),Player(19),true)
call SetPlayerAllianceStateAllyBJ(Player(22),Player(20),true)
call SetPlayerAllianceStateAllyBJ(Player(22),Player(21),true)
call SetPlayerAllianceStateAllyBJ(Player(22),Player(23),true)
call SetPlayerAllianceStateAllyBJ(Player(23),Player(1),true)
call SetPlayerAllianceStateAllyBJ(Player(23),Player(2),true)
call SetPlayerAllianceStateAllyBJ(Player(23),Player(3),true)
call SetPlayerAllianceStateAllyBJ(Player(23),Player(4),true)
call SetPlayerAllianceStateAllyBJ(Player(23),Player(5),true)
call SetPlayerAllianceStateAllyBJ(Player(23),Player(6),true)
call SetPlayerAllianceStateAllyBJ(Player(23),Player(7),true)
call SetPlayerAllianceStateAllyBJ(Player(23),Player(8),true)
call SetPlayerAllianceStateAllyBJ(Player(23),Player(9),true)
call SetPlayerAllianceStateAllyBJ(Player(23),Player($A),true)
call SetPlayerAllianceStateAllyBJ(Player(23),Player($B),true)
call SetPlayerAllianceStateAllyBJ(Player(23),Player($C),true)
call SetPlayerAllianceStateAllyBJ(Player(23),Player($D),true)
call SetPlayerAllianceStateAllyBJ(Player(23),Player($E),true)
call SetPlayerAllianceStateAllyBJ(Player(23),Player($F),true)
call SetPlayerAllianceStateAllyBJ(Player(23),Player(16),true)
call SetPlayerAllianceStateAllyBJ(Player(23),Player(17),true)
call SetPlayerAllianceStateAllyBJ(Player(23),Player(18),true)
call SetPlayerAllianceStateAllyBJ(Player(23),Player(19),true)
call SetPlayerAllianceStateAllyBJ(Player(23),Player(20),true)
call SetPlayerAllianceStateAllyBJ(Player(23),Player(21),true)
call SetPlayerAllianceStateAllyBJ(Player(23),Player(22),true)
endfunction
function config takes nothing returns nothing
call SetMapName("SotFRP PR - Requiem")
call SetMapDescription("TRIGSTR_003")
call SetPlayers(24)
call SetTeams(2)
call SetGamePlacement(MAP_PLACEMENT_TEAMS_TOGETHER)
call DefineStartLocation(0,-26688.,28864.)
call DefineStartLocation(1,-26560.,28864.)
call DefineStartLocation(2,-26432.,28864.)
call DefineStartLocation(3,-26304.,28864.)
call DefineStartLocation(4,-26176.,28864.)
call DefineStartLocation(5,-26048.,28864.)
call DefineStartLocation(6,-26688.,28736.)
call DefineStartLocation(7,-26560.,28736.)
call DefineStartLocation(8,-26432.,28736.)
call DefineStartLocation(9,-26304.,28736.)
call DefineStartLocation($A,-26176.,28736.)
call DefineStartLocation($B,-26048.,28736.)
call DefineStartLocation($C,-26688.,28608.)
call DefineStartLocation($D,-26560.,28608.)
call DefineStartLocation($E,-26432.,28608.)
call DefineStartLocation($F,-26304.,28608.)
call DefineStartLocation(16,-26176.,28608.)
call DefineStartLocation(17,-26048.,28608.)
call DefineStartLocation(18,-26688.,28480.)
call DefineStartLocation(19,-26560.,28480.)
call DefineStartLocation(20,-26432.,28480.)
call DefineStartLocation(21,-26304.,28480.)
call DefineStartLocation(22,-26176.,28480.)
call DefineStartLocation(23,-26048.,28480.)
call SetPlayerStartLocation(Player(0),0)
call SetPlayerColor(Player(0),ConvertPlayerColor(0))
call SetPlayerRacePreference(Player(0),RACE_PREF_RANDOM)
call SetPlayerRaceSelectable(Player(0),true)
call SetPlayerController(Player(0),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(1),1)
call SetPlayerColor(Player(1),ConvertPlayerColor(1))
call SetPlayerRacePreference(Player(1),RACE_PREF_RANDOM)
call SetPlayerRaceSelectable(Player(1),true)
call SetPlayerController(Player(1),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(2),2)
call SetPlayerColor(Player(2),ConvertPlayerColor(2))
call SetPlayerRacePreference(Player(2),RACE_PREF_RANDOM)
call SetPlayerRaceSelectable(Player(2),true)
call SetPlayerController(Player(2),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(3),3)
call SetPlayerColor(Player(3),ConvertPlayerColor(3))
call SetPlayerRacePreference(Player(3),RACE_PREF_RANDOM)
call SetPlayerRaceSelectable(Player(3),true)
call SetPlayerController(Player(3),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(4),4)
call SetPlayerColor(Player(4),ConvertPlayerColor(4))
call SetPlayerRacePreference(Player(4),RACE_PREF_RANDOM)
call SetPlayerRaceSelectable(Player(4),true)
call SetPlayerController(Player(4),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(5),5)
call SetPlayerColor(Player(5),ConvertPlayerColor(5))
call SetPlayerRacePreference(Player(5),RACE_PREF_RANDOM)
call SetPlayerRaceSelectable(Player(5),true)
call SetPlayerController(Player(5),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(6),6)
call SetPlayerColor(Player(6),ConvertPlayerColor(6))
call SetPlayerRacePreference(Player(6),RACE_PREF_RANDOM)
call SetPlayerRaceSelectable(Player(6),true)
call SetPlayerController(Player(6),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(7),7)
call SetPlayerColor(Player(7),ConvertPlayerColor(7))
call SetPlayerRacePreference(Player(7),RACE_PREF_RANDOM)
call SetPlayerRaceSelectable(Player(7),true)
call SetPlayerController(Player(7),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(8),8)
call SetPlayerColor(Player(8),ConvertPlayerColor(8))
call SetPlayerRacePreference(Player(8),RACE_PREF_RANDOM)
call SetPlayerRaceSelectable(Player(8),true)
call SetPlayerController(Player(8),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(9),9)
call SetPlayerColor(Player(9),ConvertPlayerColor(9))
call SetPlayerRacePreference(Player(9),RACE_PREF_RANDOM)
call SetPlayerRaceSelectable(Player(9),true)
call SetPlayerController(Player(9),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player($A),$A)
call SetPlayerColor(Player($A),ConvertPlayerColor($A))
call SetPlayerRacePreference(Player($A),RACE_PREF_RANDOM)
call SetPlayerRaceSelectable(Player($A),true)
call SetPlayerController(Player($A),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player($B),$B)
call SetPlayerColor(Player($B),ConvertPlayerColor($B))
call SetPlayerRacePreference(Player($B),RACE_PREF_RANDOM)
call SetPlayerRaceSelectable(Player($B),true)
call SetPlayerController(Player($B),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player($C),$C)
call SetPlayerColor(Player($C),ConvertPlayerColor($C))
call SetPlayerRacePreference(Player($C),RACE_PREF_RANDOM)
call SetPlayerRaceSelectable(Player($C),true)
call SetPlayerController(Player($C),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player($D),$D)
call SetPlayerColor(Player($D),ConvertPlayerColor($D))
call SetPlayerRacePreference(Player($D),RACE_PREF_RANDOM)
call SetPlayerRaceSelectable(Player($D),true)
call SetPlayerController(Player($D),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player($E),$E)
call SetPlayerColor(Player($E),ConvertPlayerColor($E))
call SetPlayerRacePreference(Player($E),RACE_PREF_RANDOM)
call SetPlayerRaceSelectable(Player($E),true)
call SetPlayerController(Player($E),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player($F),$F)
call SetPlayerColor(Player($F),ConvertPlayerColor($F))
call SetPlayerRacePreference(Player($F),RACE_PREF_RANDOM)
call SetPlayerRaceSelectable(Player($F),true)
call SetPlayerController(Player($F),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(16),16)
call SetPlayerColor(Player(16),ConvertPlayerColor(16))
call SetPlayerRacePreference(Player(16),RACE_PREF_RANDOM)
call SetPlayerRaceSelectable(Player(16),true)
call SetPlayerController(Player(16),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(17),17)
call SetPlayerColor(Player(17),ConvertPlayerColor(17))
call SetPlayerRacePreference(Player(17),RACE_PREF_RANDOM)
call SetPlayerRaceSelectable(Player(17),true)
call SetPlayerController(Player(17),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(18),18)
call SetPlayerColor(Player(18),ConvertPlayerColor(18))
call SetPlayerRacePreference(Player(18),RACE_PREF_RANDOM)
call SetPlayerRaceSelectable(Player(18),true)
call SetPlayerController(Player(18),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(19),19)
call SetPlayerColor(Player(19),ConvertPlayerColor(19))
call SetPlayerRacePreference(Player(19),RACE_PREF_RANDOM)
call SetPlayerRaceSelectable(Player(19),true)
call SetPlayerController(Player(19),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(20),20)
call SetPlayerColor(Player(20),ConvertPlayerColor(20))
call SetPlayerRacePreference(Player(20),RACE_PREF_RANDOM)
call SetPlayerRaceSelectable(Player(20),true)
call SetPlayerController(Player(20),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(21),21)
call SetPlayerColor(Player(21),ConvertPlayerColor(21))
call SetPlayerRacePreference(Player(21),RACE_PREF_RANDOM)
call SetPlayerRaceSelectable(Player(21),true)
call SetPlayerController(Player(21),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(22),22)
call SetPlayerColor(Player(22),ConvertPlayerColor(22))
call SetPlayerRacePreference(Player(22),RACE_PREF_RANDOM)
call SetPlayerRaceSelectable(Player(22),true)
call SetPlayerController(Player(22),MAP_CONTROL_USER)
call SetPlayerStartLocation(Player(23),23)
call SetPlayerColor(Player(23),ConvertPlayerColor(23))
call SetPlayerRacePreference(Player(23),RACE_PREF_RANDOM)
call SetPlayerRaceSelectable(Player(23),true)
call SetPlayerController(Player(23),MAP_CONTROL_USER)
call InitCustomTeams()
call SetStartLocPrioCount(0,23)
call SetStartLocPrio(0,0,1,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,1,2,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,2,3,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,3,4,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,4,5,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,5,6,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,6,7,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,7,8,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,8,9,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,9,$A,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,$A,$B,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,$B,$C,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,$C,$D,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,$D,$E,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,$E,$F,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,$F,16,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,16,17,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,17,18,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,18,19,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,19,20,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,20,21,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,21,22,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(0,22,23,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(1,23)
call SetStartLocPrio(1,0,0,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(1,1,2,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(1,2,3,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(1,3,4,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(1,4,5,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(1,5,6,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(1,6,7,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(1,7,8,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(1,8,9,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(1,9,$A,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(1,$A,$B,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(1,$B,$C,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(1,$C,$D,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(1,$D,$E,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(1,$E,$F,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(1,$F,16,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(1,16,17,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(1,17,18,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(1,18,19,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(1,19,20,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(1,20,21,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(1,21,22,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(1,22,23,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(2,23)
call SetStartLocPrio(2,0,0,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(2,1,1,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(2,2,3,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(2,3,4,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(2,4,5,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(2,5,6,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(2,6,7,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(2,7,8,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(2,8,9,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(2,9,$A,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(2,$A,$B,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(2,$B,$C,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(2,$C,$D,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(2,$D,$E,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(2,$E,$F,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(2,$F,16,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(2,16,17,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(2,17,18,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(2,18,19,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(2,19,20,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(2,20,21,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(2,21,22,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(2,22,23,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(3,23)
call SetStartLocPrio(3,0,0,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(3,1,1,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(3,2,2,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(3,3,4,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(3,4,5,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(3,5,6,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(3,6,7,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(3,7,8,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(3,8,9,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(3,9,$A,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(3,$A,$B,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(3,$B,$C,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(3,$C,$D,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(3,$D,$E,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(3,$E,$F,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(3,$F,16,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(3,16,17,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(3,17,18,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(3,18,19,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(3,19,20,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(3,20,21,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(3,21,22,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(3,22,23,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(4,23)
call SetStartLocPrio(4,0,0,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(4,1,1,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(4,2,2,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(4,3,3,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(4,4,5,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(4,5,6,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(4,6,7,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(4,7,8,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(4,8,9,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(4,9,$A,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(4,$A,$B,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(4,$B,$C,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(4,$C,$D,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(4,$D,$E,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(4,$E,$F,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(4,$F,16,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(4,16,17,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(4,17,18,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(4,18,19,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(4,19,20,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(4,20,21,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(4,21,22,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(4,22,23,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(5,23)
call SetStartLocPrio(5,0,0,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(5,1,1,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(5,2,2,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(5,3,3,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(5,4,4,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(5,5,6,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(5,6,7,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(5,7,8,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(5,8,9,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(5,9,$A,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(5,$A,$B,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(5,$B,$C,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(5,$C,$D,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(5,$D,$E,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(5,$E,$F,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(5,$F,16,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(5,16,17,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(5,17,18,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(5,18,19,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(5,19,20,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(5,20,21,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(5,21,22,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(5,22,23,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(6,23)
call SetStartLocPrio(6,0,0,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(6,1,1,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(6,2,2,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(6,3,3,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(6,4,4,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(6,5,5,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(6,6,7,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(6,7,8,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(6,8,9,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(6,9,$A,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(6,$A,$B,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(6,$B,$C,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(6,$C,$D,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(6,$D,$E,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(6,$E,$F,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(6,$F,16,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(6,16,17,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(6,17,18,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(6,18,19,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(6,19,20,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(6,20,21,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(6,21,22,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(6,22,23,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(7,23)
call SetStartLocPrio(7,0,0,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(7,1,1,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(7,2,2,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(7,3,3,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(7,4,4,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(7,5,5,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(7,6,6,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(7,7,8,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(7,8,9,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(7,9,$A,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(7,$A,$B,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(7,$B,$C,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(7,$C,$D,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(7,$D,$E,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(7,$E,$F,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(7,$F,16,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(7,16,17,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(7,17,18,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(7,18,19,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(7,19,20,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(7,20,21,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(7,21,22,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(7,22,23,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(8,23)
call SetStartLocPrio(8,0,0,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(8,1,1,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(8,2,2,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(8,3,3,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(8,4,4,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(8,5,5,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(8,6,6,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(8,7,7,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(8,8,9,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(8,9,$A,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(8,$A,$B,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(8,$B,$C,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(8,$C,$D,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(8,$D,$E,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(8,$E,$F,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(8,$F,16,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(8,16,17,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(8,17,18,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(8,18,19,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(8,19,20,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(8,20,21,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(8,21,22,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(8,22,23,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(9,23)
call SetStartLocPrio(9,0,0,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(9,1,1,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(9,2,2,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(9,3,3,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(9,4,4,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(9,5,5,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(9,6,6,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(9,7,7,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(9,8,8,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(9,9,$A,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(9,$A,$B,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(9,$B,$C,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(9,$C,$D,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(9,$D,$E,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(9,$E,$F,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(9,$F,16,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(9,16,17,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(9,17,18,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(9,18,19,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(9,19,20,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(9,20,21,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(9,21,22,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(9,22,23,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount($A,23)
call SetStartLocPrio($A,0,0,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($A,1,1,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($A,2,2,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($A,3,3,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($A,4,4,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($A,5,5,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($A,6,6,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($A,7,7,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($A,8,8,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($A,9,9,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($A,$A,$B,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($A,$B,$C,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($A,$C,$D,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($A,$D,$E,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($A,$E,$F,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($A,$F,16,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($A,16,17,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($A,17,18,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($A,18,19,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($A,19,20,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($A,20,21,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($A,21,22,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($A,22,23,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount($B,23)
call SetStartLocPrio($B,0,0,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($B,1,1,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($B,2,2,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($B,3,3,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($B,4,4,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($B,5,5,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($B,6,6,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($B,7,7,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($B,8,8,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($B,9,9,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($B,$A,$A,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($B,$B,$C,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($B,$C,$D,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($B,$D,$E,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($B,$E,$F,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($B,$F,16,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($B,16,17,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($B,17,18,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($B,18,19,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($B,19,20,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($B,20,21,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($B,21,22,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($B,22,23,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount($C,23)
call SetStartLocPrio($C,0,0,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($C,1,1,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($C,2,2,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($C,3,3,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($C,4,4,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($C,5,5,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($C,6,6,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($C,7,7,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($C,8,8,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($C,9,9,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($C,$A,$A,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($C,$B,$B,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($C,$C,$D,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($C,$D,$E,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($C,$E,$F,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($C,$F,16,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($C,16,17,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($C,17,18,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($C,18,19,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($C,19,20,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($C,20,21,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($C,21,22,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($C,22,23,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount($D,23)
call SetStartLocPrio($D,0,0,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($D,1,1,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($D,2,2,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($D,3,3,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($D,4,4,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($D,5,5,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($D,6,6,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($D,7,7,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($D,8,8,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($D,9,9,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($D,$A,$A,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($D,$B,$B,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($D,$C,$C,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($D,$D,$E,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($D,$E,$F,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($D,$F,16,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($D,16,17,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($D,17,18,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($D,18,19,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($D,19,20,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($D,20,21,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($D,21,22,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($D,22,23,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount($E,23)
call SetStartLocPrio($E,0,0,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($E,1,1,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($E,2,2,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($E,3,3,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($E,4,4,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($E,5,5,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($E,6,6,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($E,7,7,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($E,8,8,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($E,9,9,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($E,$A,$A,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($E,$B,$B,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($E,$C,$C,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($E,$D,$D,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($E,$E,$F,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($E,$F,16,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($E,16,17,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($E,17,18,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($E,18,19,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($E,19,20,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($E,20,21,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($E,21,22,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($E,22,23,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount($F,23)
call SetStartLocPrio($F,0,0,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($F,1,1,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($F,2,2,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($F,3,3,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($F,4,4,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($F,5,5,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($F,6,6,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($F,7,7,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($F,8,8,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($F,9,9,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($F,$A,$A,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($F,$B,$B,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($F,$C,$C,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($F,$D,$D,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($F,$E,$E,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($F,$F,16,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($F,16,17,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($F,17,18,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($F,18,19,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($F,19,20,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($F,20,21,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($F,21,22,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio($F,22,23,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(16,23)
call SetStartLocPrio(16,0,0,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(16,1,1,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(16,2,2,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(16,3,3,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(16,4,4,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(16,5,5,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(16,6,6,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(16,7,7,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(16,8,8,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(16,9,9,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(16,$A,$A,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(16,$B,$B,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(16,$C,$C,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(16,$D,$D,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(16,$E,$E,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(16,$F,$F,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(16,16,17,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(16,17,18,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(16,18,19,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(16,19,20,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(16,20,21,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(16,21,22,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(16,22,23,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(17,23)
call SetStartLocPrio(17,0,0,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(17,1,1,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(17,2,2,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(17,3,3,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(17,4,4,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(17,5,5,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(17,6,6,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(17,7,7,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(17,8,8,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(17,9,9,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(17,$A,$A,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(17,$B,$B,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(17,$C,$C,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(17,$D,$D,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(17,$E,$E,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(17,$F,$F,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(17,16,16,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(17,17,18,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(17,18,19,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(17,19,20,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(17,20,21,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(17,21,22,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(17,22,23,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(18,23)
call SetStartLocPrio(18,0,0,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(18,1,1,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(18,2,2,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(18,3,3,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(18,4,4,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(18,5,5,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(18,6,6,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(18,7,7,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(18,8,8,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(18,9,9,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(18,$A,$A,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(18,$B,$B,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(18,$C,$C,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(18,$D,$D,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(18,$E,$E,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(18,$F,$F,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(18,16,16,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(18,17,17,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(18,18,19,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(18,19,20,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(18,20,21,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(18,21,22,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(18,22,23,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(19,23)
call SetStartLocPrio(19,0,0,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(19,1,1,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(19,2,2,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(19,3,3,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(19,4,4,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(19,5,5,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(19,6,6,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(19,7,7,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(19,8,8,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(19,9,9,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(19,$A,$A,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(19,$B,$B,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(19,$C,$C,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(19,$D,$D,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(19,$E,$E,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(19,$F,$F,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(19,16,16,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(19,17,17,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(19,18,18,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(19,19,20,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(19,20,21,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(19,21,22,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(19,22,23,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(20,23)
call SetStartLocPrio(20,0,0,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(20,1,1,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(20,2,2,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(20,3,3,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(20,4,4,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(20,5,5,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(20,6,6,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(20,7,7,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(20,8,8,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(20,9,9,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(20,$A,$A,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(20,$B,$B,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(20,$C,$C,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(20,$D,$D,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(20,$E,$E,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(20,$F,$F,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(20,16,16,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(20,17,17,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(20,18,18,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(20,19,19,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(20,20,21,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(20,21,22,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(20,22,23,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(21,23)
call SetStartLocPrio(21,0,0,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(21,1,1,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(21,2,2,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(21,3,3,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(21,4,4,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(21,5,5,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(21,6,6,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(21,7,7,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(21,8,8,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(21,9,9,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(21,$A,$A,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(21,$B,$B,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(21,$C,$C,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(21,$D,$D,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(21,$E,$E,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(21,$F,$F,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(21,16,16,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(21,17,17,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(21,18,18,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(21,19,19,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(21,20,20,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(21,21,22,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(21,22,23,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(22,23)
call SetStartLocPrio(22,0,0,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(22,1,1,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(22,2,2,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(22,3,3,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(22,4,4,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(22,5,5,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(22,6,6,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(22,7,7,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(22,8,8,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(22,9,9,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(22,$A,$A,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(22,$B,$B,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(22,$C,$C,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(22,$D,$D,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(22,$E,$E,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(22,$F,$F,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(22,16,16,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(22,17,17,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(22,18,18,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(22,19,19,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(22,20,20,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(22,21,21,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(22,22,23,MAP_LOC_PRIO_HIGH)
call SetStartLocPrioCount(23,23)
call SetStartLocPrio(23,0,0,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(23,1,1,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(23,2,2,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(23,3,3,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(23,4,4,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(23,5,5,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(23,6,6,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(23,7,7,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(23,8,8,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(23,9,9,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(23,$A,$A,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(23,$B,$B,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(23,$C,$C,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(23,$D,$D,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(23,$E,$E,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(23,$F,$F,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(23,16,16,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(23,17,17,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(23,18,18,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(23,19,19,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(23,20,20,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(23,21,21,MAP_LOC_PRIO_HIGH)
call SetStartLocPrio(23,22,22,MAP_LOC_PRIO_HIGH)
endfunction
